<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Architecture on ChenSoul</title>
    <link>https://blog.chensoul.cc/categories/architecture/</link>
    <description>Recent content in Architecture on ChenSoul</description>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 05 Aug 2024 09:10:00 +0800</lastBuildDate>
    <atom:link href="https://blog.chensoul.cc/categories/architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[译]数据库分片速成课程</title>
      <link>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-in-database-sharding/</link>
      <pubDate>Mon, 05 Aug 2024 09:10:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-in-database-sharding/</guid>
      <description>原文链接：https://blog.bytebytego.com/p/a-crash-course-in-database-sharding
随着应用程序越来越受欢迎，它会吸引更多活跃用户并加入更多功能。这种增长导致每日数据生成量增加，从业务角度来看，这是一个积极的指标。
然而，它也给应用程序的架构带来挑战，特别是在数据库可扩展性方面。
数据库是任何应用程序的关键组件，但它也是最难水平扩展的组件之一。当应用程序的流量和数据量增加时，数据库可能会成为性能瓶颈，影响用户体验。
分片是一种解决数据库横向扩展难题的技术。它涉及将数据库划分为更小、更易于管理的单元（称为分片）。
在这篇文章中，我们将介绍数据库分片的基础知识，探讨其各种方法、技术考虑因素，以及展示公司如何实施分片来扩展其数据库的真实案例研究。
什么是分片？ 分片是一种架构模式，用于解决管理和查询数据库中大型数据集的难题。它涉及将大型数据库拆分为更小、更易于管理的部分（称为分片）。
共享建立在水平分区的概念之上，水平分区涉及根据分区键将表的行分成多个表。这些表称为分区。跨分区分布数据可减少查询和操作数据所需的工作量。
下图说明了水平分区的一个例子。
数据库分片将水平分区提升到了一个新的水平。分区将所有数据组存储在同一台计算机中，而分片则将它们分布在不同的计算机或节点上。这种方法通过利用多台机器的资源来实现更好的可扩展性和性能。
值得注意的是，不同数据库使用的分片术语有所不同。
在 MongoDB 中，分区称为分片 (shard)。 Couchbase 使用术语 vBucket 来表示分片。 Cassandra 将分片称为 vNode。 尽管术语存在差异，但其基本概念保持不变：将数据分成更小、更易于管理的单元，以提高查询性能和可扩展性。
数据库分片的好处 数据库分片有几个主要优点：
可扩展性： 分片的主要动机是实现可扩展性。通过将大型数据集分布在多个分片上，查询负载可以分散到多个节点上。对于对单个分片进行操作的查询，每个节点都可以独立执行针对其分配数据的查询。此外，可以在运行时动态添加新分片，而无需关闭应用程序进行维护。 性能提升： 从单个大型数据库中检索数据可能非常耗时。查询需要搜索大量行才能找到所需数据。相比之下，与整个数据库相比，分片包含的行子集更小。由于查询需要处理的行更少，因此搜索空间的减少可加快数据检索速度。 可用性： 在单片数据库架构中，如果托管数据库的节点发生故障，依赖该数据库的应用程序也会停机。数据库分片通过将数据分布在多个节点上来降低这种风险。如果发生节点故障，应用程序可以使用剩余的分片继续运行。 分片和复制 分片通常与复制一起使用，以实现分布式数据库系统中的高可用性和容错能力。
复制涉及创建数据的多个副本并将其存储在不同的节点上。在主从复制模型中，一个节点充当主节点并处理写入操作，而从节点复制主节点的数据并处理读取操作。
通过在多个节点上复制每个分片，系统可确保即使个别节点发生故障，数据仍可访问。一个节点可以存储多个分片，每个分片在主从复制模型中可以是主分片或从分片。
下图说明了一种安排，其中每个分片的领导者被分配给一个节点，而其追随者分布在其他节点上：
在此设置中，一个节点可以同时充当某些分区的领导者和其他分区的追随者。这种分布式架构允许系统在发生节点故障或网络中断时保持数据可用性和弹性。
分片类型 数据库分片的主要目标是在多个节点上均匀分布数据和查询负载。
然而，如果数据分区不平衡，一些分片最终可能会处理比其他分片多得多的数据或查询。这种情况称为倾斜分片，它会削弱分片的优势。
在极端情况下，设计不良的分片策略可能导致单个分片承担全部负载，而其余分片保持空闲状态。
这种情况称为热点，其中一个节点因过高的负载而变得不堪重负。
为了减轻分片倾斜和热点的风险，选择适当的分片策略以确保数据和查询在分片之间均匀分布至关重要。
我们来了解一些常用的分片策略：
基于范围的分片 基于范围的分片是一种根据一系列值拆分数据库行的技术。
在这种方法中，每个分片都会分配一个连续的键范围，从最小值到最大值。每个分片内的键都按排序顺序维护，以实现高效的范围扫描。
为了说明这个概念，让我们考虑一个存储产品信息的产品数据库。
可以应用基于范围的分片，根据产品的价格范围将数据库拆分为不同的分片。例如，一个分片可以存储价格范围在 0 美元到 75 美元之间的所有产品，而另一个分片可以包含价格范围在 76 美元到 150 美元之间的产品。
需要注意的是，键的范围不一定需要均匀分布。在实际应用中，数据分布可能不均匀，可以相应地调整键范围，以实现分片间数据分布的平衡。
然而，基于范围的分片有一个潜在的缺点。 某些访问模式可能会导致热点的形成。例如，如果数据库中很大一部分产品属于特定价格范围，则负责存储该范围的分片可能会承受不成比例的高负载，而其他分片仍未得到充分利用。
基于键或哈希的分片 基于密钥的分片（也称为基于哈希的分片）是一种使用哈希函数将特定密钥分配给分片的技术。
精心设计的哈希函数对于实现密钥的均衡分布起着至关重要的作用。基于哈希的分片不会为每个分片分配一系列密钥，而是为每个分片分配一系列哈希。一致性哈希是一种常用于实现基于哈希的分片的技术。
下图说明了基于键或哈希的分片的基本概念：
基于哈希的分片的主要优势之一是它能够在分片之间公平分配密钥。通过对密钥应用哈希函数，该技术有助于降低热点风险。
但是，基于哈希的分片也存在弊端。通过使用键的哈希而不是键本身，我们失去了执行高效范围查询的能力。这是因为相邻的键可能分散在不同的分区中，并且在此过程中会丢失它们的自然排序顺序。
需要注意的是，基于哈希的分片虽然有助于减少热点，但无法消除热点。在所有读取和写入都集中在单个键上的极端情况下，所有请求仍可能被路由到同一分区。例如，在社交媒体网站上，名人用户可以发布对同一键产生大量写入的内容。
基于目录的分片 基于目录的分片是一种依赖查找表来确定分片间记录分布的方法。
查找表充当目录或地址簿，映射数据与其所在的特定分片之间的关系。此表与分片本身分开存储。
下图说明了基于目录的分片的概念，使用“位置”字段作为分片键：
与其他分片策略相比，基于目录的分片的主要优势之一是灵活性。它允许更好地控制分片间数据的放置，因为数据和分片之间的映射在查找表中明确定义。
然而，基于目录的分片也有一个明显的缺点：它严重依赖查找表。与查找表相关的任何问题或故障都可能影响数据库的整体性能和可用性。
选择分片键时要考虑的因素 选择合适的分片键对于实施有效的分片策略至关重要。数据库设计人员在做出此决定时应考虑几个关键因素：
基数 基数是指分片键可以具有的可能值的数量。它决定了可以创建的最大分片数量。
例如，如果选择布尔数据字段作为分片键，则系统将仅限于两个分片。
为了最大限度地发挥水平扩展的优势，通常建议选择具有高基数的分片键。
频率 分片键的频率表示特定分片键值在数据集中出现的频率。
如果大部分记录仅包含可能的分片键值的子集，则负责存储该子集的分片可能会成为热点。
例如，如果健身网站的数据库使用年龄作为分片键，则大多数记录可能最终会出现在包含 30 至 45 岁之间的订阅者的分片中，从而导致数据分布不均匀。
单调变化 单调变化是指对于给定的记录，分片键值随着时间的推移而增加或减少。
如果分片键基于单调增加或减少的值，则可能导致分片不平衡。
考虑存储用户评论的数据库的分片方案。
分片A存储评论少于10条的用户的数据。 分片B存储有11-20条评论的用户的数据。 分片 C 存储了评论超过 30 条的用户的数据。 随着用户随着时间的推移不断添加评论，他们会逐渐迁移到分片 C，这使得它比分片 A 和 B 更加不平衡。</description>
    </item>
    <item>
      <title>[译]数据库扩展策略速成课程</title>
      <link>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-in-database-scaling/</link>
      <pubDate>Mon, 05 Aug 2024 09:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-in-database-scaling/</guid>
      <description>原文链接：https://blog.bytebytego.com/p/a-crash-course-in-database-scaling
数据库是现代应用程序开发的支柱。它们在存储、管理和检索数据方面发挥着至关重要的作用，使应用程序和服务能够有效运行。
随着应用程序越来越受欢迎并吸引越来越多的用户群，数据库面临着处理不断增加的数据量、并发用户和复杂查询的挑战。
有效地扩展数据库以确保最佳性能和良好的用户体验变得至关重要。
数据库扩展是调整和扩展数据库基础架构以适应增长并在负载增加的情况下保持性能的过程。它涉及采用各种技术和策略来有效地分配数据，优化查询执行并明智地利用硬件资源。
组织和开发人员必须了解并实施正确的数据库扩展策略。针对特定情况选择错误的策略可能会弊大于利。
在这篇文章中，我们将详细介绍最流行的数据库扩展策略，讨论它们的优点和权衡。
索引 索引是增强数据库可扩展性和性能的基础技术之一。
索引可以看作是数据库的“目录”。它包含对主数据库表中特定数据位置的引用，以便快速搜索和检索。
通过创建单独的数据结构（例如索引），数据库可以快速定位和检索特定数据，而无需扫描主表中的每个记录。
索引本身是数据的一个子集，以针对高效查询进行优化的方式组织。
为了更清楚地理解这个概念，我们假设有一个名为“客户”的数据库表，其中包含“ID”、“姓名”、“电子邮件”和“城市”等列。如果经常需要根据客户的电子邮件地址搜索客户，则在“电子邮件”列上创建索引可以提高搜索性能。
如果没有索引，通过电子邮件搜索客户将需要数据库扫描“客户”表中的每一行，直到找到匹配的记录。这个过程可能非常耗时，尤其是当表的大小增加时，这会导致查询响应时间变慢。
但是，通过在“电子邮件”列上创建索引，数据库可以使用索引数据结构快速查找所需的电子邮件地址并直接检索相应的行。这样就无需进行全表扫描，从而加快了搜索操作。
请参阅下图中的“电子邮件”列的示例索引：
索引的好处 索引提供了几个显著的好处，在处理大型数据库时这些好处变得越来越重要：
提高查询性能： 随着数据量的增长，如果数据库必须扫描大量记录，查询性能可能会下降。创建正确的索引可使数据库快速定位和检索特定的数据子集，而无需进行全表扫描。 减少资源消耗： 索引允许数据库有效地定位数据子集，从而最大限度地减少所需的磁盘 I/O 量和内存使用量。 提高并发性： 借助索引，数据库可以处理更多查询并容纳更多并发用户。这种改进的并发性在数据库必须扩展以支持大量用户的情况下尤其有益。 与索引的权衡 值得注意的是，索引会带来多重权衡。
当在列上创建索引时（例如我们示例中的电子邮件地址列），数据库会将索引数据与主表分开存储。这意味着对于每个索引列，都有一个额外的数据结构占用磁盘空间。 需要考虑的另一个权衡是索引对写入操作的潜在影响。在表中插入、更新或删除数据时，应更新相应的索引以保持准确性和一致性。这个额外的步骤增加了写入操作的开销，随着表上索引数量的增加，这种开销会变得更加明显。 为了达到正确的平衡，根据特定的查询模式和应用程序的性能要求仔细选择要索引的列非常重要。
物化视图 物化视图是一个数据库对象，它将查询结果存储为单独的、预先计算的结果集。
它源自一个或多个基表或视图，并且独立于底层数据源进行维护。
为了解释物化视图的概念，我们来考虑一个电子商务应用程序，它有一个包含数百万条记录的大型“订单”表。该应用程序经常生成每个产品类别的总销售收入报告。
如果没有物化视图，每次生成报告都需要扫描整个“订单”表，将其与“产品”表连接以获取类别信息，并执行聚合以计算每个类别的总收入。随着数据的增长，此查询会变得更慢且占用大量资源。
通过创建存储预先聚合的数据（例如每个产品类别的总收入）的物化视图，可以加快报告生成过程。
请参见下图，其中显示了存储每个产品类别的总收入的物化视图。
物化视图可以定期刷新，例如每天或每小时刷新一次，以确保数据保持最新状态。然后，可以直接从物化视图执行销售报告查询，提供即时结果，而无需处理整个“订单”表。
物化视图的好处 物化视图可以通过多种方式极大地增强数据库的可扩展性：
改进的查询性能： 物化视图存储预先计算的结果，无需重复执行复杂且耗时的查询。 减少基表的负载： 通过将计算成本高的查询结果存储在物化视图中，可以减少基表的负载。 与物化视图的权衡 虽然物化视图提供了显着的可伸缩性提升，但仍需要牢记一些权衡：
物化视图会消耗额外的存储空间，因为它们存储了结果集的单独副本。 刷新物化视图可能很耗时，尤其是对于大型数据集而言。 物化视图最终与源数据一致。换句话说，物化视图可以在短时间内包含陈旧数据。 反规范化 在规范化数据库设计中，数据被组织到单独的表中，以最大限度地减少冗余并确保数据完整性。每个表代表一个实体或概念，并使用外键建立表关系。这种方法遵循规范化的原则，旨在减少数据重复并保持数据一致性。
然而，严格遵守规范化规则有时会导致性能挑战，特别是在处理涉及跨表的多个连接的复杂查询时。
这就是非规范化发挥作用的地方。
非规范化是一种放宽严格规范化规则并允许受控数据冗余的技术。它涉及在多个表中策略性地复制数据以优化查询性能。目标是减少检索数据所需的连接和计算次数，从而提高查询速度和可扩展性。
为了理解非规范化的概念，请考虑一个包含“产品”表和“订单”表的电子商务应用程序。
在规范化设计中，“订单”表将仅存储对“产品”表的外键引用。需要将两个表连接起来才能检索带有订单信息的产品详细信息。
但随着订单数量的增长，如果应用程序经常需要在订单详情旁边显示产品名称和价格，那么连接操作可能会成为性能瓶颈。在这种情况下，可以应用非规范化来提高查询性能。
下图显示了在“订单”表上应用非规范化的示例：
通过对数据库进行非规范化并将产品名称和价格直接存储在“订单”表中，查询订单详细信息以及产品信息变得更简单、更快捷。冗余数据消除了连接的需求，使数据库在高查询负载下具有更好的扩展性。
非规范化如何帮助提高可扩展性？ 非规范化可以通过多种方式提高数据库的可伸缩性：
更快的查询执行： 消除或减少连接可以显著加快查询执行速度，尤其是对于经常访问或性能至关重要的查询。换句话说，数据库可以处理大量并发查询，从而提高整体可扩展性。 减少数据检索开销： 由于派生数据与主数据一起存储在同一张表中，因此无需执行昂贵的即时计算。 提高读取性能： 非规范化对于扩展读取密集型工作负载特别有益，因为查询无需连接多个表即可访问信息。 与非规范化的权衡 虽然非规范化可以提高查询性能和可伸缩性，但它也有一些缺点：
非规范化会引入数据冗余，从而增加存储需求。 非规范化使数据修改操作（插入、更新、删除）变得更加复杂和缓慢，因为冗余数据需要在多个表之间保持同步。 如果实施不当，非规范化可能会损害数据一致性。 垂直扩展 垂直扩展，也称为“向上扩展”，是一种通过增加单个服务器的硬件资源来提高数据库性能和可扩展性的技术。
这种方法侧重于通过为单个服务器分配更多资源来增强其功能。
垂直扩展的过程可能涉及几个关键升级：
用更快或多核处理器替换现有的 CPU，以提高处理能力并实现更快的查询执行。 向服务器添加更多 RAM 以增加内存容量，从而改善缓存。 升级到更快的存储设备，例如固态硬盘 (SSD)。 为了了解垂直扩展的好处，我们来考虑一个在购物旺季流量激增的电子商务应用程序。随着数据库服务器上的负载增加，查询响应时间可能会受到影响，从而导致用户体验不佳。
为了解决这一可扩展性挑战，应用程序所有者决定垂直扩展数据库服务器。他们使用更强大的 CPU 升级服务器，将 RAM 容量增加一倍，并用 SSD 替换硬盘驱动器 (HDD)。
这些硬件增强功能显著提高了数据库服务器的性能。更快的 CPU 和更大的内存可实现更快的查询执行和高效的缓存，而 SSD 则可提供更快的数据检索和写入速度。
因此，数据库服务器可以处理更多并发用户并提供更高的性能。
垂直扩展与数据库可扩展性的优势 垂直扩展可以通过多种方式提高数据库的可扩展性：</description>
    </item>
    <item>
      <title>[译]关系数据库设计速成课程</title>
      <link>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-relational-database/</link>
      <pubDate>Mon, 05 Aug 2024 08:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-relational-database/</guid>
      <description>原文链接：https://blog.bytebytego.com/p/a-crash-course-on-relational-database
在当今数据驱动的世界中，高效存储和管理信息是各种规模的企业和组织的关键要求。
关系数据库提供了一个强大的框架，用于根据实体之间明确定义的关系来存储和检索数据。它们提供了一种结构化的数据管理方法，使用户能够：
定义表 建立关系 执行复杂查询以从存储的信息中提取有意义的见解 然而，仅仅使用关系数据库还不足以获得其好处。
有效的数据库设计对于优化性能、确保数据完整性和促进高效的数据检索至关重要。数据库设计原则（例如规范化、索引、连接和关系）在创建结构良好且性能良好的数据库中起着至关重要的作用。
在这篇文章中，我们将研究关系数据库的基础知识，探讨其关键概念、管理系统以及有效数据库设计的基础原则。
什么是关系数据库？ 关系数据库是一种将数据组织成结构化表格（也称为关系）的数据库。这些表格由行（记录）和列（字段）组成，形成表格结构，可实现高效的数据存储和检索。
关系数据库的强大之处在于它能够在多个表之间建立关系。
通过定义相关表之间的连接，可以链接和组合信息。这允许跨多个表进行复杂的查询和数据检索操作，使您能够以各种方式访问和分析数据。
为了有效地使用关系数据库，我们需要一个关系数据库管理系统 (RDBMS)。
RDBMS 是一种用于创建、管理和与关系数据库交互的软件应用程序。
RDBMS 提供的一些关键功能包括：
数据定义： 定义数据库的结构，包括表、列、数据类型和约束。 数据操作： 对数据库中存储的数据执行各种操作。包括插入新记录、更新现有记录、删除记录等。 数据完整性： RDBMS 强制执行数据完整性规则来维护数据的准确性和一致性。 数据安全： RDBMS 还通过定义用户角色、权限和身份验证措施来提供控制数据库访问的机制。 查询优化： RDBMS 优化复杂查询的执行，以高效检索数据。它采用各种技术，例如索引和查询优化算法。 市场上有多种 RDBMS，每种都具有一组特性和功能。以下是一些示例：
MySQL： 一种开源 RDBMS，以其简单性、可靠性和广泛采用而闻名。 PostgreSQL： 一个强大的开源 RDBMS，具有高级功能和对数据完整性的强大支持。 Oracle 数据库： 一种功能全面、丰富的 RDBMS，常用于企业环境。 SQL：关系数据库语言 SQL（结构化查询语言）是用于与关系数据库交互的标准编程语言。
其主要优势之一是通用性。在 MySQL、PostgreSQL、Oracle 等上工作时，语法基本保持不变。
这种可移植性使开发人员能够以最小的学习曲线从一个 RDBMS 切换到另一个 RDBMS。
SQL 提供了一套全面的命令和语法，允许开发人员和数据库管理员对数据库中存储的数据执行各种操作。
SQL 支持四种基本的数据操作，通常称为 CRUD：
创建： 将新记录插入数据库表，有效地创建新的数据条目。 读取： 根据特定条件从一个或多个表中检索数据。 更新： 修改数据库中现有的记录。 删除： 从数据库表中删除不再需要或满足特定删除条件的记录。 除了数据操作之外，SQL 还提供定义和修改数据库结构的命令。
基本 RDBMS 概念 使用关系数据库时，了解基本概念和术语至关重要。
让我们探讨一些关键术语：
表： 按行和列组织的相关数据的结构化集合。每个表代表一个特定的实体或概念，例如客户、订单或产品。 行： 行，也称为记录或元组，表示表中的单个实例或条目。例如，在“客户”表中，每一行都属于具有某些属性的单个客户。 列： 列，也称为字段或属性，表示表中特定记录的特定特征或属性。列用于组织和分类表中的数据。 主键： 主键是一列或多列的组合，用作表中每条记录的唯一标识符。它通过防止主键列中的重复值或空值来确保数据的唯一性和完整性。 外键： 外键是表中引用另一个表的主键的列或列组合。它建立两个表之间的关系，并有助于加强引用完整性和数据一致性。 连接： 连接是一种根据相关列将两个或多个表中的行组合在一起的操作。通过指定组合表的条件，可以从多个表中检索数据。 索引： 索引是一种数据结构，可提高数据库中数据检索操作的性能。它根据一个或多个列创建表中数据的排序表示。 视图： 视图是从一个或多个基础表动态生成的虚拟表。它提供数据的自定义和简化表示。视图可用于安全性、简化或数据抽象目的。 关系数据库中的键 键是关系数据库设计中的基本组件，在数据完整性和建立表间关系方面发挥着至关重要的作用。
它们作为记录的唯一标识符，使数据检索和处理更加高效。
让我们看看不同类型的键及其在关系数据库设计中的意义。
主键和索引 主键是唯一标识表中每条记录的一列或多列的组合。
它确保每条记录都是唯一的，并且可以在表中轻松找到。主键约束强制主键列的唯一性和非空性。
下面的示例显示如何将表中的某一列定义为主键：
CREATE TABLE books ( book_id INT PRIMARY KEY, title VARCHAR(100), author VARCHAR(100), isbn VARCHAR(20) UNIQUE, publication_year INT, genre VARCHAR(50) ); 通过指定 book_id INT PRIMARY KEY，我们将 book_id 列声明为“books”表的主键。换句话说，book_id 列中的每个值都必须是唯一的，并且不能为空。</description>
    </item>
    <item>
      <title>[译]分布式系统速成课程</title>
      <link>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-distributed-systems/</link>
      <pubDate>Mon, 05 Aug 2024 08:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-distributed-systems/</guid>
      <description>原文链接：https://blog.bytebytego.com/p/a-crash-course-on-distributed-systems
分布式系统是多台计算机（也称为节点）的集合，它们协作执行特定任务或提供服务。
这些节点在物理上是分开的，并通过网络传递消息相互通信。分布式系统可以跨越地理边界，使其能够利用来自不同位置的资源。
分布式系统有几个区别于传统集中式系统的特点：
分布式系统中的计算机在物理上是分开的，并通过网络连接。它们不共享内存或公共时钟。 从外部视角来看，分布式系统对于最终用户来说是一个单一、统一的实体。 分布式系统提供了在系统中添加或删除计算机的灵活性。 分布式系统中的节点需要相互协调并达成一致才能一致地执行操作。 分布式系统中的节点可能独立发生故障，并且消息可能会在网络上丢失或延迟。 分布式系统在我们的日常生活中无处不在。例如 Google 搜索等大型 Web 应用程序、在线银行系统、多人游戏等。这些系统利用多台计算机协同工作，提供无缝且响应迅速的用户体验。
在本文中，我们将探讨分布式系统的优势和挑战。我们还将讨论用于解决这些挑战并确保分布式系统可靠运行的常用方法和技术。
理解分布式系统 “分布式系统”这个术语有时会让开发人员感到困惑。
一些常见的混淆是关于分散系统和并行系统。
让我们在分布式系统的背景下了解这些术语的含义以及它们有何异同。
分散式系统与分布式系统 “分散式系统”和“分布式系统”等术语经常互换使用，但它们有一个关键的区别。
虽然这两种类型的系统都涉及多个组件协同工作，但决策过程却使它们有所区别。
在去中心化系统中，这也是一种分布式系统，没有任何一个组件能够完全控制决策过程。相反，每个组件都拥有决策的一部分，但不拥有做出独立决策所需的完整信息。
并行系统与分布式系统 与分布式系统密切相关的另一个术语是并行系统。
分布式和并行系统都旨在扩大计算能力，但它们使用不同的方法实现这一目标。
在并行计算中，一台机器内的多个处理器同时执行多个任务。这些处理器通常可以访问共享内存，从而可以交换数据并高效地协调其活动。
另一方面，分布式系统由多台不共享内存的自主机器组成。这些机器通过网络传递消息来通信和协调其操作。每台机器独立运行，通过执行分配的任务为整体计算做出贡献。
分布式系统的主要优点 虽然设计和构建分布式系统比传统的集中式系统更复杂，但它们的优势使得付出的努力值得。
让我们探索分布式系统的一些主要优势：
可扩展性：垂直扩展涉及增加单台机器的硬件资源，通常受到物理约束的限制。例如，单台机器可以添加的处理器核心数量是有限的。相比之下，分布式系统支持水平扩展，可以将其他商用机器添加到系统中。这样可以通过添加相对便宜的硬件来扩展系统。 可靠性：与集中式系统相比，分布式系统对故障的恢复能力更强。由于数据在多个节点上复制，因此单个节点或部分节点的故障不一定会导致整个系统崩溃。其余节点可以继续运行，尽管容量会降低，但可以确保整个系统保持正常运行。 性能：分布式计算通常涉及将复杂的工作负载分解为更小、更易于管理的部分，这些部分可以在多台机器上同时处理。这种并行处理能力可以提高计算密集型任务（例如矩阵乘法或大规模数据处理）的性能。 分布式系统的挑战 分布式系统在操作方面也面临多重挑战。
了解这些挑战和克服这些挑战的技术是利用分布式系统的关键。
让我们探讨分布式系统的主要挑战以及处理这些挑战的技术。
沟通 在分布式系统中，节点需要通过网络相互通信和协调，以作为一个有凝聚力的单元发挥作用。
然而，由于底层网络基础设施不可靠，这种通信具有挑战性。
负责在节点之间传递数据包的互联网协议 (IP) 仅提供“尽力而为”的服务。这意味着网络无法保证数据包的可靠传递。
数据包传输过程中可能会出现几个问题：
数据包丢失：由于网络拥塞、硬件故障或其他因素，数据包可能在传输过程中丢失或丢弃。 数据包重复：在某些情况下，数据包可能会被重复，导致同一数据包的多个副本被传送到目标节点。 数据包损坏：数据包在传输过程中可能会损坏。损坏的数据包可能包含无效或不正确的数据，从而导致通信错误。 无序传送：数据包到达目标节点的顺序可能与发送时的顺序不同。 在这个不可靠的基础上建立可靠的沟通是一项重大挑战。
分布式系统处理这些问题的一些关键技术如下：
1 - 使用 TCP 进行可靠通信 传输控制协议 (TCP) 是一种基础协议，它提供了一种强大的机制来确保进程之间字节流的可靠、按序传输，使其成为分布式系统中可靠数据传输的基石。
它采用了几种关键机制来克服网络固有的不可靠性：
TCP 将字节流分割成更小的、有序的数据包（称为段）。 它要求接收方在收到数据包后向发送方发送确认（ACK）。 TCP 使用校验和来验证传输数据的完整性。 TCP 实现流量控制以防止发送方用大量数据淹没接收方。 最后，TCP 采用拥塞控制机制来适应可用的网络带宽。 下图显示了客户端和服务器之间建立连接的 TCP 三次握手过程。
2 - 使用 TLS 确保通信安全 尽管 TCP 能够确保在不可靠的网络上进行可靠通信，但它并未解决数据传输的安全问题。这时，传输层安全性 (TLS) 协议便应运而生。
TLS 是一种加密协议，为 TCP 建立的通信通道添加加密、身份验证和完整性。
TLS 使用多种机制来保护节点之间的通信：
TLS 使用非对称和对称加密的组合来保护数据的机密性。 TLS 依靠数字证书来验证通信方的身份。 为了确保传输数据的完整性，TLS 在每条消息中都包含校验和或消息认证码。 3 - 使用 DNS 进行服务发现 在分布式系统中，节点需要一种机制来发现彼此并相互通信。这就是域名系统 (DNS) 发挥作用的地方，它解决了服务发现问题。</description>
    </item>
    <item>
      <title>[译]领域驱动设计速成课程</title>
      <link>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</link>
      <pubDate>Mon, 05 Aug 2024 08:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</guid>
      <description>原文链接：https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design
为复杂领域开发软件是一项具有挑战性的任务。
随着问题领域的复杂性不断增长，创建准确表示业务概念、规则和流程的软件变得越来越困难。设计不良的软件很快就会变成难以理解、难以维护和扩展的混乱代码。
领域驱动设计（DDD）为这个问题提供了解决方案。
DDD 是一种软件开发方法，它通过强调对核心领域和业务逻辑进行建模的重要性并使用这些模型作为软件设计的基础来解决领域复杂性。
领域驱动设计的核心是：
将主要焦点放在核心领域上。 基于领域模型的复杂设计 建立技术专家和领域专家之间的协作。 近年来，领域驱动设计的需求愈发迫切。基于微服务和云计算的架构已导致系统由众多以复杂方式交互的小组件组成。如果没有清晰且定义明确的领域模型来指导其设计，此类系统很快就会变成“一团泥球”。
在本文中，我们将了解领域驱动设计的基础知识及其关键概念，这些概念可以帮助我们构建与核心领域和业务逻辑一致的更易于维护和扩展的系统。
领域驱动设计的核心原则 领域驱动设计 (DDD) 专注于创建与底层业务领域紧密结合的软件系统。
它旨在通过将领域模型置于开发过程的中心来弥合技术实现和业务需求之间的差距。
DDD 有三个核心原则：
根据领域专家的输入创建丰富的领域模型 使用基于领域模型的通用语言 从领域模型驱动软件设计 让我们更详细地探讨每个原则。
创建丰富的领域模型 DDD 的基础在于创建一个丰富的领域模型，该模型可以准确捕捉问题领域的关键概念、关系和业务规则。该模型不是由开发团队单独创建的，而是通过与对业务有深入了解的领域专家密切合作而产生的。
将领域知识提炼为可用模型的过程称为知识消化。
在此过程中，开发团队与领域专家密切合作，以确定和完善与问题最相关的概念和规则。这种协作工作通常包括集思广益、试验不同的模型设计，以及根据开发过程中获得的反馈和见解进行迭代改进。
例如，在银行系统中，与财务部门领域专家进行的知识会议将重点了解账户、客户、交易和利息计算等核心概念。
目标是创建一个模型来捕捉这些基本概念及其关系，这些模型可以被领域专家理解，并可作为软件系统的实践基础。
使用通用语言 随着领域模型的成型，开发团队和领域专家会形成一种共同语言。DDD 将此称为通用语言，因为它渗透到项目的各个方面。
通用语言直接基于领域模型。
代码中的类、方法和变量的名称均源自模型概念。同样，在讨论和文档中，团队使用通用语言的术语和短语，以确保清晰的沟通并避免歧义。
通过一致使用通用语言，代码直接反映模型，使得模型更容易理解和修改。
例如，如果银行领域模型包含“帐户”、“存款”和“取款”等概念，那么这些相同的术语将在代码、开发人员和领域专家之间的讨论以及项目文档中一致使用。当每个人都使用相同的语言时，任何理解上的歧义或不一致之处都会很快显现出来。
这是一个简单的代码示例，演示了在编写类及其方法时如何使用通用语言。
public class Account { private String accountNumber; private double balance; public void deposit(double amount) { // Perform deposit logic balance += amount; } public void withdraw(double amount) { // Perform withdrawal logic if (balance &amp;gt;= amount) { balance -= amount; } else { throw new InsufficientFundsException(&amp;#34;Insufficient funds for withdrawal&amp;#34;); } } } 领域模型到软件设计 在 DDD 中，领域模型不仅仅是一个概念工具。它是软件设计的基础。软件的结构和行为反映了模型的结构和行为。
这种方法称为模型驱动设计。
在实践中，这意味着代码中的类、关系和行为直接对应于领域模型中的概念、关系和规则。设计不是由技术考虑或基础设施细节驱动，而是由有效表达领域模型的需求驱动。
例如，如果银行领域模型定义了一个“帐户”概念，其中包含“存款”和“取款”等行为，那么软件设计将包括一个“帐户”类，其中包含“存款”和“取款”方法。这些方法如何工作的实现细节将由模型中捕获的规则和要求指导。我们已经在上一节中看到了这一点。
构建领域模型的关键模式 构建领域模型是领域驱动设计中最重要的方面。然而，一些关键的模式和实践可以帮助我们实现最佳结果。
让我们详细了解一下其中的主要内容。</description>
    </item>
    <item>
      <title>Redis安装和部署</title>
      <link>https://blog.chensoul.cc/posts/2024/05/14/redis-install/</link>
      <pubDate>Tue, 14 May 2024 11:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/14/redis-install/</guid>
      <description>单机安装 通过 yum 安装 在 CentOS 7 上通过 yum 安装 Redis，可以按照以下步骤进行操作：
更新系统软件包：
sudo yum update 安装 Redis：
sudo yum install redis 可以看到默认安装的 redis 版本是 3.2.12-2.el7
如果需要安装 redis 7，这需要下载 yum 源：
sudo yum install epel-release sudo yum -y install http://rpms.remirepo.net/enterprise/remi-release-7.rpm 然后，在指定源进行安装：
yum --enablerepo=remi install redis 启动 Redis 服务：
sudo systemctl start redis 配置 Redis 开机自启动：
sudo systemctl enable redis 修改配置文件 /etc/redis.conf
修改 bind 和 requirepass
bind 0.0.0.0 requirepass 123456 然后重启 redis：
sudo systemctl restart redis 开启防火墙（可选）
# 添加 redis 端口 firewall-cmd --zone=public --add-port=6379/tcp --permanent firewall-cmd --zone=public --add-port=6379/udp --permanent # 重启防火墙 firewall-cmd --reload 运行 redis-cli
redis-cli 127.0.0.1:6379&amp;gt; auth 123456 OK 通过 snap 安装 安装 redis</description>
    </item>
    <item>
      <title>[译]《Grokking the System Design Interview》设计Twitter</title>
      <link>https://blog.chensoul.cc/posts/2023/12/14/designing-twitter/</link>
      <pubDate>Thu, 14 Dec 2023 09:40:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/12/14/designing-twitter/</guid>
      <description>这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Twitter》设计 Twitter。
Let’s design a Twitter-like social networking service. Users of the service will be able to post tweets, follow other people, and favorite tweets. Difficulty Level: Medium
让我们设计一个类似 Twitter 的社交网络服务。该服务的用户将能够发布推文、关注其他人以及喜欢的推文。难度级别：中等
1. What is Twitter? 1.什么是推特？
Twitter is an online social networking service where users post and read short 140-character messages called “tweets.” Registered users can post and read tweets, but those who are not registered can only read them. Users access Twitter through their website interface, SMS, or mobile app.
Twitter 是一种在线社交网络服务，用户可以在其中发布和阅读称为“推文”的 140 个字符的简短消息。注册用户可以发布和阅读推文，但未注册的用户只能阅读推文。用户通过网站界面、短信或移动应用程序访问 Twitter。
2. Requirements and Goals of the System 系统的要求和目标 We will be designing a simpler version of Twitter with the following requirements:</description>
    </item>
    <item>
      <title>如何设计一个分布式ID生成器保证ID按时间有序？</title>
      <link>https://blog.chensoul.cc/posts/2023/12/05/distributed-id-generator/</link>
      <pubDate>Tue, 05 Dec 2023 09:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/12/05/distributed-id-generator/</guid>
      <description>很多业务有生成唯一 ID 并作为数据库主键的需求。数据库会在这个字段上建立聚集索引（参考 MySQL InnoDB），即该字段会影响各条数据再物理存储上的顺序。
ID还要尽可能短，节省内存，让数据库索引效率更高。基本上64位整数能够满足绝大多数的场景，但是如果能做到比64位更短那就更好了。需要根据具体业务进行分析，预估出ID的最大值，这个最大值通常比64位整数的上限小很多，于是我们可以用更少的bit表示这个ID。
查询的时候，往往有分页或者排序的需求，所以需要给每条数据添加一个时间字段，并在其上建立普通索引(Secondary Index)。但是普通索引的访问效率比聚集索引慢，如果能够让ID按照时间粗略有序，则可以省去这个时间字段。为什么不是按照时间精确有序呢？因为按照时间精确有序是做不到的，除非用一个单机算法，在分布式场景下做到精确有序性能一般很差。
这就引出了 ID 生成的三大核心需求：
全局唯一 按照时间粗略有序 尽可能短 下面介绍一些常用的生成 ID 的方法。
UUID UUID 是一类算法的统称，具体有不同的实现。UUID 的优点是每台机器可以独立产生 ID，理论上保证不会重复，所以天然是分布式的；缺点是生成的 ID 太长，不仅占用内存，而且索引查询效率低。
MongoDB 的 ObjectId 使用的就是 UUID 算法。生成的 ObjectId 占 12 个字节，由以下几个部分组成，
4 个字节表示的 Unix timestamp 3 个字节表示的机器的 ID 2 个字节表示的进程 ID 3 个字节表示的计数器 使用数据库 可以使用数据库中的自增主键来生成ID。将ID生成的过程交给数据库管理，每个节点向数据库插入记录时，数据库会自动分配一个唯一的ID。通过使用数据库的自动递增功能，可以保证ID的唯一性和粗略有序性。
在分布式环境下，可以使用多台数据库协同工作生成 ID。假设用 8 台MySQL服务器协同工作，第一台 MySQL 初始值是 1，每次自增 8，第二台 MySQL 初始值是 2，每次自增 8，依次类推。在数据库前面添加一个负载均衡，每来一个请求，由负载均衡随机地将请求发给 8 台 MySQL 中的任意一个，然后返回一个ID。
Flickr就是这么做的，仅仅使用了两台 MySQL 服务器。可见这个方法虽然简单无脑，但是性能足够好。不过要注意，在 MySQL 中，不需要把所有 ID 都存下来，每台机器只需要存一个 MAX_ID 就可以了。这需要用到 MySQL 的一个 REPLACE INTO 特性。
Flickr 的实现方式如下。
Tickets64 表结构如下：
CREATE TABLE `Tickets64` ( `id` bigint(20) unsigned NOT NULL auto_increment, `stub` char(1) NOT NULL default &amp;#39;&amp;#39;, PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ) ENGINE=InnoDB SELECT * from Tickets64 返回一行，如下所示：</description>
    </item>
    <item>
      <title>[译]《Grokking the System Design Interview》设计Dropbox</title>
      <link>https://blog.chensoul.cc/posts/2023/11/24/designing-dropbox/</link>
      <pubDate>Fri, 24 Nov 2023 10:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/24/designing-dropbox/</guid>
      <description>这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Dropbox》设计 Dropbox。
Let’s design a file hosting service like Dropbox or Google Drive. Cloud file storage enables users to store their data on remote servers. Usually, these servers are maintained by cloud storage providers and made available to users over a network (typically through the Internet). Users pay for their cloud data storage on a monthly basis. Similar Services: OneDrive, Google Drive Difficulty Level: Medium
让我们设计一个文件托管服务，例如 Dropbox 或 Google Drive。云文件存储使用户能够将数据存储在远程服务器上。通常，这些服务器由云存储提供商维护，并通过网络（通常通过互联网）提供给用户。用户按月支付云数据存储费用。类似服务：OneDrive、Google Drive 难度级别：中
1. Why Cloud Storage? 为什么选择云存储？ Cloud file storage services have become very popular recently as they simplify the storage and exchange of digital resources among multiple devices.</description>
    </item>
    <item>
      <title>[译]《Grokking the System Design Interview》设计Facebook Messenger</title>
      <link>https://blog.chensoul.cc/posts/2023/11/24/designing-facebook-messenger/</link>
      <pubDate>Fri, 24 Nov 2023 09:40:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/24/designing-facebook-messenger/</guid>
      <description>这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Facebook Messenger》设计 Facebook Messenger。
Let’s design an instant messaging service like Facebook Messenger where users can send text messages to each other through web and mobile interfaces. 让我们设计一个像 Facebook Messenger 这样的即时消息服务，用户可以通过网络和移动界面互相发送短信。
1. What is Facebook Messenger? 1.什么是 Facebook Messenger？
Facebook Messenger is a software application which provides text-based instant messaging services to its users. Messenger users can chat with their Facebook friends both from cell-phones and Facebook’s website.
Facebook Messenger 是一款为其用户提供基于文本的即时消息服务的软件应用程序。 Messenger 用户可以通过手机和 Facebook 网站与 Facebook 好友聊天。
2. Requirements and Goals of the System 系统的要求和目标 Our Messenger should meet the following requirements:
我们的 Messenger 应满足以下要求：
Functional Requirements:</description>
    </item>
    <item>
      <title>[译]《Grokking the System Design Interview》设计Instagram</title>
      <link>https://blog.chensoul.cc/posts/2023/11/24/designing-instagram/</link>
      <pubDate>Fri, 24 Nov 2023 09:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/24/designing-instagram/</guid>
      <description>这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Instagram》设计 Instagram。
Let’s design a photo-sharing service like Instagram, where users can upload photos to share them with other users. Similar Services: Flickr, Picasa Difficulty Level: Medium
让我们设计一个像 Instagram 这样的照片共享服务，用户可以上传照片与其他用户共享。类似服务：Flickr、Picasa 难度级别：中
1. What is Instagram? 1.Instagram是什么？
Instagram is a social networking service which enables its users to upload and share their photos and videos with other users. Instagram users can choose to share information either publicly or privately. Anything shared publicly can be seen by any other user, whereas privately shared content can only be accessed by a specified set of people. Instagram also enables its users to share through many other social networking platforms, such as Facebook, Twitter, Flickr, and Tumblr.</description>
    </item>
    <item>
      <title>[译]《Grokking the System Design Interview》设计Pastebin</title>
      <link>https://blog.chensoul.cc/posts/2023/11/24/designing-pastebin/</link>
      <pubDate>Fri, 24 Nov 2023 08:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/24/designing-pastebin/</guid>
      <description>这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Pastebin》设计 Pastebin。
Let’s design a Pastebin like web service, where users can store plain text. Users of the service will enter a piece of text and get a randomly generated URL to access it. Similar Services: pastebin.com, pasted.co, chopapp.com Difficulty Level: Easy
让我们设计一个类似 Pastebin 的 Web 服务，用户可以在其中存储纯文本。该服务的用户将输入一段文本并获得一个随机生成的 URL 来访问它。类似服务：pastebin.com、pasted.co、hopapp.com 难度级别：简单
1. What is Pastebin? 1.Pastebin是什么？
Pastebin like services enable users to store plain text or images over the network (typically the Internet) and generate unique URLs to access the uploaded data. Such services are also used to share data over the network quickly, as users would just need to pass the URL to let other users see it.</description>
    </item>
    <item>
      <title>[译]《Grokking the System Design Interview》域名系统</title>
      <link>https://blog.chensoul.cc/posts/2023/11/17/dns/</link>
      <pubDate>Fri, 17 Nov 2023 17:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/17/dns/</guid>
      <description>这是一篇双语翻译的文章，原文出自《Grokking the System Design Interview》教程的 Domain Name System 这篇章节。
Introduction to Domain Name System (DNS) 域名系统 (DNS) 简介
The origins of DNS DNS 的起源
Let’s consider the example of a mobile phone where a unique number is associated with each user. To make calls to friends, we can initially try to memorize some of the phone numbers. However, as the number of contacts grows, we’ll have to use a phone book to keep track of all our contacts. This way, whenever we need to make a call, we’ll refer to the phone book and dial the number we need.
让我们考虑一个移动电话的示例，其中每个用户都有一个唯一的号码。为了给朋友打电话，我们首先可以尝试记住一些电话号码。然而，随着联系人数量的增加，我们将不得不使用电话簿来跟踪所有联系人。这样，每当我们需要打电话时，我们都会查阅电话簿并拨打我们需要的号码。</description>
    </item>
    <item>
      <title>如何设计一个短网址服务</title>
      <link>https://blog.chensoul.cc/posts/2023/11/17/designing-a-url-shortening-service/</link>
      <pubDate>Fri, 17 Nov 2023 16:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/17/designing-a-url-shortening-service/</guid>
      <description>如何生成一个短网址服务，参考 Design a URL Shortening Service / TinyURL 和 Designing a URL Shortening service like TinyURL 两篇文章，整理如下笔记。
其中主要包括以下内容：
设计一个系统有哪些步骤 需求 预估 设计 高层次设计 API 设计 细节设计 评估 设计一个短网址服务的细节 设计步骤 Requirements 需求
功能性需求 短 URL 生成：我们的服务应该能够为给定 URL 生成唯一的较短别名。 重定向：给定一个短链接，我们的系统应该能够将用户重定向到原始 URL。 自定义短链接：用户应该能够使用我们的系统为其 URL 生成自定义短链接。 删除：在赋予权限的情况下，用户应该能够删除我们系统生成的短链接。 更新：如果有适当的权限，用户应该能够更新与短链接关联的长 URL。 过期时间：短链接必须有一个默认的过期时间，但用户应该可以根据自己的需求设置过期时间。 分功能性需求：可用性、可靠性、扩展性、可维护性、容错性 可用性：我们的系统应该具有高可用性，因为即使是第二次停机的一小部分也会导致 URL 重定向失败。由于我们系统的域位于 URL 中，因此我们没有停机时间的优势，并且我们的设计必须灌输容错条件。 可扩展性：我们的系统应该能够随着需求的增加而水平扩展。 可读性：我们的系统生成的短链接应该易于阅读、区分和输入。 延迟：系统应以低延迟执行，以便为用户提供流畅的体验。 不可预测性：从安全角度来看，我们的系统生成的短链接应该是高度不可预测的。这确保了下一个短 URL 不会连续生成，从而消除了有人猜测我们的系统已经生成或将生成的所有短 URL 的可能性。 Estimation 估计
流量 读写比：1:100 每月请求数：2 亿 单条记录占用空间：500B 记录保存多长时间：5 年 每日活跃用户 (DAU) ：1 亿 存储 5 年记录数：2 亿 x 5 x 12 =120 亿 总存储：120 亿 x 500B= 120 亿 x 0.5KB=6TB 带宽 每秒写请求：2 亿 / 30 /24 /60 /60 = 77次/s 写入带宽：77 x 500B =38KB/s 读带宽：38 x 100 =3.</description>
    </item>
    <item>
      <title>[译]《Grokking the System Design Interview》系统设计主模板</title>
      <link>https://blog.chensoul.cc/posts/2023/11/16/system-design-master-template/</link>
      <pubDate>Thu, 16 Nov 2023 12:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/16/system-design-master-template/</guid>
      <description>这是一篇双语翻译的文章，原文出自《Grokking the System Design Interview》教程的 System Design Master Template 这篇章节。
System design interviews are unstructured by design. In these interviews, you are asked to take on an open-ended design problem that doesn’t have a standard solution.
系统设计面试在设计上是非结构化的。在这些面试中，您被要求解决一个没有标准解决方案的开放式设计问题。
The two biggest challenges of answering a system design interview question are:
回答系统设计面试问题的两个最大挑战是：
To know where to start.
知道从哪里开始。
To know if you have talked about all the important parts of the system.
了解您是否已经讨论过系统的所有重要部分。
To simplify this process, the course offers a comprehensive system design template that can effectively guide you in addressing any system design interview question.
为了简化这个过程，本课程提供了一个全面的系统设计模板，可以有效地指导您解决任何系统设计面试问题。
Have a look at the following image to understand the major components that could be part of any system design and how these components interact with each other.</description>
    </item>
    <item>
      <title>[译]《Grokking the System Design Interview》设计类似 TinyURL 的 URL 缩短服务</title>
      <link>https://blog.chensoul.cc/posts/2023/11/16/designing-a-url-shortening-service/</link>
      <pubDate>Thu, 16 Nov 2023 07:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/16/designing-a-url-shortening-service/</guid>
      <description>这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing a URL Shortening service like TinyURL》设计类似 TinyURL 的 URL 缩短服务。
Let’s design a URL shortening service like TinyURL. This service will provide short aliases redirecting to long URLs. Similar services: bit.ly, goo.gl, qlink.me, etc.
让我们设计一个像 TinyURL 这样的 URL 缩短服务。该服务将提供重定向到长 URL 的短别名。类似服务：bit.ly、goo.gl、qlink.me等。
Difficulty Level: Easy
难度级别：简单
1.Why do we need URL shortening? 1.为什么需要URL缩短？
URL shortening is used to create shorter aliases for long URLs. We call these shortened aliases “short links.” Users are redirected to the original URL when they hit these short links. Short links save a lot of space when displayed, printed, messaged, or tweeted. Additionally, users are less likely to mistype shorter URLs.</description>
    </item>
    <item>
      <title>[译]《Grokking the System Design Interview》系统设计访谈：分步指南</title>
      <link>https://blog.chensoul.cc/posts/2023/11/16/sdi-a-step-by-step-guide/</link>
      <pubDate>Thu, 16 Nov 2023 06:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/16/sdi-a-step-by-step-guide/</guid>
      <description>这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《System Design Interviews: A step by step guide》系统设计访谈：分步指南。
A lot of software engineers struggle with system design interviews (SDIs) primarily because of three reasons:
许多软件工程师在系统设计面试（SDI）中遇到困难，主要是因为以下三个原因：
The unstructured nature of SDIs, where they are asked to work on an open-ended design problem that doesn’t have a standard answer.
SDI 的非结构化性质，要求他们解决没有标准答案的开放式设计问题。
Their lack of experience in developing large scale systems.
他们缺乏开发大型系统的经验。
They did not prepare for SDIs.
他们没有为 SDI 做好准备。
Like coding interviews, candidates who haven’t put a conscious effort to prepare for SDIs, mostly perform poorly especially at top companies like Google, Facebook, Amazon, Microsoft, etc. In these companies, candidates who don’t perform above average, have a limited chance to get an offer.</description>
    </item>
    <item>
      <title>分布式基础知识</title>
      <link>https://blog.chensoul.cc/posts/2023/11/14/distributed-system-basic/</link>
      <pubDate>Tue, 14 Nov 2023 07:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/14/distributed-system-basic/</guid>
      <description>什么是分布式系统？ 分布式系统是指由多个独立的计算机节点（或服务器）通过网络相互连接和协作，共同完成某个任务或提供某个服务的系统。在分布式系统中，各个节点可以同时进行计算、存储和通信，并通过消息传递等方式进行协调和同步。
分布式系统的设计目标是提高系统的性能、可靠性和可扩展性，同时减少单点故障和提高系统的容错性。通过将任务和数据分布到多个节点上，分布式系统可以实现更高的并行性和处理能力。此外，分布式系统还可以提供更好的负载均衡，以应对不断增长的工作负载。
分布式系统的主要特征 分布式系统具有以下主要特征：
分布性：分布式系统中的计算机节点分布在不同的物理或逻辑位置上，可以是同一局域网内的多台机器，也可以是分布在全球不同地区的服务器。 并行性：分布式系统中的节点可以同时进行计算和处理任务，从而实现并行处理和提高系统的性能。并行性可以通过将任务划分为子任务，并在不同节点上并行执行来实现。 通信：分布式系统通过网络进行节点之间的通信和数据传输，以实现协作和信息交换。节点之间的通信可以通过消息传递、远程过程调用（RPC）或分布式共享内存等方式实现。 缺乏全局时钟：由于节点之间的通信延迟和不可靠性，分布式系统往往无法依赖全局时钟来进行同步。因此，分布式系统需要采用一些分布式算法来实现一致性和协调，如分布式锁、一致性协议等。 容错性：分布式系统需要具备容错机制，以应对节点故障、网络故障或其他异常情况。容错性的实现通常包括备份和冗余，例如使用冗余节点、数据复制和副本机制，以确保系统的可用性和数据的完整性。 可扩展性：分布式系统应具备良好的可扩展性，即能够方便地扩展节点数量和处理能力，以适应不断增长的工作负载。可扩展性的实现可能包括水平扩展、垂直扩展、负载均衡等技术手段。 不确定性：由于节点之间的通信延迟和不可靠性，分布式系统中的操作可能存在不确定性。例如，消息传递可能会有延迟，网络可能会发生分区，导致节点之间的信息不一致。因此，分布式系统需要考虑和处理这种不确定性情况。 这些特征使得分布式系统能够实现高性能、高可用性和可扩展性，但也带来了挑战，如一致性问题、并发控制、故障处理等。因此，在设计和开发分布式系统时，需要考虑这些特征，并选择合适的技术和算法来解决相关问题。
分布式系统面临的问题 分布式系统面临的问题包括以下几个方面：
一致性问题：在分布式系统中，数据的复制和同步是一个挑战。节点之间的数据复制可能存在延迟和不一致性，需要采用合适的复制策略和同步机制，如主从复制、多主复制、一致性哈希等。 并发控制：在分布式系统中，多个节点同时对共享资源进行读写操作可能导致并发冲突和数据不一致。并发控制机制，如分布式锁、版本控制、乐观并发控制等，用于确保对共享资源的访问是安全和有序的。 故障处理和容错性：分布式系统中的节点可能会发生故障，如节点崩溃、网络分区等，这可能导致数据丢失或系统不可用。为了保证系统的可用性和数据的完整性，需要采用故障检测和恢复机制，如心跳检测、故障转移、数据备份等。 分布式系统的可扩展性：随着用户和数据量的增长，分布式系统需要能够方便地扩展节点数量和处理能力。设计和实现具有良好可扩展性的分布式系统需要考虑负载均衡、数据分片、分布式缓存等技术手段。 监控和管理：在分布式系统中，由于节点数量众多，监控和管理变得更加复杂。需要建立有效的监控系统来收集和分析系统的运行状态和性能指标，并采用自动化的管理工具来管理节点、配置和部署系统。 衡量分布式系统的指标 衡量分布式系统性能和质量的指标可以包括以下几个方面：
可用性：指系统处于正常运行状态的时间比例。如果用户无法访问系统，则称系统不可用。通常以百分比（如99.9%）表示。较高的可用性意味着系统更可靠，用户能够更稳定地访问和使用系统。
从技术角度来看，可用性主要与容错性有关。因为故障发生的概率随着组件数量的增加而增加，系统应该能够进行补偿，以确保随着组件数量的增加，系统的可靠性不会降低。
容错性是指系统在发生故障时仍能以明确定义的方式继续运行的能力。
**可扩展性：衡量分布式系统在面对不断增长的工作负载时，能够方便地扩展节点数量和处理能力的能力。**可扩展性可以包括水平扩展（增加节点数量）和垂直扩展（增加节点的处理能力）。
**一致性：表示分布式系统中的数据副本在不同节点之间保持一致的程度。**较高的一致性意味着系统中的数据在不同节点上的访问结果是相同的，而较低的一致性可能导致数据不一致的情况。
**可靠性：表示分布式系统在面对节点故障、网络故障或其他异常情况时能够继续正常运行的能力。**可靠性通常与容错性相关，包括故障检测、故障转移、数据备份等机制。
性能：是指计算机系统在使用的时间和资源相对于所完成的有用工作量来衡量的特征。
吞吐量：表示分布式系统在单位时间内能够处理的请求或事务数量。吞吐量越高，系统的处理能力越强，能够更高效地处理用户请求和数据处理任务。 响应时间：表示分布式系统对于用户请求的响应速度。较低的响应时间意味着系统能够更快地响应用户请求，提供更好的用户体验。 并发性能：衡量系统在处理并发请求时的能力。较好的并发性能意味着系统能够同时处理多个请求，并保持较低的响应时间和高吞吐量。 总结 任何计算机系统都需要完成两个基本任务：
存储 计算 随着任务规模变大：
1、使用单台计算机，硬件升级，成本过高 2、使用多台计算机，使用中档、大众化的硬件，成本降低 使用多台计算机存在如下特征：
分布性。计算机节点分布在不同的位置。 并行性。计算机节点可以同时进行计算和处理任务。 可扩展性：可以添加节点，提高处理能力。 不确定性。由于节点之间通信有延迟或者存在故障，会导致消息传递有延迟、节点信息存在不一致 使用多台计算机面临的问题：
节点的数量。
数量变多，增加系统故障概率，可能导致数据丢失或系统不可用。 数量变多，并行读写数据，会导致并发冲突和数据不一致。 节点之间的距离。
每个节点的时钟不同步，会导致网络延迟 节点之间数据需要复制和同步，会导致数据不一致性。 节点之间距离变远，会降低某些操作的性能。 所以，分布式系统要提供以下能力：
可用性。 可扩展性。可以增加节点数量和提高节点处理能力。 一致性。提高数据一致性。 可靠性。系统故障时，仍然能正常运行。 性能。 </description>
    </item>
    <item>
      <title>[译]给年轻的工程师们的关于分布式系统的一些笔记</title>
      <link>https://blog.chensoul.cc/posts/2023/11/10/notes-on-distributed-systems-for-young-bloods/</link>
      <pubDate>Fri, 10 Nov 2023 08:40:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/10/notes-on-distributed-systems-for-young-bloods/</guid>
      <description>我一直在思考分布式系统工程师在工作中学到的教训。我们大部分的教导都来自于在生产环境中犯过的错误留下的伤痕。这些伤痕固然是有用的提醒，但让更多的工程师能够完整地保留手指会更好。
新的系统工程师在自我学习中会遇到分布式计算的谬论和CAP定理。但这些都是抽象的概念，缺乏针对经验不足的工程师直接可行的建议。让人惊讶的是，新工程师在开始工作时所了解到的背景信息是如此之少。
下面是我作为一名分布式系统工程师学到的一些经验教训，值得告诉新工程师。其中一些经验是微妙的，一些是令人惊讶的，但没有一条是有争议的。这个列表是为了引导新的分布式系统工程师思考他们所从事领域的问题，虽然不是全面的，但是是一个很好的开始。
这个列表最糟糕的特点是它主要关注技术问题，很少讨论工程师可能遇到的社交问题。由于分布式系统需要更多的机器和资本，它们的工程师往往需要与更多的团队和更大的组织合作。社交问题通常是任何软件开发者工作中最困难的部分，也许对于分布式系统的开发来说尤其如此。
我们的背景、教育和经验使我们倾向于采用技术解决方案，即使社交解决方案可能更高效、更令人满意。让我们试着纠正这一点。与计算机相比，人们并不那么挑剔，即使他们的接口没有那么标准化。
好了，我们开始吧。
分布式系统是不同的，因为它们经常失败。 当被问及是什么将分布式系统与软件工程的其他领域区分开来时，这位新工程师经常引用延迟，认为这是使分布式计算变得困难的原因。
但他们错了。分布式系统工程的区别在于失败的概率，更糟糕的是，部分失败的概率。如果格式良好的互斥锁解锁失败并出现错误，我们可以假设该过程不稳定并使其崩溃。但是，分布式互斥锁解锁的失败必须内置到锁定协议中。
没有从事过分布式计算的系统工程师会想出一些想法，比如“好吧，它只是将写入发送到两台机器”或“它会不断重试写入，直到它成功”。这些工程师还没有完全接受（尽管他们通常在理智上认识到）网络系统比只存在于一台机器上的系统更容易失败，而且故障往往是部分的而不是全部的。
其中一个写入可能会成功，而另一个写入失败，那么现在我们如何获得一致的数据视图呢？这些部分故障更难推理。
交换机故障、垃圾回收暂停导致领导者“消失”、套接字写操作似乎成功但实际上在另一台机器上失败、一台机器上的慢速磁盘驱动引起整个集群中的通信协议变慢等等。从本地内存读取比通过几个交换机读取更稳定。。
为失败而设计！
编写健壮的分布式系统比编写健壮的单机系统成本更高。 与单机解决方案相比，创建强大的分布式解决方案需要更多的资金，因为只有许多计算机才会发生故障。虚拟机和云技术使分布式系统工程更便宜，但不像能够在您已经拥有的计算机上进行设计、实施和测试那样便宜。并且存在难以在单台机器上复制的故障条件。
无论是因为它们只发生在比共享机器上可以容纳的数据集大小大得多的数据集上，还是在数据中心的网络条件下，分布式系统往往需要实际的（而不是模拟的）分发来清除它们的错误。当然，模拟非常有用。
健壮的开源分布式系统远不如健壮的单机系统常见。长时间运行多台机器的成本是开源社区的负担。业余爱好者和业余爱好者是开源软件的引擎，他们没有可用的财务资源来探索或解决分布式系统将遇到的许多问题。业余爱好者在空闲时间使用他们已经拥有的机器编写开源代码以取乐。
要找到愿意启动、维护和支付一堆机器的开源开发人员要困难得多。
为公司实体工作的工程师已经填补了部分空缺。但是，其组织的优先级可能与组织的优先级不一致。
虽然开源社区中的一些人已经意识到了这个问题，但它还没有得到解决。这很难。
协调非常困难。 尽可能避免协调机器。这通常被描述为“水平可伸缩性”。水平可扩展性的真正诀窍是独立性——能够将数据传送到机器上，从而将这些机器之间的通信和共识保持在最低限度。每当两台机器必须就某件事达成一致时，服务就会变得更难实现。
信息的传播速度是有上限的，网络通信比你想象的要脆弱，你对什么是共识的想法可能是错误的。在这里，了解 Two Generals 和 拜占庭将军 的问题很有用。（哦，Paxos真的很难实现；这不是脾气暴躁的老工程师认为他们比你更了解。）
如果你能把你的问题放在内存中，那可能是微不足道的。 对于分布式系统工程师来说，一台机器的本地问题很容易解决。当数据距离几个开关而不是几个指针取消引用时，弄清楚如何快速处理数据会更难。在分布式系统中，自计算机科学开始以来就记录的陈旧效率技巧不再适用。
对于在单台机器上运行的算法，有大量的文献和实现，因为大部分计算都是在单一的、不协调的机器上完成的。对于分布式系统来说，存在的数量要少得多。
“很慢”是你调试过的最难的问题。 “速度慢”可能意味着执行用户请求所涉及的一个或多个系统速度较慢。这可能意味着跨多台计算机的转换管道的一个或多个部分速度较慢。“它很慢”很难，部分原因是问题陈述没有提供很多关于缺陷位置的线索。部分故障，即那些没有出现在你通常查找的图表上的故障，潜伏在一个黑暗的角落里。
而且，在退化变得非常明显之前，您将无法获得那么多的资源（时间、金钱和工具）来解决它。Dapper 和 Zipkin 的出现是有原因的。
**在整个系统中实现反压机制。**反压是服务系统向请求系统发出故障信号，并由请求系统处理这些故障以防止自身和服务系统过载。设计反压意味着在负载过重和系统故障时限制资源使用。这是创建健壮的分布式系统的基本构建块之一。
实现反压通常涉及以下两种方式之一：要么将新消息丢弃，要么在资源受限或发生故障时将错误返回给用户（并在两种情况下增加指标）。对于与其他系统的连接和请求，超时和指数退避也是至关重要的。
如果没有反压机制，可能会发生级联故障或意外消息丢失。当一个系统无法处理另一个系统的故障时，它倾向于将故障传播给依赖它的另一个系统。
寻找实现部分可用性的方法。 部分可用性是指即使系统的某些部分发生故障，仍能返回一些结果。
搜索是一个理想的案例来探讨这个问题。搜索系统在结果质量和用户等待时间之间进行权衡。一个典型的搜索系统会设置一个时间限制，如果在搜索所有文档之前超过了时间限制，它会返回已经收集到的结果。这使得搜索在面对间歇性减速和错误时更容易扩展，因为这些故障被视为无法搜索所有文档的情况。系统允许返回部分结果给用户，并增加了其弹性。
再以Web应用程序中的私密消息功能为例。无论你做什么，私密消息的存储机器都可能同时宕机，用户会注意到这一点。那么在这个系统中，我们希望出现什么样的部分故障呢？
这需要一些思考。一般来说，人们对于无法使用私密消息功能（或许是其他一些用户也无法使用）会更容忍，而对于所有用户中有一些消息丢失则更为不满意。如果服务过载或其中一台机器故障，只让一小部分用户无法使用比让更大比例的用户丢失数据更可取。除此之外，我们可能不希望一个无关的功能（比如公共图片上传）受到影响，只因为私密消息功能出现问题。我们愿意付出多少努力来保持这些故障域的独立？
能够在部分可用性中识别这些权衡是很有帮助的。
指标是完成工作的唯一途径。 公开指标（如延迟百分比、特定操作的计数器增加、变化速率等）是弥合您对系统在生产环境中所做的假设与实际情况之间差距的唯一途径。了解系统在第20天的行为与第15天的行为有何不同，是成功工程和失败巫术之间的区别。当然，指标是了解问题和行为的必要手段，但并不足以知道接下来该做什么。
稍微提一下日志记录。日志文件是很有用的，但它们往往会欺骗人。例如，很常见的情况是几个错误类别的日志记录占据了日志文件的很大比例，但实际上在请求中的比例非常低。因为在大多数情况下记录成功是多余的（并且在大多数情况下会耗尽磁盘空间），而且工程师经常错误地猜测哪些错误类别是有用的，所以日志文件中充斥着各种奇怪的信息。最好以一种假设有人会阅读日志但没有看过代码的方式进行日志记录。
我见过很多次由于另一位工程师（或者我自己）过于强调日志中的一些奇怪现象而导致故障延长，而没有先将其与指标进行对比。我还见过另一位工程师（或者我自己）从少数几行日志中推断出整套失败行为的情况。但请注意：a) 我们之所以记住这些成功案例，是因为它们非常罕见；b) 除非指标或实验证实了故事，否则你并不是福尔摩斯（Sherlock）。
使用百分位数而不是平均值。 在绝大多数分布式系统中，百分位数（50th、99th、99.9th、99.99th）比平均值更准确、更有信息量。使用平均值假设正在评估的指标遵循正态分布曲线，但在实践中，这只适用于少数工程师关心的指标。 &amp;ldquo;平均延迟&amp;rdquo; 是一个常见的报告指标，但我从未见过一个延迟遵循正态分布曲线的分布式系统。如果指标不遵循正态分布曲线，平均值就没有意义，会导致错误的决策和理解。通过使用百分位数来避免这个陷阱。默认使用百分位数，你将更好地了解用户真正看待你的系统的方式。
学会估算你的容量。 因此，你将会知道一天有多少秒。知道你需要多少台机器来执行一个任务是一个持久系统和一个在工作开始3个月后需要被替换的系统之间的区别。或者更糟糕的是，在你完成将其投入生产之前就需要被替换。
以推文为例。在一台普通的机器上，你可以将多少个推文ID存放在内存中? 嗯，到2012年底，一台典型的机器有24 GB的内存，你需要4-5 GB的开销来运行操作系统，另外还需要至少几个GB来处理请求，而一个推文ID占用8个字节。这是你可能会进行的粗略计算。Jeff Dean的《每个人都应该知道的数字》幻灯片是一个很好的期望设定工具。
特性标志（Feature flags）是基础设施推出的方式。 特性标志是产品工程师在系统中推出新功能的常用方式。特性标志通常与前端A/B测试相关联，用于向部分用户展示新的设计或功能。但它们也是替换基础设施的强大方式。
很多项目因为选择了“大切换”或一系列“大切换”，然后由于发现了太晚的错误而被迫回滚，从而导致失败。通过使用特性标志，你将增强对项目的信心并减轻失败的成本。
假设你要从单一数据库迁移到一个隐藏了新存储解决方案细节的服务。使用特性标志，你可以逐步将写操作转移到新服务，与对旧数据库的写操作并行进行，以确保其写路径的正确性和速度足够快。在写路径达到100%并将数据回填到服务的数据存储完成后，你可以使用单独的特性标志开始从该服务读取，而不在用户响应中使用该数据，以检查性能问题。另一个特性标志可以用于比较从旧系统和新系统读取的数据。最后一个标志可以用于逐步增加从新系统进行“真实”读取操作。
通过将部署拆分为多个步骤，并通过特性标志提供快速和部分反应，你可以更容易地在扩展过程中发现错误和性能问题，而不是在“一次性发布”时发现。如果出现问题，你只需立即将特性标志设置降低到较低（可能是零）的设置。通过调整速率，你可以在不同的流量量级下进行调试和实验，知道任何问题都不会造成灾难。使用特性标志，你还可以选择其他迁移策略，例如基于每个用户的方式将请求转移到新系统，以提供对新系统的更好洞察。当你的新服务仍在原型阶段时，你可以将特性标志设置为较低，以减少新系统的资源消耗。
现在，特性标志对于经典训练的开发人员或新工程师来说可能听起来像是一堆条件语句的可怕混乱。而使用特性标志意味着接受多个基础设施和数据版本是一种常态，而不是罕见情况。这是一个深刻的教训。在单机系统中有效的方法在面对分布式问题时有时会失败。
特性标志最好被理解为一种权衡，以在代码和一个系统中交换局部复杂性，以获得全局的简单性和弹性。
**明智地选择ID空间。 **你为系统选择的ID空间将塑造你的系统。
要获取数据所需的ID数量越多，就越有选择将数据进行分区的选项。要获取数据所需的ID数量越少，消费你的系统输出就越容易。
以Twitter API的第一个版本为例。所有获取、创建和删除推文的操作都是基于每个推文的单个数字ID进行的。推文ID是一个简单的64位数字，不与任何其他数据相关联。随着推文数量的增加，人们意识到，如果将同一用户的所有推文存储在同一台机器上，可以有效地构建用户的推文时间线和其他用户订阅的时间线。
但公共API要求每个推文只能通过推文ID进行访问。要按用户对推文进行分区，需要构建一个查找服务，它知道哪个用户拥有哪个推文ID。如果必要，这是可行的，但成本不可忽视。
另一种选择是在任何推文查找时要求用户ID，并且最初只是使用推文ID进行存储，直到用户分区存储上线。另一种选择是在推文ID本身中包含用户ID，这样做的代价是推文ID不再具有k-sortable和数字的特性。
要注意在ID中明确和隐含地编码了哪种类型的信息。客户端可能利用ID的结构来去匿名化私人数据，以意想不到的方式爬取你的系统（自增ID通常是一个痛点），或进行其他一系列攻击。
利用数据局部性。 将数据的处理和缓存与其持久存储保持靠近，处理效率更高，同时保持缓存一致性和快速性更容易。与指针解引用和fread（3）相比，网络故障和延迟更多。
当然，数据局部性意味着在空间上靠近，但也意味着在时间上靠近。如果多个用户几乎同时进行相同的昂贵请求，也许可以将它们的请求合并为一个请求。如果在相近的时间内发出了多个相同类型的数据请求，可以将它们合并为一个更大的请求。这样做通常可以降低通信开销并更容易进行故障管理。
**将缓存数据写回持久存储是不好的。 **这种情况在比想象中更多的系统中发生。尤其是那些最初由缺乏分布式系统经验的人设计的系统。你将继承许多具有此缺陷的系统。如果实施者谈到“俄罗斯套娃缓存”，你很有可能遇到非常明显的错误。这个条目本可以从列表中省略，但我对此特别痛恨。这种缺陷的常见表现是用户信息（例如屏幕名称、电子邮件和哈希密码）神秘地恢复到先前的值。
计算机的能力超乎你的想象。 现在的现场存在很多关于机器能力的错误信息，这些信息来自于没有太多经验的从业者。
在2012年底，轻型Web服务器拥有6个或更多处理器，24GB内存和比你能使用的更多磁盘空间。在现代语言运行时环境中，一个相对复杂的CRUD应用程序在单个机器上可以在几百毫秒内轻松处理数千个请求每秒。这还只是下限。在大多数情况下，每台机器每秒处理数百个请求并不值得夸耀。
获得更高的性能并不难，尤其是如果你愿意对应用程序进行性能分析，并根据测量结果引入效率。
**利用CAP定理对系统进行批判。 **CAP定理不能用作构建系统的基础。它不是一个可以作为第一原则并从中推导出一个可行系统的定理。它的适用范围过于广泛，可能的解决方案空间也过于宽泛。
然而，CAP定理非常适合用于对分布式系统设计进行批判，并理解需要做出的权衡。通过对系统设计进行迭代，考虑CAP对其子系统施加的约束，最终可以得到更好的设计。作业中，将CAP定理的约束应用于俄罗斯套娃缓存的实际实现。
最后需要注意的是：在一致性（C）、可用性（A）和分区容忍性（P）中，不能选择CA。
**提取服务。 **这里的&amp;quot;服务&amp;quot;指的是&amp;quot;一个包含高级逻辑的分布式系统，通常具有请求-响应式的API&amp;quot;。要留意那些如果存在于一个单独的服务中而不是你的系统中，将更容易进行的代码更改。
提取出一个服务提供了封装的好处，通常与创建库相提并论。然而，提取出一个服务改进了创建库的方式，因为它允许更快、更容易地部署变更，而不像升级客户系统中的库那样麻烦。（当然，如果提取出的服务难以部署，那么客户系统将变得更容易部署。）这种便利是由于较小、提取出的服务中的代码和操作依赖较少，并且其创建的严格边界使得很难&amp;quot;走捷径&amp;quot;，而库则允许这种走捷径。这些走捷径通常会使迁移内部或客户系统到新版本变得更加困难。
当存在多个客户系统时，使用服务的协调成本也比使用共享库要低得多。即使不需要进行API更改，升级库也需要协调每个客户系统的部署。如果部署次序颠倒，可能会导致数据损坏（而且很难预测这种情况），这使得升级库变得更加困难。如果客户系统由不同的维护者负责，升级库的社交协调成本也比部署服务更高。让其他人意识到并愿意升级是非常困难的，因为他们的优先事项可能与你的不一致。
典型的服务使用案例是隐藏一个将要进行变更的存储层。提取出的服务具有更方便且表面积更小的API，与其前端的存储层相比。通过提取服务，客户系统无需了解迁移到新的存储系统或格式的复杂性，只需要评估新服务中肯定会发现的与新存储布局相关的错误。
在执行此操作时，需要考虑许多操作和社交问题。在这里无法对它们进行充分阐述。需要撰写另一篇文章对此进行详细说明。
我对我的审稿人Bill de hÓra、Coda Hale、JD Maturen、Micaela McDonald和Ted Nyman表示衷心感谢。你们的见解和关心是无价的。</description>
    </item>
    <item>
      <title>[译]《分布式系统：为了乐趣和利益》6.进一步阅读和附录</title>
      <link>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-06/</link>
      <pubDate>Fri, 10 Nov 2023 08:34:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-06/</guid>
      <description>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者Mikito Takada撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
6. 进一步阅读和附录 如果您已经做到了这一点，谢谢您。
如果您喜欢这本书，请在 Github（或 Twitter）上关注我。我很高兴看到我产生了某种积极的影响。 “创造的价值比你获取的价值更多”等等。
非常感谢：logpath、alexras、globalcitizen、graue、frankshearar、roryokane、jpfuentes2、eeror、cmeiklejohn、stevenproctor eos2102 和 steveloughran 的帮助！当然，任何错误和遗漏都是我的错！
值得注意的是，我关于最终一致性的章节相当以伯克利为中心；我想改变这一点。我还跳过了一个重要的时间用例：一致的快照。我还应该扩展几个主题：即，对安全性和活性属性的明确讨论以及对一致性哈希的更详细讨论。不过，我要去《Strange Loop 2013》了，所以无论如何。
如果这本书有第六章，它可能是关于如何利用和处理大量数据的。似乎最常见的“大数据”计算类型是通过单个简单程序传递大型数据集的计算。我不确定后续章节会是什么（也许是高性能计算，因为当前的重点是可行性），但我可能会在几年后知道。
有关分布式系统的书籍 Distributed Algorithms (Lynch) 这可能是最常推荐的分布式算法书籍。我也推荐它，但有一个警告。它非常全面，但是是为研究生读者编写的，因此在了解从业者最感兴趣的内容之前，您将花费大量时间阅读同步系统和共享内存算法。
Introduction to Reliable and Secure Distributed Programming (Cachin, Guerraoui &amp;amp; Rodrigues) 对于一个修炼者来说，这是一件有趣的事。它很短并且充满了实际的算法实现。
Replication: Theory and Practice 如果您对复制感兴趣，这本书非常棒。关于复制的章节主要基于对本书有趣部分以及最近阅读的内容的综合。
Distributed Systems: An Algorithmic Approach (Ghosh) Introduction to Distributed Algorithms (Tel) Transactional Information Systems: Theory, Algorithms, and the Practice of Concurrency Control and Recovery (Weikum &amp;amp; Vossen) 本书介绍的是传统的交易信息系统，例如：本地 RDBMS。最后有两章介绍分布式事务，但本书的重点是事务处理。
Transaction Processing: Concepts and Techniques by Gray and Reuter 经典之作。我发现 Weikum &amp;amp; Vossen 更更新。
开创性论文 每年，Edsger W. Dijkstra 分布式计算奖都会颁发给有关分布式计算原理的杰出论文。查看完整列表的链接，其中包括经典内容，例如：
&amp;ldquo;Time, Clocks and Ordering of Events in a Distributed System&amp;rdquo; - Leslie Lamport &amp;ldquo;Impossibility of Distributed Consensus With One Faulty Process&amp;rdquo; - Fisher, Lynch, Patterson &amp;ldquo;Unreliable failure detectors and reliable distributed systems&amp;rdquo; - Chandra and Toueg Microsoft 学术搜索有一个分布式和并行计算领域的顶级出版物列表，按引用次数排序 - 这可能是一个有趣的列表，可以浏览更多经典著作。</description>
    </item>
    <item>
      <title>[译]《分布式系统：为了乐趣和利益》5.复制：弱一致性模型协议</title>
      <link>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-05/</link>
      <pubDate>Fri, 10 Nov 2023 08:33:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-05/</guid>
      <description>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者 Mikito Takada 撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
5. 复制：弱一致性模型协议 现在，我们已经研究了一些可以在越来越现实的故障情况下实施单副本一致性的协议，让我们转向当我们放弃单副本一致性的要求时所打开的选择世界。
总的来说，很难找到一个单一的维度来定义或描述允许副本发散的协议。大多数这样的协议都具有高可用性，关键问题更多地在于最终用户是否发现这些保证、抽象和 API 对他们的目的有用，尽管在节点和/或网络故障发生时副本可能发散。
为什么弱一致性系统没有更受欢迎呢？
正如我在介绍中所述，我认为分布式编程很大程度上涉及处理分布的两个结果所带来的影响：
信息以光速传播； 独立的事物独立地发生故障。 由于信息传输速度受限，节点以不同且独特的方式体验世界。在单个节点上进行计算很容易，因为一切都按照可预测的全局总序发生。在分布式系统上进行计算很困难，因为没有全局总序。
长期以来（例如几十年的研究时间），我们通过引入全局总序来解决这个问题。我已经讨论了许多实现强一致性的方法，通过在没有自然总序的情况下以容错方式创建顺序的方法。
当然，问题在于强制执行顺序是昂贵的。这在大规模的互联网系统中特别突出，因为系统需要保持可用性。强一致性的系统不像分布式系统那样运行，而是像单个系统，这对于分区期间的可用性是不利的。
此外，对于每个操作，通常需要联系大多数节点，而且通常不止一次（正如您在关于 2PC 的讨论中所看到的）。这在需要在地理上分布以为全球用户提供足够性能的系统中尤其困难。
因此，默认情况下像单个系统一样运行可能并不理想。
也许我们希望拥有一种可以编写不使用昂贵协调的代码，但仍返回一个“可用”值的系统。我们将允许不同的副本彼此发散-既为了保持效率，也为了容忍分区-然后尝试以某种方式处理这种发散。
最终一致性表达了这个想法：节点在一段时间内可以相互发散，但最终它们将达成一致的值。
在提供最终一致性的系统集合中，有两种类型的系统设计：
带有概率保证的最终一致性。这种类型的系统可以在以后的某个时间点检测到冲突的写操作，但不能保证结果与某个正确的顺序执行等效。换句话说，冲突的更新有时会导致将较新的值覆盖为较旧的值，并且在正常操作（或分区）期间可能会出现一些异常情况。
近年来，最有影响力的提供单副本一致性的系统设计是亚马逊的 Dynamo，我将以它作为提供带有概率保证的最终一致性系统示例进行讨论。
带有强保证的最终一致性。这种类型的系统保证最终结果会收敛到一个共同的值，该值等同于某个正确的顺序执行。换句话说，这样的系统不会产生任何异常结果；在没有任何协调的情况下，您可以构建相同服务的副本，并且这些副本可以以任何模式进行通信并以任何顺序接收更新，只要它们都看到相同的信息，它们最终会就最终结果达成一致。
CRDT（收敛复制数据类型）是一种数据类型，它保证在网络延迟、分区和消息重排序的情况下收敛到相同的值。它们可以被证明是收敛的，但可以实现为 CRDT 的数据类型是有限的。
CALM（一致性作为逻辑单调性）猜想是相同原则的另一种表达方式：它将逻辑单调性与收敛等同起来。如果我们可以得出某个东西在逻辑上是单调的，那么在没有协调的情况下运行它也是安全的。收敛分析-特别是在 Bloom 编程语言中的应用-可用于指导程序员在何时何地使用强一致性系统的协调技术以及在何时可以安全地执行无需协调的操作。
协调不同的操作指令 不强制执行单副本一致性的系统是什么样子呢？让我们通过几个例子来更具体地了解。
也许最明显的非强制执行单副本一致性系统的特征是它们允许副本彼此发散。这意味着没有严格定义的通信模式：副本可以相互分离，但仍然保持可用并接受写操作。
让我们想象一个由三个副本组成的系统，每个副本彼此分离。例如，这些副本可能位于不同的数据中心，并因某种原因无法通信。在分离期间，每个副本仍然可用，可以接受一些客户端的读写操作：
[Clients] - &amp;gt; [A] --- Partition --- [Clients] - &amp;gt; [B] --- Partition --- [Clients] - &amp;gt; [C] 一段时间后，分区会修复并且副本服务器会交换信息。他们从不同的客户那里收到了不同的更新，并且彼此存在分歧，因此需要进行某种协调。我们希望所有的副本都收敛到相同的结果。
[A] \ --&amp;gt; [merge] [B] / | | [C] ----[merge]---&amp;gt; result 考虑具有弱一致性保证的系统的另一种方法是想象一组客户端按某种顺序向两个副本发送消息。由于没有强制执行单一总顺序的协调协议，因此消息可以在两个副本上以不同的顺序传递：
[Clients] --&amp;gt; [A] 1, 2, 3 [Clients] --&amp;gt; [B] 2, 3, 1 从本质上讲，这就是我们需要协调协议的原因。例如，假设我们尝试连接一个字符串，消息 1、2 和 3 中的操作为：
1: { operation: concat(&amp;#39;Hello &amp;#39;) } 2: { operation: concat(&amp;#39;World&amp;#39;) } 3: { operation: concat(&amp;#39;!</description>
    </item>
    <item>
      <title>[译]《分布式系统：为了乐趣和利益》4.复制</title>
      <link>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-04/</link>
      <pubDate>Fri, 10 Nov 2023 08:32:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-04/</guid>
      <description>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者 Mikito Takada 撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
4. 复制 复制问题是分布式系统中的众多问题之一。与诸如领导者选举、故障检测、互斥、共识和全局快照等其他问题相比，我选择关注复制问题，因为这通常是人们最感兴趣的部分。并行数据库在复制特性方面的差异化就是一个例子。此外，复制为许多子问题提供了一个上下文，例如领导者选举、故障检测、共识和原子广播。
复制是一个组通信问题。什么样的安排和通信模式能够满足我们所期望的性能和可用性特性？在面对网络分区和同时节点故障的情况下，我们如何确保容错性、耐久性和非发散性？
同样，有许多方法可以解决复制问题。我在这里采用的方法只是看一下具有复制功能的系统可能具有的高级模式。从可视化的角度来看，有助于将讨论集中在整体模式上，而不是具体涉及的消息传递。我在这里的目标是探索设计空间，而不是解释每个算法的具体细节。
让我们首先定义一下复制是什么样子。我们假设我们有一些初始数据库，并且客户端发出请求来改变数据库的状态。
这种安排和通信模式可以分为几个阶段：
（请求）客户端向服务器发送请求 （同步）进行复制的同步部分 （响应）将响应返回给客户端 （异步）进行复制的异步部分 根据这些阶段，我们可以创建不同的通信模式。我们选择的模式将对性能和可用性产生影响，具体取决于所选择的算法。
同步复制 第一个模式是同步复制（也称为主动复制、急切复制、推送复制或悲观复制）。让我们画出它的示意图：
在这里，我们可以看到三个明显的阶段：首先，客户端发送请求。接下来，我们所称的同步复制的部分发生。这个术语指的是客户端被阻塞 - 等待系统的回复。
在同步阶段期间，第一个服务器会联系其他两个服务器，并等待收到所有其他服务器的回复。最后，它向客户端发送一个响应，告知其结果（例如成功或失败）。
这一切似乎很简单。在不讨论同步阶段算法的细节的情况下，我们能从这个特定的通信模式安排中得出什么结论呢？首先，注意这是一种 N-对-N 的写入方式：在返回响应之前，它必须被系统中的每个服务器看到并确认。
从性能的角度来看，这意味着系统的速度将取决于其中最慢的服务器。该系统还对网络延迟的变化非常敏感，因为它要求在继续之前每个服务器都必须回复。
考虑到 N-对-N 的方式，系统无法容忍任何服务器的丢失。当一个服务器丢失时，系统无法再写入所有节点，因此无法继续进行。在这种设计中，它可能能够对数据提供只读访问，但在节点故障后不允许进行修改。
这种安排可以提供非常强大的耐久性保证：当返回响应时，客户端可以确信所有 N 个服务器都已接收、存储和确认了请求。为了丢失一个已接受的更新，所有 N 个副本都需要丢失，这是一个非常好的保证。
异步复制 让我们将其与第二种模式进行对比 - 异步复制（也称为被动复制、拉式复制或惰性复制）。正如您可能已经猜到的，这与同步复制相反：
在这种情况下，主节点（也称为领导者或协调者）立即向客户端返回响应。它最多只会在本地存储更新，但不会同步执行任何重要工作，客户端也不需要等待更多的服务器之间的通信轮次。
在稍后的阶段，复制任务的异步部分发生。在这里，主节点使用某种通信模式联系其他服务器，并更新它们的数据副本。具体的实现取决于所使用的算法。
在不涉及算法细节的情况下，我们对这种具体的安排能得出什么结论呢？嗯，这是一种写 1-对-N 的方式：立即返回响应，更新传播在稍后发生。
从性能的角度来看，这意味着系统很快：客户端不需要额外花费时间等待系统内部完成工作。系统对网络延迟更具容忍性，因为内部延迟的波动不会导致客户端需要额外等待。
这种安排只能提供弱的或概率性的耐久性保证。如果没有出现问题，数据最终会复制到所有 N 台机器上。然而，如果在此之前包含数据的唯一服务器丢失，数据将永久丢失。
考虑到 1-对-N 的方式，只要至少有一个节点正常运行，系统就可以保持可用性（理论上至少如此，但实际上负载可能会太高）。这种纯粹的惰性方式不提供耐久性或一致性保证；你可以向系统写入数据，但如果发生任何故障，不能保证能够读取你所写入的内容。
最后值得注意的是，被动复制无法确保系统中的所有节点始终包含相同的状态。如果在多个位置接受写入操作，并且不要求这些节点同步一致，那么就会存在发散的风险：不同位置的读取可能返回不同的结果（特别是在节点故障和恢复后），并且无法强制执行全局约束（需要与所有人通信）。
我没有详细讨论读取（而不是写入）时的通信模式，因为读取模式实际上是根据写入模式来确定的：在读取过程中，你希望与尽可能少的节点进行联系。我们将在仲裁机制的背景下进一步讨论这个问题。
我们只讨论了两种基本的安排，并没有涉及具体的算法。然而，我们已经能够了解可能的通信模式以及它们的性能、耐久性保证和可用性特性的一些信息。
主要复制方法概述 在讨论了同步和异步复制这两种基本复制方法之后，让我们来看一下主要的复制算法。
有很多不同的方式来对复制技术进行分类。在同步与异步之后，我想引入的第二个区别是：
防止发散的复制方法（单副本系统）和 存在发散风险的复制方法（多主系统） 第一组方法具有“行为像单一系统”的特性。特别是在部分故障发生时，系统确保只有一个副本处于活动状态。此外，系统确保副本始终保持一致。这被称为共识问题。
当多个进程（或计算机）就某个值达成共识时，它们实现了共识。更具体地说：
一致性：每个正确的进程必须就同一个值达成一致。 完整性：每个正确的进程最多决定一个值，并且如果它决定了某个值，则该值必须由某个进程提出。 终止性：所有进程最终都会达成决策。 有效性：如果所有正确的进程提议相同的值 V，则所有正确的进程都决定 V。 互斥、领导者选举、组播和原子广播都是共识问题的更一般实例。维护单一副本一致性的复制系统需要以某种方式解决共识问题。 维护单一副本一致性的复制算法包括：
1n 消息（异步主/备份） 2n 消息（同步主/备份） 4n 消息（两阶段提交，多 Paxos） 6n 消息（三阶段提交，带有重复领导者选举的 Paxos） 这些算法在容错性方面有所不同（例如，它们可以容忍的故障类型）。我根据算法执行期间交换的消息数量进行了简单的分类，因为我认为尝试回答“通过增加消息交换我们得到了什么？”这个问题很有趣。
下面的图表，改编自 Google 的 Ryan Barret，描述了不同选项的一些方面：
上述图表中的一致性、延迟、吞吐量、数据丢失和故障转移特性实际上可以追溯到两种不同的复制方法：同步复制（例如，在响应之前等待）和异步复制。当您等待时，性能会变差，但可以获得更强的保证。在讨论分区（和延迟）容忍性时，2PC 和仲裁系统之间的吞吐量差异将变得明显。
在该图表中，强制弱（/最终）一致性的算法被归类为一类（&amp;ldquo;gossip&amp;rdquo;）。然而，我将更详细地讨论弱一致性的复制方法 - gossip 和（部分）仲裁系统。&amp;ldquo;事务&amp;quot;行实际上更多地涉及全局谓词评估，而在具有弱一致性的系统中不支持（尽管可以支持本地谓词评估）。</description>
    </item>
    <item>
      <title>[译]《分布式系统：为了乐趣和利益》3.时间及顺序</title>
      <link>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-03/</link>
      <pubDate>Fri, 10 Nov 2023 08:31:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-03/</guid>
      <description>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者 Mikito Takada 撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
3. 时间及顺序 什么是顺序，为什么它很重要？
你说的“什么是顺序”是什么意思？
我的意思是，为什么我们对顺序如此着迷？为什么我们关心 A 是否发生在 B 之前？为什么我们不关心其他属性，比如“颜色”？
好吧，我的疯狂朋友，让我们回到分布式系统的定义来回答这个问题。
你可能还记得，我将分布式编程描述为使用多台计算机解决单台计算机可以解决的同一个问题的艺术。
事实上，这正是对顺序如此着迷的核心所在。任何只能一次执行一项任务的系统都会创建操作的总体顺序。就像人们通过一扇门一样，每个操作都有明确定义的前任和后继。这基本上是我们努力保留的编程模型。
传统的模型是：一个程序，一个进程，一个在一个 CPU 上运行的内存空间。操作系统抽象了可能存在多个 CPU 和多个程序的事实，以及计算机内存实际上是多个程序共享的。我并不是说线程编程和事件驱动编程不存在；只是它们是“一个/一个/一个”模型之上的特殊抽象。程序被编写成按照一定顺序执行：从上往下执行。
顺序作为一种属性受到了如此多的关注，是因为定义“正确性”的最简单方法是说“它的工作方式与单台计算机上的工作方式相同”。而通常这意味着 a）我们运行相同的操作，b）我们按照相同的顺序运行它们 - 即使有多台计算机。
保持顺序（如单个系统定义的顺序）的分布式系统的优点在于它们是通用的。你不需要关心操作是什么，因为它们将与在单台计算机上完全相同的方式执行。这很棒，因为你知道无论操作是什么，你都可以使用相同的系统。
实际上，分布式程序在多个节点上运行，具有多个 CPU 和多个操作流。你仍然可以分配一个总体顺序，但这需要准确的时钟或某种形式的通信。你可以使用完全准确的时钟为每个操作标记时间戳，然后利用它来确定总体顺序。或者你可以使用某种通信系统，使得可以分配类似总体顺序的连续编号。
全序和偏序 在分布式系统中，自然状态是偏序。网络和独立节点都不对相对顺序做出任何保证，但在每个节点上，你可以观察到一个局部顺序。
总序是一种二元关系，它为某个集合中的每个元素定义了一个顺序。
当两个不同的元素可比较时，其中一个大于另一个。在偏序集中，某些元素对不可比较，因此偏序并不指定每个项目的确切顺序。
总序和偏序都是传递性和反对称性的。对于集合 X 中的所有 a、b 和 c，以下陈述在总序和偏序中都成立：
If a ≤ b and b ≤ a then a = b (antisymmetry); If a ≤ b and b ≤ c then a ≤ c (transitivity); 然而，总序是完全的：
a ≤ b or b ≤ a (totality) for all a, b in X 而偏序是自反的：
a ≤ a (reflexivity) for all a in X 注意，全序性蕴含自反性；因此，偏序是总序的一种较弱的变体。在偏序中的某些元素上，全序性不成立 - 换句话说，其中一些元素不可比较。</description>
    </item>
    <item>
      <title>[译]《分布式系统：为了乐趣和利益》2.抽象层次的上下</title>
      <link>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-02/</link>
      <pubDate>Fri, 10 Nov 2023 08:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-02/</guid>
      <description>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者 Mikito Takada 撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
2. 抽象层次的上下 在本章中，我们将在抽象层次之间穿梭，探讨一些不可能性结果（CAP 和 FLP），然后出于性能考虑回归到更低层次。
如果你有进行过编程，抽象层次的概念可能对你来说很熟悉。你总是在某个抽象层次上进行工作，通过某个 API 与较低层次的接口进行交互，并可能为用户提供一些更高层次的 API 或用户界面。计算机网络的七层 OSI 模型就是一个很好的例子。
分布式编程很大程度上涉及处理分布的后果（显而易见！）。也就是说，我们面临着现实中存在许多节点的现实和我们希望系统“像一个单一系统一样工作”的愿望之间存在着紧张关系。这意味着需要找到一个良好的抽象，平衡可能性、可理解性和性能。
当我们说 X 比 Y 更抽象时，我们是指 X 没有引入任何与 Y 根本不同的新内容。事实上，X 可能会去除 Y 的某些方面或以更易于处理的方式呈现它们。其次，X 在某种意义上比 Y 更容易理解，假设 X 从 Y 中去除的内容对于当前问题并不重要。
如尼采所写：
每个概念都是通过我们将不相等的事物等同起来形成的。没有一片叶子完全等同于另一片叶子，概念“叶子”是通过对这些个体差异进行任意抽象而形成的，通过遗忘区别；现在它产生了一个想法，即在自然界中可能存在除了叶子之外的东西，这些东西将是“叶子”的一种原始形式 - 所有叶子都已经被编织、标记、复制、着色、卷曲和绘制，但是由于技术不熟练，没有一份副本能够成为原始形式的正确、可靠和忠实的图像。
抽象本质上是虚构的。每种情况都是独特的，每个节点也是如此。但是抽象使得世界变得可管理：简化的问题陈述 - 不受现实约束 - 更易于分析，并且只要我们没有忽略任何重要的东西，解决方案就是广泛适用的。
事实上，如果我们保留下来的东西是重要的，那么我们可以得出的结果就会具有广泛的适用性。这就是为什么不可能性结果如此重要：它们采用了问题的最简单可能的表述，并证明在一些约束或假设条件下无法解决该问题。
所有的抽象都会忽略一些与现实独特的东西，以便将它们等同起来。关键是要摆脱一切非必要的东西。你如何知道什么是必要的？嗯，你可能事先不知道。
每次我们在系统规范中排除系统的某个方面时，我们都存在引入错误和/或性能问题的风险。这就是为什么有时我们需要朝着相反的方向前进，并有选择性地引入一些真实硬件和现实世界问题的方面。重新引入一些特定的硬件特性（例如物理顺序性）或其他物理特性可能足以获得足够好的性能的系统。
系统模型 在分布式系统中，分布是一个关键特性。具体而言，分布式系统中的程序具有以下特点：
在独立节点上并发运行&amp;hellip; 通过可能引入非确定性和消息丢失的网络连接&amp;hellip; 没有共享内存或共享时钟。 这有许多含义：
每个节点并发执行程序。 知识是局部的：节点仅能快速访问本地状态，对于全局状态的任何信息都可能过时。 节点可以独立发生故障并进行恢复。 消息可能会延迟或丢失（与节点故障无关；很难区分网络故障和节点故障）。 而且节点之间的时钟不同步（本地时间戳与全局实际时间顺序不对应，很难观察到）。 系统模型列举了与特定系统设计相关的许多假设。
系统模型是关于实现分布式系统的环境和设施的一组假设。
系统模型在其对环境和设施的假设方面存在差异。这些假设包括：
节点的能力和故障方式 通信链路的操作方式以及可能的故障方式 整个系统的属性，例如有关时间和顺序的假设 健壮的系统模型是对假设最弱的模型：针对这种系统编写的任何算法都对不同的环境非常容忍，因为它有非常少且非常弱的假设。
另一方面，我们可以通过进行强假设来创建一个易于推理的系统模型。例如，假设节点不会发生故障意味着我们的算法不需要处理节点故障。然而，这样的系统模型是不现实的，因此在实践中很难应用。
让我们更详细地看一下节点、链路、时间和顺序的属性。
我们系统模型中的节点 节点作为计算和存储的主机。它们具有以下特点：
能够执行程序。 能够将数据存储到易失性内存（在故障时可能丢失）和稳定状态（在故障后可以读取）。 时钟（可以被假设为准确或不准确）。 节点执行确定性算法：局部计算、计算后的本地状态和发送的消息是根据接收到的消息和接收消息时的本地状态唯一确定的。
有许多可能的故障模型描述了节点可能发生的故障方式。在实践中，大多数系统假设使用崩溃恢复故障模型：也就是说，节点只能通过崩溃来发生故障，并且可以在稍后某个时间点（可能）进行恢复。
另一种选择是假设节点可以以任意方式发生故障。这被称为拜占庭容错。拜占庭故障在实际的商业系统中很少处理，因为对任意故障具有弹性的算法运行成本更高，实现更复杂。在这里我不会讨论拜占庭容错。
我们系统模型中的通信链路 通信链接将各个节点彼此连接，并允许消息在任意方向上发送。许多讨论分布式算法的书籍假设每对节点之间都有独立的链接，这些链接为消息提供了先进先出（FIFO）的顺序，只能传递已发送的消息，并且已发送的消息可能会丢失。
某些算法假设网络是可靠的：消息永远不会丢失，也不会无限期地延迟。这在某些实际情况下可能是合理的假设，但一般来说，更倾向于将网络视为不可靠的，可能会发生消息丢失和延迟的情况。
当网络发生故障而节点本身仍可运行时，就会发生网络分区。在这种情况下，消息可能会丢失或延迟，直到网络分区被修复。分区的节点可能对某些客户端是可访问的，因此必须与崩溃的节点进行不同处理。下图说明了节点故障和网络分区的区别：
通常很少对通信链接做进一步的假设。我们可以假设链接只能单向工作，或者可以为不同的链接引入不同的通信成本（例如由于物理距离引起的延迟）。然而，在商业环境中，除了长距离链接（广域网延迟）之外，这些很少是关注的问题，因此我在这里不会讨论它们；成本和拓扑的更详细模型可以在复杂性的代价下实现更好的优化。
时间/顺序假设 物理分布的一个结果是每个节点以独特的方式体验世界。这是无法避免的，因为信息只能以光速传播。如果节点之间的距离不同，那么从一个节点发送到其他节点的任何消息都会在其他节点以不同的时间到达，并有可能以不同的顺序到达。
时间假设是捕捉我们在多大程度上考虑这个现实的便捷方式。主要的两种选择是：
同步系统模型。进程以同步方式执行；消息传输延迟有已知的上界；每个进程具有准确的时钟。 异步系统模型。没有时间假设 - 例如进程以独立的速率执行；消息传输延迟没有上界；没有可靠的时钟存在。 同步系统模型对时间和顺序施加了许多限制。它基本上假设节点有相同的体验：发送的消息总是在特定的最大传输延迟内接收，并且进程以同步方式执行。这很方便，因为它允许您作为系统设计者对时间和顺序做出假设，而异步系统模型则不允许。
异步性是一种非假设：它只是假设您不能依赖于时间（或“时间传感器”）。</description>
    </item>
    <item>
      <title>[译]《分布式系统：为了乐趣和利益》1.高层分布式系统</title>
      <link>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-01/</link>
      <pubDate>Fri, 10 Nov 2023 07:20:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-01/</guid>
      <description>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者 Mikito Takada 撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
1. 高层分布式系统 分布式编程是利用多台计算机解决在单台计算机上可以解决的相同问题的一种技术。
任何计算机系统都需要完成两个基本任务：
存储 计算 分布式编程是一种艺术，通过利用多台计算机解决在单台计算机上可以解决的相同问题，通常是因为该问题已经超出了单台计算机的处理能力。
实际上，并没有强制要求我们使用分布式系统。如果拥有无限的资金和无限的研发时间，我们就不需要分布式系统。所有的计算和存储可以在一个魔盒上完成，这是一台单一的、极其快速和可靠的系统，你可以支付给别人来为你设计。
然而，很少有人拥有无限的资源。因此，他们必须在现实世界的成本效益曲线上找到合适的位置。在小规模情况下，升级硬件是一种可行的策略。然而，随着问题规模的增加，你会达到一个阶段，在这个阶段，要么不存在可以让你在单个节点上解决问题的硬件升级，要么成本过高。在这一点上，我欢迎你进入分布式系统的世界。
当前的现实是，只要通过容错软件将维护成本控制在较低水平，中档、大众化硬件提供了最佳的性价比。
计算主要受益于高端硬件，尤其是在能够通过内部内存访问取代缓慢的网络访问时。在需要节点间大量通信的任务中，高端硬件的性能优势有限。
正如 Barroso、Clidaras 和 Hölzle 的上图所示，假设所有节点都采用统一的内存访问模式，高端硬件和商用硬件之间的性能差距会随着集群规模的扩大而缩小。
理想情况下，添加一台新的机器将线性增加系统的性能和容量。但是，现实情况并非如此，因为由于存在独立的计算机，会产生一些开销。数据需要在计算机之间进行复制，计算任务需要进行协调等等。 这就是为什么值得研究分布式算法的原因——它们提供了针对特定问题的高效解决方案，以及关于可能性、正确实现的最低成本以及不可能性的指导。
这段文字的重点是在一个平凡但商业相关的环境中，即数据中心的分布式编程和系统。例如，我不会讨论由于具有异乎寻常的网络配置或在共享内存设置中出现的专门问题。此外，重点是探索系统设计空间，而不是优化任何特定设计——后者是一个更专门的文本主题。
我们想要实现的目标：可扩展性和其他好的东西 从我看来，一切都始于处理规模的需求。
在小规模下，大多数事情都是微不足道的，而同样的问题一旦超过一定的大小、容量或其他物理限制，就会变得更加困难。举起一块巧克力很容易，但举起一座山就很困难。数一下房间里有多少人很容易，但数一下国家里有多少人就很难。
所以一切都始于规模——可扩展性。非正式地说，在一个可扩展的系统中，当我们从小规模向大规模过渡时，事情不应该逐渐变得更糟。以下是另一种定义：
可扩展性是指系统、网络或进程处理不断增长的工作负载的能力，或者说它能够被扩大以适应这种增长的能力。
什么是在增长呢？嗯，你可以用几乎任何方式来衡量增长（人数、用电量等）。但有三个特别有趣的方面值得关注：
规模可扩展性：增加更多节点应该使系统线性加快；增加数据集的大小不应增加延迟。 地理可扩展性：应该可以利用多个数据中心来缩短响应用户查询所需的时间，同时以某种合理的方式处理跨数据中心的延迟。 管理可扩展性：添加更多节点不应增加系统的管理成本（例如管理员与机器的比率）。 当然，在真实的系统中，增长同时发生在多个不同的轴上；每个指标仅反映增长的某些方面。
可扩展的系统是一种随着规模的增加而持续满足用户需求的系统。有两个特别相关的方面——性能和可用性——可以通过多种方式来衡量。
性能（和延迟） 性能是指计算机系统在使用的时间和资源相对于所完成的有用工作量来衡量的特征。
根据具体情况，这可能涉及实现以下一项或多项：
对于给定的工作，响应时间短/延迟低 高吞吐量（处理工作率） 计算资源利用率低 针对任何这些结果进行优化都需要权衡。例如，系统可以通过处理更大批量的工作来实现更高的吞吐量，从而减少操作开销。由于批处理，权衡将是个别工作的响应时间更长。
我发现低延迟（实现较短的响应时间）是性能中最有趣的方面，因为它与物理（而不是财务）限制密切相关。使用财务资源来解决延迟问题比性能的其他方面更难。
对于延迟有很多非常具体的定义，但我真的很喜欢这个词的词源所唤起的想法：
延迟是指潜伏状态，延迟的或在某事物开始和发生之间的一段时间。
“潜在的”是什么意思？
潜在的是指某物存在或出现，但被隐藏、隐蔽或处于不活动状态。它描述了一种存在却不容易察觉或可见的状态，但它仍以隐藏或潜在的形式存在。
这个定义非常酷，因为它强调了延迟是指某件事发生到它产生影响或变得可见之间的时间。
例如，假设您感染了一种空气传播的病毒，该病毒会将人变成僵尸。潜伏期是指从你被感染到变成僵尸之间的时间。这就是潜伏期：已经发生的事情被隐藏起来的时间。
让我们假设我们的分布式系统只执行一项高级任务：给定一个查询，它会获取系统中的所有数据并计算一个结果。换句话说，将分布式系统视为一个数据存储，能够对其当前内容运行单个确定性计算（函数）：
result = query(all data in the system) 那么，对延迟来说重要的不是旧数据的数量，而是新数据在系统中“生效”的速度。例如，延迟可以根据写入对读者可见所需的时间来衡量。
基于这个定义的另一个关键点是，如果什么都没有发生，就没有“潜伏期”。数据不改变的系统不会（或不应该）存在延迟问题。
在分布式系统中，存在一个无法克服的最小延迟：光速限制了信息传输的速度，而硬件组件每个操作都会产生一定的最小延迟成本（例如内存、硬盘以及 CPU）。
最小延迟对查询的影响程度取决于这些查询的性质以及信息需要传输的物理距离。
可用性（和容错） 可扩展系统的第二个方面是可用性。
可用性是指系统处于正常运行状态的时间比例。如果用户无法访问系统，则称系统不可用。
分布式系统使我们能够实现在单一系统上很难实现的理想特性。例如，单个机器无法容忍任何故障，因为它要么发生故障，要么正常运行。
分布式系统可以采用一堆不可靠的组件，并在它们之上构建一个可靠的系统。
没有冗余的系统只能达到其底层组件的可用性。而具备冗余的系统可以容忍部分故障，从而提高可用性。 值得注意的是，“冗余”可以在不同层面上有不同的含义，比如组件、服务器、数据中心等。
从公式上讲，可用性为： Availability = uptime / (uptime + downtime) 。
从技术角度来看，可用性主要与容错性有关。因为故障发生的概率随着组件数量的增加而增加，系统应该能够进行补偿，以确保随着组件数量的增加，系统的可靠性不会降低。
例如：
可用性 ％ 90%（“一个九”） 一个多月了 99%（“两个九”） 少于 4 天 99.9%（“三个九”） 不到 9 小时 99.</description>
    </item>
    <item>
      <title>[译]《分布式系统：为了乐趣和利益》介绍</title>
      <link>https://blog.chensoul.cc/posts/2023/11/09/distributed-systems-intro/</link>
      <pubDate>Thu, 09 Nov 2023 11:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/09/distributed-systems-intro/</guid>
      <description>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者Mikito Takada撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
介绍 我想要一本能够汇集许多最新分布式系统（例如 Amazon 的 Dynamo、Google 的 BigTable 和 MapReduce、Apache 的 Hadoop 等系统）背后的思想的文本。
在本文中，我试图提供更易于理解的分布式系统介绍。对我来说，这意味着两件事：介绍您需要的关键概念，以便您可以愉快地阅读更严肃的文本，并提供足够详细的叙述，以便您了解正在发生的事情的要点，而不会陷入困境关于细节。现在是 2013 年，您已经有了互联网，您可以有选择地阅读更多您认为最感兴趣的主题。
在我看来，分布式编程的大部分内容都是关于处理分布式的两个后果的影响：
信息以光速传播 独立的事物会独立失败 换句话说，分布式编程的核心是处理距离（废话！）并且拥有不止一件事（废话！）。这些约束定义了可能的系统设计空间，我希望读完本文后您将更好地了解距离、时间和一致性模型如何相互作用。
本文重点介绍理解数据中心商业系统所需的分布式编程和系统概念。试图涵盖一切将是疯狂的。您将学习许多关键协议和算法（例如，涵盖该学科中许多被引用次数最多的论文），包括一些尚未进入大学教科书的最终一致性的令人兴奋的新方法 - 例如 CRDT和 CALM 定理。
我希望你喜欢它！如果您想表达感谢，请在 Github（或 Twitter）上关注我。如果发现错误，请在 Github 上提交拉取请求。
1. 基础知识 第一章通过介绍一些重要的术语和概念，从高层次上介绍了分布式系统。它涵盖了高级别目标，例如可扩展性、可用性、性能、延迟和容错；这些是如何难以实现的，以及抽象和模型以及分区和复制如何发挥作用。
2. 抽象层次的上下 第二章更深入地探讨抽象和不可能性的结果。它以尼采的名言开始，然后介绍系统模型以及典型系统模型中所做的许多假设。然后讨论了 CAP 定理并总结了 FLP 不可能性结果。然后转向 CAP 定理的含义，其中之一是人们应该探索其他一致性模型。然后讨论了许多一致性模型。
3. 时间及顺序 理解分布式系统的一个重要部分是理解时间和顺序。如果我们无法理解和建模时间，我们的系统就会失败。第三章讨论时间和顺序、时钟以及时间、顺序和时钟的各种用途（例如矢量时钟和故障检测器）。
4. 复制：防止发散 第四章介绍了复制问题以及执行该问题的两种基本方法。事实证明，大多数相关特征都可以通过这个简单的表征来讨论。然后，从最低容错（2PC）到Paxos讨论了维持单副本一致性的复制方法。
5. 复制：接受分歧 第五章讨论了具有弱一致性保证的复制。它引入了一个基本的协调场景，其中分区副本尝试达成一致。然后，它讨论了 Amazon 的 Dynamo 作为具有弱一致性保证的系统设计的示例。最后，讨论了无序编程的两个观点：CRDT 和 CALM 定理。
Appendix 附录 附录包含进一步阅读的建议。</description>
    </item>
    <item>
      <title>用户故事如何应用到个人管理</title>
      <link>https://blog.chensoul.cc/posts/2023/08/21/user-stories-in-self-manager/</link>
      <pubDate>Mon, 21 Aug 2023 11:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/21/user-stories-in-self-manager/</guid>
      <description>用户故事（User Stories）是敏捷软件开发中的一种需求表达方式，用于描述用户的需求、期望和价值。尽管用户故事主要应用于软件开发团队，但其原则和方法也可以应用到个人管理中，以帮助个人更好地管理自己的任务和目标。
在个人管理中，可以将用户故事的思维方式应用如下：
角色定义：将自己作为一个角色，例如“个人”或“自己的名字”。明确自己的身份和角色，以便更好地理解自己的需求和期望。 需求描述：将自己的需求和期望转化为用户故事的形式。例如：“作为一个个人，我希望每天早晨锻炼，以保持健康和增加活力。” 价值定义：确定每个用户故事的价值和意义。例如，锻炼身体可以增强健康、提高精力和改善心情，从而提升整体生活质量。 优先级排序：对用户故事进行优先级排序，以确定哪些是最重要的和紧急的。这有助于集中精力和资源，实现最有价值的目标。 制定计划：根据用户故事的优先级，制定个人管理计划。将每个用户故事转化为具体的任务、行动和时间安排，以实现期望的结果。 迭代和反馈：将个人管理过程视为一个迭代循环，不断评估和调整。根据实际执行情况和反馈，对计划进行调整和改进。 以下是一个制定个人管理计划的示例：
用户故事：作为一个个人，我希望提高工作效率和时间管理，以更好地完成任务和增加工作成果。
计划：
用户故事：作为一个个人，我希望设定明确的目标和优先级，以便更好地管理我的任务。 任务 1：制定长期目标和短期目标，并将其记录在个人笔记本或任务管理工具中。 任务 2：为每个目标设定优先级，以确定最重要的任务和活动。 用户故事：作为一个个人，我希望改善时间管理，以充分利用我的时间。 任务 1：分析我的日常时间分配，并识别时间浪费的区域。 任务 2：制定时间表或日程安排，将任务和活动合理分配到特定时间段。 任务 3：学习和采用时间管理技巧，如番茄工作法（Pomodoro Technique）或时间块（Time Blocking）。 用户故事：作为一个个人，我希望提高专注力和减少干扰，以更好地完成任务。 任务 1：创建一个有利于专注的工作环境，如清理工作区域、关闭手机通知或使用专注应用程序。 任务 2：学习并使用注意力管理技巧，如集中注意力训练（Focused Attention Training）或冥想。 用户故事：作为一个个人，我希望保持健康和提高精力，以更好地应对工作和任务。 任务 1：制定健康的生活习惯，如定期锻炼、健康饮食和充足的睡眠。 任务 2：安排休息和放松的时间，以避免过度劳累和疲劳。 用户故事：作为一个个人，我希望定期评估和调整我的个人管理计划，以适应变化和改进效果。 任务 1：每周或每月回顾我的个人管理计划，并记录我取得的成果和遇到的挑战。 任务 2：根据反馈和经验，调整计划中的任务和策略，以改进效果和适应新的需求。 这只是一个示例个人管理计划，你可以根据自己的需求和目标进行定制和调整。记得将计划中的任务具体化、可衡量，并逐步实施，以确保计划的可行性和有效性。
逐步实施个人管理计划是确保计划可行性和有效性的重要步骤。以下是一些方法来逐步实施你的个人管理计划：
制定优先级：根据计划中的任务和目标，确定它们的优先级顺序。将重要且紧急的任务放在首位，逐步处理其他任务。 制定计划：为每个任务制定具体的计划和行动步骤。将任务分解为更小的可管理的子任务，并为每个子任务设定截止日期或时间范围。 设定目标：为每个任务设定明确的目标和可衡量的指标。这样可以更好地跟踪和评估你的进展。 时间管理：合理安排时间以实施计划。使用时间管理技巧，如时间块，将任务和活动分配到特定的时间段，并设定时间限制以保持专注和高效。 建立习惯：将计划中的任务和行动转化为习惯。重复执行任务并坚持一段时间，以形成良好的习惯。 监控和评估：定期监控和评估你的进展。检查完成的任务，评估是否达到预期的目标和指标。根据反馈和经验，进行调整和改进。 适应变化：灵活应对变化和调整。如果遇到新的需求或情况，根据实际情况重新安排任务和优先级。 持续改进：根据实施的经验和反馈，不断改进个人管理计划。尝试新的方法和策略，寻找提高效率和成果的机会。 逐步实施个人管理计划需要耐心和坚持，一步一个脚印地完成每个任务，并逐渐扩大和提高目标的范围。记得给自己一定的弹性和容错空间，以适应意外情况和挑战。最重要的是保持积极的态度和动力，不断努力实现个人目标和提升自我管理能力。</description>
    </item>
    <item>
      <title>如何成为一名合格的架构师</title>
      <link>https://blog.chensoul.cc/posts/2023/08/21/architecture/</link>
      <pubDate>Mon, 21 Aug 2023 09:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/21/architecture/</guid>
      <description>如何成为一名合格的架构师 成为一名合格的架构师需要不断学习和积累经验。以下是一些步骤和建议，可以帮助你成为一名合格的架构师：
学习基础知识：建立坚实的计算机科学和软件工程基础，包括数据结构、算法、操作系统、数据库等。深入学习编程语言和开发技术，了解不同技术栈的优缺点。
实践项目开发：通过参与实际的软件开发项目，积累项目管理和开发经验。亲身经历软件开发的各个阶段，从需求分析到设计、开发、测试和部署，深入了解软件开发的流程和挑战。
学习系统设计和架构：深入学习系统设计和架构的相关知识，包括架构模式、设计原则。阅读相关的书籍、文章和技术博客，参与架构设计讨论和社区活动。
以下是关于架构模式、设计原则和一些常见架构的简要介绍：
架构模式： 分层架构（Layered Architecture）：将系统划分为多个层次，每个层次有不同的职责和功能，实现松耦合和可维护性。 客户端-服务器模式（Client-Server）：将系统分为客户端和服务器，客户端发送请求并接收响应，服务器处理请求并提供服务。 发布-订阅模式（Publish-Subscribe）：基于事件的模式，发布者发布事件，订阅者订阅感兴趣的事件，实现解耦和扩展性。 微服务架构（Microservices Architecture）：将系统拆分为一组小型、自治的服务，每个服务专注于一个特定的业务功能，通过轻量通信协议进行交互。 事件驱动架构（Event-Driven Architecture）：系统的组成部分通过事件进行通信和协调，事件的发生触发相应的处理和反应。 设计原则： 单一职责原则（Single Responsibility Principle）：一个模块或类应该有且只有一个单一的责任。 开闭原则（Open-Closed Principle）：软件实体应该对扩展开放，对修改封闭。 里氏替换原则（Liskov Substitution Principle）：子类应该能够替换掉父类，并且不会破坏程序的正确性。 接口隔离原则（Interface Segregation Principle）：不应该强迫客户端依赖于它们不需要的接口。 依赖倒置原则（Dependency Inversion Principle）：应该依赖于抽象而不是具体实现。 实践架构设计：在实际项目中担任架构师的角色，负责系统的整体设计和架构决策。通过实践中的挑战和经验，不断提升自己的架构设计能力。
学习领域知识：根据自己的兴趣和发展方向，深入学习特定领域的知识。例如，如果你在金融领域工作，了解金融系统的特点和要求，掌握相关的技术和解决方案。
不断学习和跟进技术趋势：保持对新技术和趋势的敏感性，持续学习和跟进行业的最新发展。参加技术研讨会、培训课程和行业会议，阅读技术书籍和博客，与同行进行交流和讨论。
培养沟通和领导能力：作为架构师，与团队成员、业务部门和其他利益相关者进行有效的沟通和合作非常重要。培养良好的沟通和领导能力，能够清晰地表达设计思想和技术方案，并协调各方利益。
寻求 mentor 或参与指导项目：寻找经验丰富的架构师作为 mentor，从他们那里获得指导和建议。参与指导性项目，与其他架构师合作，共同解决复杂问题，学习他们的设计思路和方法。
持续改进和反思：持续改进自己的技术能力和专业素养。定期回顾和反思自己的设计决策和经验，寻找改进的空间，并从失败和挑战中吸取教训。
最重要的是，成为一名合格的架构师是一个渐进的过程，需要不断学习、实践和积累经验。通过不断提升自己的技术水平、设计能力和沟通能力，你将逐步成为一名优秀的架构师。
架构师必备的技能和知识 作为架构师，以下是一些必备的技能和知识：
系统设计和架构：具备全面的系统设计和架构能力，能够设计可靠、可扩展、高性能和安全的系统架构。了解常用的架构模式和设计原则，如分层架构、微服务架构、事件驱动架构等。 编程和开发经验：具备扎实的编程能力和开发经验，熟悉多种编程语言和技术栈。能够理解和评估不同技术选型的优缺点，并在需要时能够进行原型开发和演示。 分布式系统：了解分布式系统的概念、原理和常见挑战，熟悉分布式计算、分布式存储和分布式通信等相关技术。能够设计和优化分布式系统的架构，解决分布式系统中的一致性、容错和性能问题。 性能优化和调优：具备性能优化和调优的经验，能够分析和解决系统性能瓶颈。熟悉性能测试工具和性能监控工具，能够设计和实施性能测试计划，并提出相应的优化建议。 安全设计和防御：具备系统安全设计和防御的能力，了解常见的安全威胁和攻击方式，能够设计和实施安全策略和措施，确保系统的安全性和数据的保密性。 数据库和存储系统：熟悉各种数据库和存储系统的原理和使用，包括关系型数据库、NoSQL 数据库、缓存系统等。能够进行数据库设计和优化，保证数据的一致性和可靠性。 云计算和容器技术：了解云计算和容器技术的概念和基本原理，包括虚拟化、容器化、自动化部署等。能够设计和部署基于云计算和容器技术的系统架构，如使用 Docker、Kubernetes 等。 消息队列和事件驱动：熟悉消息队列和事件驱动架构，了解消息中间件的选择和使用。能够设计和实现基于消息队列和事件驱动的系统，实现松耦合和可扩展性。 高可用和容错设计：能够设计和实现高可用和容错的系统架构，包括故障恢复、负载均衡、容灾和备份策略等。了解分布式一致性和容错算法，如 Paxos、Raft 等。 沟通和领导能力：作为架构师，需要具备良好的沟通和领导能力。能够与团队成员、业务部门和其他利益相关者进行有效的沟通和合作，推动项目的顺利进行。 这些技能和知识将帮助架构师在设计和构建复杂系统时做出明智的决策，并确保系统的可靠性、可扩展性和性能。此外，架构师还应不断学习和保持对新技术和趋势的敏感性，以保持在技术领域的竞争力。
架构师学习路线图 作为架构师，以下是一个可能的学习路线图，可以帮助你系统地学习和发展架构师的技能：
基础知识： 学习软件开发基础知识，包括编程语言、数据结构和算法等。 理解软件开发流程和常用开发方法，如敏捷开发和 DevOps。 学习面向对象设计和设计模式。 架构设计基础： 学习软件架构的基本概念、原则和模式。 研究和理解常见的架构模式，如分层架构、客户端-服务器模式和发布-订阅模式等。 掌握设计原则，如单一职责原则、开闭原则和依赖倒置原则等。 深入学习架构模式和技术： 学习微服务架构的原理、设计和实施。 研究事件驱动架构和消息队列的使用。 探索大数据架构和分布式系统设计。 了解容器化和容器编排技术，如 Docker 和 Kubernetes。 实践和项目经验： 参与实际项目，从中学习架构设计和实施的经验。 尝试设计和开发自己的小型项目，实践架构设计和解决实际问题。 参与开源项目或贡献，与其他架构师交流和分享经验。 持续学习和发展： 关注行业趋势和新兴技术，如人工智能、物联网和区块链等。 参加架构师培训和认证课程，如 TOGAF、AWS Certified Solutions Architect 等。 参与架构师社区和论坛，与其他专业人士交流和学习。 请注意，这只是一个示例学习路线图，你可以根据自己的兴趣、目标和实际情况进行调整和扩展。重要的是保持持续学习和不断实践，通过实际项目和经验来提升自己的架构师技能。
架构师学习资源 以下是一些关于系统设计和架构的经典书籍：
《软件架构实践》（Software Architecture in Practice） - Len Bass、Paul Clements、Rick Kazman 《大规模分布式存储系统》（Designing Data-Intensive Applications） - Martin Kleppmann 《企业集成模式》（Enterprise Integration Patterns） - Gregor Hohpe、Bobby Woolf 《架构之美》（Beautiful Architecture） - Diomidis Spinellis、Georgios Gousios 《架构设计原则》（The Art of Software Architecture: Design Methods and Techniques） - Stephen T.</description>
    </item>
    <item>
      <title>软件开发流程和常用开发方法</title>
      <link>https://blog.chensoul.cc/posts/2023/08/21/the-software-development-process/</link>
      <pubDate>Mon, 21 Aug 2023 09:30:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/21/the-software-development-process/</guid>
      <description>软件开发流程和常用开发方法，如敏捷开发和 DevOps，对于架构师来说非常重要。下面我将简要介绍这些概念：
软件开发流程：
软件开发流程是指在开发软件时，按照一定的步骤和阶段进行工作的过程。常见的软件开发流程包括瀑布模型、迭代模型和增量模型等。这些流程以不同的方式组织和管理开发过程，包括需求分析、设计、编码、测试和部署等阶段。
敏捷开发：
敏捷开发是一种迭代和增量的软件开发方法，强调团队协作、快速响应变化和持续交付。敏捷开发强调通过迭代周期（如 Scrum 中的 Sprint）来开发软件，每个迭代都会产生可部署的软件功能。常见的敏捷方法包括 Scrum、XP（极限编程）和 Kanban 等。
DevOps：
DevOps 是一种软件开发和运维的方法论，旨在通过自动化和协作来加速软件交付和提高质量。DevOps 强调开发团队和运维团队之间的协作和共享责任，借助自动化工具和流程来实现持续集成、持续交付和持续部署。
开发流程 软件开发流程通常包括以下阶段：
需求收集：收集和记录软件的功能和非功能性需求。 分析与规划：分析需求并规划开发过程，包括资源分配、时间表和交付物。 设计：基于需求创建软件架构、模块和组件的详细设计。 实现：编写代码并集成设计的组件，进行软件开发。 测试：进行各种测试活动，如单元测试、集成测试和系统测试，确保软件按预期功能。 部署：发布软件并在生产环境中向最终用户提供使用。 维护与支持：在部署后提供持续的维护、错误修复和支持。 在整个过程中，遵循版本控制、文档化和协作等最佳实践是非常重要的，以确保软件开发生命周期的顺利和高效进行。
常见的软件开发流程包括瀑布模型、迭代模型和增量模型等：
瀑布模型（Waterfall Model）： 瀑布模型是一种线性顺序的软件开发流程，按照固定的阶段依次执行，每个阶段的输出作为下一个阶段的输入。典型的阶段包括需求分析、系统设计、编码、测试和维护等。瀑布模型适用于需求稳定且较小规模的项目，但缺乏灵活性和适应变化的能力。
下面是瀑布模型的典型阶段：
需求分析阶段：在这个阶段，与用户和利益相关者一起收集和明确软件系统的需求。定义系统的功能和性能要求，并编写详细的需求规格说明书。 系统设计阶段：在需求分析完成后，进行系统设计。这包括定义系统的整体架构、模块划分、数据结构和算法设计等。设计结果通常以文档形式呈现。 编码阶段：在系统设计完成后，开发团队开始实际的编码工作。根据设计文档，开发人员编写代码并实现系统的各个功能模块。 测试阶段：在编码完成后，进行系统测试。测试人员根据需求和设计规范执行功能测试、集成测试和系统测试，以验证系统的正确性和稳定性。 集成和部署阶段：在测试通过后，将各个模块进行集成，并进行系统级的测试和部署准备。确保整个系统能够协同工作，并准备好部署到目标环境中。 运维和维护阶段：一旦系统部署并投入使用，进入运维和维护阶段。在这个阶段，团队负责监控系统的运行状况，处理问题和错误，并进行必要的修复和更新。 瀑布模型的特点是每个阶段的工作是线性、顺序的，下一个阶段的开始依赖于前一个阶段的完成。这种模型适合需求稳定、项目规模较小、技术风险较低的项目。然而，瀑布模型缺乏灵活性和对变化的适应能力，难以应对需求变更和项目延期等问题。
因此，在面对需求变化频繁、项目复杂度高、风险较大的情况下，敏捷开发方法如 Scrum 和 Kanban 等更为适用，它们强调迭代、增量和持续交付，能更好地满足客户需求并快速响应变化。
迭代模型（Iterative Model）： 迭代模型强调通过多个迭代周期来逐步构建和完善软件。每个迭代周期包括需求分析、设计、编码、测试和部署等阶段，每个迭代都会产生可部署的软件版本。迭代模型适用于需求不完全明确或可能变化的项目，能够更好地适应变化和快速反馈。
以下是迭代模型的一般流程：
阶段规划：确定每个迭代周期的目标、范围和计划。这包括确定要开发的功能、分配资源、制定时间表等。 需求分析：在每个迭代的开始阶段，与用户和利益相关者一起收集和分析需求，并明确每个迭代的功能和优先级。 设计和开发：根据需求分析的结果，进行系统设计和开发工作。在每个迭代中，系统的某个部分会被设计、开发和测试。 测试和验证：在每个迭代周期结束时，进行系统的内部测试和验证。确保开发的功能符合需求，并满足预期的质量标准。 评审和反馈：在每个迭代周期结束后，与用户和利益相关者进行评审和反馈。他们提供对当前功能的评价和建议，以指导下一个迭代的开发工作。 迭代调整：根据用户的反馈和评审结果，对下一个迭代的计划进行调整和优化。可能需要重新定义需求、调整功能优先级、增加新的需求等。 重复迭代：通过不断重复上述步骤，每个迭代周期都会逐步增加系统的功能、完善系统的性能，并在每个迭代中交付一个可用的软件增量。 迭代模型的优势在于能够快速响应变化和不断提供增值。它允许在开发过程中灵活调整需求，并通过每个迭代的反馈和评审来改进产品。然而，迭代模型也需要适当的计划和管理，以确保每个迭代都能按时交付，并控制开发过程中的风险。
敏捷方法如 Scrum 和 Kanban 是迭代模型的典型实践，它们更加强调团队的协作、自组织和持续交付，适用于需求变化频繁和项目复杂度较高的环境
增量模型（Incremental Model）： 增量模型将软件按模块或功能进行划分，每个模块或功能被称为一个增量，通过逐步添加增量来逐渐构建完整的软件系统。每个增量都经历需求分析、设计、开发和测试等阶段。增量模型适用于大规模项目和需要分阶段交付的情况，可以提供更早的价值交付和更好的风险管理。
以下是增量模型的一般流程：
阶段划分：将整个软件系统划分为多个增量，每个增量都代表一个可用的软件部分。划分的方式可以基于功能、模块、业务流程等来定义。 需求分析：在每个增量开始时，与用户和利益相关者一起收集和明确关于该增量的需求和功能。确定每个增量的优先级和范围。 设计和开发：根据需求分析的结果，进行系统设计和开发工作。每个增量的设计和开发都是独立进行的，可以采用适合的开发方法和技术。 测试和验证：在每个增量完成开发后，进行系统的测试和验证。确保该增量的功能符合需求，并满足预期的质量标准。 增量交付：经过测试和验证后，将该增量交付给用户或利益相关者。用户可以开始使用该增量，并提供反馈和建议以进一步改进和优化。 增量整合：在完成一个增量的交付后，将该增量与之前交付的增量进行整合。确保不同增量之间的功能和模块可以协同工作，并形成一个完整的软件系统。 通过不断重复上述步骤，每个增量都逐步增加系统的功能和完善系统的性能。增量模型允许在开发过程中快速交付可用的软件部分，并根据用户的反馈和需求变化进行调整。它可以提高软件开发的可见性和用户满意度，降低项目风险。
与迭代模型相比，增量模型更加强调不同增量之间的独立性和可用性。每个增量都是一个可用的软件部分，用户可以在开发过程中逐步使用和评估系统功能。然而，增量模型可能需要更好的规划和管理，以确保增量之间的集成和整合顺利进行，并避免系统架构上的问题。
敏捷开发 敏捷开发（Agile Development）是一种以迭代、增量和协作为核心的软件开发方法。它强调团队合作、快速响应变化和持续交付，以提高客户满意度和项目成功率。以下是敏捷开发的核心原则和常用实践：
核心原则：
个体和互动胜过流程和工具（Individuals and interactions over processes and tools）：强调团队成员之间的沟通、合作和相互支持，重视人与人之间的交流。 可工作的软件胜过详尽的文档（Working software over comprehensive documentation）：注重以可工作的软件作为验证和沟通的手段，而不是过多依赖繁杂的文档。 客户合作胜过合同谈判（Customer collaboration over contract negotiation）：鼓励与客户密切合作，及时获取反馈并根据需求变化进行调整。 响应变化胜过遵循计划（Responding to change over following a plan）：灵活应对需求变化，通过迭代和增量的方式快速适应变化的环境。 常用实践：</description>
    </item>
    <item>
      <title>数据库如何设计树形结构</title>
      <link>https://blog.chensoul.cc/posts/2023/08/15/tree-structure-in-database/</link>
      <pubDate>Tue, 15 Aug 2023 10:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/15/tree-structure-in-database/</guid>
      <description>在 MySQL 中，设计树形结构的区域表有多种方式。以下是一些常见的方案：
父子关系（Parent-Child Relationship）模型：在这种模型中，每个行记录包含一个指向其父级的引用。可以使用一个额外的列来存储父级 ID，或者使用自连接表来表示关系。这种模型简单直观，易于理解和管理。 路径（Path）模型：在这种模型中，每个行记录都包含一个代表其完整路径的字段。路径可以是以某种分隔符（如斜杠）分隔的字符串，例如：/地区/国家/城市。通过解析和处理路径字段，可以轻松地查询父级、子级和兄弟节点。 嵌套集模型（Nested Set Model）：这是一种基于左右值的模型，通过预先计算每个节点的左右值，可以高效地查询树形结构。每个节点都有一个左值和一个右值，用于表示其在树中的位置。这种模型适用于大型树结构，但需要特殊的操作来维护左右值。 物化路径（Materialized Path）模型：这是路径模型的一种改进版本，它使用额外的列来存储节点的层级关系。除了路径字段外，还可以添加一个表示节点级别的字段。这样可以更高效地进行查询，并且可以轻松地获取节点的父级、子级和兄弟节点。 父子关系（Parent-Child Relationship）模型 父子关系（Parent-Child Relationship）模型是一种在 MySQL 中设计树形结构的方式。在该模型中，每个区域记录包含一个指向其父级区域的引用。通过这种父子关系，可以建立区域之间的层级结构。
以区域为例，我们可以创建一个名为&amp;quot;area&amp;quot;的表来存储区域信息。该表可以包含以下列：
id：区域的唯一标识符（主键） name：区域的名称 parent_id：指向父级区域的引用 通过使用父子关系模型，我们可以创建以下区域的层级结构：
id | name | parent_id --------------------------- 1 | 世界 | NULL 2 | 亚洲 | 1 3 | 欧洲 | 1 4 | 北美洲 | 1 5 | 中国 | 2 6 | 日本 | 2 7 | 德国 | 3 8 | 法国 | 3 9 | 美国 | 4 10 | 加拿大 | 4 11 | 北京市 | 5 12 | 上海市 | 5 13 | 东京都 | 6 14 | 横滨市 | 6 在上述示例中，&amp;ldquo;area&amp;quot;表的每一行代表一个区域，通过&amp;quot;parent_id&amp;quot;列建立父子关系。根区域（世界）的&amp;quot;parent_id&amp;quot;为 NULL，表示没有父级区域。其他区域通过指定父级区域的&amp;quot;id&amp;quot;来建立层级关系。</description>
    </item>
    <item>
      <title>[译]微服务设计模式</title>
      <link>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</link>
      <pubDate>Mon, 26 Jun 2023 08:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</guid>
      <description>基于微服务的应用程序的主要特征在 微服务、单体和 NoOps 中定义。它们是功能分解或领域驱动设计、定义良好的接口、明确发布的接口、单一责任原则和潜在的多语言。每项服务都是完全自主和全栈的。
因此，更改服务实现不会影响其他服务，因为它们使用定义良好的接口进行通信。这种应用程序有几个优点，但它不是 免费的午餐，需要在 NoOps 方面付出大量努力。
但是假设您了解构建此类应用程序所需的工作或至少其中的一部分，并且愿意跳槽。你做什么工作？您构建此类应用程序的方法是什么？
是否有任何关于这些微服务如何相互协作的设计模式？
应用程序和团队的功能分解是构建成功的微服务架构的关键。
这允许您实现松耦合（REST 接口）和高内聚（多个服务可以相互组合以定义更高级别的服务或应用程序）。
应用程序的动词（例如 Checkout）或名词（Product）是实现现有应用程序分解的有效方法之一。
例如，产品、目录和结帐可以是三个独立的微服务，然后相互协作以提供完整的购物车体验。
功能分解提供了敏捷性、灵活性、可扩展性和其他能力，但业务目标仍然是创建应用程序。因此，一旦识别出不同的微服务，您如何组合它们以提供应用程序的功能？
本博客将讨论一些关于如何将微服务组合在一起的推荐模式。
聚合微服务设计模式 第一个，也可能是最常见的，是聚合器微服务设计模式。
在其最简单的形式中，聚合器将是一个简单的网页，它调用多个服务来实现应用程序所需的功能。由于每个服务（服务 A、服务 B 和服务 C）都使用轻量级 REST 机制公开，因此网页可以检索数据并相应地处理/显示数据。如果需要某种处理，比如将业务逻辑应用于从各个服务接收的数据，那么您可能有一个 CDI bean 可以转换数据，以便网页可以显示它。
聚合器的另一个选择是不需要显示，它只是一个更高级别的复合微服务，可以被其他服务使用。
在这种情况下，聚合器只需从每个单独的微服务收集数据，对其应用业务逻辑，然后将其进一步发布为 REST 端点。然后可以由需要它的其他服务使用。
这种设计模式遵循 DRY 原则。
如果有多个服务需要访问服务 A、B 和 C，那么建议将该逻辑抽象为一个复合微服务，并将该逻辑聚合到一个服务中。在此级别进行抽象的一个优点是各个服务，即服务 A、B 和 C，并且可以独立发展，业务需求仍然由组合微服务提供。
请注意，每个单独的微服务都有自己的（可选）缓存和数据库。如果聚合器是一个复合微服务，那么它也可能有自己的缓存和数据库层。
聚合器也可以在 X 轴和 Z 轴上独立缩放。因此，如果它是一个网页，那么您可以启动额外的 Web 服务器，或者如果它是一个使用 Java EE 的复合微服务，那么您可以启动额外的 WildFly 实例来满足不断增长的需求。
代理微服务设计模式 代理微服务设计模式是聚合器的一种变体。在这种情况下，客户端不需要进行聚合，但可以根据业务需要调用不同的微服务。
就像 Aggregator 一样，Proxy 也可以在 X 轴和 Z 轴上独立扩展。您可能喜欢这样做，因为每个单独的服务都不需要向消费者公开，而是应该通过一个界面。
代理可能是一个哑代理，在这种情况下，它只是将请求委托给其中一项服务。或者，它可能是一个智能代理，在将响应提供给客户端之前应用一些数据转换。一个很好的例子就是可以将不同设备的表示层封装在智能代理中。
链式微服务设计模式 链式微服务设计模式对请求产生单一的综合响应。在这种情况下，来自客户端的请求由服务 A 接收，然后服务 A 与服务 B 通信，而服务 B 又可能与服务 C 通信。
所有服务都可能使用同步 HTTP 请求/响应消息传递。
要记住的关键部分是客户端被阻塞，直到完成请求/响应链，即服务&amp;lt;-&amp;gt;服务 B 和服务 B&amp;lt;-&amp;gt;服务 C，完成。从服务 B 到服务 C 的请求可能看起来与从服务 A 到服务 B 的请求完全不同。
同样，服务 B 对服务 A 的响应可能看起来与服务 C 对服务 B 的响应完全不同。无论如何，这就是不同服务增加其业务价值的全部要点。</description>
    </item>
  </channel>
</rss>
