<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Architecture | ChenSoul</title>
<meta name=keywords content><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/categories/architecture/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/categories/architecture/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/categories/architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Architecture"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/categories/architecture/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Architecture"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Architecture
<a href=/categories/architecture/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]《分布式系统：为了乐趣和利益》3.时间及顺序</h2></header><div class=entry-content><p>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者 Mikito Takada 撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
3. 时间及顺序 什么是顺序，为什么它很重要？
你说的“什么是顺序”是什么意思？
我的意思是，为什么我们对顺序如此着迷？为什么我们关心 A 是否发生在 B 之前？为什么我们不关心其他属性，比如“颜色”？
好吧，我的疯狂朋友，让我们回到分布式系统的定义来回答这个问题。
你可能还记得，我将分布式编程描述为使用多台计算机解决单台计算机可以解决的同一个问题的艺术。
事实上，这正是对顺序如此着迷的核心所在。任何只能一次执行一项任务的系统都会创建操作的总体顺序。就像人们通过一扇门一样，每个操作都有明确定义的前任和后继。这基本上是我们努力保留的编程模型。
传统的模型是：一个程序，一个进程，一个在一个 CPU 上运行的内存空间。操作系统抽象了可能存在多个 CPU 和多个程序的事实，以及计算机内存实际上是多个程序共享的。我并不是说线程编程和事件驱动编程不存在；只是它们是“一个/一个/一个”模型之上的特殊抽象。程序被编写成按照一定顺序执行：从上往下执行。
顺序作为一种属性受到了如此多的关注，是因为定义“正确性”的最简单方法是说“它的工作方式与单台计算机上的工作方式相同”。而通常这意味着 a）我们运行相同的操作，b）我们按照相同的顺序运行它们 - 即使有多台计算机。
保持顺序（如单个系统定义的顺序）的分布式系统的优点在于它们是通用的。你不需要关心操作是什么，因为它们将与在单台计算机上完全相同的方式执行。这很棒，因为你知道无论操作是什么，你都可以使用相同的系统。
实际上，分布式程序在多个节点上运行，具有多个 CPU 和多个操作流。你仍然可以分配一个总体顺序，但这需要准确的时钟或某种形式的通信。你可以使用完全准确的时钟为每个操作标记时间戳，然后利用它来确定总体顺序。或者你可以使用某种通信系统，使得可以分配类似总体顺序的连续编号。
全序和偏序 在分布式系统中，自然状态是偏序。网络和独立节点都不对相对顺序做出任何保证，但在每个节点上，你可以观察到一个局部顺序。
总序是一种二元关系，它为某个集合中的每个元素定义了一个顺序。
当两个不同的元素可比较时，其中一个大于另一个。在偏序集中，某些元素对不可比较，因此偏序并不指定每个项目的确切顺序。
总序和偏序都是传递性和反对称性的。对于集合 X 中的所有 a、b 和 c，以下陈述在总序和偏序中都成立：
If a ≤ b and b ≤ a then a = b (antisymmetry); If a ≤ b and b ≤ c then a ≤ c (transitivity); 然而，总序是完全的：
a ≤ b or b ≤ a (totality) for all a, b in X 而偏序是自反的：
a ≤ a (reflexivity) for all a in X 注意，全序性蕴含自反性；因此，偏序是总序的一种较弱的变体。在偏序中的某些元素上，全序性不成立 - 换句话说，其中一些元素不可比较。...</p></div><footer class=entry-footer><span title='2023-11-10 00:00:00 +0800 CST'>2023-11-10</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;648 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]《分布式系统：为了乐趣和利益》3.时间及顺序" href=https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-03/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]《分布式系统：为了乐趣和利益》4.复制</h2></header><div class=entry-content><p>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者 Mikito Takada 撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
4. 复制 复制问题是分布式系统中的众多问题之一。与诸如领导者选举、故障检测、互斥、共识和全局快照等其他问题相比，我选择关注复制问题，因为这通常是人们最感兴趣的部分。并行数据库在复制特性方面的差异化就是一个例子。此外，复制为许多子问题提供了一个上下文，例如领导者选举、故障检测、共识和原子广播。
复制是一个组通信问题。什么样的安排和通信模式能够满足我们所期望的性能和可用性特性？在面对网络分区和同时节点故障的情况下，我们如何确保容错性、耐久性和非发散性？
同样，有许多方法可以解决复制问题。我在这里采用的方法只是看一下具有复制功能的系统可能具有的高级模式。从可视化的角度来看，有助于将讨论集中在整体模式上，而不是具体涉及的消息传递。我在这里的目标是探索设计空间，而不是解释每个算法的具体细节。
让我们首先定义一下复制是什么样子。我们假设我们有一些初始数据库，并且客户端发出请求来改变数据库的状态。
这种安排和通信模式可以分为几个阶段：
（请求）客户端向服务器发送请求 （同步）进行复制的同步部分 （响应）将响应返回给客户端 （异步）进行复制的异步部分 根据这些阶段，我们可以创建不同的通信模式。我们选择的模式将对性能和可用性产生影响，具体取决于所选择的算法。
同步复制 第一个模式是同步复制（也称为主动复制、急切复制、推送复制或悲观复制）。让我们画出它的示意图：
在这里，我们可以看到三个明显的阶段：首先，客户端发送请求。接下来，我们所称的同步复制的部分发生。这个术语指的是客户端被阻塞 - 等待系统的回复。
在同步阶段期间，第一个服务器会联系其他两个服务器，并等待收到所有其他服务器的回复。最后，它向客户端发送一个响应，告知其结果（例如成功或失败）。
这一切似乎很简单。在不讨论同步阶段算法的细节的情况下，我们能从这个特定的通信模式安排中得出什么结论呢？首先，注意这是一种 N-对-N 的写入方式：在返回响应之前，它必须被系统中的每个服务器看到并确认。
从性能的角度来看，这意味着系统的速度将取决于其中最慢的服务器。该系统还对网络延迟的变化非常敏感，因为它要求在继续之前每个服务器都必须回复。
考虑到 N-对-N 的方式，系统无法容忍任何服务器的丢失。当一个服务器丢失时，系统无法再写入所有节点，因此无法继续进行。在这种设计中，它可能能够对数据提供只读访问，但在节点故障后不允许进行修改。
这种安排可以提供非常强大的耐久性保证：当返回响应时，客户端可以确信所有 N 个服务器都已接收、存储和确认了请求。为了丢失一个已接受的更新，所有 N 个副本都需要丢失，这是一个非常好的保证。
异步复制 让我们将其与第二种模式进行对比 - 异步复制（也称为被动复制、拉式复制或惰性复制）。正如您可能已经猜到的，这与同步复制相反：
在这种情况下，主节点（也称为领导者或协调者）立即向客户端返回响应。它最多只会在本地存储更新，但不会同步执行任何重要工作，客户端也不需要等待更多的服务器之间的通信轮次。
在稍后的阶段，复制任务的异步部分发生。在这里，主节点使用某种通信模式联系其他服务器，并更新它们的数据副本。具体的实现取决于所使用的算法。
在不涉及算法细节的情况下，我们对这种具体的安排能得出什么结论呢？嗯，这是一种写 1-对-N 的方式：立即返回响应，更新传播在稍后发生。
从性能的角度来看，这意味着系统很快：客户端不需要额外花费时间等待系统内部完成工作。系统对网络延迟更具容忍性，因为内部延迟的波动不会导致客户端需要额外等待。
这种安排只能提供弱的或概率性的耐久性保证。如果没有出现问题，数据最终会复制到所有 N 台机器上。然而，如果在此之前包含数据的唯一服务器丢失，数据将永久丢失。
考虑到 1-对-N 的方式，只要至少有一个节点正常运行，系统就可以保持可用性（理论上至少如此，但实际上负载可能会太高）。这种纯粹的惰性方式不提供耐久性或一致性保证；你可以向系统写入数据，但如果发生任何故障，不能保证能够读取你所写入的内容。
最后值得注意的是，被动复制无法确保系统中的所有节点始终包含相同的状态。如果在多个位置接受写入操作，并且不要求这些节点同步一致，那么就会存在发散的风险：不同位置的读取可能返回不同的结果（特别是在节点故障和恢复后），并且无法强制执行全局约束（需要与所有人通信）。
我没有详细讨论读取（而不是写入）时的通信模式，因为读取模式实际上是根据写入模式来确定的：在读取过程中，你希望与尽可能少的节点进行联系。我们将在仲裁机制的背景下进一步讨论这个问题。
我们只讨论了两种基本的安排，并没有涉及具体的算法。然而，我们已经能够了解可能的通信模式以及它们的性能、耐久性保证和可用性特性的一些信息。
主要复制方法概述 在讨论了同步和异步复制这两种基本复制方法之后，让我们来看一下主要的复制算法。
有很多不同的方式来对复制技术进行分类。在同步与异步之后，我想引入的第二个区别是：
防止发散的复制方法（单副本系统）和 存在发散风险的复制方法（多主系统） 第一组方法具有“行为像单一系统”的特性。特别是在部分故障发生时，系统确保只有一个副本处于活动状态。此外，系统确保副本始终保持一致。这被称为共识问题。
当多个进程（或计算机）就某个值达成共识时，它们实现了共识。更具体地说：
一致性：每个正确的进程必须就同一个值达成一致。 完整性：每个正确的进程最多决定一个值，并且如果它决定了某个值，则该值必须由某个进程提出。 终止性：所有进程最终都会达成决策。 有效性：如果所有正确的进程提议相同的值 V，则所有正确的进程都决定 V。 互斥、领导者选举、组播和原子广播都是共识问题的更一般实例。维护单一副本一致性的复制系统需要以某种方式解决共识问题。 维护单一副本一致性的复制算法包括：
1n 消息（异步主/备份） 2n 消息（同步主/备份） 4n 消息（两阶段提交，多 Paxos） 6n 消息（三阶段提交，带有重复领导者选举的 Paxos） 这些算法在容错性方面有所不同（例如，它们可以容忍的故障类型）。我根据算法执行期间交换的消息数量进行了简单的分类，因为我认为尝试回答“通过增加消息交换我们得到了什么？”这个问题很有趣。
下面的图表，改编自 Google 的 Ryan Barret，描述了不同选项的一些方面：
上述图表中的一致性、延迟、吞吐量、数据丢失和故障转移特性实际上可以追溯到两种不同的复制方法：同步复制（例如，在响应之前等待）和异步复制。当您等待时，性能会变差，但可以获得更强的保证。在讨论分区（和延迟）容忍性时，2PC 和仲裁系统之间的吞吐量差异将变得明显。
在该图表中，强制弱（/最终）一致性的算法被归类为一类（“gossip”）。然而，我将更详细地讨论弱一致性的复制方法 - gossip 和（部分）仲裁系统。“事务"行实际上更多地涉及全局谓词评估，而在具有弱一致性的系统中不支持（尽管可以支持本地谓词评估）。...</p></div><footer class=entry-footer><span title='2023-11-10 00:00:00 +0800 CST'>2023-11-10</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;566 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]《分布式系统：为了乐趣和利益》4.复制" href=https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-04/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]《分布式系统：为了乐趣和利益》5.复制：弱一致性模型协议</h2></header><div class=entry-content><p>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者 Mikito Takada 撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
5. 复制：弱一致性模型协议 现在，我们已经研究了一些可以在越来越现实的故障情况下实施单副本一致性的协议，让我们转向当我们放弃单副本一致性的要求时所打开的选择世界。
总的来说，很难找到一个单一的维度来定义或描述允许副本发散的协议。大多数这样的协议都具有高可用性，关键问题更多地在于最终用户是否发现这些保证、抽象和 API 对他们的目的有用，尽管在节点和/或网络故障发生时副本可能发散。
为什么弱一致性系统没有更受欢迎呢？
正如我在介绍中所述，我认为分布式编程很大程度上涉及处理分布的两个结果所带来的影响：
信息以光速传播； 独立的事物独立地发生故障。 由于信息传输速度受限，节点以不同且独特的方式体验世界。在单个节点上进行计算很容易，因为一切都按照可预测的全局总序发生。在分布式系统上进行计算很困难，因为没有全局总序。
长期以来（例如几十年的研究时间），我们通过引入全局总序来解决这个问题。我已经讨论了许多实现强一致性的方法，通过在没有自然总序的情况下以容错方式创建顺序的方法。
当然，问题在于强制执行顺序是昂贵的。这在大规模的互联网系统中特别突出，因为系统需要保持可用性。强一致性的系统不像分布式系统那样运行，而是像单个系统，这对于分区期间的可用性是不利的。
此外，对于每个操作，通常需要联系大多数节点，而且通常不止一次（正如您在关于 2PC 的讨论中所看到的）。这在需要在地理上分布以为全球用户提供足够性能的系统中尤其困难。
因此，默认情况下像单个系统一样运行可能并不理想。
也许我们希望拥有一种可以编写不使用昂贵协调的代码，但仍返回一个“可用”值的系统。我们将允许不同的副本彼此发散-既为了保持效率，也为了容忍分区-然后尝试以某种方式处理这种发散。
最终一致性表达了这个想法：节点在一段时间内可以相互发散，但最终它们将达成一致的值。
在提供最终一致性的系统集合中，有两种类型的系统设计：
带有概率保证的最终一致性。这种类型的系统可以在以后的某个时间点检测到冲突的写操作，但不能保证结果与某个正确的顺序执行等效。换句话说，冲突的更新有时会导致将较新的值覆盖为较旧的值，并且在正常操作（或分区）期间可能会出现一些异常情况。
近年来，最有影响力的提供单副本一致性的系统设计是亚马逊的 Dynamo，我将以它作为提供带有概率保证的最终一致性系统示例进行讨论。
带有强保证的最终一致性。这种类型的系统保证最终结果会收敛到一个共同的值，该值等同于某个正确的顺序执行。换句话说，这样的系统不会产生任何异常结果；在没有任何协调的情况下，您可以构建相同服务的副本，并且这些副本可以以任何模式进行通信并以任何顺序接收更新，只要它们都看到相同的信息，它们最终会就最终结果达成一致。
CRDT（收敛复制数据类型）是一种数据类型，它保证在网络延迟、分区和消息重排序的情况下收敛到相同的值。它们可以被证明是收敛的，但可以实现为 CRDT 的数据类型是有限的。
CALM（一致性作为逻辑单调性）猜想是相同原则的另一种表达方式：它将逻辑单调性与收敛等同起来。如果我们可以得出某个东西在逻辑上是单调的，那么在没有协调的情况下运行它也是安全的。收敛分析-特别是在 Bloom 编程语言中的应用-可用于指导程序员在何时何地使用强一致性系统的协调技术以及在何时可以安全地执行无需协调的操作。
协调不同的操作指令 不强制执行单副本一致性的系统是什么样子呢？让我们通过几个例子来更具体地了解。
也许最明显的非强制执行单副本一致性系统的特征是它们允许副本彼此发散。这意味着没有严格定义的通信模式：副本可以相互分离，但仍然保持可用并接受写操作。
让我们想象一个由三个副本组成的系统，每个副本彼此分离。例如，这些副本可能位于不同的数据中心，并因某种原因无法通信。在分离期间，每个副本仍然可用，可以接受一些客户端的读写操作：
[Clients] - > [A] --- Partition --- [Clients] - > [B] --- Partition --- [Clients] - > [C] 一段时间后，分区会修复并且副本服务器会交换信息。他们从不同的客户那里收到了不同的更新，并且彼此存在分歧，因此需要进行某种协调。我们希望所有的副本都收敛到相同的结果。
[A] \ --> [merge] [B] / | | [C] ----[merge]---> result 考虑具有弱一致性保证的系统的另一种方法是想象一组客户端按某种顺序向两个副本发送消息。由于没有强制执行单一总顺序的协调协议，因此消息可以在两个副本上以不同的顺序传递：
[Clients] --> [A] 1, 2, 3 [Clients] --> [B] 2, 3, 1 从本质上讲，这就是我们需要协调协议的原因。例如，假设我们尝试连接一个字符串，消息 1、2 和 3 中的操作为：
1: { operation: concat('Hello ') } 2: { operation: concat('World') } 3: { operation: concat('!...</p></div><footer class=entry-footer><span title='2023-11-10 00:00:00 +0800 CST'>2023-11-10</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1139 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]《分布式系统：为了乐趣和利益》5.复制：弱一致性模型协议" href=https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-05/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]《分布式系统：为了乐趣和利益》6.进一步阅读和附录</h2></header><div class=entry-content><p>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者Mikito Takada撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
6. 进一步阅读和附录 如果您已经做到了这一点，谢谢您。
如果您喜欢这本书，请在 Github（或 Twitter）上关注我。我很高兴看到我产生了某种积极的影响。 “创造的价值比你获取的价值更多”等等。
非常感谢：logpath、alexras、globalcitizen、graue、frankshearar、roryokane、jpfuentes2、eeror、cmeiklejohn、stevenproctor eos2102 和 steveloughran 的帮助！当然，任何错误和遗漏都是我的错！
值得注意的是，我关于最终一致性的章节相当以伯克利为中心；我想改变这一点。我还跳过了一个重要的时间用例：一致的快照。我还应该扩展几个主题：即，对安全性和活性属性的明确讨论以及对一致性哈希的更详细讨论。不过，我要去《Strange Loop 2013》了，所以无论如何。
如果这本书有第六章，它可能是关于如何利用和处理大量数据的。似乎最常见的“大数据”计算类型是通过单个简单程序传递大型数据集的计算。我不确定后续章节会是什么（也许是高性能计算，因为当前的重点是可行性），但我可能会在几年后知道。
有关分布式系统的书籍 Distributed Algorithms (Lynch) 这可能是最常推荐的分布式算法书籍。我也推荐它，但有一个警告。它非常全面，但是是为研究生读者编写的，因此在了解从业者最感兴趣的内容之前，您将花费大量时间阅读同步系统和共享内存算法。
Introduction to Reliable and Secure Distributed Programming (Cachin, Guerraoui & Rodrigues) 对于一个修炼者来说，这是一件有趣的事。它很短并且充满了实际的算法实现。
Replication: Theory and Practice 如果您对复制感兴趣，这本书非常棒。关于复制的章节主要基于对本书有趣部分以及最近阅读的内容的综合。
Distributed Systems: An Algorithmic Approach (Ghosh) Introduction to Distributed Algorithms (Tel) Transactional Information Systems: Theory, Algorithms, and the Practice of Concurrency Control and Recovery (Weikum & Vossen) 本书介绍的是传统的交易信息系统，例如：本地 RDBMS。最后有两章介绍分布式事务，但本书的重点是事务处理。
Transaction Processing: Concepts and Techniques by Gray and Reuter 经典之作。我发现 Weikum & Vossen 更更新。
开创性论文 每年，Edsger W. Dijkstra 分布式计算奖都会颁发给有关分布式计算原理的杰出论文。查看完整列表的链接，其中包括经典内容，例如：
“Time, Clocks and Ordering of Events in a Distributed System” - Leslie Lamport “Impossibility of Distributed Consensus With One Faulty Process” - Fisher, Lynch, Patterson “Unreliable failure detectors and reliable distributed systems” - Chandra and Toueg Microsoft 学术搜索有一个分布式和并行计算领域的顶级出版物列表，按引用次数排序 - 这可能是一个有趣的列表，可以浏览更多经典著作。...</p></div><footer class=entry-footer><span title='2023-11-10 00:00:00 +0800 CST'>2023-11-10</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;237 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]《分布式系统：为了乐趣和利益》6.进一步阅读和附录" href=https://blog.chensoul.cc/posts/2023/11/10/distributed-systems-06/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]给年轻的工程师们的关于分布式系统的一些笔记</h2></header><div class=entry-content><p>我一直在思考分布式系统工程师在工作中学到的教训。我们大部分的教导都来自于在生产环境中犯过的错误留下的伤痕。这些伤痕固然是有用的提醒，但让更多的工程师能够完整地保留手指会更好。
新的系统工程师在自我学习中会遇到分布式计算的谬论和CAP定理。但这些都是抽象的概念，缺乏针对经验不足的工程师直接可行的建议。让人惊讶的是，新工程师在开始工作时所了解到的背景信息是如此之少。
下面是我作为一名分布式系统工程师学到的一些经验教训，值得告诉新工程师。其中一些经验是微妙的，一些是令人惊讶的，但没有一条是有争议的。这个列表是为了引导新的分布式系统工程师思考他们所从事领域的问题，虽然不是全面的，但是是一个很好的开始。
这个列表最糟糕的特点是它主要关注技术问题，很少讨论工程师可能遇到的社交问题。由于分布式系统需要更多的机器和资本，它们的工程师往往需要与更多的团队和更大的组织合作。社交问题通常是任何软件开发者工作中最困难的部分，也许对于分布式系统的开发来说尤其如此。
我们的背景、教育和经验使我们倾向于采用技术解决方案，即使社交解决方案可能更高效、更令人满意。让我们试着纠正这一点。与计算机相比，人们并不那么挑剔，即使他们的接口没有那么标准化。
好了，我们开始吧。
分布式系统是不同的，因为它们经常失败。 当被问及是什么将分布式系统与软件工程的其他领域区分开来时，这位新工程师经常引用延迟，认为这是使分布式计算变得困难的原因。
但他们错了。分布式系统工程的区别在于失败的概率，更糟糕的是，部分失败的概率。如果格式良好的互斥锁解锁失败并出现错误，我们可以假设该过程不稳定并使其崩溃。但是，分布式互斥锁解锁的失败必须内置到锁定协议中。
没有从事过分布式计算的系统工程师会想出一些想法，比如“好吧，它只是将写入发送到两台机器”或“它会不断重试写入，直到它成功”。这些工程师还没有完全接受（尽管他们通常在理智上认识到）网络系统比只存在于一台机器上的系统更容易失败，而且故障往往是部分的而不是全部的。
其中一个写入可能会成功，而另一个写入失败，那么现在我们如何获得一致的数据视图呢？这些部分故障更难推理。
交换机故障、垃圾回收暂停导致领导者“消失”、套接字写操作似乎成功但实际上在另一台机器上失败、一台机器上的慢速磁盘驱动引起整个集群中的通信协议变慢等等。从本地内存读取比通过几个交换机读取更稳定。。
为失败而设计！
编写健壮的分布式系统比编写健壮的单机系统成本更高。 与单机解决方案相比，创建强大的分布式解决方案需要更多的资金，因为只有许多计算机才会发生故障。虚拟机和云技术使分布式系统工程更便宜，但不像能够在您已经拥有的计算机上进行设计、实施和测试那样便宜。并且存在难以在单台机器上复制的故障条件。
无论是因为它们只发生在比共享机器上可以容纳的数据集大小大得多的数据集上，还是在数据中心的网络条件下，分布式系统往往需要实际的（而不是模拟的）分发来清除它们的错误。当然，模拟非常有用。
健壮的开源分布式系统远不如健壮的单机系统常见。长时间运行多台机器的成本是开源社区的负担。业余爱好者和业余爱好者是开源软件的引擎，他们没有可用的财务资源来探索或解决分布式系统将遇到的许多问题。业余爱好者在空闲时间使用他们已经拥有的机器编写开源代码以取乐。
要找到愿意启动、维护和支付一堆机器的开源开发人员要困难得多。
为公司实体工作的工程师已经填补了部分空缺。但是，其组织的优先级可能与组织的优先级不一致。
虽然开源社区中的一些人已经意识到了这个问题，但它还没有得到解决。这很难。
协调非常困难。 尽可能避免协调机器。这通常被描述为“水平可伸缩性”。水平可扩展性的真正诀窍是独立性——能够将数据传送到机器上，从而将这些机器之间的通信和共识保持在最低限度。每当两台机器必须就某件事达成一致时，服务就会变得更难实现。
信息的传播速度是有上限的，网络通信比你想象的要脆弱，你对什么是共识的想法可能是错误的。在这里，了解 Two Generals 和 拜占庭将军 的问题很有用。（哦，Paxos真的很难实现；这不是脾气暴躁的老工程师认为他们比你更了解。）
如果你能把你的问题放在内存中，那可能是微不足道的。 对于分布式系统工程师来说，一台机器的本地问题很容易解决。当数据距离几个开关而不是几个指针取消引用时，弄清楚如何快速处理数据会更难。在分布式系统中，自计算机科学开始以来就记录的陈旧效率技巧不再适用。
对于在单台机器上运行的算法，有大量的文献和实现，因为大部分计算都是在单一的、不协调的机器上完成的。对于分布式系统来说，存在的数量要少得多。
“很慢”是你调试过的最难的问题。 “速度慢”可能意味着执行用户请求所涉及的一个或多个系统速度较慢。这可能意味着跨多台计算机的转换管道的一个或多个部分速度较慢。“它很慢”很难，部分原因是问题陈述没有提供很多关于缺陷位置的线索。部分故障，即那些没有出现在你通常查找的图表上的故障，潜伏在一个黑暗的角落里。
而且，在退化变得非常明显之前，您将无法获得那么多的资源（时间、金钱和工具）来解决它。Dapper 和 Zipkin 的出现是有原因的。
**在整个系统中实现反压机制。**反压是服务系统向请求系统发出故障信号，并由请求系统处理这些故障以防止自身和服务系统过载。设计反压意味着在负载过重和系统故障时限制资源使用。这是创建健壮的分布式系统的基本构建块之一。
实现反压通常涉及以下两种方式之一：要么将新消息丢弃，要么在资源受限或发生故障时将错误返回给用户（并在两种情况下增加指标）。对于与其他系统的连接和请求，超时和指数退避也是至关重要的。
如果没有反压机制，可能会发生级联故障或意外消息丢失。当一个系统无法处理另一个系统的故障时，它倾向于将故障传播给依赖它的另一个系统。
寻找实现部分可用性的方法。 部分可用性是指即使系统的某些部分发生故障，仍能返回一些结果。
搜索是一个理想的案例来探讨这个问题。搜索系统在结果质量和用户等待时间之间进行权衡。一个典型的搜索系统会设置一个时间限制，如果在搜索所有文档之前超过了时间限制，它会返回已经收集到的结果。这使得搜索在面对间歇性减速和错误时更容易扩展，因为这些故障被视为无法搜索所有文档的情况。系统允许返回部分结果给用户，并增加了其弹性。
再以Web应用程序中的私密消息功能为例。无论你做什么，私密消息的存储机器都可能同时宕机，用户会注意到这一点。那么在这个系统中，我们希望出现什么样的部分故障呢？
这需要一些思考。一般来说，人们对于无法使用私密消息功能（或许是其他一些用户也无法使用）会更容忍，而对于所有用户中有一些消息丢失则更为不满意。如果服务过载或其中一台机器故障，只让一小部分用户无法使用比让更大比例的用户丢失数据更可取。除此之外，我们可能不希望一个无关的功能（比如公共图片上传）受到影响，只因为私密消息功能出现问题。我们愿意付出多少努力来保持这些故障域的独立？
能够在部分可用性中识别这些权衡是很有帮助的。
指标是完成工作的唯一途径。 公开指标（如延迟百分比、特定操作的计数器增加、变化速率等）是弥合您对系统在生产环境中所做的假设与实际情况之间差距的唯一途径。了解系统在第20天的行为与第15天的行为有何不同，是成功工程和失败巫术之间的区别。当然，指标是了解问题和行为的必要手段，但并不足以知道接下来该做什么。
稍微提一下日志记录。日志文件是很有用的，但它们往往会欺骗人。例如，很常见的情况是几个错误类别的日志记录占据了日志文件的很大比例，但实际上在请求中的比例非常低。因为在大多数情况下记录成功是多余的（并且在大多数情况下会耗尽磁盘空间），而且工程师经常错误地猜测哪些错误类别是有用的，所以日志文件中充斥着各种奇怪的信息。最好以一种假设有人会阅读日志但没有看过代码的方式进行日志记录。
我见过很多次由于另一位工程师（或者我自己）过于强调日志中的一些奇怪现象而导致故障延长，而没有先将其与指标进行对比。我还见过另一位工程师（或者我自己）从少数几行日志中推断出整套失败行为的情况。但请注意：a) 我们之所以记住这些成功案例，是因为它们非常罕见；b) 除非指标或实验证实了故事，否则你并不是福尔摩斯（Sherlock）。
使用百分位数而不是平均值。 在绝大多数分布式系统中，百分位数（50th、99th、99.9th、99.99th）比平均值更准确、更有信息量。使用平均值假设正在评估的指标遵循正态分布曲线，但在实践中，这只适用于少数工程师关心的指标。 “平均延迟” 是一个常见的报告指标，但我从未见过一个延迟遵循正态分布曲线的分布式系统。如果指标不遵循正态分布曲线，平均值就没有意义，会导致错误的决策和理解。通过使用百分位数来避免这个陷阱。默认使用百分位数，你将更好地了解用户真正看待你的系统的方式。
学会估算你的容量。 因此，你将会知道一天有多少秒。知道你需要多少台机器来执行一个任务是一个持久系统和一个在工作开始3个月后需要被替换的系统之间的区别。或者更糟糕的是，在你完成将其投入生产之前就需要被替换。
以推文为例。在一台普通的机器上，你可以将多少个推文ID存放在内存中? 嗯，到2012年底，一台典型的机器有24 GB的内存，你需要4-5 GB的开销来运行操作系统，另外还需要至少几个GB来处理请求，而一个推文ID占用8个字节。这是你可能会进行的粗略计算。Jeff Dean的《每个人都应该知道的数字》幻灯片是一个很好的期望设定工具。
特性标志（Feature flags）是基础设施推出的方式。 特性标志是产品工程师在系统中推出新功能的常用方式。特性标志通常与前端A/B测试相关联，用于向部分用户展示新的设计或功能。但它们也是替换基础设施的强大方式。
很多项目因为选择了“大切换”或一系列“大切换”，然后由于发现了太晚的错误而被迫回滚，从而导致失败。通过使用特性标志，你将增强对项目的信心并减轻失败的成本。
假设你要从单一数据库迁移到一个隐藏了新存储解决方案细节的服务。使用特性标志，你可以逐步将写操作转移到新服务，与对旧数据库的写操作并行进行，以确保其写路径的正确性和速度足够快。在写路径达到100%并将数据回填到服务的数据存储完成后，你可以使用单独的特性标志开始从该服务读取，而不在用户响应中使用该数据，以检查性能问题。另一个特性标志可以用于比较从旧系统和新系统读取的数据。最后一个标志可以用于逐步增加从新系统进行“真实”读取操作。
通过将部署拆分为多个步骤，并通过特性标志提供快速和部分反应，你可以更容易地在扩展过程中发现错误和性能问题，而不是在“一次性发布”时发现。如果出现问题，你只需立即将特性标志设置降低到较低（可能是零）的设置。通过调整速率，你可以在不同的流量量级下进行调试和实验，知道任何问题都不会造成灾难。使用特性标志，你还可以选择其他迁移策略，例如基于每个用户的方式将请求转移到新系统，以提供对新系统的更好洞察。当你的新服务仍在原型阶段时，你可以将特性标志设置为较低，以减少新系统的资源消耗。
现在，特性标志对于经典训练的开发人员或新工程师来说可能听起来像是一堆条件语句的可怕混乱。而使用特性标志意味着接受多个基础设施和数据版本是一种常态，而不是罕见情况。这是一个深刻的教训。在单机系统中有效的方法在面对分布式问题时有时会失败。
特性标志最好被理解为一种权衡，以在代码和一个系统中交换局部复杂性，以获得全局的简单性和弹性。
**明智地选择ID空间。 **你为系统选择的ID空间将塑造你的系统。
要获取数据所需的ID数量越多，就越有选择将数据进行分区的选项。要获取数据所需的ID数量越少，消费你的系统输出就越容易。
以Twitter API的第一个版本为例。所有获取、创建和删除推文的操作都是基于每个推文的单个数字ID进行的。推文ID是一个简单的64位数字，不与任何其他数据相关联。随着推文数量的增加，人们意识到，如果将同一用户的所有推文存储在同一台机器上，可以有效地构建用户的推文时间线和其他用户订阅的时间线。
但公共API要求每个推文只能通过推文ID进行访问。要按用户对推文进行分区，需要构建一个查找服务，它知道哪个用户拥有哪个推文ID。如果必要，这是可行的，但成本不可忽视。
另一种选择是在任何推文查找时要求用户ID，并且最初只是使用推文ID进行存储，直到用户分区存储上线。另一种选择是在推文ID本身中包含用户ID，这样做的代价是推文ID不再具有k-sortable和数字的特性。
要注意在ID中明确和隐含地编码了哪种类型的信息。客户端可能利用ID的结构来去匿名化私人数据，以意想不到的方式爬取你的系统（自增ID通常是一个痛点），或进行其他一系列攻击。
利用数据局部性。 将数据的处理和缓存与其持久存储保持靠近，处理效率更高，同时保持缓存一致性和快速性更容易。与指针解引用和fread（3）相比，网络故障和延迟更多。
当然，数据局部性意味着在空间上靠近，但也意味着在时间上靠近。如果多个用户几乎同时进行相同的昂贵请求，也许可以将它们的请求合并为一个请求。如果在相近的时间内发出了多个相同类型的数据请求，可以将它们合并为一个更大的请求。这样做通常可以降低通信开销并更容易进行故障管理。
**将缓存数据写回持久存储是不好的。 **这种情况在比想象中更多的系统中发生。尤其是那些最初由缺乏分布式系统经验的人设计的系统。你将继承许多具有此缺陷的系统。如果实施者谈到“俄罗斯套娃缓存”，你很有可能遇到非常明显的错误。这个条目本可以从列表中省略，但我对此特别痛恨。这种缺陷的常见表现是用户信息（例如屏幕名称、电子邮件和哈希密码）神秘地恢复到先前的值。
计算机的能力超乎你的想象。 现在的现场存在很多关于机器能力的错误信息，这些信息来自于没有太多经验的从业者。
在2012年底，轻型Web服务器拥有6个或更多处理器，24GB内存和比你能使用的更多磁盘空间。在现代语言运行时环境中，一个相对复杂的CRUD应用程序在单个机器上可以在几百毫秒内轻松处理数千个请求每秒。这还只是下限。在大多数情况下，每台机器每秒处理数百个请求并不值得夸耀。
获得更高的性能并不难，尤其是如果你愿意对应用程序进行性能分析，并根据测量结果引入效率。
**利用CAP定理对系统进行批判。 **CAP定理不能用作构建系统的基础。它不是一个可以作为第一原则并从中推导出一个可行系统的定理。它的适用范围过于广泛，可能的解决方案空间也过于宽泛。
然而，CAP定理非常适合用于对分布式系统设计进行批判，并理解需要做出的权衡。通过对系统设计进行迭代，考虑CAP对其子系统施加的约束，最终可以得到更好的设计。作业中，将CAP定理的约束应用于俄罗斯套娃缓存的实际实现。
最后需要注意的是：在一致性（C）、可用性（A）和分区容忍性（P）中，不能选择CA。
**提取服务。 **这里的"服务"指的是"一个包含高级逻辑的分布式系统，通常具有请求-响应式的API"。要留意那些如果存在于一个单独的服务中而不是你的系统中，将更容易进行的代码更改。
提取出一个服务提供了封装的好处，通常与创建库相提并论。然而，提取出一个服务改进了创建库的方式，因为它允许更快、更容易地部署变更，而不像升级客户系统中的库那样麻烦。（当然，如果提取出的服务难以部署，那么客户系统将变得更容易部署。）这种便利是由于较小、提取出的服务中的代码和操作依赖较少，并且其创建的严格边界使得很难"走捷径"，而库则允许这种走捷径。这些走捷径通常会使迁移内部或客户系统到新版本变得更加困难。
当存在多个客户系统时，使用服务的协调成本也比使用共享库要低得多。即使不需要进行API更改，升级库也需要协调每个客户系统的部署。如果部署次序颠倒，可能会导致数据损坏（而且很难预测这种情况），这使得升级库变得更加困难。如果客户系统由不同的维护者负责，升级库的社交协调成本也比部署服务更高。让其他人意识到并愿意升级是非常困难的，因为他们的优先事项可能与你的不一致。
典型的服务使用案例是隐藏一个将要进行变更的存储层。提取出的服务具有更方便且表面积更小的API，与其前端的存储层相比。通过提取服务，客户系统无需了解迁移到新的存储系统或格式的复杂性，只需要评估新服务中肯定会发现的与新存储布局相关的错误。
在执行此操作时，需要考虑许多操作和社交问题。在这里无法对它们进行充分阐述。需要撰写另一篇文章对此进行详细说明。
我对我的审稿人Bill de hÓra、Coda Hale、JD Maturen、Micaela McDonald和Ted Nyman表示衷心感谢。你们的见解和关心是无价的。...</p></div><footer class=entry-footer><span title='2023-11-10 00:00:00 +0800 CST'>2023-11-10</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;113 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]给年轻的工程师们的关于分布式系统的一些笔记" href=https://blog.chensoul.cc/posts/2023/11/10/notes-on-distributed-systems-for-young-bloods/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]《分布式系统：为了乐趣和利益》介绍</h2></header><div class=entry-content><p>《分布式系统：为了乐趣和利益》是一本广受欢迎的资源，用于理解和学习分布式系统。该书由作者Mikito Takada撰写，介绍了构建分布式系统的基本概念、原则和挑战。
这本书涵盖了与分布式系统相关的广泛主题，包括网络、容错性、一致性模型、分布式算法、可扩展性等等。它旨在以清晰易懂的方式解释复杂的概念，适合初学者和有经验的分布式系统从业者阅读。
在整本书中，作者提供了各种实际案例和案例研究，以说明分布式系统的实际应用和实践方面。它还强调了构建分布式系统涉及的权衡和设计考虑，帮助读者全面理解这个主题。
《分布式系统：为了乐趣和利益》作为开源资源，可以免费在线获取，非常适合任何对学习分布式系统感兴趣的人。
原文链接：Distributed systems: for fun and profit
介绍 我想要一本能够汇集许多最新分布式系统（例如 Amazon 的 Dynamo、Google 的 BigTable 和 MapReduce、Apache 的 Hadoop 等系统）背后的思想的文本。
在本文中，我试图提供更易于理解的分布式系统介绍。对我来说，这意味着两件事：介绍您需要的关键概念，以便您可以愉快地阅读更严肃的文本，并提供足够详细的叙述，以便您了解正在发生的事情的要点，而不会陷入困境关于细节。现在是 2013 年，您已经有了互联网，您可以有选择地阅读更多您认为最感兴趣的主题。
在我看来，分布式编程的大部分内容都是关于处理分布式的两个后果的影响：
信息以光速传播 独立的事物会独立失败 换句话说，分布式编程的核心是处理距离（废话！）并且拥有不止一件事（废话！）。这些约束定义了可能的系统设计空间，我希望读完本文后您将更好地了解距离、时间和一致性模型如何相互作用。
本文重点介绍理解数据中心商业系统所需的分布式编程和系统概念。试图涵盖一切将是疯狂的。您将学习许多关键协议和算法（例如，涵盖该学科中许多被引用次数最多的论文），包括一些尚未进入大学教科书的最终一致性的令人兴奋的新方法 - 例如 CRDT和 CALM 定理。
我希望你喜欢它！如果您想表达感谢，请在 Github（或 Twitter）上关注我。如果发现错误，请在 Github 上提交拉取请求。
1. 基础知识 第一章通过介绍一些重要的术语和概念，从高层次上介绍了分布式系统。它涵盖了高级别目标，例如可扩展性、可用性、性能、延迟和容错；这些是如何难以实现的，以及抽象和模型以及分区和复制如何发挥作用。
2. 抽象层次的上下 第二章更深入地探讨抽象和不可能性的结果。它以尼采的名言开始，然后介绍系统模型以及典型系统模型中所做的许多假设。然后讨论了 CAP 定理并总结了 FLP 不可能性结果。然后转向 CAP 定理的含义，其中之一是人们应该探索其他一致性模型。然后讨论了许多一致性模型。
3. 时间及顺序 理解分布式系统的一个重要部分是理解时间和顺序。如果我们无法理解和建模时间，我们的系统就会失败。第三章讨论时间和顺序、时钟以及时间、顺序和时钟的各种用途（例如矢量时钟和故障检测器）。
4. 复制：防止发散 第四章介绍了复制问题以及执行该问题的两种基本方法。事实证明，大多数相关特征都可以通过这个简单的表征来讨论。然后，从最低容错（2PC）到Paxos讨论了维持单副本一致性的复制方法。
5. 复制：接受分歧 第五章讨论了具有弱一致性保证的复制。它引入了一个基本的协调场景，其中分区副本尝试达成一致。然后，它讨论了 Amazon 的 Dynamo 作为具有弱一致性保证的系统设计的示例。最后，讨论了无序编程的两个观点：CRDT 和 CALM 定理。
Appendix 附录 附录包含进一步阅读的建议。</p></div><footer class=entry-footer><span title='2023-11-09 00:00:00 +0800 CST'>2023-11-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;72 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]《分布式系统：为了乐趣和利益》介绍" href=https://blog.chensoul.cc/posts/2023/11/09/distributed-systems-intro/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>如何成为一名合格的架构师</h2></header><div class=entry-content><p>如何成为一名合格的架构师 成为一名合格的架构师需要不断学习和积累经验。以下是一些步骤和建议，可以帮助你成为一名合格的架构师：
学习基础知识：建立坚实的计算机科学和软件工程基础，包括数据结构、算法、操作系统、数据库等。深入学习编程语言和开发技术，了解不同技术栈的优缺点。
实践项目开发：通过参与实际的软件开发项目，积累项目管理和开发经验。亲身经历软件开发的各个阶段，从需求分析到设计、开发、测试和部署，深入了解软件开发的流程和挑战。
学习系统设计和架构：深入学习系统设计和架构的相关知识，包括架构模式、设计原则。阅读相关的书籍、文章和技术博客，参与架构设计讨论和社区活动。
以下是关于架构模式、设计原则和一些常见架构的简要介绍：
架构模式： 分层架构（Layered Architecture）：将系统划分为多个层次，每个层次有不同的职责和功能，实现松耦合和可维护性。 客户端-服务器模式（Client-Server）：将系统分为客户端和服务器，客户端发送请求并接收响应，服务器处理请求并提供服务。 发布-订阅模式（Publish-Subscribe）：基于事件的模式，发布者发布事件，订阅者订阅感兴趣的事件，实现解耦和扩展性。 微服务架构（Microservices Architecture）：将系统拆分为一组小型、自治的服务，每个服务专注于一个特定的业务功能，通过轻量通信协议进行交互。 事件驱动架构（Event-Driven Architecture）：系统的组成部分通过事件进行通信和协调，事件的发生触发相应的处理和反应。 设计原则： 单一职责原则（Single Responsibility Principle）：一个模块或类应该有且只有一个单一的责任。 开闭原则（Open-Closed Principle）：软件实体应该对扩展开放，对修改封闭。 里氏替换原则（Liskov Substitution Principle）：子类应该能够替换掉父类，并且不会破坏程序的正确性。 接口隔离原则（Interface Segregation Principle）：不应该强迫客户端依赖于它们不需要的接口。 依赖倒置原则（Dependency Inversion Principle）：应该依赖于抽象而不是具体实现。 实践架构设计：在实际项目中担任架构师的角色，负责系统的整体设计和架构决策。通过实践中的挑战和经验，不断提升自己的架构设计能力。
学习领域知识：根据自己的兴趣和发展方向，深入学习特定领域的知识。例如，如果你在金融领域工作，了解金融系统的特点和要求，掌握相关的技术和解决方案。
不断学习和跟进技术趋势：保持对新技术和趋势的敏感性，持续学习和跟进行业的最新发展。参加技术研讨会、培训课程和行业会议，阅读技术书籍和博客，与同行进行交流和讨论。
培养沟通和领导能力：作为架构师，与团队成员、业务部门和其他利益相关者进行有效的沟通和合作非常重要。培养良好的沟通和领导能力，能够清晰地表达设计思想和技术方案，并协调各方利益。
寻求 mentor 或参与指导项目：寻找经验丰富的架构师作为 mentor，从他们那里获得指导和建议。参与指导性项目，与其他架构师合作，共同解决复杂问题，学习他们的设计思路和方法。
持续改进和反思：持续改进自己的技术能力和专业素养。定期回顾和反思自己的设计决策和经验，寻找改进的空间，并从失败和挑战中吸取教训。
最重要的是，成为一名合格的架构师是一个渐进的过程，需要不断学习、实践和积累经验。通过不断提升自己的技术水平、设计能力和沟通能力，你将逐步成为一名优秀的架构师。
架构师必备的技能和知识 作为架构师，以下是一些必备的技能和知识：
系统设计和架构：具备全面的系统设计和架构能力，能够设计可靠、可扩展、高性能和安全的系统架构。了解常用的架构模式和设计原则，如分层架构、微服务架构、事件驱动架构等。 编程和开发经验：具备扎实的编程能力和开发经验，熟悉多种编程语言和技术栈。能够理解和评估不同技术选型的优缺点，并在需要时能够进行原型开发和演示。 分布式系统：了解分布式系统的概念、原理和常见挑战，熟悉分布式计算、分布式存储和分布式通信等相关技术。能够设计和优化分布式系统的架构，解决分布式系统中的一致性、容错和性能问题。 性能优化和调优：具备性能优化和调优的经验，能够分析和解决系统性能瓶颈。熟悉性能测试工具和性能监控工具，能够设计和实施性能测试计划，并提出相应的优化建议。 安全设计和防御：具备系统安全设计和防御的能力，了解常见的安全威胁和攻击方式，能够设计和实施安全策略和措施，确保系统的安全性和数据的保密性。 数据库和存储系统：熟悉各种数据库和存储系统的原理和使用，包括关系型数据库、NoSQL 数据库、缓存系统等。能够进行数据库设计和优化，保证数据的一致性和可靠性。 云计算和容器技术：了解云计算和容器技术的概念和基本原理，包括虚拟化、容器化、自动化部署等。能够设计和部署基于云计算和容器技术的系统架构，如使用 Docker、Kubernetes 等。 消息队列和事件驱动：熟悉消息队列和事件驱动架构，了解消息中间件的选择和使用。能够设计和实现基于消息队列和事件驱动的系统，实现松耦合和可扩展性。 高可用和容错设计：能够设计和实现高可用和容错的系统架构，包括故障恢复、负载均衡、容灾和备份策略等。了解分布式一致性和容错算法，如 Paxos、Raft 等。 沟通和领导能力：作为架构师，需要具备良好的沟通和领导能力。能够与团队成员、业务部门和其他利益相关者进行有效的沟通和合作，推动项目的顺利进行。 这些技能和知识将帮助架构师在设计和构建复杂系统时做出明智的决策，并确保系统的可靠性、可扩展性和性能。此外，架构师还应不断学习和保持对新技术和趋势的敏感性，以保持在技术领域的竞争力。
架构师学习路线图 作为架构师，以下是一个可能的学习路线图，可以帮助你系统地学习和发展架构师的技能：
基础知识： 学习软件开发基础知识，包括编程语言、数据结构和算法等。 理解软件开发流程和常用开发方法，如敏捷开发和 DevOps。 学习面向对象设计和设计模式。 架构设计基础： 学习软件架构的基本概念、原则和模式。 研究和理解常见的架构模式，如分层架构、客户端-服务器模式和发布-订阅模式等。 掌握设计原则，如单一职责原则、开闭原则和依赖倒置原则等。 深入学习架构模式和技术： 学习微服务架构的原理、设计和实施。 研究事件驱动架构和消息队列的使用。 探索大数据架构和分布式系统设计。 了解容器化和容器编排技术，如 Docker 和 Kubernetes。 实践和项目经验： 参与实际项目，从中学习架构设计和实施的经验。 尝试设计和开发自己的小型项目，实践架构设计和解决实际问题。 参与开源项目或贡献，与其他架构师交流和分享经验。 持续学习和发展： 关注行业趋势和新兴技术，如人工智能、物联网和区块链等。 参加架构师培训和认证课程，如 TOGAF、AWS Certified Solutions Architect 等。 参与架构师社区和论坛，与其他专业人士交流和学习。 请注意，这只是一个示例学习路线图，你可以根据自己的兴趣、目标和实际情况进行调整和扩展。重要的是保持持续学习和不断实践，通过实际项目和经验来提升自己的架构师技能。
架构师学习资源 以下是一些关于系统设计和架构的经典书籍：
《软件架构实践》（Software Architecture in Practice） - Len Bass、Paul Clements、Rick Kazman 《大规模分布式存储系统》（Designing Data-Intensive Applications） - Martin Kleppmann 《企业集成模式》（Enterprise Integration Patterns） - Gregor Hohpe、Bobby Woolf 《架构之美》（Beautiful Architecture） - Diomidis Spinellis、Georgios Gousios 《架构设计原则》（The Art of Software Architecture: Design Methods and Techniques） - Stephen T....</p></div><footer class=entry-footer><span title='2023-08-21 00:00:00 +0800 CST'>2023-08-21</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;258 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 如何成为一名合格的架构师" href=https://blog.chensoul.cc/posts/2023/08/21/architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>用户故事如何应用到个人管理</h2></header><div class=entry-content><p>用户故事（User Stories）是敏捷软件开发中的一种需求表达方式，用于描述用户的需求、期望和价值。尽管用户故事主要应用于软件开发团队，但其原则和方法也可以应用到个人管理中，以帮助个人更好地管理自己的任务和目标。
在个人管理中，可以将用户故事的思维方式应用如下：
角色定义：将自己作为一个角色，例如“个人”或“自己的名字”。明确自己的身份和角色，以便更好地理解自己的需求和期望。 需求描述：将自己的需求和期望转化为用户故事的形式。例如：“作为一个个人，我希望每天早晨锻炼，以保持健康和增加活力。” 价值定义：确定每个用户故事的价值和意义。例如，锻炼身体可以增强健康、提高精力和改善心情，从而提升整体生活质量。 优先级排序：对用户故事进行优先级排序，以确定哪些是最重要的和紧急的。这有助于集中精力和资源，实现最有价值的目标。 制定计划：根据用户故事的优先级，制定个人管理计划。将每个用户故事转化为具体的任务、行动和时间安排，以实现期望的结果。 迭代和反馈：将个人管理过程视为一个迭代循环，不断评估和调整。根据实际执行情况和反馈，对计划进行调整和改进。 以下是一个制定个人管理计划的示例：
用户故事：作为一个个人，我希望提高工作效率和时间管理，以更好地完成任务和增加工作成果。
计划：
用户故事：作为一个个人，我希望设定明确的目标和优先级，以便更好地管理我的任务。 任务 1：制定长期目标和短期目标，并将其记录在个人笔记本或任务管理工具中。 任务 2：为每个目标设定优先级，以确定最重要的任务和活动。 用户故事：作为一个个人，我希望改善时间管理，以充分利用我的时间。 任务 1：分析我的日常时间分配，并识别时间浪费的区域。 任务 2：制定时间表或日程安排，将任务和活动合理分配到特定时间段。 任务 3：学习和采用时间管理技巧，如番茄工作法（Pomodoro Technique）或时间块（Time Blocking）。 用户故事：作为一个个人，我希望提高专注力和减少干扰，以更好地完成任务。 任务 1：创建一个有利于专注的工作环境，如清理工作区域、关闭手机通知或使用专注应用程序。 任务 2：学习并使用注意力管理技巧，如集中注意力训练（Focused Attention Training）或冥想。 用户故事：作为一个个人，我希望保持健康和提高精力，以更好地应对工作和任务。 任务 1：制定健康的生活习惯，如定期锻炼、健康饮食和充足的睡眠。 任务 2：安排休息和放松的时间，以避免过度劳累和疲劳。 用户故事：作为一个个人，我希望定期评估和调整我的个人管理计划，以适应变化和改进效果。 任务 1：每周或每月回顾我的个人管理计划，并记录我取得的成果和遇到的挑战。 任务 2：根据反馈和经验，调整计划中的任务和策略，以改进效果和适应新的需求。 这只是一个示例个人管理计划，你可以根据自己的需求和目标进行定制和调整。记得将计划中的任务具体化、可衡量，并逐步实施，以确保计划的可行性和有效性。
逐步实施个人管理计划是确保计划可行性和有效性的重要步骤。以下是一些方法来逐步实施你的个人管理计划：
制定优先级：根据计划中的任务和目标，确定它们的优先级顺序。将重要且紧急的任务放在首位，逐步处理其他任务。 制定计划：为每个任务制定具体的计划和行动步骤。将任务分解为更小的可管理的子任务，并为每个子任务设定截止日期或时间范围。 设定目标：为每个任务设定明确的目标和可衡量的指标。这样可以更好地跟踪和评估你的进展。 时间管理：合理安排时间以实施计划。使用时间管理技巧，如时间块，将任务和活动分配到特定的时间段，并设定时间限制以保持专注和高效。 建立习惯：将计划中的任务和行动转化为习惯。重复执行任务并坚持一段时间，以形成良好的习惯。 监控和评估：定期监控和评估你的进展。检查完成的任务，评估是否达到预期的目标和指标。根据反馈和经验，进行调整和改进。 适应变化：灵活应对变化和调整。如果遇到新的需求或情况，根据实际情况重新安排任务和优先级。 持续改进：根据实施的经验和反馈，不断改进个人管理计划。尝试新的方法和策略，寻找提高效率和成果的机会。 逐步实施个人管理计划需要耐心和坚持，一步一个脚印地完成每个任务，并逐渐扩大和提高目标的范围。记得给自己一定的弹性和容错空间，以适应意外情况和挑战。最重要的是保持积极的态度和动力，不断努力实现个人目标和提升自我管理能力。</p></div><footer class=entry-footer><span title='2023-08-21 00:00:00 +0800 CST'>2023-08-21</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;54 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 用户故事如何应用到个人管理" href=https://blog.chensoul.cc/posts/2023/08/21/user-stories-in-self-manager/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>软件开发流程和常用开发方法</h2></header><div class=entry-content><p>软件开发流程和常用开发方法，如敏捷开发和 DevOps，对于架构师来说非常重要。下面我将简要介绍这些概念：
软件开发流程：
软件开发流程是指在开发软件时，按照一定的步骤和阶段进行工作的过程。常见的软件开发流程包括瀑布模型、迭代模型和增量模型等。这些流程以不同的方式组织和管理开发过程，包括需求分析、设计、编码、测试和部署等阶段。
敏捷开发：
敏捷开发是一种迭代和增量的软件开发方法，强调团队协作、快速响应变化和持续交付。敏捷开发强调通过迭代周期（如 Scrum 中的 Sprint）来开发软件，每个迭代都会产生可部署的软件功能。常见的敏捷方法包括 Scrum、XP（极限编程）和 Kanban 等。
DevOps：
DevOps 是一种软件开发和运维的方法论，旨在通过自动化和协作来加速软件交付和提高质量。DevOps 强调开发团队和运维团队之间的协作和共享责任，借助自动化工具和流程来实现持续集成、持续交付和持续部署。
开发流程 软件开发流程通常包括以下阶段：
需求收集：收集和记录软件的功能和非功能性需求。 分析与规划：分析需求并规划开发过程，包括资源分配、时间表和交付物。 设计：基于需求创建软件架构、模块和组件的详细设计。 实现：编写代码并集成设计的组件，进行软件开发。 测试：进行各种测试活动，如单元测试、集成测试和系统测试，确保软件按预期功能。 部署：发布软件并在生产环境中向最终用户提供使用。 维护与支持：在部署后提供持续的维护、错误修复和支持。 在整个过程中，遵循版本控制、文档化和协作等最佳实践是非常重要的，以确保软件开发生命周期的顺利和高效进行。
常见的软件开发流程包括瀑布模型、迭代模型和增量模型等：
瀑布模型（Waterfall Model）： 瀑布模型是一种线性顺序的软件开发流程，按照固定的阶段依次执行，每个阶段的输出作为下一个阶段的输入。典型的阶段包括需求分析、系统设计、编码、测试和维护等。瀑布模型适用于需求稳定且较小规模的项目，但缺乏灵活性和适应变化的能力。
下面是瀑布模型的典型阶段：
需求分析阶段：在这个阶段，与用户和利益相关者一起收集和明确软件系统的需求。定义系统的功能和性能要求，并编写详细的需求规格说明书。 系统设计阶段：在需求分析完成后，进行系统设计。这包括定义系统的整体架构、模块划分、数据结构和算法设计等。设计结果通常以文档形式呈现。 编码阶段：在系统设计完成后，开发团队开始实际的编码工作。根据设计文档，开发人员编写代码并实现系统的各个功能模块。 测试阶段：在编码完成后，进行系统测试。测试人员根据需求和设计规范执行功能测试、集成测试和系统测试，以验证系统的正确性和稳定性。 集成和部署阶段：在测试通过后，将各个模块进行集成，并进行系统级的测试和部署准备。确保整个系统能够协同工作，并准备好部署到目标环境中。 运维和维护阶段：一旦系统部署并投入使用，进入运维和维护阶段。在这个阶段，团队负责监控系统的运行状况，处理问题和错误，并进行必要的修复和更新。 瀑布模型的特点是每个阶段的工作是线性、顺序的，下一个阶段的开始依赖于前一个阶段的完成。这种模型适合需求稳定、项目规模较小、技术风险较低的项目。然而，瀑布模型缺乏灵活性和对变化的适应能力，难以应对需求变更和项目延期等问题。
因此，在面对需求变化频繁、项目复杂度高、风险较大的情况下，敏捷开发方法如 Scrum 和 Kanban 等更为适用，它们强调迭代、增量和持续交付，能更好地满足客户需求并快速响应变化。
迭代模型（Iterative Model）： 迭代模型强调通过多个迭代周期来逐步构建和完善软件。每个迭代周期包括需求分析、设计、编码、测试和部署等阶段，每个迭代都会产生可部署的软件版本。迭代模型适用于需求不完全明确或可能变化的项目，能够更好地适应变化和快速反馈。
以下是迭代模型的一般流程：
阶段规划：确定每个迭代周期的目标、范围和计划。这包括确定要开发的功能、分配资源、制定时间表等。 需求分析：在每个迭代的开始阶段，与用户和利益相关者一起收集和分析需求，并明确每个迭代的功能和优先级。 设计和开发：根据需求分析的结果，进行系统设计和开发工作。在每个迭代中，系统的某个部分会被设计、开发和测试。 测试和验证：在每个迭代周期结束时，进行系统的内部测试和验证。确保开发的功能符合需求，并满足预期的质量标准。 评审和反馈：在每个迭代周期结束后，与用户和利益相关者进行评审和反馈。他们提供对当前功能的评价和建议，以指导下一个迭代的开发工作。 迭代调整：根据用户的反馈和评审结果，对下一个迭代的计划进行调整和优化。可能需要重新定义需求、调整功能优先级、增加新的需求等。 重复迭代：通过不断重复上述步骤，每个迭代周期都会逐步增加系统的功能、完善系统的性能，并在每个迭代中交付一个可用的软件增量。 迭代模型的优势在于能够快速响应变化和不断提供增值。它允许在开发过程中灵活调整需求，并通过每个迭代的反馈和评审来改进产品。然而，迭代模型也需要适当的计划和管理，以确保每个迭代都能按时交付，并控制开发过程中的风险。
敏捷方法如 Scrum 和 Kanban 是迭代模型的典型实践，它们更加强调团队的协作、自组织和持续交付，适用于需求变化频繁和项目复杂度较高的环境
增量模型（Incremental Model）： 增量模型将软件按模块或功能进行划分，每个模块或功能被称为一个增量，通过逐步添加增量来逐渐构建完整的软件系统。每个增量都经历需求分析、设计、开发和测试等阶段。增量模型适用于大规模项目和需要分阶段交付的情况，可以提供更早的价值交付和更好的风险管理。
以下是增量模型的一般流程：
阶段划分：将整个软件系统划分为多个增量，每个增量都代表一个可用的软件部分。划分的方式可以基于功能、模块、业务流程等来定义。 需求分析：在每个增量开始时，与用户和利益相关者一起收集和明确关于该增量的需求和功能。确定每个增量的优先级和范围。 设计和开发：根据需求分析的结果，进行系统设计和开发工作。每个增量的设计和开发都是独立进行的，可以采用适合的开发方法和技术。 测试和验证：在每个增量完成开发后，进行系统的测试和验证。确保该增量的功能符合需求，并满足预期的质量标准。 增量交付：经过测试和验证后，将该增量交付给用户或利益相关者。用户可以开始使用该增量，并提供反馈和建议以进一步改进和优化。 增量整合：在完成一个增量的交付后，将该增量与之前交付的增量进行整合。确保不同增量之间的功能和模块可以协同工作，并形成一个完整的软件系统。 通过不断重复上述步骤，每个增量都逐步增加系统的功能和完善系统的性能。增量模型允许在开发过程中快速交付可用的软件部分，并根据用户的反馈和需求变化进行调整。它可以提高软件开发的可见性和用户满意度，降低项目风险。
与迭代模型相比，增量模型更加强调不同增量之间的独立性和可用性。每个增量都是一个可用的软件部分，用户可以在开发过程中逐步使用和评估系统功能。然而，增量模型可能需要更好的规划和管理，以确保增量之间的集成和整合顺利进行，并避免系统架构上的问题。
敏捷开发 敏捷开发（Agile Development）是一种以迭代、增量和协作为核心的软件开发方法。它强调团队合作、快速响应变化和持续交付，以提高客户满意度和项目成功率。以下是敏捷开发的核心原则和常用实践：
核心原则：
个体和互动胜过流程和工具（Individuals and interactions over processes and tools）：强调团队成员之间的沟通、合作和相互支持，重视人与人之间的交流。 可工作的软件胜过详尽的文档（Working software over comprehensive documentation）：注重以可工作的软件作为验证和沟通的手段，而不是过多依赖繁杂的文档。 客户合作胜过合同谈判（Customer collaboration over contract negotiation）：鼓励与客户密切合作，及时获取反馈并根据需求变化进行调整。 响应变化胜过遵循计划（Responding to change over following a plan）：灵活应对需求变化，通过迭代和增量的方式快速适应变化的环境。 常用实践：...</p></div><footer class=entry-footer><span title='2023-08-21 00:00:00 +0800 CST'>2023-08-21</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;254 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 软件开发流程和常用开发方法" href=https://blog.chensoul.cc/posts/2023/08/21/the-software-development-process/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>数据库如何设计树形结构</h2></header><div class=entry-content><p>在 MySQL 中，设计树形结构的区域表有多种方式。以下是一些常见的方案：
父子关系（Parent-Child Relationship）模型：在这种模型中，每个行记录包含一个指向其父级的引用。可以使用一个额外的列来存储父级 ID，或者使用自连接表来表示关系。这种模型简单直观，易于理解和管理。 路径（Path）模型：在这种模型中，每个行记录都包含一个代表其完整路径的字段。路径可以是以某种分隔符（如斜杠）分隔的字符串，例如：/地区/国家/城市。通过解析和处理路径字段，可以轻松地查询父级、子级和兄弟节点。 嵌套集模型（Nested Set Model）：这是一种基于左右值的模型，通过预先计算每个节点的左右值，可以高效地查询树形结构。每个节点都有一个左值和一个右值，用于表示其在树中的位置。这种模型适用于大型树结构，但需要特殊的操作来维护左右值。 物化路径（Materialized Path）模型：这是路径模型的一种改进版本，它使用额外的列来存储节点的层级关系。除了路径字段外，还可以添加一个表示节点级别的字段。这样可以更高效地进行查询，并且可以轻松地获取节点的父级、子级和兄弟节点。 父子关系（Parent-Child Relationship）模型 父子关系（Parent-Child Relationship）模型是一种在 MySQL 中设计树形结构的方式。在该模型中，每个区域记录包含一个指向其父级区域的引用。通过这种父子关系，可以建立区域之间的层级结构。
以区域为例，我们可以创建一个名为"area"的表来存储区域信息。该表可以包含以下列：
id：区域的唯一标识符（主键） name：区域的名称 parent_id：指向父级区域的引用 通过使用父子关系模型，我们可以创建以下区域的层级结构：
id | name | parent_id --------------------------- 1 | 世界 | NULL 2 | 亚洲 | 1 3 | 欧洲 | 1 4 | 北美洲 | 1 5 | 中国 | 2 6 | 日本 | 2 7 | 德国 | 3 8 | 法国 | 3 9 | 美国 | 4 10 | 加拿大 | 4 11 | 北京市 | 5 12 | 上海市 | 5 13 | 东京都 | 6 14 | 横滨市 | 6 在上述示例中，“area"表的每一行代表一个区域，通过"parent_id"列建立父子关系。根区域（世界）的"parent_id"为 NULL，表示没有父级区域。其他区域通过指定父级区域的"id"来建立层级关系。...</p></div><footer class=entry-footer><span title='2023-08-15 00:00:00 +0800 CST'>2023-08-15</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1003 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 数据库如何设计树形结构" href=https://blog.chensoul.cc/posts/2023/08/15/tree-structure-in-database/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/categories/architecture/page/2/>«&nbsp;Prev&nbsp;2/4
</a><a class=next href=https://blog.chensoul.cc/categories/architecture/page/4/>Next&nbsp;4/4&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>