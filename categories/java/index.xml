<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on ChenSoul</title><link>https://blog.chensoul.cc/categories/java/</link><description>Recent content in Java on ChenSoul</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 14 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.chensoul.cc/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>2024-11-14-Quarkus 快速入门</title><link>https://blog.chensoul.cc/posts/2024/11/14/quarkus-quick-start/</link><pubDate>Thu, 14 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/11/14/quarkus-quick-start/</guid><description>&lt;h2 id="使用--quarkus-cli-创建项目">使用 Quarkus CLI 创建项目&lt;/h2>
&lt;ol>
&lt;li>使用 sdk 安装&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sdk install quarkus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>创建应用&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>quarkus create &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cd code-with-quarkus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>出现异常：&lt;/p></description></item><item><title>[译]从JUnit4迁移到JUnit5：权威指南</title><link>https://blog.chensoul.cc/posts/2024/11/07/junit-5-migration/</link><pubDate>Thu, 07 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/11/07/junit-5-migration/</guid><description>&lt;p>在本文中，我们将了解从 JUnit 4 迁移到 JUnit 5 所需的步骤。我们将了解如何运行新版本的现有测试，以及迁移代码需要进行哪些更改。&lt;/p>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>JUnit 5 与之前的版本不同，采用模块化设计。新架构的关键点在于将编写测试、扩展和工具之间的关注点分开。&lt;/p></description></item><item><title>Tutorials</title><link>https://blog.chensoul.cc/tutorials/</link><pubDate>Mon, 04 Nov 2024 21:00:00 +0800</pubDate><guid>https://blog.chensoul.cc/tutorials/</guid><description>&lt;h2 id="java">Java&lt;/h2>
&lt;h2 id="kubernetes">Kubernetes&lt;/h2>
&lt;h2 id="microservices">Microservices&lt;/h2>
&lt;h2 id="spring-boot">Spring Boot&lt;/h2>
&lt;h2 id="spring-cloud">Spring Cloud&lt;/h2>
&lt;h2 id="spring-security-oauth-20">Spring Security OAuth 2.0&lt;/h2></description></item><item><title>ActiveMQ源码-BrokerService和PersistenceAdapter</title><link>https://blog.chensoul.cc/posts/2024/08/27/activemq-source-code-broker-service/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/27/activemq-source-code-broker-service/</guid><description>&lt;p>activemq-broker 模块 test/java 目录下有个 IDERunner 类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">IDERunner&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> TRANSPORT_TRACE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span>args) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BrokerService brokerService &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BrokerService();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// brokerService.addConnector(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;#34;tcp://0.0.0.0:61616?trace=&amp;#34; + TRANSPORT_TRACE +&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;#34;&amp;amp;transport.wireFormat.maxFrameSize=104857600&amp;#34;);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">setPersistent&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">setUseJmx&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">setAdvisorySupport&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">waitUntilStopped&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注释掉 brokerService 调用 addConnector 方法的三行代码，然后 debug 运行该类的 main 方法。&lt;/p></description></item><item><title>ThingsBoard源码编译和Idea运行</title><link>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</guid><description>&lt;p>ThingsBoard 源码地址：&lt;a href="https://github.com/thingsboard/thingsboard" target="_blank">https://github.com/thingsboard/thingsboard&lt;/a>，从 &lt;a href="https://github.com/thingsboard/thingsboard/releases/tag/v3.7" target="_blank">3.7&lt;/a> 版本之后，要求 JDK17。官方提供了源码编译的文档：&lt;a href="https://thingsboard.io/docs/user-guide/install/building-from-source/" target="_blank">Building from sources&lt;/a>&lt;/p>
&lt;h2 id="源码编译">源码编译&lt;/h2>
&lt;p>下载代码：&lt;/p></description></item><item><title>ActiveMQ源码本地调试运行</title><link>https://blog.chensoul.cc/posts/2024/08/09/debug-activemq-source-code/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/09/debug-activemq-source-code/</guid><description>&lt;h2 id="源码构建">源码构建&lt;/h2>
&lt;p>1、从 &lt;a href="https://github.com/apache/activemq" target="_blank">https://github.com/apache/activemq&lt;/a> 下载源码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/apache/activemq
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2、切换至 activemq-5.18.x 分支&lt;/p></description></item><item><title>Github Action 发布 Jar 到 Maven 中央仓库</title><link>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</link><pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</guid><description>&lt;p>作为一名 Java 开发者,将自己的项目发布到 Maven 中央仓库是一个非常重要的步骤。这不仅可以让更多的开发者发现和使用您的项目,也可以提高项目的知名度和影响力。&lt;/p>
&lt;p>在过去,发布 Jar 到 Maven 中央仓库通常需要手动完成一系列繁琐的步骤，比如：申请 JIRA 账号、创建 Sonatype JIRA Issure、上传 Jar 包、签名 Jar 包等。但是随着 Github Action 的出现，这个过程变得更加自动化和简单。&lt;/p></description></item><item><title>[译]JMS 2.0 中的新增功能</title><link>https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/</guid><description>&lt;p>原文链接：&lt;a href="https://hasithah.medium.com/what-is-new-in-jms-2-0-821266fc1bf0" target="_blank">What is new in JMS 2.0&lt;/a>&lt;/p>
&lt;p>在在软件集成领域，从一个软件组件到另一个软件组件进行通信是一项基本要求。虽然已经出现了许多具有这种能力的技术，但 Java 编程语言为我们提供了一个 API，以促进用 Java 编写的组件之间的消息传递。此 API 的实现将由不同的供应商（JMS 提供商）通过代理软件提供。&lt;/p></description></item><item><title>[译]JMS 2.0 中的新增功能（第一部分）- 易于使用</title><link>https://blog.chensoul.cc/posts/2024/07/24/jms20/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/jms20/</guid><description>&lt;p>原文链接：&lt;a href="https://www.oracle.com/technical-resources/articles/java/jms20.html" target="_blank">https://www.oracle.com/technical-resources/articles/java/jms20.html&lt;/a>&lt;/p>
&lt;p>&lt;em>作者：Nigel Deakin&lt;/em>
出版日期：2013 年 5 月&lt;/p>
&lt;p>&lt;strong>了解新的易用性功能如何使您编写更少的代码行。&lt;/strong>&lt;/p>
&lt;p>本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在&lt;a href="https://www.oracle.com/technical-resources/articles/java/jms2messaging.html" target="_blank">第二部分&lt;/a>中，我们将介绍新的消息传递特性。&lt;/p></description></item><item><title>[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能</title><link>https://blog.chensoul.cc/posts/2024/07/24/jms20/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/jms20/</guid><description>&lt;p>原文链接：&lt;a href="https://www.oracle.com/technical-resources/articles/java/jms2messaging.html" target="_blank">https://www.oracle.com/technical-resources/articles/java/jms2messaging.html&lt;/a>&lt;/p>
&lt;p>&lt;em>作者：Nigel Deakin&lt;/em>
出版日期：2013 年 5 月&lt;/p>
&lt;p>&lt;strong>了解如何利用 JMS 2.0 中的新消息传递功能。&lt;/strong>&lt;/p></description></item><item><title>[译]JMS 2.0 的十个好处意味着可以减少代码编写量</title><link>https://blog.chensoul.cc/posts/2024/07/24/jms20-means-less-code/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/jms20-means-less-code/</guid><description>&lt;p>原文链接：&lt;a href="https://javaee.github.io/jms-spec/pages/JMS20MeansLessCode" target="_blank">Ten ways in which JMS 2.0 means writing less code&lt;/a>&lt;/p></description></item><item><title>[译]JMS 事务的实际应用</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-transactions-in-action/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-transactions-in-action/</guid><description>&lt;p>在本文中，您将了解如何选择性地使用 JMS 事务。在 JMS 中，您可以选择控制一个会话的原子操作。每个会话都支持一系列事务。每个事务将一组生成或使用的消息分组为一个原子工作单元。确保您已经理解了&lt;a href="https://jstobigdata.com/jms/guaranteed-delivery-using-jms-message-acknowledgement/" target="_blank">JMS 中的消息确认&lt;/a>。&lt;/p>
&lt;p>&lt;strong>交易提交时 –&lt;/strong> ( &lt;code>jmsContext.commit()&lt;/code>)&lt;/p></description></item><item><title>[译]JMS 发布-订阅消息模型</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-pub-sub-messaging-model/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-pub-sub-messaging-model/</guid><description>&lt;p>在本文中，您将了解 JMS 发布-订阅 (publish-subscribe) 消息传递模型。正如您在&lt;a href="https://jstobigdata.com/jms/jms-introduction-java-message-service/" target="_blank">JMS 简介文章&lt;/a>中所读到的，在发布/订阅模型中，客户端通过称为主题的中介将消息发送给多个接收者。发送者通常称为发布者，接收者称为订阅者。&lt;/p>
&lt;h2 id="jms-发布订阅消息传递示例">JMS 发布/订阅消息传递示例&lt;/h2>
&lt;p>下面是一个简单的代码示例，演示了发布/订阅消息模型的工作原理。我创建了 2 个主线程，&lt;code>publisher&lt;/code>和&lt;code>subscriber1&lt;/code>。将订阅者 1 克隆到&lt;code>subscriber2&lt;/code>。所以基本上我有一个消息发布者和 2 个消息订阅者。链接至&lt;a href="https://github.com/jstobigdata/jms-parent-app/blob/master/jms-glassfish5/src/main/java/lab03/message/pubsub/SimplePubSubExample.java" target="_blank">GitHub&lt;/a> 。&lt;/p></description></item><item><title>[译]JMS 消息优先级</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/</guid><description>&lt;p>我们将通过示例详细讨论 JMS 消息优先级。每条消息的标头字段代表其优先级。我在消息模型教程&lt;code>JMSPriority&lt;/code>中讨论过消息优先级。&lt;/p>
&lt;p>JMS 有 10 个优先级，从 0 到 9。0 是最低优先级，9 是最高优先级。根据 JMS 标准，优先级为 0-4 的消息为正常优先级，优先级为 5-9 的消息被视为加急优先级。&lt;/p></description></item><item><title>[译]JMS 消息模型</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/</guid><description>&lt;p>消息是 JMS 的核心，无论是事件还是业务数据。消息由标头、自定义属性和正文组成。这是您将在 JMS 消息模型（JMS 消息剖析）中学习的内容。&lt;/p>
&lt;p>&lt;img src="https://blog.chensoul.cc/images/JMS-message-model-min-1024x536.webp" alt="JMS 消息模型">&lt;/p></description></item><item><title>[译]JMS 消息选择器在过滤消息中的应用</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-message-selectors-in-action-to-filter-messages/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-message-selectors-in-action-to-filter-messages/</guid><description>&lt;p>发送给接收方的消息通常需要根据某些标准进行过滤。JMS 提供消息选择器，允许 JMS 消费者根据消息头指定其感兴趣的消息。在本文中，您将学习使用 JMS 消息选择器来过滤消息。&lt;/p>
&lt;p>这是一篇高级教程，在继续阅读本文之前，请确保您对 JMS 有基本的了解。如果您是 JMS 新手，请查看&lt;a href="https://jstobigdata.com/jms/jms-point-to-point-messaging-in-action/" target="_blank">JMS 点对点消息传递模型文章。&lt;/a>&lt;/p></description></item><item><title>[译]JMS 点对点消息传递的实际应用</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/</guid><description>&lt;p>点对点系统使用队列进行消息传递。客户端将消息发送到特定队列，特定订阅者监听或接收来自该队列的消息。在 JMS 点对点消息传递系统中，队列用于处理单个发送者和单个消费者。确保您已经阅读了有关&lt;a href="https://jstobigdata.com/jms/jms-message-model/" target="_blank">JMS 消息模型&lt;/a>以及&lt;a href="https://jstobigdata.com/jms/send-and-receive-message-in-jms/" target="_blank">如何在 JMS 中发送和接收消息的&lt;/a>先前教程。&lt;/p>
&lt;h2 id="使用队列进行-ptp-消息传送">使用队列进行 PTP 消息传送&lt;/h2>
&lt;p>您现在知道点对点消息传递完全是利用队列。JMS 提供&lt;code>javax.jms.Queue&lt;/code>表示队列对象的功能。我将利用 JMS 2.0 API 来&lt;code>javax.jms.JMSProducer&lt;/code>发送&lt;code>javax.jms.JMSConsumer&lt;/code>和接收消息。&lt;/p></description></item><item><title>[译]JMS介绍 – Java消息服务</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/</guid><description>&lt;p>JMS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。这是一个 JMS 介绍教程，为您提供消息传递和 JMS 的简要概述。您将了解使用 JMS 的优势以及 JMS 中的不同消息传递模型。&lt;/p></description></item><item><title>[译]为 JMS 安装和设置 Glassfish</title><link>https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/</guid><description>&lt;p>在本文中，我们将为 JMS 2.0 设置 Glassfish，创建一个 Java 项目并添加必要的依赖项。&lt;/p>
&lt;h2 id="先决条件">先决条件&lt;/h2>
&lt;p>请确保您的系统上安装了以下工具。&lt;/p></description></item><item><title>[译]使用 JMS 消息确认保证传送</title><link>https://blog.chensoul.cc/posts/2024/07/23/guaranteed-delivery-using-jms-message-acknowledgement/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/guaranteed-delivery-using-jms-message-acknowledgement/</guid><description>&lt;p>JMS 通过 JMS 消息确认（确认模式）确保消息传递的可靠性。如果会话已进行事务处理，则该&lt;code>commit()&lt;/code>方法会自动处理消息确认。否则，该方法将处理恢复&lt;code>rollback()&lt;/code>。在本文中，我们将假设会话未进行事务处理。这是一个高级主题，请确保您对 JMS 有基本的了解。如果您是 JMS 新手，可以参考使用 JMS&lt;a href="https://jstobigdata.com/jms/send-and-receive-message-in-jms/" target="_blank">发送和接收消息。&lt;/a>&lt;/p></description></item><item><title>[译]在 JMS 中发送和接收消息</title><link>https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/</guid><description>&lt;p>您将了解 JMS 架构，学习如何在 JMS 中发送和接收消息。我将介绍管理对象、JMS 1.1 API 和 JMS 2.0 API。我们还将看到与 JMS 1.1 API 相比，JMS 2.0 API 的使用有多么简单。在继续学习本课程之前，请确保您已完成 JMS 设置。如果您是初学者，请确保您已了解&lt;a href="https://jstobigdata.com/jms/jms-introduction-java-message-service/" target="_blank">JMS 的基础知识&lt;/a>。&lt;/p></description></item><item><title>[译]完整的 JMS 2.0 教程</title><link>https://blog.chensoul.cc/posts/2024/07/23/a-complete-jms-2-0-tutorial/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/a-complete-jms-2-0-tutorial/</guid><description>&lt;p>JMS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。消息传递是在各种应用程序或服务之间交换业务数据的过程。这是&lt;strong>一个完整的 JMS 2.0 教程，&lt;/strong> 其中包含大量代码示例。完整的代码示例可在 GitHub 上找到，请下载并运行示例。本教程使用 Glassfish 开源服务器作为 JMS 提供程序的示例。&lt;/p></description></item><item><title>将 Maven 站点发布到 GitHub Pages</title><link>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</guid><description>&lt;p>本文源代码：&lt;a href="https://github.com/chensoul/maven-site-github-example/" target="_blank">https://github.com/chensoul/maven-site-github-example/&lt;/a> 。&lt;/p>
&lt;h2 id="创建-java-maven-项目">创建 Java Maven 项目&lt;/h2>
&lt;p>让我们使用 Maven 创建一个简单的 Java 项目&lt;/p></description></item><item><title>All things about OAuth</title><link>https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/</guid><description>&lt;p>OAuth 是一种&lt;strong>开放协议&lt;/strong>，允许通过网络、移动和桌面应用程序以&lt;strong>简单&lt;/strong>、&lt;strong>标准的方式进行&lt;/strong>安全授权。&lt;/p>
&lt;h2 id="oauth-2-入门">OAuth 2 入门&lt;/h2>
&lt;p>以下是一些 OAuth 2.0 指南，涵盖了理解和实现客户端和服务器所需的许多主题。&lt;/p></description></item><item><title>JWT</title><link>https://blog.chensoul.cc/posts/2024/06/06/jwt/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/06/jwt/</guid><description>&lt;h2 id="什么是-jwt">什么是 JWT？&lt;/h2>
&lt;p>JWT（JSON Web Token）是一种开放标准(RFC 7519)，用于在网络应用程序之间安全地传输信息。它被设计用于在两方之间传输声明，这些声明可以是身份验证和授权信息，也可以是任何其他类型的信息。&lt;/p>
&lt;p>设计目的：不需要服务器端存储状态，安全地传递非敏感信息。&lt;/p>
&lt;h2 id="jwt-特点">JWT 特点&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>可扩展性&lt;/strong>：可以在 payload 中携带任意的 JSON 数据&lt;/li>
&lt;li>&lt;strong>自包含性&lt;/strong>：所有用户相关信息都在 JWT 中，不需要依赖数据库&lt;/li>
&lt;li>&lt;strong>无状态性&lt;/strong>：服务器不需要保存会话状态，提高了系统的可扩展性&lt;/li>
&lt;li>&lt;strong>跨域支持&lt;/strong>：可以跨域传递，因为是 JSON 格式&lt;/li>
&lt;li>&lt;strong>安全性&lt;/strong>：通过签名确保数据不被篡改&lt;/li>
&lt;/ul>
&lt;h2 id="jwt-组成">JWT 组成&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>eyJraWQiOiJmYTNkZmZjMS0xZmQ3LTRhM2QtYTEyMC1mNjY4OWE4NDM5YjQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJjbGllbnQiLCJhdWQiOiJjbGllbnQiLCJuYmYiOjE3MTc1NDk5NDMsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MCIsImV4cCI6MTcxNzU1MDI0MywiaWF0IjoxNzE3NTQ5OTQzLCJqdGkiOiJiMjU0ZGVhMi1kMWE2LTQxNzEtYjEyYy1lNmYzYzZjMDJkMGQifQ.eRiS0H2E-h5PiDEfJikjoPGH1DCqWVt4VIzLtPoSOaIK6jBIaw0h5m-reZVUyZPNYZG68Ymhey17aZBMveirqCxN-lNcPMIGfuqMptfsD9E6Hfam6bEMgpEAOQsQ6Ruk3vGtdmjnEC2h9ZStoqT5-C6JgArwFLGgX92LXrRYz7-60n0I6EAB07u9kxc6FQKLow90RiyXi2YLur-ttOUQpecf8zHi48zRc-HLLoWAMaNddT-4hg4v0Qts4DultpxZB_Xu7DRc91G_8M6sYFSvFSVFHlcWFgKNLZqUYwepLHX2LxoXdbTLGqV9x__-J8UO0TO3TkpC2BaZAiseYcpYMw
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JWT 主要有以下三个部分通过 base64 加密组成:&lt;/p></description></item><item><title>OAuth2和OIDC区别</title><link>https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/</guid><description>&lt;h2 id="认证和授权">认证和授权&lt;/h2>
&lt;p>&lt;strong>认证 (Authentication)&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>认证是验证用户、设备或系统身份的过程。&lt;/li>
&lt;li>常见的认证方式包括用户名/密码、生物特征(如指纹、人脸)、单点登录(SSO)等。&lt;/li>
&lt;li>认证确保只有被授权的实体才能访问系统或资源。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>授权 (Authorization)&lt;/strong>：&lt;/p></description></item><item><title>[译]OAuth2.0服务器</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-server/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-server/</guid><description>&lt;h1 id="背景">背景&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>&lt;em>作者：&lt;a href="https://aaronparecki.com/" target="_blank">Aaron Parecki&lt;/a>&lt;/em>&lt;/p>
&lt;p>我第一次接触 OAuth 是在 2010 年，当时我正在构建一个 API，我知道我希望第三方开发人员能够在其基础上构建应用程序。当时，OAuth 看起来令人生畏。OAuth 1 的实现只有少数几个，而 OAuth 2.0 仍是一个草稿。一天晚上，我决定坐下来，拿着精酿啤酒和最新草案的纸质副本，从头到尾阅读它，直到我理解它。&lt;/p></description></item><item><title>[译]OAuth2简化版</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth-2-simplified/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth-2-simplified/</guid><description>&lt;p>这篇文章以简化的格式描述了 OAuth 2.0，以帮助开发人员和服务提供商实现该协议。&lt;/p>
&lt;p>&lt;a href="https://oauth.net/2/" target="_blank">OAuth 2 规范&lt;/a>读起来可能有点混乱，所以我写了这篇文章来帮助以简化的格式描述术语。核心规范将许多决策留给实现者，通常基于实现的安全权衡。这篇文章没有描述成功实施 OAuth 2 所需的所有可能决策，而是做出适用于大多数实现的决策。&lt;/p></description></item><item><title>RFC6749 | OAuth2.0授权框架中文版</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;h3 id="摘要">摘要&lt;/h3>
&lt;p>OAuth2.0 授权框架允许第三方应用获取对 HTTP 服务的有限的访问权限，既可以以资源所有者名义在资源所有者和 HTTP 服务之间进行允许的交互，也可以允许第三方应用以自己的名义进行访问。本规范取代并淘汰 RFC 5849 中描述的 OAuth 1.0 协议。&lt;/p></description></item><item><title>All things about WebSocket</title><link>https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/</link><pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/</guid><description>&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank">Wikipedia：WebSocket&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank">WebSocket - Web APIs | MDN&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.pubnub.com/guides/websockets/" target="_blank">PubNub：什么是 WebSocket？&lt;/a>&lt;/p></description></item><item><title>All things about Spring Modulith</title><link>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</link><pubDate>Thu, 09 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</guid><description>&lt;p>VMware 推出了一个实验性的项目&lt;a href="https://spring.io/projects/spring-modulith" target="_blank">Spring Modulith&lt;/a>，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。&lt;/p></description></item><item><title>[译]探索 http2（第 1 部分）：概述</title><link>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/</guid><description>&lt;p>原文链接：&lt;a href="https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f" target="_blank">https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>让我们来谈谈&lt;/em> &lt;strong>http2 的内容、原因、时间和方式&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>完整的代码可以在&lt;a href="https://github.com/noobg1/http1_vs_http2" target="_blank">github&lt;/a>上找到。&lt;/p>
&lt;p>&lt;strong>第 1 部分：概述&lt;/strong>
第 2 部分：&lt;a href="https://medium.com/@noobj/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249" target="_blank">使用 node-http2 核心和 hapijs 进行探索&lt;/a>&lt;/p></description></item><item><title>[译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</title><link>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/</guid><description>&lt;p>原文链接：&lt;a href="https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249" target="_blank">https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://blog.chensoul.cc/images/exploring-http2-part-2-overview-01.webp" alt="img">&lt;/p>
&lt;p>来源：&lt;a href="https://www.thewebmaster.com/hosting/2015/dec/14/what-is-http2-and-how-does-it-compare-to-http1-1/" target="_blank">https://www.thewebmaster.com/&lt;/a>&lt;/p>
&lt;p>&lt;strong>先决条件&lt;/strong>：了解 javascript、客户端-服务器架构。&lt;/p>
&lt;p>完整的代码可以在&lt;a href="https://github.com/noobg1/http1_vs_http2" target="_blank">github&lt;/a>上找到。&lt;/p>
&lt;p>第 1 部分：&lt;a href="https://medium.com/@noobj/exploring-http2-part-1-overview-dc3e9b53968f" target="_blank">概述（&lt;em>http2 的原因、内容、时间、方式&lt;/em>）&lt;/a>&lt;strong>第 2 部分：使用 node-http2 核心和 hapijs 进行探索&lt;/strong>&lt;/p></description></item><item><title>[译]比较 Socket.IO 和 HTTP：主要区别和用例</title><link>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/socketio-vs-http" target="_blank">https://ably.com/topic/socketio-vs-http&lt;/a>&lt;/p>
&lt;p>在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对&lt;a href="https://ably.com/topic/socketio" target="_blank">Socket.IO&lt;/a>实时库和&lt;a href="https://ably.com/topic/websockets-vs-http#http" target="_blank">HTTP&lt;/a>协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。&lt;/p>
&lt;h2 id="什么是socketio">什么是Socket.IO？&lt;/h2>
&lt;p>Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。&lt;/p></description></item><item><title>[译]2024年最好的WebSocket替代品</title><link>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websocket-alternatives" target="_blank">https://ably.com/topic/websocket-alternatives&lt;/a>&lt;/p>
&lt;h2 id="什么是-websocket">什么是 WebSocket？&lt;/h2>
&lt;p>简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。&lt;/p></description></item><item><title>[译]Apache Kafka、RabbitMQ 与 AWS SNSSQS：哪个消息代理最好？</title><link>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs" target="_blank">https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs&lt;/a>&lt;/p>
&lt;p>将消息从一个组件获取到另一个组件是微服务架构中最重要的部分之一。每个服务必须能够与任何其他服务异步、可靠且大规模地通信。&lt;/p>
&lt;p>这就是消息代理的用武之地。消息代理（例如 Apache Kafka、RabbitMQ 和&lt;a href="https://ably.com/topic/aws-sns-vs-sqs" target="_blank">AWS SNS/SQS&lt;/a>）为您提供一个通用接口和一组保证，而不是手动协调可能数千个微服务之间的通信。这简化了集成并更容易推理您的系统。&lt;/p>
&lt;p>然而，比较消息代理可能很棘手，因为每个消息代理都采用不同的方法来完成工作。那么，您如何决定哪个消息代理最适合您的用例？&lt;/p></description></item><item><title>[译]HTTP 的演变 – HTTP2 深入探讨</title><link>https://blog.chensoul.cc/posts/2024/05/07/http2/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http2/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/http2" target="_blank">https://ably.com/topic/http2&lt;/a>&lt;/p>
&lt;p>可以毫不夸张地说，超文本传输协议 (HTTP) 造就了我们所熟知的互联网。 HTTP 最初是由万维网的发明者蒂姆·伯纳斯·李 (Tim Berners-Lee) 于 1989 年提出的应用程序协议。第一个记录版本 HTTP/0.9 被称为单行协议。鉴于它催生了万维网，它现在可以被描述为有史以来最伟大的俏皮话。&lt;/p></description></item><item><title>[译]Java和WebSockets：构建可靠的实时应用程序</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</guid><description>&lt;p>原文：&lt;a href="https://ably.com/topic/websockets-java" target="_blank">https://ably.com/topic/websockets-java&lt;/a>&lt;/p>
&lt;p>在全球范围内，人们对实时传输数据的需求不断增长，&lt;a href="https://ably.com/topic/websockets" target="_blank">WebSocket&lt;/a>可能是此类用例中最流行的传输协议。在 WebSocket 出现之前，“实时”网络已经存在，但它很难实现，通常速度较慢，并且是通过破解现有的网络技术来实现的，而这些技术并不是为实时应用程序设计的。 WebSocket 协议为真正的实时网络铺平了道路。&lt;/p>
&lt;p>Java是一种流行的编程语言和计算语言。它是 Android 智能手机应用程序的核心编程语言之一，是构建实时系统的可靠选择。 WebSockets 成为 Java 标准版 SDK 的一部分已经有一段时间了。WebSocket 协议最初是在 2013 年作为&lt;a href="https://www.oracle.com/technical-resources/articles/java/jsr356.html" target="_blank">JSR 356&lt;/a>的一部分提出的，目前已作为&lt;a href="https://docs.oracle.com/javaee/7/api/index.html?javax/websocket/package-summary.html" target="_blank">javax.websocket&lt;/a>包的一部分包含在 Java SDK 中。&lt;/p></description></item><item><title>[译]WebSocket API和协议说明</title><link>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</guid><description>&lt;p>原文地址：&lt;a href="https://ably.com/topic/websockets" target="_blank">https://ably.com/topic/websockets&lt;/a>&lt;/p>
&lt;p>WebSocket 标志着 Web 开发的转折点。 WebSocket 技术旨在以事件为驱动，并针对低延迟进行了优化，已成为许多寻求构建交互式实时数字体验以提供令人愉悦的用户体验的组织和开发人员的首选。本文探讨了与 WebSocket 相关的关键主题：&lt;/p></description></item><item><title>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websockets-vs-http" target="_blank">https://ably.com/topic/websockets-vs-http&lt;/a>&lt;/p>
&lt;p>当谈到 WebSocket 与 HTTP 时，决定使用哪一种并不总是那么明确。哪一个更好？您的应用程序应该使用哪一款？&lt;/p>
&lt;p>但问题的答案不一定是其中之一 - 开发人员经常根据场景在同一个应用程序中同时使用 WebSocket 和 HTTP。更重要的问题是 - 我如何确定 WebSockets 还是 HTTP 是特定类型通信的正确通信协议？&lt;/p></description></item><item><title>[译]WebSocket与REST</title><link>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websocket-vs-rest" target="_blank">https://ably.com/topic/websocket-vs-rest&lt;/a>&lt;/p>
&lt;p>无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。&lt;/p>
&lt;p>好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。&lt;/p></description></item><item><title>[译]什么是 HTTP？</title><link>https://blog.chensoul.cc/posts/2024/05/07/http/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/http/" target="_blank">https://www.pubnub.com/guides/http/&lt;/a>&lt;/p>
&lt;h2 id="http-概述">HTTP 概述&lt;/h2>
&lt;p>HTTP，即超文本传输协议，是互联网通信的基础。它在客户端-服务器模型上运行，其中前端客户端（例如网络浏览器）通过向服务器发送HTTP请求消息来发起请求，例如请求网页（例如搜索引擎）。然后，服务器使用包含所请求资源的 HTTP 响应消息进行响应，如果资源不可用，则使用错误消息进行响应。&lt;/p>
&lt;p>HTTP 是一种无状态协议，这意味着每个请求都是独立的，与之前或将来的请求无关。这允许客户端和服务器之间进行有效的通信。&lt;/p></description></item><item><title>[译]什么是 OAuth？</title><link>https://blog.chensoul.cc/posts/2024/05/07/oauth/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/oauth/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/oauth/" target="_blank">https://www.pubnub.com/guides/oauth/&lt;/a>&lt;/p>
&lt;h2 id="什么是-oauth">什么是 OAuth？&lt;/h2>
&lt;p>&lt;a href="https://oauth.net/" target="_blank">OAuth（开放授权）&lt;/a>是一种开放标准授权框架，允许第三方应用程序访问用户数据，而无需用户共享其登录凭据。它为用户提供了一种安全且标准化的方式，将其在一个网站上的资源的访问权限授予另一个网站或应用程序，而无需暴露其密码。&lt;/p>
&lt;p>简单来说，OAuth 充当最终用户和他们想要授予访问权限的应用程序之间的中间人。用户不会直接向 Web 应用程序提供用户名和密码，而是会被重定向到授权服务器（例如 Google、Facebook 或 Twitter），在那里他们可以安全地验证自己的身份。经过身份验证后，用户可以授予或拒绝对其想要使用的应用程序上的数据的访问权限。&lt;/p></description></item><item><title>[译]什么是HTTP/3？</title><link>https://blog.chensoul.cc/posts/2024/05/07/http3/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http3/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/http-3/" target="_blank">https://www.pubnub.com/guides/http-3/&lt;/a>&lt;/p>
&lt;h2 id="什么是-http3">什么是 HTTP/3？&lt;/h2>
&lt;p>HTTP/3（或 HTTP-over-QUIC）是超文本传输协议 ( &lt;a href="https://www.pubnub.com/guides/http/" target="_blank">HTTP&lt;/a> ) 的第三个主要版本。它是用于 Web 浏览器和服务器之间通信的应用层协议。 HTTP/3 旨在提高 Web 通信的性能和安全性。&lt;/p></description></item><item><title>[译]什么是HTTP流式传输？</title><link>https://blog.chensoul.cc/posts/2024/05/07/http-streaming/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http-streaming/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/http-streaming/" target="_blank">https://www.pubnub.com/guides/http-streaming/&lt;/a>&lt;/p>
&lt;h2 id="什么是-http-流式传输">什么是 HTTP 流式传输？&lt;/h2>
&lt;p>HTTP 流，也称为基于 HTTP 的流或 HTTP 实时流，是一种用于通过 Internet 传送实时多媒体内容（例如音频或视频）的技术。该协议允许从服务器到客户端设备的连续数据传输，使用户能够消费媒体内容而无需完整的文件下载。&lt;/p></description></item><item><title>[译]什么是Socket.IO？</title><link>https://blog.chensoul.cc/posts/2024/05/07/socket-io/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/socket-io/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/socket-io/" target="_blank">https://www.pubnub.com/guides/socket-io/&lt;/a>&lt;/p>
&lt;h1 id="什么是socketio">什么是Socket.IO？&lt;/h1>
&lt;p>&lt;a href="https://socket.io/" target="_blank">Socket.IO&lt;/a>是一个开源的跨平台库，它提供客户端和服务器之间基于事件的&lt;a href="https://www.geeksforgeeks.org/transmission-modes-computer-networks/" target="_blank">全双工双向通信&lt;/a>。它基于 WebSocket 协议构建，提供附加功能，例如自动重新连接以及在无法使用 &lt;a href="https://www.pubnub.com/guides/what-are-websockets-and-when-should-you-use-them/" target="_blank">WebSocket时回退到&lt;/a>&lt;a href="https://www.pubnub.com/blog/http-long-polling/" target="_blank">HTTP 长轮询。&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://blog.chensoul.cc/images/Client_Server.webp" alt="img">&lt;/p>
&lt;p>Socket.IO 客户端由客户端和服务器端库组成。虽然最初在服务器上支持&lt;a href="https://www.pubnub.com/blog/nodejs-websocket-programming-examples/" target="_blank">NodeJS ，在客户端支持&lt;/a>&lt;a href="https://www.pubnub.com/guides/javascript/" target="_blank">JavaScript&lt;/a>，但现在它支持各种服务器和客户端技术，包括&lt;a href="https://www.pubnub.com/docs/sdks/java" target="_blank">Java&lt;/a>、&lt;a href="https://www.pubnub.com/docs/sdks/python" target="_blank">Python&lt;/a>、&lt;a href="https://www.pubnub.com/docs/sdks/swift" target="_blank">Swift&lt;/a>和&lt;a href="https://www.pubnub.com/docs/sdks/kotlin" target="_blank">Kotlin&lt;/a>，它们都是官方代码库的一部分，由活跃社区贡献。&lt;/p></description></item><item><title>[译]什么是WebSocket？</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/websockets/" target="_blank">https://www.pubnub.com/guides/websockets/&lt;/a>&lt;/p>
&lt;h2 id="什么是-websocket">什么是 WebSocket？&lt;/h2>
&lt;p>&lt;a href="https://www.pubnub.com/guides/tcp-ip/" target="_blank">WebSocket 是一种通过单个TCP&lt;/a>连接提供全双工通信通道的通信协议。它支持客户端和服务器之间的实时、事件驱动的连接。&lt;/p>
&lt;p>与遵循请求-响应模型的传统 HTTP 软件不同，WebSocket 允许双向（双向）通信。这意味着客户端和服务器可以随时向对方发送数据，而无需持续轮询。&lt;/p></description></item><item><title>[译]什么是长轮询？</title><link>https://blog.chensoul.cc/posts/2024/05/07/long-polling/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/long-polling/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/long-polling/" target="_blank">https://www.pubnub.com/guides/long-polling/&lt;/a>&lt;/p>
&lt;h2 id="什么是长轮询">什么是长轮询？&lt;/h2>
&lt;p>长轮询用于实时 Web 应用程序，以实现客户端和 Web 服务器之间近乎即时的通信。它在实时更新至关重要的聊天和消息应用程序中特别有用。&lt;/p>
&lt;p>在传统的&lt;a href="https://www.pubnub.com/guides/http/" target="_blank">HTTP&lt;/a>通信中，客户端向服务器发送新请求并等待响应。这称为短轮询。然而，在实时场景中，短轮询可能效率不高，因为它需要频繁向服务器请求，导致不必要的网络开销和增加延迟。&lt;/p></description></item><item><title>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websockets-kafka" target="_blank">https://ably.com/topic/websockets-kafka&lt;/a>&lt;/p>
&lt;p>Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。&lt;/p></description></item><item><title>ThingsBoard的领域模型</title><link>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</guid><description>&lt;p>ThingsBoard是一个开源的物联网平台，用于管理和监控物联网设备和数据。它提供了一个可扩展的架构，可以连接各种设备，并实时收集、处理和分析设备生成的数据。&lt;/p>
&lt;h2 id="领域模型">领域模型&lt;/h2>
&lt;p>在ThingsBoard中，领域模型是一个关键概念，用于描述物联网系统中的物理实体、属性和行为。以下是ThingsBoard中的主要领域模型组件：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>租户（Tenant）：租户是ThingsBoard中的顶级组织单位。它代表了一个独立的实体，可以是一个用户、组织或公司。租户拥有和管理自己的设备、客户、规则和仪表板等资源。租户之间的数据和配置是相互隔离的，每个租户都有自己的独立环境。租户由系统管理员创建和管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>租户配置（TenantProfile）：用于定义租户级别的配置和属性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>客户（Customer）：客户是租户下的子级实体，代表了物联网系统中的用户或组织。一个租户可以包含多个客户，每个客户都有自己的访问权限和角色。客户可以访问和监控租户下的设备和数据。客户可以有自己的设备、规则和仪表板等资源，但这些资源受到租户级别的限制。客户由租户管理员创建和管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户（User）：保存用户的基本信息&lt;/p>
&lt;ol>
&lt;li>用户的角色（Authority）：SYS_ADMIN、TENANT_ADMIN、CUSTOMER_USER、REFRESH_TOKEN、PRE_VERIFICATION_TOKEN&lt;/li>
&lt;li>用户凭证（UserCredentials）：保存用户的密码、激活用户 Token、重置密码 Token、密码使用历史&lt;/li>
&lt;li>用户认证设置（UserAuthSettings）：保存用户 2FA 认证设置&lt;/li>
&lt;li>用户设置（UserSettings）：保存用户的设置，包括：通用设置、通知、访问过的仪表盘等等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>系统设置（AdminSettings）：是用于配置和管理整个系统的全局设置和参数，包括：通用设置、邮件、JWT、连接设置等等。&lt;/p></description></item><item><title>All things about ThingsBoard</title><link>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</link><pubDate>Mon, 29 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</guid><description>&lt;p>thingsboard 是一款乌克兰团队基于java语言研发的开源物联网框架，开源的是ce版，企业版需要购买授权且无源码。&lt;/p>
&lt;p>官方网站：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Thingsboard 官网：&lt;a href="https://thingsboard.io/" target="_blank">https://thingsboard.io/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Thingsboard社区免费版本：&lt;a href="https://demo.thingsboard.io/" target="_blank">https://demo.thingsboard.io/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Thingsboard 企业付费版本：&lt;a href="https://thingsboard.cloud/" target="_blank">https://thingsboard.cloud/&lt;/a>&lt;/p></description></item><item><title>TBMQ测试和源码分析</title><link>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</link><pubDate>Sun, 28 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</guid><description>&lt;ol>
&lt;li>
&lt;p>启动 TBMQ 程序，浏览器访问 http://localhost:8083，创建一个 Application，Credentials Type 为 BASIC，客户端 ID、用户名和密码均设置为 tbmq_app&lt;/p></description></item><item><title>ThingsBoard TBMQ本地和通过Docker运行</title><link>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</guid><description>&lt;h2 id="docker-compose-运行">docker-compose 运行&lt;/h2>
&lt;p>参考：&lt;a href="https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/" target="_blank">https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>下载源代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd tbmq/docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建逻辑卷并执行安装程序&lt;/p></description></item><item><title>All things about MicroProfile</title><link>https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/</link><pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/</guid><description>&lt;p>最近在一些开源项目中看到了 MicroProfile ，于是在网上查阅了相关资料加深对 MicroProfile 的理解，并做了笔记形成此文。&lt;/p>
&lt;h2 id="microprofile">MicroProfile&lt;/h2>
&lt;p>MicroProfile是一个开放的企业级Java微服务框架，旨在简化和标准化基于微服务架构的应用程序开发。它是由Eclipse Foundation主导的一个开源项目，致力于提供轻量级、可移植和可互操作的Java微服务规范和实现。&lt;/p></description></item><item><title>JHipster安装和介绍</title><link>https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/</link><pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/</guid><description>&lt;p>JHipster 是一个开发平台，可以快速生成，开发和部署现代 Web 应用程序+微服务架构。&lt;/p>
&lt;p>JHipster 或者称 Java Hipster，是一个应用代码产生器，能够创建 Spring Boot/Spring Cloud + React/VueJs/AngularJS 的应用。使用 JHipster，首先你要配置好 Java 、Git 以及 Maven 或者 Gradle 的环境，然后通过 NodeJs 管理工具安装 JHipster 。&lt;/p></description></item><item><title>JSR 166规范</title><link>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</guid><description>&lt;h2 id="jsr-介绍">JSR 介绍&lt;/h2>
&lt;p>JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=335" target="_blank">JSR 335&lt;/a>，新的日期和时间 API 对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=310" target="_blank">JSR 310&lt;/a>。&lt;/p></description></item></channel></rss>