<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on ChenSoul</title>
    <link>https://blog.chensoul.cc/categories/java/</link>
    <description>Recent content in Java on ChenSoul</description>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 27 Aug 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blog.chensoul.cc/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ActiveMQ源码-BrokerService和PersistenceAdapter</title>
      <link>https://blog.chensoul.cc/posts/2024/08/27/activemq-source-code-broker-service/</link>
      <pubDate>Tue, 27 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/27/activemq-source-code-broker-service/</guid>
      <description>activemq-broker 模块 test/java 目录下有个 IDERunner 类：
public class IDERunner { private static final boolean TRANSPORT_TRACE = false; public static void main(String[]args) throws Exception { BrokerService brokerService = new BrokerService(); // brokerService.addConnector( // &amp;#34;tcp://0.0.0.0:61616?trace=&amp;#34; + TRANSPORT_TRACE + // &amp;#34;&amp;amp;transport.wireFormat.maxFrameSize=104857600&amp;#34;); brokerService.setPersistent(false); brokerService.setUseJmx(false); brokerService.setAdvisorySupport(false); brokerService.start(); brokerService.waitUntilStopped(); } } 注释掉 brokerService 调用 addConnector 方法的三行代码，然后 debug 运行该类的 main 方法。
BrokerService BrokerService 管理 ActiveMQ Broker 的生命周期。BrokerService 由许多传输连接器、网络连接器和一系列属性组成，这些属性可用于在延迟创建代理时对其进行配置。
BrokerService 类实现了 Service 接口。Service 接口是 ActiveMQ 组件的核心生命周期接口。如果有标准方法，最好将此接口注册到 Spring，以便它将启动/ 停止方法视为 org.springframework.beans.factory.InitializingBean 和 org.springframework. beans.factory.DisposableBean 的方法
public interface Service { void start() throws Exception; void stop() throws Exception; } BrokerService 类没有构造方法，有一个 static 代码块：
static { try { Boolean bouncyCastleNotAdded = Boolean.getBoolean(&amp;#34;org.apache.activemq.broker.BouncyCastleNotAdded&amp;#34;); if (bouncyCastleNotAdded == null || bouncyCastleNotAdded == false) { ClassLoader loader = BrokerService.</description>
    </item>
    <item>
      <title>ThingsBoard源码编译和Idea运行</title>
      <link>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</link>
      <pubDate>Tue, 27 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</guid>
      <description>ThingsBoard 源码地址：https://github.com/thingsboard/thingsboard，从 3.7 版本之后，要求 JDK17。官方提供了源码编译的文档：Building from sources
源码编译 下载代码：
git clone git@github.com:thingsboard/thingsboard.git 设置当前 JDK 版本为 17 以上。这里我使用 sdkman 切换 java。
sdk use java 17.0.12-tem 终端编译源码：
cd thingsboard mvn clean install -Dmaven.test.skip=true 如果在编译过程中提示找不到 Gradle：
[ERROR] Failed to execute goal org.thingsboard:gradle-maven-plugin:1.0.12:invoke (default) on project http: org.gradle.tooling.BuildException: Could not execute build using connection to Gradle distribution &amp;#39;https://services.gradle.org/distributions/gradle-7.3.3-bin.zip&amp;#39;. -&amp;gt; [Help 1] 往上查看详细异常日志：
* What went wrong: Could not compile build file &amp;#39;/Users/chensoul/Codes/github/thingsboard/packaging/java/build.gradle&amp;#39;. &amp;gt; startup failed: General error during conversion: Unsupported class file major version 65 java.lang.IllegalArgumentException: Unsupported class file major version 65 可以看到是 JDK 版本过高的原因。需要确认 JDK 版本使用 17，不能是 21。
如果 maven 下载太慢，则修改 mirrors 节点如下：</description>
    </item>
    <item>
      <title>ActiveMQ源码本地调试运行</title>
      <link>https://blog.chensoul.cc/posts/2024/08/09/debug-activemq-source-code/</link>
      <pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/09/debug-activemq-source-code/</guid>
      <description>源码构建 1、从 https://github.com/apache/activemq 下载源码
git clone https://github.com/apache/activemq 2、切换至 activemq-5.18.x 分支
cd activemq git checkout activemq-5.18.x 3、构建源码
mvn package -DskipTests 构建成功之后，在 assembly/target 目录可以看到打包好的压缩文件。
在 Idea 中运行代码 activemq-console 在 Idea 中运行代码 activemq-console，启动 activemq：
1、在 idea 中打开项目
2、解压 assembly/target 目录下生成的压缩文件，将 conf、webapps 和 lib 目录拷贝到项目的根目录下面。
3、在idea中选中子模块 activemq-console，右击 选择 Open Module Settings —&amp;gt; Modules —&amp;gt; Dependencies，点击+(加号) —&amp;gt;选择 JARS or directories，把 lib 中的包（包括子目录下的）全部导入
4、配置从 activemq-console 下的 Main 类启动，在 Program arguments 添加 start
5、debug 运行 Main.java 类
在 Idea 中运行单元测试类 分析 Main.java 类的 main 方法，调用链如下：
Main.java -&amp;gt; ShellCommand.java -&amp;gt; StartCommand.java -&amp;gt; BrokerService.java 从 BrokerService 类，可以看到启动 broker 的关键代码如下：
final BrokerService broker; try { // If no config uri, use default setting if (brokerURIs.</description>
    </item>
    <item>
      <title>Github Action 发布 Jar 到 Maven 中央仓库</title>
      <link>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</link>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</guid>
      <description>作为一名 Java 开发者,将自己的项目发布到 Maven 中央仓库是一个非常重要的步骤。这不仅可以让更多的开发者发现和使用您的项目,也可以提高项目的知名度和影响力。
在过去,发布 Jar 到 Maven 中央仓库通常需要手动完成一系列繁琐的步骤，比如：申请 JIRA 账号、创建 Sonatype JIRA Issure、上传 Jar 包、签名 Jar 包等。但是随着 Github Action 的出现，这个过程变得更加自动化和简单。
下面我将以一个简单的 Maven 项目为例，介绍如何使用 Github Action 实现自动发布 Jar 到 Maven 中央仓库。
前提条件 在 Github 创建一个 Maven 项目 安装 gpg 并创建 gpg 秘钥和公钥，参考 How to Publish Artifacts to Maven Central 创建 OSSRH 账号，参考 Generate a Token on OSSRH Sonatype Nexus Repository Manager servers 创建 Maven 项目 首先在Github上面创建项目：https://github.com/chensoul/maven-hello-world
增加两个 Maven 插件：
&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-gpg-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.2&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;sign&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;phase&amp;gt;verify&amp;lt;/phase&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.sonatype.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;nexus-staging-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7.0&amp;lt;/version&amp;gt; &amp;lt;extensions&amp;gt;true&amp;lt;/extensions&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;serverId&amp;gt;ossrh&amp;lt;/serverId&amp;gt; &amp;lt;nexusUrl&amp;gt;https://s01.oss.sonatype.org/&amp;lt;/nexusUrl&amp;gt; &amp;lt;autoReleaseAfterClose&amp;gt;true&amp;lt;/autoReleaseAfterClose&amp;gt; &amp;lt;keepStagingRepositoryOnCloseRuleFailure&amp;gt;false&amp;lt;/keepStagingRepositoryOnCloseRuleFailure&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; 可以将上面的两个插件加入到 pom.xml 的 build 节点下面，也可以配置到 profile 节点下。https://github.</description>
    </item>
    <item>
      <title>[译]JMS 2.0 中的新增功能</title>
      <link>https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/</link>
      <pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/</guid>
      <description>原文链接：What is new in JMS 2.0
在在软件集成领域，从一个软件组件到另一个软件组件进行通信是一项基本要求。虽然已经出现了许多具有这种能力的技术，但 Java 编程语言为我们提供了一个 API，以促进用 Java 编写的组件之间的消息传递。此 API 的实现将由不同的供应商（JMS 提供商）通过代理软件提供。
这个API被称为Java消息服务（JMS）。
JMS 规范的最后一次更新是在 2002 年，当时推出了JMS 1.1。从那时起，多年来，该 API 已在全球许多软件组件中使用，证明了其对开发人员的友好性。JMS 的下一个版本（JMS 2.0）于 2013 年 4 月问世，距离 1.1 版已有数年之久。
JMS 2.0 只能与Java SE 7 及更高版本一起使用。了解 JMS 2.0 中的新功能将会很有趣。
易于使用的语言功能 从语言角度来看，对 API 所做的最重大的更改是减少了开发人员需要编写的代码量。让我们将 JMS 2.0 与 1.1 进行比较，看看它们有什么区别。
连接和会话对象纳入单个 JMSContext 不再需要创建连接和会话对象。您可以创建 JMSContext 并直接使用它来创建消息生产者。
//JMS 1.1 public void sendMessageJMS11(ConnectionFactory connectionFactory, Queue queueString text) { try { Connection connection = connectionFactory.createConnection(); try { Session session =connection.createSession(false,Session.AUTO_ACKNOWLEDGE); MessageProducer messageProducer = session.createProducer(queue); TextMessage textMessage = session.createTextMessage(text); messageProducer.send(textMessage); } finally { connection.close(); } } catch (JMSException ex) { // handle exception (details omitted) } } //JMS 2.</description>
    </item>
    <item>
      <title>[译]JMS 2.0 中的新增功能（第一部分）- 易于使用</title>
      <link>https://blog.chensoul.cc/posts/2024/07/24/jms20/</link>
      <pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/24/jms20/</guid>
      <description>原文链接：https://www.oracle.com/technical-resources/articles/java/jms20.html
作者：Nigel Deakin 出版日期：2013 年 5 月
了解新的易用性功能如何使您编写更少的代码行。
本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在第二部分中，我们将介绍新的消息传递特性。
JMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。
JMS 2.0 的重点是追赶其他企业 Java 技术的易用性改进。虽然企业 JavaBeans 或 Java 持久性等技术现在比十年前使用起来简单得多，但 JMS 仍然保持着成功但相当冗长的 API。
JMS 2.0 中最大的变化是引入了用于发送和接收消息的新 API，从而减少了开发人员必须编写的代码量。对于在 Java EE 应用服务器中运行的应用程序，新 API 还支持资源注入。这允许应用服务器负责创建和管理 JMS 对象，从而进一步简化应用程序。
JMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序，也可以在 Java SE 环境中独立使用。正如我在下面解释的那样，这里描述的某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。
简化的 API 新 API 称为简化 API。顾名思义，它旨在比现有的 JMS 1.1 API 更简单、更易于使用，而后者现在（相当可预测地）被称为经典 API。
简化的 API 包含三个新接口：JMSContext、JMSProducer和JMSConsumer：
JMSContext用单个对象替换经典 API 中单独的Connection和Session对象。 JMSProducer是经典 API 中对象的轻量级替代品。它允许使用方法链（有时称为构建器模式MessageProducer）配置消息传递选项、标头和属性。 JMSConsumer替代了MessageConsumer经典API中的对象，使用方式类似。 开发人员现在可以选择是使用传统 API（JMS 1.</description>
    </item>
    <item>
      <title>[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能</title>
      <link>https://blog.chensoul.cc/posts/2024/07/24/jms20/</link>
      <pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/24/jms20/</guid>
      <description>原文链接：https://www.oracle.com/technical-resources/articles/java/jms2messaging.html
作者：Nigel Deakin 出版日期：2013 年 5 月
了解如何利用 JMS 2.0 中的新消息传递功能。
本文是两部分系列文章中的第二部分，介绍了 Java 消息服务 (JMS) 2.0 中引入的一些新消息传递功能。本文假设读者对 JMS 1.1 有基本的了解。
在第一部分中，我们了解了 JMS 2.0 中引入的新的易用特性。在这里，我们来了解一下重要的新消息传递特性。
JMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。
JMS 2.0 的重点是跟上近年来对其他企业 Java 技术所做的易用性改进。同时还借此机会引入了许多新的消息传递功能。
JMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序。它也可以单独用于 Java SE 环境中。正如我下面所解释的那样，某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。
这里我们讨论 JMS 2.0 中的五个重要的新消息传递功能。
允许多个消费者订阅同一主题 在 JMS 1.1 中，一个主题的订阅不允许同时有多个使用者。这意味着，处理主题订阅上的消息的工作不能在多个线程、连接或 Java 虚拟机 (JVM) 之间共享，从而限制了应用程序的可伸缩性。JMS 2.0 中引入了一种称为共享订阅的新主题订阅，从而消除了此限制。
让我们回顾一下主题订阅在 JMS 1.1 中的工作方式。在清单 1 中，方法createConsumeronSession用于创建指定主题的非持久订阅（我们稍后将讨论持久订阅）：
private void createUnsharedConsumer(ConnectionFactory connectionFactory, Topic topic) throws JMSException { Connection connection = connectionFactory.</description>
    </item>
    <item>
      <title>[译]JMS 2.0 的十个好处意味着可以减少代码编写量</title>
      <link>https://blog.chensoul.cc/posts/2024/07/24/jms20-means-less-code/</link>
      <pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/24/jms20-means-less-code/</guid>
      <description>原文链接：Ten ways in which JMS 2.0 means writing less code
这里有十个简单的例子，说明 JMS 2.0 比 JMS 1.1 需要更少的代码。
单一 JMSContext 而不是单独的 Connection 和 Session 对象 JMS 2.0 简化 API 引入了一个新对象， JMSContext 它提供了与 JMS 1.1 API 中的分隔 Connection 对象 Session 相同的功能：
JMS 1.1
Connection connection = connectionFactory.createConnection(); Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); JMS 2.0
JMSContext context = connectionFactory.createContext(JMSContext.SESSION_TRANSACTED); 使用 try-with-resources 块意味着不需要调用 close 使用后未能关闭Connection可能会导致您的应用程序耗尽资源。
JMS 1.1
在 JMS 1.1 中，确保使用后关闭连接的最佳方法是调用close()一个finally块：
try { Connection connection = connectionFactory.createConnection(); try { Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); ... etc ... } finally { connection.close(); } } catch (JMSException ex) { ex.printStackTrace(); } 这太冗长了。更糟糕的是，如果您在块主体中遇到异常try，然后在中遇到异常close()，则第一个异常将会丢失，即使第一个异常可能是失败的根本原因。
JMS 2.0
在 JMS 2.0 中，Connection对象实现了java.lang.AutoCloseable接口。这意味着，如果您Connection 在 try-with-resources 块中创建对象，则该close方法将在该块的末尾自动调用。</description>
    </item>
    <item>
      <title>[译]JMS 事务的实际应用</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/jms-transactions-in-action/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/jms-transactions-in-action/</guid>
      <description>在本文中，您将了解如何选择性地使用 JMS 事务。在 JMS 中，您可以选择控制一个会话的原子操作。每个会话都支持一系列事务。每个事务将一组生成或使用的消息分组为一个原子工作单元。确保您已经理解了JMS 中的消息确认。
交易提交时 – ( jmsContext.commit())
其输入的原子单位被承认。 对于消费者来说，类似地，其相关的输出也被发送（被消费者接收）。 如果事务回滚完成– （jmsContext.rollback()）
其产生的信息被销毁。 其使用的消息被恢复（不会从 JMS 服务器中删除）。 让我们看一下代码示例，以更好地理解其功能。链接到GitHub 代码库。
package lab07.transactons.example; import labxx.common.settings.CommonSettings; import javax.jms.*; public class TransactionExample { public static void main(String[] args) { ConnectionFactory connectionFactory = CommonSettings.getConnectionFactory(); Queue queue = CommonSettings.getDefaultQueue(); Thread messageproducer = new Thread() { public void run() { try (JMSContext jmsContext = connectionFactory.createContext(JMSContext.SESSION_TRANSACTED)) { JMSProducer producer = jmsContext.createProducer(); producer.send(queue, &amp;#34;This is a SESSION_TRANSACTED message&amp;#34;); producer.send(queue, &amp;#34;Sending another message&amp;#34;); //TODO - Comment and see the result, message is not delivered until committed sleep(5000); jmsContext.commit(); //Important //Next message is never delivered as it is rollback() producer.send(queue, &amp;#34;This message will not be delivered&amp;#34;); jmsContext.</description>
    </item>
    <item>
      <title>[译]JMS 发布-订阅消息模型</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/jms-pub-sub-messaging-model/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/jms-pub-sub-messaging-model/</guid>
      <description>在本文中，您将了解 JMS 发布-订阅 (publish-subscribe) 消息传递模型。正如您在JMS 简介文章中所读到的，在发布/订阅模型中，客户端通过称为主题的中介将消息发送给多个接收者。发送者通常称为发布者，接收者称为订阅者。
JMS 发布/订阅消息传递示例 下面是一个简单的代码示例，演示了发布/订阅消息模型的工作原理。我创建了 2 个主线程，publisher和subscriber1。将订阅者 1 克隆到subscriber2。所以基本上我有一个消息发布者和 2 个消息订阅者。链接至GitHub 。
package lab03.message.pubsub; import labxx.common.settings.CommonSettings; import javax.jms.*; public class SimplePubSubExample { private static ConnectionFactory connectionFactory = null; private static Topic defaultTopic = null; static { connectionFactory = CommonSettings.getConnectionFactory(); defaultTopic = CommonSettings.getDefautTopic(); } public static void main(String[] args) { Thread publisher = new Thread(){ @Override public void run(){ try(JMSContext jmsContext = connectionFactory.createContext()) { Thread.sleep(1000); JMSProducer producer = jmsContext.createProducer(); TextMessage message = jmsContext.createTextMessage(&amp;#34;World needs to worry about the Climate changes&amp;#34;); producer.send(defaultTopic, message); } catch (InterruptedException ex){ ex.printStackTrace(); } } }; Thread subscriber1 = new Thread(){ @Override public void run(){ try(JMSContext jmsContext = connectionFactory.</description>
    </item>
    <item>
      <title>[译]JMS 消息优先级</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/</guid>
      <description>我们将通过示例详细讨论 JMS 消息优先级。每条消息的标头字段代表其优先级。我在消息模型教程JMSPriority中讨论过消息优先级。
JMS 有 10 个优先级，从 0 到 9。0 是最低优先级，9 是最高优先级。根据 JMS 标准，优先级为 0-4 的消息为正常优先级，优先级为 5-9 的消息被视为加急优先级。
JMS 优先级示例 在下面的例子中，具有不同优先级的消息被发送给接收方。但是，优先级最高的消息（9）最先到达，同样，优先级最低的消息最后到达。
package lab01.message.model; import labxx.common.settings.CommonSettings; import javax.jms.*; public class MessagePriorityTest { public static void main(String[] args) throws JMSException { ConnectionFactory connectionFactory = CommonSettings.getConnectionFactory(); Queue queue = CommonSettings.getDefaultQueue(); try (JMSContext jmsContext = connectionFactory.createContext()) { JMSProducer producer = jmsContext.createProducer(); String[] messages = {&amp;#34;Msg One&amp;#34;, &amp;#34;Msg two&amp;#34;, &amp;#34;Msg three&amp;#34;, &amp;#34;Msg four&amp;#34;, &amp;#34;Msg five&amp;#34;}; producer.setPriority(0).send(queue, messages[0]); producer.setPriority(9).send(queue, messages[1]); producer.setPriority(4).send(queue, messages[2]); producer.setPriority(2).send(queue, messages[3]); producer.send(queue, messages[4]); JMSConsumer consumer = jmsContext.createConsumer(queue); for (int i = 0; i &amp;lt; messages.length; i++) { Message message = consumer.receive(); System.out.println(&amp;#34;Priority: &amp;#34; + message.</description>
    </item>
    <item>
      <title>[译]JMS 消息模型</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/</guid>
      <description>消息是 JMS 的核心，无论是事件还是业务数据。消息由标头、自定义属性和正文组成。这是您将在 JMS 消息模型（JMS 消息剖析）中学习的内容。
JMS 消息由 Header、Properties 和 Body（Payload）组成。我们将在下面详细讨论它们。
消息头是有关消息的元数据。消息头有两种类型：开发人员设置的头和 JMS 提供商设置的头。
消息属性是用于向消息添加可选标头字段的附加标头字段。属性字段基本上有 3 种类型。
应用程序特定属性 - 允许设置应用程序特定的自定义标题。 标准属性 – JMS 定义的标准属性。 JMS-Provider 特定属性。 消息主体是发送到目的地的有效负载。JMS 支持多种类型（格式）的有效负载。
1. 消息头字段 一些消息头由程序员设置，一些由 JMS 提供商内部设置。消息头是 JMS 消息模型中首先要探讨的内容。
1.1. JMS 目标 此标头包含消息发送的目的地。收到消息时，目的地必须与分配的值相等。
javax.jms.Message#setJMSDestination(Destination) javax.jms.Message#getJMSDestination() 1.2. JMS交付模式 JMS 支持 PERSISTEN T和 NON_PERSISTENT 消息传输模式。此标头表示传递模式。
javax.jms.Message#setJMSDeliveryMode（int） javax.jms.Message#getJMSDeliveryMode() javax.jms.DeliveryMode 1.3. JMS消息ID 此标头字段值唯一标识提供商发送的每个消息。它是一个字符串值。程序员不需要处理它。
javax.jms.Message#getJMSMessageID() javax.jms.Message#setJMSMessageID(String) javax.jms.MessageProducer#setDisableMessageID(boolean) 1.4. JMS时间戳 消息被交给提供商处理的时间戳。
javax.jms.Message#setJMSTimestamp(long) javax.jms.MessageProducer#setDisableMessageTimestamp(boolean) 1.5. JMS重新交付 当客户端收到带有此标头的消息时，很可能该消息已在过去送达，但未收到确认。程序员无法更改此值。
javax.jms.Message#setJMSRedelivered（boolean） javax.jms.Message#getJMSRedelivered() 1.6. JMSExpiration – 设置消息生存时间 JMS 通过添加生存时间值来为每条消息设置过期值。生存时间值在方法中指定send()。如果生存时间值设置为零，则 JMSExpiration 标头值也会变为零，这意味着消息不会过期。
jmsProducer.setTimeToLive(long timeToLive); javax.jms.Message#setJMSExpiration(long) javax.jms.Message#getJMSExpiration() 下面的示例演示了如何使用producer.setTimeToLive()方法来设置消息过期时间。正如您在输出中看到的那样，消息的生命周期只有 2 秒，5 秒后它将从队列中删除。因此，消费者不会收到该消息并记录 NullPointer 异常。
package lab01.message.model; import labxx.common.settings.CommonSettings; import javax.jms.*; public class MessageExpirationTest { public static void main(String[] args) throws InterruptedException, JMSException { ConnectionFactory connectionFactory = CommonSettings.</description>
    </item>
    <item>
      <title>[译]JMS 消息选择器在过滤消息中的应用</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/jms-message-selectors-in-action-to-filter-messages/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/jms-message-selectors-in-action-to-filter-messages/</guid>
      <description>发送给接收方的消息通常需要根据某些标准进行过滤。JMS 提供消息选择器，允许 JMS 消费者根据消息头指定其感兴趣的消息。在本文中，您将学习使用 JMS 消息选择器来过滤消息。
这是一篇高级教程，在继续阅读本文之前，请确保您对 JMS 有基本的了解。如果您是 JMS 新手，请查看JMS 点对点消息传递模型文章。
为什么要使用消息选择器？ 当一条消息被广播给许多接收者时，将标准放入订阅中以注册特定的兴趣是很有用的。这样只有感兴趣的消息才会被传递给订阅者。
消息选择器是一种String基于SQL92条件表达式的语法。 仅传递标题和属性与选择器匹配的消息。 消息选择器不能引用消息正文值。 消息选择器从左到右进行评估。 选择器文字和运算符通常以大写字母书写，但它们不区分大小写。 1. 按属性过滤消息 就像我之前提到的，你只能根据属性或标头过滤消息，而不能根据实际消息内容过滤消息。下面的示例显示，只有级别日志被传递给消费者。链接至GitHub 代码库。
package lab04.message.filtering; import labxx.common.settings.CommonSettings; import org.junit.jupiter.api.Test; import javax.jms.*; import java.util.UUID; public class MessageSelectorExample { private static ConnectionFactory connectionFactory = null; private static Queue defaultQueue = null; static { connectionFactory = CommonSettings.getConnectionFactory(); defaultQueue = CommonSettings.getDefaultQueue(); } @Test public void messageFilterOnProperties() throws JMSException, InterruptedException { try (JMSContext jmsContext = connectionFactory.createContext()) { LogEvent event1 = new LogEvent(&amp;#34;Sample ERROR Log&amp;#34;, UUID.randomUUID().toString(), LogLevel.ERROR); LogEvent event2 = new LogEvent(&amp;#34;Sample DEBUG Log&amp;#34;, UUID.randomUUID().toString(), LogLevel.DEBUG); LogEvent event3 = new LogEvent(&amp;#34;Sample INFO Log&amp;#34;, UUID.randomUUID().toString(), LogLevel.INFO); LogEvent event4 = new LogEvent(&amp;#34;Sample WARN Log&amp;#34;, UUID.</description>
    </item>
    <item>
      <title>[译]JMS 点对点消息传递的实际应用</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/</guid>
      <description>点对点系统使用队列进行消息传递。客户端将消息发送到特定队列，特定订阅者监听或接收来自该队列的消息。在 JMS 点对点消息传递系统中，队列用于处理单个发送者和单个消费者。确保您已经阅读了有关JMS 消息模型以及如何在 JMS 中发送和接收消息的先前教程。
使用队列进行 PTP 消息传送 您现在知道点对点消息传递完全是利用队列。JMS 提供javax.jms.Queue表示队列对象的功能。我将利用 JMS 2.0 API 来javax.jms.JMSProducer发送javax.jms.JMSConsumer和接收消息。
我已经向您展示了多个使用 JMS 队列的示例。以下代码表示在 JMS 2.0 API 中使用 JMS 队列的步骤，只是为了再次刷新一下概念。
package lab00.simple.helloworld; import javax.jms.*; import javax.naming.InitialContext; import javax.naming.NamingException; public class TestHelloWorld { public static void main(String[] args) { ConnectionFactory connectionFactory = null; Queue queue = null; try { InitialContext initialContext = new InitialContext(); //Step-1 Create ConnectionFactory connectionFactory = (ConnectionFactory) initialContext.lookup(&amp;#34;jms/__defaultConnectionFactory&amp;#34;); //Step-2 Get the Destination queue = (Queue) initialContext.lookup(&amp;#34;jms/PTPQueue&amp;#34;); } catch (NamingException e) { e.printStackTrace(); } //Step-3 Create J MSContext try (JMSContext jmsContext = connectionFactory.createContext()) { //Step-4a Create a Text Message and send TextMessage textMessage = jmsContext.createTextMessage(&amp;#34;Message using JMS 2.</description>
    </item>
    <item>
      <title>[译]JMS介绍 – Java消息服务</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/</guid>
      <description>JMS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。这是一个 JMS 介绍教程，为您提供消息传递和 JMS 的简要概述。您将了解使用 JMS 的优势以及 JMS 中的不同消息传递模型。
什么是消息传递？ 消息传递是跨各种应用程序或服务交换业务数据的过程。消息通常是其他应用程序或服务使用的异步请求、响应、报告或事件。这些消息包含重要信息。
消息传递为微服务架构提供了可扩展性。消息传递也传统上用于面向服务的架构，以在它们之间建立异步且可靠的通信。
消息系统也称为面向消息的中间件产品。目前有多种消息中间件可供选择，例如 ActiveMQ、RabbitMQ、ActiveMQ Artemis、Apache Kafka、应用服务器（Glassfish、Wildfly、Websphere MQ）等。
使用消息中间件的优点 可靠性– 消息中间件保证交付。如果消费者因某种原因宕机，消息系统会存储消息，直到其再次启动。 异步– JMS 是异步的，发送者和接收者不需要互相等待。 易于集成– 多个应用程序可以用不同的编程语言编写或运行在不同的服务器上。只要它们使用相同的协议，就可以使用消息中间件在它们之间建立通信。 可扩展性——消息传递有助于向多个接收者广播，从而有助于实现可扩展性。 灵活性——您可以为不同的消息分配不同的协议，这使您在设计架构时具有很大的灵活性。 什么是 JMS？ 目前有几种企业消息中间件（面向消息的中间件）产品，如 TIBCO MQ、Apache ActiveMQ、Apache Kafka、RabbitMQ、ActiveMQ Artemis、IBM MQ 等。
JMS 提供了标准的 Java API，这意味着 Java 程序可以创建、发送、接收和读取企业消息系统的消息。我们将探讨 JMS 1.x 和 2.0 API 标准。
并非所有企业消息中间件都实现 JMS 标准。实现 JMS 标准的中间件称为 JMS 提供程序。其中包括 Apache ActiveMQ、Apache ActiveMQ Artem、Oracle WebLogic Server、Glassfish、IBM MQ、Jboss Wildfly、Apache Qpid 等。无论您使用哪种实现，如果您坚持 JMS 标准，切换供应商都很简单。
JMS 不可互操作，这意味着它主要用于用 Java 或 JVM 语言编写的应用程序。如果您想使用具有更好互操作性支持的消息传递协议（可以在 NodeJS、Python、C# 等中工作），请查看AMQP（高级消息队列协议），例如 RabbitMQ。
JMS 标准的局限性 JMS 标准不包括以下功能，因为 JMS 仅用于发送和接收消息。
负载平衡/容错 错误/建议通知 JMS 提供程序的管理 API 安全 没有消息类型存储库定义 JMS 中的消息传递模型 JMS 支持两种主要的消息传递样式，如下所示。作为 JMS 介绍的一部分，我们在此仅讨论这些类型，本教程的后面部分将通过几个示例介绍每种类型。</description>
    </item>
    <item>
      <title>[译]为 JMS 安装和设置 Glassfish</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/</guid>
      <description>在本文中，我们将为 JMS 2.0 设置 Glassfish，创建一个 Java 项目并添加必要的依赖项。
先决条件 请确保您的系统上安装了以下工具。
已安装JDK 8。尚未使用任何更高版本的 Java 进行测试。 Eclipse、STS 或 IntelliJ IDEA。 Glassfish 安装和设置步骤 步骤 1，下载 Glassfish 并解压缩 您需要从 Glassfish GitHub repo下载开源 Glassfish 版本，然后将其解压缩到我们将运行服务器的文件夹中。我使用的是带有 JDK 8 的 GlassFish 5.0。
步骤2，启动服务器 cd glassfish5\glassfish\bin\从终端导航到解压的文件夹内以启动服务器。
sh startserv如果您使用的是 Mac 或 Linux，请从终端运行。或者，startserv.bat如果您使用的是 Windows，请运行。让服务器有时间进行引导。
步骤 3，打开管理控制台 完成上述步骤后，接下来访问管理控制台http://localhost:4848。
现在，查看“ JMS 资源/连接工厂”，您可以看到 Glassfish 为您创建的默认 JMS 工厂。我们将jms/__defaultConnectionFactory在整个课程中使用它。
步骤 4，创建 JMS 目标资源 默认情况下，Glassfish 管理控制台上不会列出任何目标资源。请记住，您需要先创建这些资源，然后编写代码以通过这些资源发送或接收消息。
点击新建按钮添加新的目标资源，我们将创建 2 个Queue和一个Topic供示例工作，如下所示。
创建队列 1，其 JNDI 名称为jms/PTPQueue，目标名称为PTPQueue。 创建队列2，其JNDI名称为jms/ReplyQueue，目标名称为ReplyQueue。 然后，创建 pub-sub 主题，其 JNDI 名称为jms/PubSubTopic，目标名称为PubSubTopic。 理想情况下，目标资源和 ConnectionFactory 由服务器管理员创建。作为开发人员，您无需在现实世界中创建它们。但出于开发或测试目的，您需要在本地计算机上创建它们。
无论您使用哪个 JMS 提供程序，它们始终需要提供 ConnectionFactory 和 Destination 。这意味着在我们编写 Java 代码之前，需要在 JMS 提供程序中配置它们。您将在本教程的后半部分详细了解它们。有一些例外，例如 ActiveMQ，允许在运行时创建Destination。
一旦创建目标资源，JMS 目标资源将如下面的屏幕截图所示。
配置 IDE 的步骤 ​ 所有代码示例均可在 GitHub 上下载。或者，您可以按照以下步骤创建一个具有下面列出的依赖项的 Maven 项目。
步骤 1，创建一个 Maven 项目 在你的 IDE（Eclipse、STS 或 IntelliJ）中创建一个 maven 项目&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; 打开pom.</description>
    </item>
    <item>
      <title>[译]使用 JMS 消息确认保证传送</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/guaranteed-delivery-using-jms-message-acknowledgement/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/guaranteed-delivery-using-jms-message-acknowledgement/</guid>
      <description>JMS 通过 JMS 消息确认（确认模式）确保消息传递的可靠性。如果会话已进行事务处理，则该commit()方法会自动处理消息确认。否则，该方法将处理恢复rollback()。在本文中，我们将假设会话未进行事务处理。这是一个高级主题，请确保您对 JMS 有基本的了解。如果您是 JMS 新手，可以参考使用 JMS发送和接收消息。
JMS Client会话未进行事务处理时使用消息确认。消息确认是在（JMS 生产者和 JMS 消费者）和之间建立的协议JMS Server。
JMS 提供三种确认选项，并且恢复是手动处理的。
AUTO_ACKNOWLEDGE – JMS 会话自动确认客户端已收到消息。不会发送重复消息。 CLIENT_ACKNOWLEDGE – JMS 客户端必须通过调用消息的acknowledge()方法来确认。 DUPS_OK_ACKNOWLEDGE – JMS 服务器可以放心地向 JMSConsumer 发送重复消息。客户端应用程序应该能够在此模式下处理重复消息。 1. JMS AUTO_ACKNOWLEDGE消息传递的实际操作 这是创建Session或时设置的默认确认模式JMSContext。您可以手动指定AUTO_ACKNOWLEDGE模式，如下所示。
JMSContext jmsContext = connectionFactory.createContext(JMSContext.AUTO_ACKNOWLEDGE); 在此模式下，当客户端成功从接收调用返回或其调用来处理消息的消息侦听器成功返回时，JMS 会话会自动确认客户端已收到消息。以下代码显示了此模式的用法。链接至GitHub 代码库。
package lab06.message.acknowledgement; import labxx.common.settings.CommonSettings; import javax.jms.*; public class AutoAcknowledgeExample { public static void main(String[] args) { ConnectionFactory connectionFactory = CommonSettings.getConnectionFactory(); Queue queue = CommonSettings.getDefaultQueue(); Thread messageproducer = new Thread() { public void run() { try (JMSContext jmsContext = connectionFactory.createContext(JMSContext.AUTO_ACKNOWLEDGE)) { JMSProducer producer = jmsContext.createProducer(); //Send the message Message message = jmsContext.createTextMessage(&amp;#34;This is an AUTO_ACKNOWLEDGEMENT message&amp;#34;); producer.send(queue, message); } } }; Thread messageConsumer = new Thread() { public void run() { try (JMSContext jmsContext = connectionFactory.</description>
    </item>
    <item>
      <title>[译]在 JMS 中发送和接收消息</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/</guid>
      <description>您将了解 JMS 架构，学习如何在 JMS 中发送和接收消息。我将介绍管理对象、JMS 1.1 API 和 JMS 2.0 API。我们还将看到与 JMS 1.1 API 相比，JMS 2.0 API 的使用有多么简单。在继续学习本课程之前，请确保您已完成 JMS 设置。如果您是初学者，请确保您已了解JMS 的基础知识。
请记住，当您使用 JMS 时，需要在 JMS 提供程序中配置ConnectionFactory和Destination对象（队列和主题）。这就是它们被称为受管理对象的原因。 您通常会执行 JNDI 查找以获取ConnectionFactory，然后从 ConnectionFactory获取物理Connection对象。 获得连接后，您将需要打开一个会话来发送/接收消息。 JMS API 版本 您需要了解基本上有两组用于发送和接收消息的主要接口。
JMS 1.1 – 也称为经典 API，这是遗留 API。 JMS 2.0 – 被称为简化 API，提供更简单的 API，需要更少的接口。这正是您在新项目中需要使用的。 通用接口 队列– 用于点对点消息传递的受管理对象。单个生产者和单个接收者。 主题– 用于发布/订阅消息的受管对象。单个生产者，但多个接收者。 目的地– 队列和主题的共同超类型。 Message、ByteMessage、MapMessage、ObjectMessage、StreamMessage和StreamMessage – 表示发送到 JMS 提供程序或从 JMS 提供程序接收的消息类型。 使用 JMS 发送和接收消息 我们将看到使用 JMS 1.1（经典 API）和 JMS 2.0（简化 API）发送和接收文本消息的简单示例。我建议使用 JMS 2.0 API，本教程将对此进行更多讨论。但是，如果您碰巧使用的是旧版应用程序，最好也关注一下旧版 API。
使用 JMS 1.1 开发客户端 下面是一个示例，演示了如何使用经典 API。它创建一条简单的文本消息并将其发送到队列。然后，消息消费者从同一队列读取同一条消息。
package lab00.classic.helloworld; import javax.jms.*; import javax.naming.InitialContext; import javax.naming.NamingException; public class TestHelloWorldQueue { public static void main(String[] args) throws NamingException { InitialContext initialContext = null; try { initialContext = new InitialContext(); //Step-1 Create ConnectionFactory ConnectionFactory connectionFactory = (ConnectionFactory) initialContext.</description>
    </item>
    <item>
      <title>[译]完整的 JMS 2.0 教程</title>
      <link>https://blog.chensoul.cc/posts/2024/07/23/a-complete-jms-2-0-tutorial/</link>
      <pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/23/a-complete-jms-2-0-tutorial/</guid>
      <description>JMS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。消息传递是在各种应用程序或服务之间交换业务数据的过程。这是一个完整的 JMS 2.0 教程， 其中包含大量代码示例。完整的代码示例可在 GitHub 上找到，请下载并运行示例。本教程使用 Glassfish 开源服务器作为 JMS 提供程序的示例。
您可以使用 ActiveMQ 或 ActiveMQ Artemes 作为 JMS 提供程序，JMS API 保持不变，只有使用相应 JMS 提供程序的 maven 依赖项会发生变化。以下是本教程中涵盖的主题。
代码示例
JMS 简介 – Java 消息服务 为 JMS 安装和设置 Glassfish 在 JMS 中发送和接收消息 JMS 消息模型 JMS 确定消息优先级 JMS 点对点消息传递的实际应用 JMS 发布-订阅消息模型 JMS 消息选择器在过滤消息中的应用 使用 JMS 消息确认保证传送 JMS 事务的实际应用 参考 Apache ActiveMQ Artemis 用户手册 管理和排除 Glassfish JMS 故障 JMS 2.0 中的新增功能 原文链接：A Complete JMS 2.0 Tutorial</description>
    </item>
    <item>
      <title>将 Maven 站点发布到 GitHub Pages</title>
      <link>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</link>
      <pubDate>Thu, 18 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</guid>
      <description>本文源代码：https://github.com/chensoul/maven-site-github-example/ 。
创建 Java Maven 项目 让我们使用 Maven 创建一个简单的 Java 项目
mvn archetype:generate \ -DgroupId=com.mycompany.app \ -DartifactId=maven-site-github-example \ -DarchetypeArtifactId=maven-archetype-quickstart \ -DarchetypeVersion=1.4 \ -DinteractiveMode=false 这将创建包含 Maven 项目的my-app文件夹。让我们进入该文件夹并确保它编译正常：
cd maven-site-github-example mvn clean verify 我们还可以生成该项目的站点：
mvn clean site 该站点将在target/site文件夹中生成，可以使用浏览器打开；例如，让我们打开它的 index.html：
chrome target/site/index.html 创建 github 项目 在你的 github 上创建一个项目 maven-site-github-example，然后在本地的 maven-site-github-example 目录提交代码：
echo &amp;#34;# maven-site-github-example&amp;#34; &amp;gt;&amp;gt; README.md git init git add . git commit -m &amp;#34;first commit&amp;#34; git branch -M main git remote add origin git@github.com:chensoul/maven-site-github-example.git git push -u origin main GitHub Page 设置 现在我们必须在 Git 存储库上创建 gh-pages分支。
git checkout --orphan gh-pages rm .git/index ; git clean -fdx echo &amp;#34;It works&amp;#34; &amp;gt; index.html git add .</description>
    </item>
    <item>
      <title>Spring Boot集成SpringDoc生成Api文档</title>
      <link>https://blog.chensoul.cc/posts/2024/07/10/springdoc-with-spring-boot/</link>
      <pubDate>Wed, 10 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/10/springdoc-with-spring-boot/</guid>
      <description>以下以 Maven 为例介绍 Spring Boot集成SpringDoc生成Api文档。
添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springdoc&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springdoc-openapi-starter-webmvc-ui&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 配置 annotationProcessor，实现通过 javadoc 生成文档。 每个 maven 模块都需要配置：
&amp;lt;properties&amp;gt; &amp;lt;therapi-runtime-javadoc.version&amp;gt;0.15.0&amp;lt;/therapi-runtime-javadoc.version&amp;gt; &amp;lt;maven-compiler-plugin.version&amp;gt;3.13.0&amp;lt;/maven-compiler-plugin.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${maven-compiler-plugin.version}&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;annotationProcessorPaths&amp;gt; &amp;lt;!-- https://springdoc.org/#javadoc-support --&amp;gt; &amp;lt;path&amp;gt; &amp;lt;groupId&amp;gt;com.github.therapi&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;therapi-runtime-javadoc-scribe&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${therapi-runtime-javadoc.version}&amp;lt;/version&amp;gt; &amp;lt;/path&amp;gt; &amp;lt;/annotationProcessorPaths&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; 配置 spring boot 插件，生成 build.properties &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt; &amp;lt;goal&amp;gt;build-info&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; 自动装配 @Configuration(proxyBeanMethods = false) @ConditionalOnProperty(name = SPRINGDOC_ENABLED, matchIfMissing = true) @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) public class SpringdocConfig { @Value(&amp;#34;${server.port}&amp;#34;) private String port; @Value(&amp;#34;${openapi.prod-url:https://localhost}&amp;#34;) private String prodUrl; @Bean public OpenAPI openAPI() { Server devServer = new Server(); devServer.setUrl(&amp;#34;http://localhost:&amp;#34; + port); devServer.setDescription(&amp;#34;Server URL in Development environment&amp;#34;); Server prodServer = new Server(); prodServer.</description>
    </item>
    <item>
      <title>All things about OAuth</title>
      <link>https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/</link>
      <pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/</guid>
      <description>OAuth 是一种开放协议，允许通过网络、移动和桌面应用程序以简单、标准的方式进行安全授权。
OAuth 2 入门 以下是一些 OAuth 2.0 指南，涵盖了理解和实现客户端和服务器所需的许多主题。
OAuth 2.0 简化版 由 Aaron Parecki 编写的*《OAuth 2.0 Simplified*》是一份专注于编写客户端的 OAuth 2.0 指南，它在入门级别上清晰地概述了规范。
角色：应用程序、API 和用户
创建应用程序
授权
：获取访问令牌
Web 服务器应用程序 单页应用程序 移动应用程序 其他的 发出经过身份验证的请求
与 OAuth 1.0 的区别
身份验证和签名 用户体验和替代授权流程 规模性能 资源
OAuth 2.0 服务器 OAuth 2.0 服务器，由Aaron Parecki编写并由Okta发布，是构建 OAuth 2.0 服务器的指南，其中包括许多不属于规范的细节。
代码和库 有多种语言的客户端和服务器库可以帮助您快速入门。
图书 您可以找到一些有关 OAuth 2.0 的优秀书籍。
咨询 寻找一位OAuth 顾问来帮助您的组织。
Spring Authorization Server Spring Authorization Server官方文档
Spring Authorization Server 配置模型
Spring Authorization Server （如何使用具有 PKCE 的单页应用程序进行身份验证-1）
Spring Authorization Server （如何使用具有 PKCE 的单页应用程序进行身份验证-2）
Spring Authorization Server相关文章</description>
    </item>
    <item>
      <title>JWT</title>
      <link>https://blog.chensoul.cc/posts/2024/06/06/jwt/</link>
      <pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/06/jwt/</guid>
      <description>什么是 JWT？ JWT（JSON Web Token）是一种开放标准(RFC 7519)，用于在网络应用程序之间安全地传输信息。它被设计用于在两方之间传输声明，这些声明可以是身份验证和授权信息，也可以是任何其他类型的信息。
设计目的：不需要服务器端存储状态，安全地传递非敏感信息。
JWT 特点 可扩展性：可以在 payload 中携带任意的 JSON 数据 自包含性：所有用户相关信息都在 JWT 中，不需要依赖数据库 无状态性：服务器不需要保存会话状态，提高了系统的可扩展性 跨域支持：可以跨域传递，因为是 JSON 格式 安全性：通过签名确保数据不被篡改 JWT 组成 eyJraWQiOiJmYTNkZmZjMS0xZmQ3LTRhM2QtYTEyMC1mNjY4OWE4NDM5YjQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJjbGllbnQiLCJhdWQiOiJjbGllbnQiLCJuYmYiOjE3MTc1NDk5NDMsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MCIsImV4cCI6MTcxNzU1MDI0MywiaWF0IjoxNzE3NTQ5OTQzLCJqdGkiOiJiMjU0ZGVhMi1kMWE2LTQxNzEtYjEyYy1lNmYzYzZjMDJkMGQifQ.eRiS0H2E-h5PiDEfJikjoPGH1DCqWVt4VIzLtPoSOaIK6jBIaw0h5m-reZVUyZPNYZG68Ymhey17aZBMveirqCxN-lNcPMIGfuqMptfsD9E6Hfam6bEMgpEAOQsQ6Ruk3vGtdmjnEC2h9ZStoqT5-C6JgArwFLGgX92LXrRYz7-60n0I6EAB07u9kxc6FQKLow90RiyXi2YLur-ttOUQpecf8zHi48zRc-HLLoWAMaNddT-4hg4v0Qts4DultpxZB_Xu7DRc91G_8M6sYFSvFSVFHlcWFgKNLZqUYwepLHX2LxoXdbTLGqV9x__-J8UO0TO3TkpC2BaZAiseYcpYMw JWT 主要有以下三个部分通过 base64 加密组成:
Header（头部）：描述 JWT 的元数据，通常包含两部分信息:
声明类型，通常是 &amp;ldquo;JWT&amp;rdquo; 所使用的哈希算法，如 HMAC SHA256 或 RSA Payload（负载）：包含声明，即一些跟当前用户相关的重要信息，如用户 ID、用户角色等。
Signature（签名）：由 header 和 payload 使用密钥进行签名而组成，用于验证消息不被篡改。
HMAC_SHA256( secret, base64urlEncoding(header) + &amp;#39;.&amp;#39; + base64urlEncoding(payload) ) HMAC-SHA256 是一种基于加密哈希函数的消息认证码（HMAC）算法，是对称算法，它结合使用了 HMAC 和 SHA-256 哈希函数。
Header base64解密后：
{ &amp;#34;kid&amp;#34;: &amp;#34;fa3dffc1-1fd7-4a3d-a120-f6689a8439b4&amp;#34;, &amp;#34;alg&amp;#34;: &amp;#34;RS256&amp;#34; } Payload 解密后：
{ &amp;#34;sub&amp;#34;: &amp;#34;client&amp;#34;, &amp;#34;aud&amp;#34;: &amp;#34;client&amp;#34;, &amp;#34;nbf&amp;#34;: 1717549943, &amp;#34;iss&amp;#34;: &amp;#34;http://localhost:8080&amp;#34;, &amp;#34;exp&amp;#34;: 1717550243, &amp;#34;iat&amp;#34;: 1717549943, &amp;#34;jti&amp;#34;: &amp;#34;b254dea2-d1a6-4171-b12c-e6f3c6c02d0d&amp;#34; } JWS 和 JWE JWS（JSON Web Signature）是 JSON Web Token (JWT) 规范的一个子规范，它定义了使用 JSON 数据结构表示签名或未签名的内容。
只对内容做签名，确保其不被篡改，但内容本身并没有加密。 JWS 主要包含以下三个部分:</description>
    </item>
    <item>
      <title>OAuth2和OIDC区别</title>
      <link>https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/</link>
      <pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/</guid>
      <description>认证和授权 认证 (Authentication)：
认证是验证用户、设备或系统身份的过程。 常见的认证方式包括用户名/密码、生物特征(如指纹、人脸)、单点登录(SSO)等。 认证确保只有被授权的实体才能访问系统或资源。 授权 (Authorization)：
授权是确定已认证的实体被允许执行哪些操作或访问哪些资源的过程。 授权通常基于预定义的策略和规则，如角色、权限、访问控制列表(ACL)等。 授权决定了经过身份验证的实体可以执行的操作和访问的资源。 认证和授权的关系：
认证是先决条件，在授权之前必须先完成用户或实体的身份验证。 认证确保只有合法的实体可以访问系统，授权则决定了这些实体可以执行哪些操作。 认证和授权通常结合使用，共同构成完整的访问控制机制。 在实际应用中，认证和授权通常遵循以下流程:
用户或客户端提供身份凭证进行认证。 系统验证用户或客户端的身份，确认其身份有效。 根据已验证的身份，授予用户或客户端相应的访问权限和操作权限。 用户或客户端可以在授权范围内执行操作和访问资源。 OIDC OAuth 2.0 代表开放授权，是一种标准，旨在代表用户提供对资源的同意访问，而无需共享用户的凭据。OAuth 2.0 是一种授权协议，而不是身份验证协议，它主要被设计为授予对一组资源（例如远程 API 或用户数据）的访问权限的一种方式。
OAuth 2.0 仅用于授权，用于授予从一个应用程序到另一个应用程序的数据和功能的访问权限。OpenID Connect (OIDC) 是一个位于 OAuth 2.0 之上的薄层，它添加了有关登录人员的登录和个人资料信息。
​	图片来自Azure 文档
OIDC 的工作原理 授权码流程 要验证用户身份，应用程序首先将用户的浏览器重定向到 OpenID 提供商。OpenID 提供商验证用户身份，并使用授权码将用户的浏览器重定向回应用程序。然后，应用程序使用授权码获取ID Token和Access Token：
隐式流 传统上，无法安全存储机密的应用程序会使用隐式流程。使用此流程不再被视为请求访问令牌的最佳实践。
混合流 混合流程是一种 OpenID Connect 流程，它结合了隐式流程和授权码流程的特征。它使客户端能够直接从授权端点获取一些令牌，同时仍然可以从令牌端点获取其他令牌。
OpenID 演示 您可以使用以下网站来玩自己的：https://openidconnect.net/
OAuth2 和 OIDC OAuth 2.0 和 OpenID Connect (OIDC) 是两个不同但相关的协议，它们之间有以下主要区别:
目的不同： OAuth 2.0 是一种授权框架，目的是授予第三方应用程序有限的访问权限，而不需要共享用户的凭证。 OIDC 是构建在 OAuth 2.0 之上的身份验证协议，目的是提供安全的身份验证和用户信息交换。 认证和授权的区别： OAuth 2.0 主要处理授权，即允许第三方应用程序访问受保护资源的过程。 OIDC 在 OAuth 2.0 的基础上增加了认证功能，即验证用户身份的过程。 返回的数据不同： OAuth 2.0 返回的是访问令牌(Access Token)，用于访问受保护资源。 OIDC 返回的是 ID 令牌(ID Token)，包含了有关已验证用户的声明信息。 协议流程不同： OAuth 2.0 定义了四种授权许可类型，如授权码、隐式、客户端凭证等。 OIDC 在 OAuth 2.</description>
    </item>
    <item>
      <title>[译][译]OAuth2 with Spring 第5部分：使用PKCE保护您的Spring Boot应用程序以增强安全性</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</guid>
      <description>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769
免责声明：本文技术性很强，需要清楚了解本系列前几篇文章，特别是第 1 部分和第 3 部分。
带有代码交换证明密钥 (PKCE) 的授权代码流用于无法存储客户端机密的应用程序。此类应用程序包括：
原生应用程序——可以反编译并检索客户端凭证的移动应用程序。 单页应用 — 整个源代码可在浏览器中使用。因此，无法安全地存储客户端机密。 怎么运行的 Spring Boot OAuth2 与 PKCE
希望这张图已经足够清晰易懂了。因此，我将直接进入演示。
对于此演示，我们有 3 台服务器。
授权服务器：在端口 9001 上运行。 资源服务器：在端口8090上运行。 社交登录客户端（BFF）：在端口 8080 上运行。 让我们看一下代码。
授权服务器 一、pom.xml
授权服务器的 pom.xml 中没有太多需要解释的变化
application.yml.yml
application.yml文件有很多更改，特别是删除了客户端注册。当前版本的application.yml非常简短，如下所示。
server: port: 9001 logging: level: org: springframework: security: trace 三. SecurityConfig 类
所有的安全配置以及客户端和用户详细信息注册、JWT token 解码都放在此类中
@Configuration public class SecurityConfig { // This first SecurityFilterChain Bean is only specific to authorization server specific configurations // More on this can be found in this stackoverflow question answers: // https://stackoverflow.com/questions/69126874/why-two-formlogin-configured-in-spring-authorization-server-sample-code @Bean @Order(1) public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); http.getConfigurer(OAuth2AuthorizationServerConfigurer.class).oidc(withDefaults()); return http .exceptionHandling(e -&amp;gt; e .</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第1部分：了解基本概念</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</guid>
      <description>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a
在本系列关于 Spring 的 OAuth2的文章中，我将尝试介绍和解释与 OAuth2 相关的每一个问题以及如何在 Spring 框架中实现这些问题。请记住，OAuth2 完全是一个概念性的东西，在不同的框架中，它有自己的实现。此外，许多应用程序开发人员开发自己的 OAuth2 实现，而不使用 Spring 框架提供的 OAuth2 框架支持。因此，我将就这个主题撰写一系列文章。
什么是 OAuth2 以及为什么？ 根据Octa的说法，OAuth2 是一种用于身份验证和授权的开放标准。它实际上不是一种服务，但它通过 TLS 提供基于令牌的安全性来保护服务。它使用令牌而不是凭据来授权设备、服务器、API 和应用程序。
OAuth2 的主要目的是让用户能够从单个点或提供商访问多个应用程序，这些应用程序可以使用相同的身份验证和授权信息。这意味着，并不总是需要使用用户 ID 和密码登录。相反，用户将被重定向到拥有用户身份的授权服务器，用户只需单击一下即可允许其他应用程序使用其身份验证信息。一旦获得授权，用户就可以使用来自授权服务器的相同 ID。
OAuth2 参与者和授权类型 a) 参与者
对于 OAuth2 架构，有 4 个参与者 -
资源所有者——在授权服务器中拥有自己的授权信息（通常是用户名、密码、角色等）的用户 客户端——客户端可以被视为资源所有者能够请求资源服务器中受保护资源的应用程序 授权服务器——位于客户端和资源所有者中间，检查身份验证和授权的服务器 资源服务器——包含资源 所有者想要访问的资源。 b) 授权类型
OAuth2 有几种授权类型来请求访问令牌。授权类型的唯一目的是生成访问令牌。授权类型包括：
授权码— 为了接收访问令牌，授权客户端向授权服务器发送请求以及先前从授权服务器收到的授权码。本系列的第 3 部分专门介绍此授权码授予。 **PKCE —**代码交换证明密钥 (PKCE) 是授权代码授予的扩展版本，旨在支持单页应用程序或移动应用程序，以防止 CSRF 或授权代码注入攻击。PKCE 最初旨在保护移动应用程序中的授权代码流，但其防止授权代码注入的能力使其适用于每种类型的 OAuth 客户端，甚至是使用客户端身份验证的 Web 应用程序。本系列的第 5 部分描述了此流程的代码示例。 客户端凭证— 在此流程中，客户端应用程序使用 client_id 和 client_secret 进行请求，授权类型为 client_credential。这通常发生在使用服务的第三方应用程序中。本系列的第 2 部分专门介绍此客户端凭证。 刷新令牌授权— 此授权类型由客户端使用。当访问令牌过期时，存储在客户端内存中的刷新令牌将以授权类型 refresh_token 发送到授权服务器。服务器将返回一个新的 access_token。我们不会专门写一篇文章，因为它主要由应用程序内部处理。 了解接收访问令牌的工作流程 OAuth 工作流
为了请求资源服务器中的某些资源，资源所有者需要访问令牌 资源所有者打开一个应用程序（可能是授权服务器的客户端，在上图中为 BusinessClient）来请求资源服务器中的一些安全资源。 当资源所有者请求没有任何令牌的资源时，他/她可以选择授权服务器。 选择后，客户端将被重定向到授权服务器 (OAuthSercer)。授权服务器要求输入用户名和密码（以及grant_type）。 资源所有者提供所需信息并提交。如果信息真实，授权服务器将访问令牌（以及其他信息，可选）发送给客户端。 客户端保存令牌并在内部创建对资源的请求，这是资源所有者在没有令牌时提出的。 收到令牌后，资源服务器将其发送到授权服务器以验证令牌。 如果授权服务器向资源服务器提供了肯定的响应，资源服务器将响应资源所有者请求的信息。 这就是整个过程的工作原理。在我的下一篇文章中，我将深入研究代码并演示使用内存客户端的 OAuth2 实现。
参考： OAuth2 授权类型 — https://oauth.net/2/grant-types/ OAuth2 角色 - http://websystique.</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第2部分：授权服务器入门</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-2-getting-started-with-authorization-server/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-2-getting-started-with-authorization-server/</guid>
      <description>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-2-getting-started-with-authorization-server-13804910cb2a
Spring 团队最近发布了他们的授权服务器。OAuth2 一直是一个热门话题，而构建或理解授权服务器一直是一个谜。在本系列的第 1 部分中，我描述了几乎所有您需要了解的有关 OAuth2 的概念性内容。在本系列的这篇文章中，我将尝试演示如何构建具有client_credential授权类型的授权服务器。我将从使用配置属性进行自动配置开始解释它们，并通过编写 Java 代码自定义配置。让我们开始吧。
设置授权服务器 让我们转到Spring Initializr并生成项目。
为了创建授权服务器，我们需要 Oauth2 授权服务器依赖。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-oauth2-authorization-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 生成项目并导入到您最喜欢的 IDE。
现在让我们在application.yml中添加我们想要的配置。
在第 1 部分中，我们了解到我们需要一个客户端来从授权服务器获取令牌。因此，我们需要授权服务器有一些客户端信息。在 application.yml 中，我将放置获取令牌和其他授权信息所需的最少客户端信息。
spring: security: oauth2: authorization-server: client: client-1: registration: client-id: client client-secret: &amp;#34;{noop}secret&amp;#34; client-authentication-methods: client_secret_basic authorization-grant-types: client_credentials 根据上面的配置属性，我们注册了一个客户端client-1。
对于client-1，我们定义了 4 个属性：
clientId client-secret client-authentication-methods：本例中为基本身份验证（client_secret_basic） authorization-grant-types：用于请求新令牌的授予类型。在本例中为 client_credentials。 现在，我们必须启动授权服务器应用程序。
接下来，在 postman 中，我们向*/oauth2/token端点发出 POST 请求以获取令牌。为什么是/oauth2/token*端点？
我们可以看到，一旦我们提交请求，我们就会收到详细的令牌信息。
瞧，我们最小的授权服务器现在已经启动并运行了。
该项目的链接可以在这里找到。
问题 1. 我们在哪里找到默认令牌端点？
答：在 OAuth2 的 RFC 中，它提到默认令牌端点应该是*/token*。但是，很难找到 Spring Boot 授权服务器的默认令牌端点。我不得不浏览源代码。在类OAuth2TokenEndpointFilter中，提到了默认令牌端点。
感谢您的耐心阅读。在下一篇文章中，我们将尝试创建一个资源服务器，使用authorization_code授权获取令牌以访问一些私人数据。</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</guid>
      <description>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a
在上一篇文章中，我们讨论了使用 client_credential 的 OAuth2 授权服务器配置。在本文中，我们将讨论使用 authorization_code 授予类型的授权服务器配置。此授权流程将有一个 OIDC 客户端，它将通过使用授权码进行请求来获取 JWT 令牌。
如今，社交登录非常流行，它已由 OAuth2 和 OIDC 规范标准化。我们今天的讨论主题是设置我们的社交登录客户端 (oidc-client) 应用程序，将其注册到 Spring Boot 授权服务器，使用授权服务器登录并从 OIDC 客户端应用程序访问安全资源。
今天的演示将包含 2 个应用程序：
授权服务器（端口 8080） 社交登录客户端（端口 8081） 由于这是一个复杂的主题，让我们首先查看 UI 中的应用程序身份验证和授权流程，然后再讨论配置。
要继续阅读本文，请从此处获取项目源代码。首先启动授权服务器应用程序，然后在您最喜欢的 IDE 上启动社交登录客户端应用程序。
我们的社交登录客户端有 2 个端点：
“/” 将使我们能够访问公共数据 “/private-data” 将为我们提供 JWT 令牌 在浏览器上，导航到“ http://127.0.0.1:8081/private-data ”。这将带我们进入客户端应用程序的登录页面。
由于我们对社交登录感兴趣，因此不要在此登录页面中输入您的用户名和密码，而是单击oidc-client。它将带您进入授权服务器的登录页面。
在下面的屏幕中输入“ user”作为用户名，输入“ secret”作为密码，然后单击“登录”。
这将带您进入同意页面。请注意同意页面的以下 URL：
http://localhost:8080/oauth2/authorize?response_type=code&amp;amp;client_id=oidc-client&amp;amp;scope=openid%20profile%20read%20write&amp;amp;state=PcF7UjHDmYvmhwpKfv9zVosy0ZBIA2pZe7HHPixZ76E%3D&amp;amp;redirect_uri=http://127.0.0.1:8081/login/oauth2/code/oidc-client&amp;amp;nonce=_KHIsN6mNur-AFQz5KNK0TnZi3VPmj567qbe8-4zPMo&amp;amp;continue
从上面的URL我们可以找到几条信息：
response_type=code client_id=oidc-client scope = openid, profile, read, write redirect_uri=http://127.0.0.1:8081/login/oauth2/code/oidc-client 现在，从上面的页面提供您想要允许客户端应用程序的同意。
如果最初请求的URL（/private-data）具有您刚刚提供的正确同意，它将向我们提供访问令牌和刷新令牌，否则它将显示403错误页面。
现在让我们深入研究代码。
授权服务器配置 在这个应用程序中，所有的事情都在 application.yml 文件中完成。Java 方面没有什么内容，除了主类。
spring: security: user: # Definition of the user details that we will use for login # in the authorization server name: user password: &amp;#34;{noop}secret&amp;#34; roles: USER # Oauth2 client registration starts from here oauth2: authorization-server: client: # We have defined only one client: oidc-client # This client information was also mentioned # in the above URL: client_id=oidc-client oidc-client: registration: # The following client ID and client secret will be matched with the # provided client credentials from client application client-id: oidc-client client-secret: &amp;#34;{noop}secret2&amp;#34; # The following authorization-grant-type will be matched with the # provided authorization-grant-type from the client application authorization-grant-types: - &amp;#34;authorization_code&amp;#34; - &amp;#34;refresh_token&amp;#34; client-authentication-methods: - client_secret_basic # This following redirect URI will be used to redirect the resource owner to the # Client application after the resource owner (user) provides necessary consents.</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第4部分：Spring授权客户端与Google授权服务器的社交登录演示</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</guid>
      <description>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5
在之前的文章中，我们学习了如何使用 OIDC 连接到我们自己的授权服务器。我们在自托管授权服务器中定义了我们自己的客户端应用程序。在今天的文章中，我们将使用 Google 和 GitHub 作为我们的授权服务器，并将我们的授权客户端应用程序连接到这些授权服务器并从它们接收令牌。应用程序登录屏幕将如下所示。
为了实现这一点，我们需要将我们的授权客户端应用程序注册为 Google 授权服务器中的客户端，并使用客户端应用程序中的客户端凭据以及可用范围。
Google 授权服务器中的客户端注册 我们需要在 Google 开发者控制台中创建一个应用程序并配置必要的内容。
打开浏览器并转到https://console.developers.google.com/。您将看到如图 1 所示的屏幕。
图。1
从这里，选择下拉菜单以选择一个项目（1.1）。它将显示一个像上面一样的弹出窗口。从弹出窗口中，单击**“新建项目”按钮（1.2）。由于我已经创建了我的应用程序并将我的应用程序命名为google-auth-server-demo（1.3），所以我不会再创建新的应用程序了。
创建应用程序后，从上面的屏幕中选择您的应用程序，您将看到仪表板。从左侧导航中，单击API 和服务和页面。由于我们目前对列表中的任何 Google 服务都不感兴趣，我们可以单击左侧导航中的凭据 (2.1) 。但如果您有兴趣从客户端应用程序中使用任何 Google 服务，您可能会发现这篇文章很有趣，我在其中演示了如何访问 Google Drive 数据。
图 2
它将带我们进入以下页面。
图 3
从这里，我们可以创建新的凭证 (3.1)。由于我们已经创建了凭证 (3.2)，我们可以编辑它 (3.3) 以查看我们如何配置它。
图 4
在客户端注册页面，我们配置了客户端名称（4.1）、授权 JS 来源（4.2）以注册以应对 CORS 安全问题，授权重定向 URI（4.3）。当我们第一次点击保存按钮（4.4）时，它会为我们生成客户端 ID（4.5）和客户端密钥（4.6）。
我们需要在客户端应用程序的配置文件即application.yml中使用这些客户端ID、客户端密钥和重定向URI。
在授权客户端 application.yml 文件中使用上述信息：
该配置与我们第 3 部分的客户端配置部分非常相似。
spring: security: oauth2: client: registration: google: client-id: &amp;#34;615531537634-806j95c1s18uundif9nl4oggcag7lcm6.apps.googleusercontent.com&amp;#34; client-secret: &amp;#34;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&amp;#34; redirect-uri: &amp;#34;{baseUrl}/login/oauth2/code/{registrationId}&amp;#34; 现在，我们需要在 Google 授权服务器中设置同意屏幕，以允许客户端应用程序请求所需的范围。
要进入同意屏幕，我们需要单击左侧导航栏中的Oauth 同意屏幕（5.1）。
图 5
我已经创建了同意屏幕，所以让我们通过编辑应用程序看看我做了什么（5.2）
图 6
此屏幕已在屏幕右侧详细记录（6.1）。遵循这些准则并保存以继续执行步骤 2：范围（6.2）
图 7
在上面的屏幕上，单击**“添加或删除范围”按钮 (7.1)，右侧会打开一个弹出窗口。从这个弹出窗口中，我们为我们的演示 (7.2) 选择了几个最低要求的范围，然后单击“更新”**按钮 (7.3)。更新后，这些范围将显示在图 7 的 (7.4) 部分中。
当我们从此范围步骤单击**“保存并继续”**按钮时，我们可以从客户端应用程序添加一些测试用户来测试。
图 8
为了测试目的，我们只允许 2 个用户（8.1）。
现在，一旦我们保存了步骤 3 和步骤 4，我们就可以准备在客户端应用程序中使用这些范围了。</description>
    </item>
    <item>
      <title>[译]OAuth2.0服务器</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-server/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-server/</guid>
      <description>背景 前言 作者：Aaron Parecki
我第一次接触 OAuth 是在 2010 年，当时我正在构建一个 API，我知道我希望第三方开发人员能够在其基础上构建应用程序。当时，OAuth 看起来令人生畏。OAuth 1 的实现只有少数几个，而 OAuth 2.0 仍是一个草稿。一天晚上，我决定坐下来，拿着精酿啤酒和最新草案的纸质副本，从头到尾阅读它，直到我理解它。
在仔细阅读了长达 44 页的规范后，我学到了以下几点：阅读规范并不是了解 OAuth 工作原理的最佳方式，而且 OAuth 2.0 远没有我最初想象的那么复杂。我开始撰写一份简化的规范概述，当我第一次学习这个规范时，我希望它就存在。我将其作为一篇名为“OAuth 2.0 简化版”的博客文章发布在我的网站上。现在，这篇文章每年的阅读量达到数十万次。很明显，人们知道 OAuth 2.0 是保护其 API 的正确选择，并且正在寻找资源来帮助理解它。
我一直想将这篇博文扩展为更全面的 OAuth 服务器指南，2016 年，我与 Okta 取得了联系，我们在oauth.com上发布了这个新 OAuth 指南的第一个版本。2017 年，我们合作出版了这本书的印刷版，并于 2018 年和 2020 年出版了修订版。
我希望这本书能让 OAuth 2.0 更加平易近人，并为您在继续使用 Web 技术时提供坚实的知识基础。
背景 在 OAuth 出现之前，向第三方应用授予您帐户访问权限的常见模式是简单地向其提供您的密码并允许其以您的身份行事。我们经常在 Twitter 应用中看到这种情况，这些应用会要求您提供 Twitter 密码，以便向您提供一些帐户统计数据，或者要求能够从您的帐户发送推文以换取一些有价值的东西。
这种应用程序获取用户密码的模式显然存在许多问题。由于应用程序需要以用户身份登录服务，因此这些应用程序通常会以纯文本形式存储用户的密码，这使它们成为密码窃取的目标。一旦应用程序获得了用户的密码，它就可以完全访问用户的帐户，包括访问更改用户密码等功能！另一个问题是，在向应用程序提供密码后，您能够撤销该访问权限的唯一方法是更改密码，而用户通常不愿意这样做。
自然，许多服务很快意识到了这种模式的问题和局限性，并寻求快速解决。许多服务实现了类似于 OAuth 1.0 的东西。Flickr 的 API 使用了所谓的“FlickrAuth”，它使用了“frobs”和“tokens”。谷歌创建了“AuthSub”。Facebook 选择向每个应用程序发布一个秘密，并要求应用程序使用该秘密的 md5 哈希对每个请求进行签名。雅虎创建了“BBAuth”（基于浏览器的身份验证）。结果产生了各种各样的解决方案，彼此完全不兼容，并且经常无法解决某些安全问题。
2006 年 11 月左右，Twitter 首席架构师布莱恩·库克 (Blaine Cook) 正在寻找一种更好的 Twitter API 身份验证方法，这种方法不需要用户向第三方应用程序透露他们的 Twitter 密码。
我们想要类似 Flickr Auth / Google AuthSub / Yahoo! BBAuth 的东西，但以开放标准的形式发布，具有通用的服务器和客户端库等。
– 布莱恩·库克，2007 年 4 月 5 日
2007 年，一群致力于 OpenID 开发的人员聚在一起，创建了一个邮件列表，旨在制定 API 访问控制标准提案，该提案可供任何系统使用，无论其是否使用 OpenID。最初的这个小组包括 Blaine Cook、Kellen Elliott-McCrea、Larry Halff、Tara Hunt、Ian McKeller、Chris Messina 和其他一些人。</description>
    </item>
    <item>
      <title>[译]OAuth2简化版</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth-2-simplified/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth-2-simplified/</guid>
      <description>这篇文章以简化的格式描述了 OAuth 2.0，以帮助开发人员和服务提供商实现该协议。
OAuth 2 规范读起来可能有点混乱，所以我写了这篇文章来帮助以简化的格式描述术语。核心规范将许多决策留给实现者，通常基于实现的安全权衡。这篇文章没有描述成功实施 OAuth 2 所需的所有可能决策，而是做出适用于大多数实现的决策。
注意：本文已根据 OAuth 2.0 的当前最佳实践从原始 2012 版本更新而来。原始版本可以在这里找到。
角色 第三方应用程序：“客户端” 客户端是尝试访问用户帐户的应用程序。它需要先获得用户的许可，然后才能执行此操作。
API：“资源服务器” 资源服务器是用于访问用户信息的 API 服务器。
授权服务器 这是提供用户批准或拒绝请求的接口的服务器。在较小的实现中，这可能与 API 服务器是同一台服务器，但更大规模的部署通常会将其构建为单独的组件。
用户：“资源所有者” 资源所有者是授予访问其帐户某些部分的权限的人员。
创建应用程序 在开始 OAuth 过程之前，必须先向服务注册新应用。注册新应用时，通常会注册应用名称、网站、徽标等基本信息。此外，还必须注册一个重定向 URI，用于将用户重定向到 Web 服务器、基于浏览器的应用程序或移动应用程序。
重定向 URI 该服务只会将用户重定向到已注册的 URI，这有助于防止某些攻击。任何 HTTP 重定向 URI 都必须通过 HTTPS 提供。这有助于防止令牌在授权过程中被截获。本机应用可能会使用应用程序的自定义 URL 方案注册重定向 URI，这可能类似于 demoapp://redirect .
客户端 ID 和密码 注册应用后，你将收到一个客户端 ID 和一个（可选）的客户端密码。客户端 ID 被视为公共信息，用于构建登录 URL，或包含在页面上的 Javascript 源代码中。客户端密码必须保密。如果已部署的应用无法对机密保密，例如单页 Javascript 应用或本机应用，则不会使用该密钥，理想情况下，该服务首先不应向这些类型的应用发布机密。
授权 OAuth 2 的第一步是从用户那里获得授权。对于基于浏览器或移动的应用程序，这通常是通过向用户显示服务提供的界面来实现的。
OAuth 2 为不同的用例提供了几种“授权类型”。定义的授权类型包括：
Authorization Code 在 Web 服务器、基于浏览器的应用程序和移动应用程序上运行的应用程序的授权代码
Password 使用用户名和密码登录的密码（仅适用于第一方应用）
Client credentials 在没有用户在场的情况下进行应用程序访问的客户端凭据
Implicit 隐式以前被推荐给没有秘密的客户端，但已被使用授权代码授予与PKCE取代。
下面将详细介绍每个用例。
Web 服务器应用程序 Web 服务器应用程序是您在处理 OAuth 服务器时遇到的最常见的应用程序类型。Web 应用程序是用服务器端语言编写的，并在应用程序源代码不向公众开放的服务器上运行。这意味着应用程序在与授权服务器通信时能够使用其客户端密钥，这有助于避免许多攻击媒介。
授权 创建一个“登录”链接，将用户发送到：
https://authorization-server.com/auth?response_type=code&amp;amp; client_id=CLIENT_ID&amp;amp;redirect_uri=REDIRECT_URI&amp;amp;scope=photos&amp;amp;state=1234zyx response_type=code 指示您的服务器希望收到授权代码 client_id 首次创建应用程序时收到的客户端 ID redirect_uri 示授权完成后要将用户返回到的 URI scope 一个或多个范围值，指示您希望访问用户帐户的哪些部分 state 应用程序生成的随机字符串，稍后将对其进行验证 用户看到授权提示</description>
    </item>
    <item>
      <title>RFC6749 | OAuth2.0授权框架中文版</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2/</guid>
      <description>前言 摘要 OAuth2.0 授权框架允许第三方应用获取对 HTTP 服务的有限的访问权限，既可以以资源所有者名义在资源所有者和 HTTP 服务之间进行允许的交互，也可以允许第三方应用以自己的名义进行访问。本规范取代并淘汰 RFC 5849 中描述的 OAuth 1.0 协议。
本备忘录状态 这是一个互联网标准化过程文档。
本文档是互联网工程任务组（IETF）的作品。它代表了 IETF 社区的一致看法。它已接受公开审阅并由互联网工程指导小组（IESG）批准公布。有关互联网标准的进一步信息可在 RFC 5741 的第 2 节找到。
有关本文档的当前状态、勘误表以及如何对它提供反馈可参见 http://www.rfc-editor.org/info/rfc6749。
版权声明 IETF 信托及标识为本文档的作者的个人版权所有（c）2012。保留所有权利。
本文档受 BCP78 和 IETF 信托有关 IETF 文档的法律条款 (http://trustee.ietf.org/license-info)的约束，自本文档发布之日起生效。请仔细查阅这些文件，因为它们描述了与本文档有关的权利和限制。从本文档中提取的代码片段必须按信托法律条款 4.e 节所述包括简化 BSD 许可证文本；并且按简化 BSD 许可证中所述不附带质量保证。
目录 [toc]
1. 简介 在传统的客户端-服务器身份验证模式中，客户端请求服务器上限制访问的资源（受保护资源）时，需要使用资源所有者的凭据在服务器上进行身份验证。资源所有者为了给第三方应用提供受限资源的访问，需要与第三方共享它的凭据。 这造成一些问题和局限：
需要第三方应用存储资源所有者的凭据，以供将来使用，通常是明文密码。 需要服务器支持密码身份认证，尽管密码认证天生就有安全缺陷。 第三方应用获得的资源所有者的受保护资源的访问权限过于宽泛，从而导致资源所有者失去对资源使用时限或使用范围的控制。 资源所有者不能在不撤销对所有第三方的访问权限的情况下撤销对单个第三方的访问权限，而且必须通过更改第三方的密码来这样做。 与任何第三方应用的让步导致对终端用户的密码及该密码所保护的所有数据的让步。 OAuth 通过引入授权层以及分离客户端角色和资源所有者角色来解决这些问题。在 OAuth 中，客户端在请求受资源所有者控制并托管在资源服务器上的资源的访问权限时，将被颁发一组不同于资源所有者所拥有凭据的凭据。
客户端获得一个访问令牌（一个代表特定作用域、生命期以及其他访问属性的字符串），用以代替使用资源所有者的凭据来访问受保护资源。访问令牌由授权服务器在资源所有者认可的情况下颁发给第三方客户端。客户端使用访问令牌访问托管在资源服务器的受保护资源。
例如，终端用户（资源所有者）可以授权一个打印服务（客户端）访问她存储在图片分享服务（资源服务器）上的受保护图片，而无需与打印服务分享自己的用户名和密码。反之，她直接与图片分享服务信任的服务器（授权服务器）进行身份验证，该服务器颁发给打印服务具体委托凭据（访问令牌）。
本规范是为 HTTP（[RFC2616]）协议定制。在任何非 HTTP 协议上使用 OAuth 不在本规范的范围之内。
OAuth 1.0 协议（[RFC5849]）作为一个指导性文档发布，是一个小社区的工作成果。本标准化规范在 OAuth 1.0 的部署经验之上构建，也包括其他使用案例以及从更广泛的 IETF 社区收集到的可扩展性需求。OAuth 2.0 协议不向后兼容 OAuth 1.0。这两个版本可以在网络上共存，实现者可以选择同时支持他们。然而，本规范的用意是新的实现支持按本文档指定的 Auth 2.0，OAuth 1.0 仅用于支持现有的部署。OAuth 2.0 协议与 OAuth 1.0 协议实现细节没有太多关联。熟悉 OAuth 1.0 的实现者应该学习本文档，而不对有关 OAuth 2.0 的结构和细节做任何假设。
1.1. 角色 OAuth 定义了四种角色：
资源所有者
能够授予对受保护资源访问权限的实体。当资源所有者是一个人时，它被称为终端用户。
资源服务器</description>
    </item>
    <item>
      <title>[译]使用 Spring Boot 构建 RESTful API：集成 DDD 和六边形架构</title>
      <link>https://blog.chensoul.cc/posts/2024/05/30/building-a-restful-api-with-spring-boot-integrating-ddd-and-hexagonal-architecture/</link>
      <pubDate>Thu, 30 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/30/building-a-restful-api-with-spring-boot-integrating-ddd-and-hexagonal-architecture/</guid>
      <description>原文链接：Building a RESTful API with Spring Boot: Integrating DDD and Hexagonal Architecture
介绍 在快节奏的软件开发世界中，API 扮演着至关重要的角色，可以有效地促进不同系统之间的交互和数据交换。API 创建最突出的技术之一是 Spring Boot，它是一种强大的工具，可以简化 Java 应用程序的开发，使开发人员可以专注于业务逻辑而不是环境设置。
在本文中，我们将探讨如何使用 Spring Boot 设计和构建 RESTful API，但我们将超越单纯的开发。我们将集成领域驱动设计 (DDD) 和六边形架构等高级概念，这些概念对于创建强大、可扩展且易于维护的应用程序至关重要。这些方法不仅可以改善代码结构和关注点分离，还可以促进技术团队和利益相关者之间的协作，使软件设计与业务需求保持一致。
在本文中，我们将把这些复杂的概念分解为简单的解释和实际示例，确保即使是初学者也可以遵循这些高级实践并将其应用到自己的项目中。无论您是希望增强应用程序架构的经验丰富的开发人员，还是 Spring Boot 世界的新手，您都可以在本文中找到适合您的开发需求的宝贵经验和技巧。
让我们深入了解构建 API 的迷人过程，该 API 不仅运行良好，而且从概念到实现都设计精良。
第 0 节：什么是 REST API？ 什么是 API？ API（应用程序编程接口）是一组规则和规范，允许不同的应用程序或软件组件相互交互。它充当中介，使开发人员能够访问软件服务中的特定功能或数据，而无需了解该软件的内部细节。
REST API 的起源 REST（表述性状态转移）架构由 Roy Fielding 于 2000 年在其博士论文中定义。REST 是一套原则，概述了应如何设计客户端和服务器之间的交互。它的创建是出于对标准的需求，该标准可以提高互联网通信的可扩展性，从而提供比当时可用的接口（例如被认为过于复杂和僵化的 SOAP）更简单、更高效的接口。
REST 旨在解决什么问题？ REST 的出现是为了应对现有架构的复杂性，这些复杂性使 Web 应用程序的开发和可扩展性变得复杂。通过采用无状态模型并使用标准 HTTP 方法（GET、POST、PUT、DELETE），REST 简化了客户端与服务器交互的实现。这种简单性使开发人员能够创建更高效、更易于维护的 Web 和移动应用程序。
REST基于六个基本原则：
**统一接口：**确保客户端和服务器之间的接口一致、标准化。 **无状态：**每个客户端对服务器的请求都必须包含理解和完成请求所需的所有信息。 **可缓存：**响应必须隐式或显式地定义它们是否可缓存。 **分层系统：**客户端不需要知道它是直接与终端服务器通信还是与中介通信。 **客户端-服务器：**用户界面（客户端）和数据存储（服务器）之间的职责分离，通过简化服务器组件增强了用户界面跨多个平台的可移植性和可扩展性。 **按需代码（可选）：**服务器可以通过发送可执行代码来扩展或定制客户端的功能。 结合这些原则不仅解决了可扩展性和维护问题，而且还促进了更为健壮、交互和高效的 Web 应用程序的创建。
现在，如果你已经读到这里，你可能会想，“HTTP 到底是什么？”好吧，让我们开始吧。
HTTP 简介 HTTP（超文本传输协议）是互联网工程任务组（IETF）定义的网络交互中使用的底层协议。它是浏览器（客户端）和网络服务器之间传输数据的手段。该协议基于请求-响应模型，对于 RESTful 通信至关重要，因为它的方法促进了 REST API 中基本的 CRUD（创建、读取、更新、删除）操作。
HTTP 方法及其使用时机 HTTP 方法定义您想要对已识别的资源执行的操作。以下是 REST API 中最常用的方法：
**GET：**用于从服务器检索信息。它不应修改资源的状态，因此非常适合无副作用的读取操作。示例：获取用户列表或特定用户的详细信息。 **POST：**用于创建新资源。当请求结果导致服务器状态改变或产生副作用时，此方法非常有用。例如：添加新用户。 **PUT：**用于更新/替换现有资源。在请求中发送完整实体很重要。示例：更新现有用户的姓名和年龄。 **DELETE：**用于删除资源。例如：删除用户。 **PATCH：**与 PUT 不同，PATCH 用于对资源进行部分更新。例如：仅更新用户的名称而不触及其他字段。 HTTP 方法的最佳实践 在设计 RESTful API 时，遵循一些最佳实践以确保 API 易于理解和使用至关重要：</description>
    </item>
    <item>
      <title>[译]如何组织代码</title>
      <link>https://blog.chensoul.cc/posts/2024/05/30/how-to-structure-our-code/</link>
      <pubDate>Thu, 30 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/30/how-to-structure-our-code/</guid>
      <description>原文链接：How to Structure Code
软件设计最佳实践，逐层发现包、按功能发现包以及六角形架构/端口和适配器。
在这篇博文中，我将探讨如何构建我们的代码并讨论最佳实践，涵盖三种不同的方法：按层打包、按功能打包以及六边形架构/端口和适配器及其优缺点。
在探索构建代码的不同方法之前，我们需要了解基本的软件设计原则：
内聚力：指模块内各类之间的相互关联程度。 耦合度：指不同模块之间的依赖程度。 模块化：指软件系统被划分为独立模块的程度。每个模块都封装了一组特定的功能，并设计为独立工作，同时通过明确定义的接口相互交互。 抽象：隐藏实现细节并仅通过接口公开必要的功能。 关注点分离：设有不同的部分，每个部分解决一个特定的关注点。 封装：将数据和方法捆绑到单个模块或类中以隐藏内部细节。 让我们仔细看看内聚力和耦合力？
内聚力描述了软件的集中程度。它与单一责任原则密切相关。
高内聚力意味着模块内的类紧密相关并具有共同的、明确定义的目的。 低内聚力意味着模块内的类之间关系松散，缺乏明确的目的且职责不相关。 要遵循的最佳实践是实现模块之间的高内聚和松散耦合。
松耦合被认为是结构良好和设计良好的计算机系统的标志，与高内聚力相结合，可带来较高的可读性和可维护性。
现在，让我们探索构建代码的不同方式。首先，我将逐层介绍包，然后逐功能介绍包，并比较两者。之后，我们将探索端口和适配器模式。
层封装 它代表一个项目结构，其中类被组织成多个层，每个层负责一组特定的功能。
src ├── main │ ├── java │ │ └── com │ │ └── app │ │ ├── service │ │ │ └── UserService.java │ │ │ └── OrderService.java │ │ │ └── ProductService.java │ │ ├── domain │ │ │ └── User.java │ │ │ └── Order.java │ │ │ └── Product.java │ │ ├── repository │ │ │ └── UserRepository.java │ │ │ └── OrderRepository.java │ │ │ └── ProductRepository.java │ │ ├── controller │ │ │ └── UserController.</description>
    </item>
    <item>
      <title>All things about WebSocket</title>
      <link>https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/</guid>
      <description>Wikipedia：WebSocket
WebSocket - Web APIs | MDN
PubNub：什么是 WebSocket？
What are WebSockets?
websocket protocol - RFC6455 - tools.ietf.org
WebSocket
Ably：What are WebSockets used for? Pusher：What are WebSockets?
WebSocket vs. HTTP communication protocols
What are WebSockets? | Web Security Academy
Educative：What is WebSocket?
Spring：WebSocket
Writing a WebSocket server in Java - Web APIs
Baeldung：A Guide to the Java API for WebSocket
Baeldung：A Java Client for a WebSockets API
WebSocket Implementation with Spring Boot and STOMP
ApiFox：WebSocket协议入门到精通
JSR 356, Java API for WebSocket
WebSocket 协议解析 [RFC 6455]
WebSocket原理及技术简介
【NO.23】一篇文章彻底搞懂websocket协议的原理与应用（一）
WebSocket 协议详解
WebSocket 协议（RFC 6455 中文版）
用JAVA分别实现WebSocket客户端与服务端
WebSocket Programming with Java
MQTT Websocket Client</description>
    </item>
    <item>
      <title>All things about Spring Modulith</title>
      <link>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</link>
      <pubDate>Thu, 09 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</guid>
      <description>VMware 推出了一个实验性的项目Spring Modulith，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。
2022 年 11 月推出的Spring Boot 3会是 Spring Modulith 的基础。所以它的基线是 Spring Framework 6、Java 17 和 Jakarta EE 9。Spring Modulith 是Moduliths（其名字有个“s”后缀）项目的继承者。该项目使用 Spring Boot 2.7，目前已经退役，只接收缺陷修正，直至 2023 年 11 月份。
https://spring.io/blog/2022/10/21/introducing-spring-modulith
https://www.baeldung.com/spring-modulith
https://www.baeldung.com/spring-modulith-event-externalization
https://piotrminkowski.com/2023/10/13/guide-to-modulith-with-spring-boot/
https://springdoc.cn/guide-to-modulith-with-spring-boot/
https://medium.com/andamp/event-sourcing-with-spring-modulith-2b35b0569dbb
https://www.geeksforgeeks.org/what-is-spring-modulith/
https://github.com/xsreality/spring-modulith-with-ddd
https://riteshshergill.medium.com/the-spring-modulith-monolithic-but-manageable-ca1532a1e585
https://www.infoq.com/news/2022/11/spring-modulith-launch/
https://dzone.com/articles/architecture-style-modulith-vs-microservices
https://speakerdeck.com/olivergierke/spring-modulith-a-deep-dive
https://www.jappware.com/proffesional-activity/make-monolithic-apps-great-again-with-spring-modulith-coffeejug/
https://blog.worldline.tech/2024/01/23/modulith.html
https://springdoc.cn/spring-modulith-intro/
https://dimitri.codes/checking-out-spring-modulith/
https://www.lefer.cn/posts/29752/
https://www.jdon.com/63003.html
https://blog.csdn.net/cfy_banq/article/details/132185951
https://www.zhihu.com/question/567053421</description>
    </item>
    <item>
      <title>[译]探索 http2（第 1 部分）：概述</title>
      <link>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/</link>
      <pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/</guid>
      <description>原文链接：https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f
让我们来谈谈 http2 的内容、原因、时间和方式
完整的代码可以在github上找到。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
什么是http2？ **http2*是自 1999 年以来使用的http1.1***之后的最新更新
http2协议注重性能；具体来说，最终用户感知的延迟、网络和服务器资源的使用情况。 （在此处阅读有关规格的信息*）*
为什么是http2？ 换句话说http1.1有什么问题
加载网页是一项资源密集型工作，因为 HTTP/1.1 只允许每个 TCP 连接有一个未完成的请求。网络需要进行更新，以提高效率、安全性和速度。
http2如何解决性能问题？
http2 带来的改进：
**单一连接：**仅使用一个与服务器的连接来加载网站，并且只要网站打开，该连接就保持打开状态。这减少了建立多个 TCP 连接所需的往返次数。（更多信息在这里） **多路复用：**同一连接上同时允许多个请求。以前，在 HTTP/1.1 中，每个传输都必须等待其他传输完成。（更多信息在这里） **服务器推送：**可以将其他资源发送到客户端以供将来使用。（更多信息在这里） **优先级：**请求被分配依赖级别，服务器可以使用它来更快地交付更高优先级的资源。（更多信息在这里） **二进制：**使 HTTP/2 更易于服务器解析、更紧凑且不易出错。将信息从文本转换为二进制不会浪费额外的时间。（更多信息在这里） 标头压缩： HTTP/2 使用HPACK压缩，从而减少开销。在 HTTP/1.1 中，每个请求中的许多标头都使用相同的值发送。（更多信息在这里） 我们什么时候可以开始使用http2？ 现在！
这是时间线，
来源：https://www.polyglotdeveloper.com/
是的，从 1999 年到今天，我们（大多数）都在使用同样好的旧 http1.1； 15年！
如何开始使用http2？ 以下是各种语言的 http2 库实现列表。
根据Can I Use的统计，大约 83% 的在线浏览器已经支持 http2
查看实际情况，http1.1 与 http2（网络节流：快速 3g）
http1.1（左）与http2（右）；让我们在下一节中构建它
在下一部分中，我们将构建一个支持 http2 的简单服务器；具有http1.1向后兼容性；一步一步使用http2-node core 和hapi js。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
完整的代码可以在github上找到。</description>
    </item>
    <item>
      <title>[译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</title>
      <link>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/</link>
      <pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/</guid>
      <description>原文链接：https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249
来源：https://www.thewebmaster.com/
先决条件：了解 javascript、客户端-服务器架构。
完整的代码可以在github上找到。
第 1 部分：概述（http2 的原因、内容、时间、方式）第 2 部分：使用 node-http2 核心和 hapijs 进行探索
免责声明：本文将使用node@v9+附带的http2模块。这里列出了其他几个 http2 客户端-服务器库实现。
让我们开始创建一个具有单一路由的简单 http1.1 服务器。
mkdir hapijs-http2 &amp;amp;&amp;amp; \ cd hapijs-http2 &amp;amp;&amp;amp; \ npm init -y &amp;amp;&amp;amp; \ npm i hapi@^16.6 -s &amp;amp;&amp;amp; \ touch http1Server.js 将下面的代码复制到此处或从此处http1Server.js克隆整个存储库。
const Hapi = require(&amp;#39;hapi&amp;#39;); const server = new Hapi.Server(); // define server config server.connection({ port: &amp;#39;8000&amp;#39; }); // define route config server.route([{ method: &amp;#39;GET&amp;#39;, path: &amp;#39;/ping&amp;#39;, handler: (request, reply) =&amp;gt; { reply(&amp;#39;pong&amp;#39;); } }]); // start server server.start(err =&amp;gt; { if (err) console.error(err) console.log(`Started ${server.connections.length} connections`) }); 现在，让我们进行健全性检查。
启动服务器，node http1Server.js
⇒ http://127.0.0.1:8000/ping pong 凉爽的！如果我们得到 pong 的 ping，让我们尝试将http2集成到我们的 hapijs 服务器中。</description>
    </item>
    <item>
      <title>[译]比较 Socket.IO 和 HTTP：主要区别和用例</title>
      <link>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</link>
      <pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</guid>
      <description>原文链接：https://ably.com/topic/socketio-vs-http
在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。
什么是Socket.IO？ Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。
Socket.IO 需要两个库 - 一个在服务器上，一个在客户端上。 Socket.IO 创建者维护以下“官方”：
Socket.IO是 Node.js 服务器组件。 Socket.IO-client是客户端 JavaScript 库。 一些 Socket.IO 客户端和服务器实现可以用其他语言实现。请阅读Socket.IO 是什么来获取列表。
下图总结了典型的 Socket.IO 设置：
Socket.IO 主要特性 Socket.IO 具有以下主要特性：
**向后兼容性：**在现代浏览器中，Socket.IO 使用WebSocket API提供所需的连接并发送消息。 WebSocket 在服务器和浏览器之间提供全双工、低延迟、事件驱动的连接。它也是有状态的。如果需要旧版浏览器支持，或者 WebSocket 连接无法使用（由于防火墙或公司代理），Socket.IO 可以回退到 HTTP 和长轮询。 重连和缓冲： Socket.IO提供自动重连功能。当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送。 多种数据格式： Socket.IO 支持任何可序列化格式的数据传输，包括Buffer或TypedArray等二进制对象。 **致谢：**使用 Socket.IO，一旦成功接收到消息就可以发送响应消息。 命名空间： Socket.IO 使您能够设置具有不同客户端、房间、事件和应用程序逻辑的不同通道。 **广播到不同的客户端组：**从服务器，您可以向所有连接的客户端或子集发送消息。 Socket.IO 的优缺点 Socket.IO 专业人士 连接效率： Socket.IO 使用 HTTP 长轮询发起连接，一旦建立可用性就升级到 WebSocket（有关更多详细信息，请参阅升级机制）。当发生这种情况时，客户端-服务器连接使用单个 WebSocket，而不必启动多个连接，从而减少延迟并改善用户体验。 **客户端和服务器发起的通信：**由于WebSocket提供了全双工、双向的通信通道，因此服务器可以向客户端发送消息，并且两者可以同时发送消息。 事件驱动的通信： WebSocket是一种事件驱动的协议，这意味着您可以在收到消息后立即监听并响应消息，而不是使用轮询机制来检查更新，这样既浪费又低效。 丰富的功能集： Socket.IO 提供了实现实时应用程序所需的一切。当使用原始 HTTP 甚至原始 WebSocket 时，您必须自己实现其中大部分功能。 有状态： Socket.IO 使用 WebSocket，它是有状态的。该状态一直持续到连接关闭为止。 Socket.IO 缺点 **有限的平台支持：**我们之前提到，Socket.IO 在不同的平台和语言上有多种服务器和客户端实现。值得一提的是，其中一些没有得到积极维护，或者功能集有限，因此在考虑使用它们之前请仔细检查它们。此外，Socket.IO 实现与本机 WebSocket 不兼容，因为 Socket.IO 会向其发送的每个数据包添加额外的元数据。 可扩展性： Socket.IO 非常适合有限数量用户的实时通信应用程序。但是，如果您的用户数量和数据量开始变大，您的服务器可能会过载。当您的服务器达到最大负载时，您将需要将连接拆分到多个服务器上，否则可能会丢失重要信息。这种增加的架构复杂性带来了更多问题。阅读Scaling Socket.IO - 实际注意事项以获取更多信息。 **内存泄漏：**已知 Socket.IO 存在一些与内存泄漏相关的问题。内存泄漏不太可能导致任何直接问题，但如果您的应用程序使用了很长一段时间，它们最终可能会导致用户的设备冻结或崩溃。 什么是 HTTP？ HTTP 是一种请求/响应协议，作为 Web 的主要通信机制，构建在 TCP 网络协议之上。有限版本最初由 Tim Berners-Lee 于 1989 年提出，随后经过快速修改以支持更广泛的浏览器和服务器功能。 HTTP 工作组于 1996 年将这些修改记录为 HTTP/1.</description>
    </item>
    <item>
      <title>[译]2024年最好的WebSocket替代品</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</guid>
      <description>原文链接：https://ably.com/topic/websocket-alternatives
什么是 WebSocket？ 简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。
了解更多：
什么是 WebSocket？ WebSocket 是如何工作的？ 什么时候应该考虑使用 WebSocket 替代方案？ 对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括聊天应用程序、多人协作体验以及广播实时路况更新。
了解有关 WebSocket 用例的更多信息
然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。
我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。
了解 WebSocket 的优点和缺点
WebSocket 协议的五种替代方案 现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。
服务器发送的事件 服务器发送事件 (SSE)是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。
服务器发送事件的优点
内置对重新连接的支持。 所有现代浏览器都支持。 轻量级协议。 服务器发送事件的缺点
它是单向的；只有服务器可以将数据推送到客户端。 每个浏览器在同一时间只能有六个并发 SSE 连接。 仅支持UTF-8文本数据； SSE 无法处理二进制数据。 对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。
查看 SSE 与 WebSocket 的比较
长轮询 长轮询是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。
长轮询的优点
长轮询是在XMLHttpRequest的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。 在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。 长轮询的缺点
与 WebSocket 相比，长轮询在服务器上消耗更多资源。 长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。 可靠的消息排序可能是一个问题。 长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。
查看轮询与 WebSocket 相比需要多长时间</description>
    </item>
    <item>
      <title>[译]Apache Kafka、RabbitMQ 与 AWS SNSSQS：哪个消息代理最好？</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</guid>
      <description>原文链接：https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs
将消息从一个组件获取到另一个组件是微服务架构中最重要的部分之一。每个服务必须能够与任何其他服务异步、可靠且大规模地通信。
这就是消息代理的用武之地。消息代理（例如 Apache Kafka、RabbitMQ 和AWS SNS/SQS）为您提供一个通用接口和一组保证，而不是手动协调可能数千个微服务之间的通信。这简化了集成并更容易推理您的系统。
然而，比较消息代理可能很棘手，因为每个消息代理都采用不同的方法来完成工作。那么，您如何决定哪个消息代理最适合您的用例？
在本文中，您将找到有关业界最受欢迎的三个消息代理如何适用于不同用例的指南。我们将研究诸如它们的扩展方法、它们支持的消息传递模式以及它们如何处理性能和智能消息路由之间的权衡等特征。
比较消息代理：您应该寻找什么？ 消息代理是一个广泛的类别。虽然我们正在考虑的三个选项中的每一个都在更大系统中的组件之间移动数据，但在它们之间做出决定取决于它们如何做到这一点。
因此，我们需要检查每个消息代理的特征，根据它们如何影响其移动数据的能力以及它的工作方式。我们将研究以下六个因素以及它们如何应用于 Apache Kafka、RabbitMQ 和 AWS SNS/SQS：
**消息传递模式：**消息代理组织和分发消息的方式（例如发布/订阅或请求回复）比其他架构和用例更适合某些架构和用例。 **消息路由：**消息代理能否根据消息的内容和其他标准来路由消息？ **可扩展性：**并非每种情况都需要每秒处理数百万条消息。确保消息代理可以扩展到您需要的吞吐量级别，同时牢记这将如何影响设置和操作的复杂性。 **可靠性：**消息代理如何处理故障？它会保留消息还是仅通过系统传递消息？ **安全性：**数据是否加密？消息代理是否提供审核日志？它如何处理身份验证和访问控制？是否经过 HIPAA 和 PCI DSS 等行业标准认证？ **成本和许可：**消息代理是开源的吗？需要哪些云或服务器资源？是否持续收取许可费？您的团队需要花费多少时间来运行它？ 介绍 Apache Kafka、RabbitMQ 以及 AWS SNS 和 SQS 在详细进行比较之前，我们先来谈谈为什么我们关注这三种解决方案。原因之一是它们是您可能遇到的最常见的消息代理解决方案之一。研究表明，全球有近 50,000 家公司使用 RabbitMQ，而超过60,000 家公司正在使用 Apache Kafka。尽管 AWS SQS 的用户群似乎较小，但只有超过 24,000 家公司，但它在更广泛的 Amazon Web Services 生态系统中发挥着重要作用。这种广泛的部署使得您可以更轻松地招募经验丰富的员工、与现有技术堆栈集成，以及当您需要时寻求支持。但还有另一个考虑因素。我们正在研究的每个消息代理都从不同的角度解决该问题。 Apache Kafka 专为吞吐量而设计，而 RabbitMQ 更关注复杂的消息路由。与 RabbitMQ 一样，SNS 和 SQS 这两种 AWS 解决方案更关注路由而不是吞吐量，我们在这里考虑它们是因为 AWS 生态系统的重要性。
阿帕奇·卡夫卡 Apache Kafka 是一个实时流平台，旨在构建可扩展、容错的分布式应用程序。它专门以非常高的吞吐量传输数据，通常用于操作数据，例如日志记录和指标。
拥有如此庞大的安装基础，有一些工具可以将 Apache Kafka 连接到几乎任何其他正在运行的系统。尽管 Apache Kafka 专注于高吞吐量，但它也可以处理传输中的数据，例如触发操作和转换数据。然而，这种灵活性和强大功能是有代价的，因为 Apache Kafka 比某些替代方案更难设置和操作。
RabbitMQ 与 Apache Kafka 专注于流数据不同，RabbitMQ 是一个开源分布式消息代理，支持多种不同的消息传递模式，例如发布/订阅和生产者/消费者。尽管它确实拥有高吞吐量，但它的重点更多地是根据消息内容、一天中的时间、发送者和其他标准智能地路由数据，这使得它非常适合事件驱动的架构。
与 Apache Kafka 一样，RabbitMQ 得到了广泛的支持，具有丰富的集成生态系统。
AWS SNS 和 SQS Amazon Web Services (AWS) 提供了两种适合消息代理旗帜的产品。 AWS Simple Notification Service (SNS) 是一种高吞吐量消息传递服务，它使用发布/订阅模型在微服务或分发应用程序的组件之间传递消息。</description>
    </item>
    <item>
      <title>[译]HTTP 的演变 – HTTP2 深入探讨</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/http2/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/http2/</guid>
      <description>原文链接：https://ably.com/topic/http2
可以毫不夸张地说，超文本传输协议 (HTTP) 造就了我们所熟知的互联网。 HTTP 最初是由万维网的发明者蒂姆·伯纳斯·李 (Tim Berners-Lee) 于 1989 年提出的应用程序协议。第一个记录版本 HTTP/0.9 被称为单行协议。鉴于它催生了万维网，它现在可以被描述为有史以来最伟大的俏皮话。
随着我们对互联网的需求不断增长，HTTP 作为网络协议也必须不断发展才能提供可接受的性能。 HTTP/2 标志着一次重大改革，是自 1997 年 HTTP/1.1 ( RFC 2068 ) 提供以来第一个新的标准化。本文介绍了 HTTP/2 如何设计来克服 HTTP/1.1 的限制、新协议的实现、HTTP/2 的工作原理以及其自身的限制。
通过单个 TCP 连接的 HTTP/2 客户端-服务器。
出身卑微——HTTP 简史 HTTP/0.9 的“单行协议”由请求组成：方法GET后跟文档地址、可选端口地址，并以回车符和换行符结束。由一串 ASCII 字符组成的请求。只能传输 HTML 文件。没有 HTTP 标头、状态代码或错误代码。
进化的第一阶段必须很快到来。
HTTP/1.0 – 突破限制 为了克服 HTTP/0.9 的严重限制，浏览器和服务器独立修改了协议。一些关键的协议更改：
请求允许包含多个由换行符分隔的标头字段。 服务器发送了包含单个状态行的响应。 响应中添加了一个标头字段。响应标头对象由由换行符分隔的标头字段组成。 服务器可以使用 HTML 以外的文件进行响应。 这些修改没有以有序或商定的方式完成，导致 HTTP/0.9 的不同风格，进而导致互操作性问题。为了解决这些问题，HTTP 工作组成立，并于 1996 年发布了 HTTP/1.0（RFC 1945）。它是一个信息性 RFC，仅记录当时的所有用法。因此，HTTP/1.0 不被视为正式规范或互联网标准。
HTTP/1.0 请求/响应的代码示例 来自客户端的使用 GET 方法的请求
GET /contact HTTP/1.0 Host: www.ably.io User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0) Accept: text/*, text/html, text/html;level=1, */*Accept-Language: en-us 客户端通过 POST 方法发出请求
POST /contact HTTP/1.0 Host: www.ably.io User-Agent: Mozilla/4.</description>
    </item>
    <item>
      <title>[译]Java和WebSockets：构建可靠的实时应用程序</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</guid>
      <description>原文：https://ably.com/topic/websockets-java
在全球范围内，人们对实时传输数据的需求不断增长，WebSocket可能是此类用例中最流行的传输协议。在 WebSocket 出现之前，“实时”网络已经存在，但它很难实现，通常速度较慢，并且是通过破解现有的网络技术来实现的，而这些技术并不是为实时应用程序设计的。 WebSocket 协议为真正的实时网络铺平了道路。
Java是一种流行的编程语言和计算语言。它是 Android 智能手机应用程序的核心编程语言之一，是构建实时系统的可靠选择。 WebSockets 成为 Java 标准版 SDK 的一部分已经有一段时间了。WebSocket 协议最初是在 2013 年作为JSR 356的一部分提出的，目前已作为javax.websocket包的一部分包含在 Java SDK 中。
由于对实时数据的需求正在稳步增长，并且 Java 已成为一种成熟且广泛使用的语言/平台，因此我认为值得考虑为Java 客户端应用程序实现可靠的 WebSocket 解决方案所面临的众多挑战。
现状——简要概述 基本或原始的 WebSocket 实现很少能够满足为未知（但可能非常多）数量的用户提供服务的实时应用程序的需求。大多数时候，您需要考虑扩展 Java 客户端 WebSocket 实现的功能。
为此，您可以使用nv-websocket-client等开源库，其中包含一些附加功能，例如代理支持。这是使用 nv-websocket-client 创建 WebSocket 实例的方法：
// Create a WebSocket. The scheme part can be one of the following: // &amp;#39;ws&amp;#39;, &amp;#39;wss&amp;#39;, &amp;#39;http&amp;#39; and &amp;#39;https&amp;#39; (case-insensitive). The user info // part, if any, is interpreted as expected. If a raw socket failed // to be created, an IOException is thrown. WebSocket ws = new WebSocketFactory().createSocket(&amp;#34;ws://localhost/endpoint&amp;#34;); 创建 WebSocket 实例后，下一步是注册侦听器以接收 WebSocket 事件：
// Register a listener to receive WebSocket events.</description>
    </item>
    <item>
      <title>[译]WebSocket API和协议说明</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</guid>
      <description>原文地址：https://ably.com/topic/websockets
WebSocket 标志着 Web 开发的转折点。 WebSocket 技术旨在以事件为驱动，并针对低延迟进行了优化，已成为许多寻求构建交互式实时数字体验以提供令人愉悦的用户体验的组织和开发人员的首选。本文探讨了与 WebSocket 相关的关键主题：
WebSocket 协议和 API 解释
WebSockets 是如何工作的？
WebSockets的优缺点是什么？
WebSockets 是否可扩展？
WebSocket 的用途是什么？
WebSockets 的最佳替代品是什么？
如何开始使用 WebSockets 构建实时体验
WebSocket 常见问题解答
WebSocket：协议和 API 解释 WebSocket 是一种实时技术，可通过持久的单套接字连接在客户端和服务器之间实现双向全双工通信。只要需要，WebSocket 连接就会保持活动状态（理论上，它可以永远持续下去），允许服务器和客户端随意发送数据，开销最小。
WebSocket 技术由两个核心构建块组成：
WebSocket 协议。 WebSocket API。 WebSocket的历史是什么？ 第一个实时 Web 应用程序开始出现在 2000 年代，试图提供响应迅速、动态和交互式的最终用户体验。然而，在那个时候，实时网络很难实现，而且比我们现在习惯的要慢;它是通过入侵现有的基于HTTP的技术（AJAX和Comet）来实现的，这些技术不是为实时应用程序设计和优化的。很明显，需要一个更好的替代方案。
在 2008 年，开发人员 Michael Carter 和 Ian Hickson 特别敏锐地感受到了在实现任何类似实时的东西时使用 AJAX 和 Comet 的痛苦和局限性。通过在 IRC 和 W3C 邮件列表上的合作，他们提出了一个计划，为网络上的现代、真正的实时通信引入一个新标准。因此，“WebSocket”这个名字被创造出来。
什么是 WebSocket 协议？ WebSocket 协议支持 Web 客户端和 Web 服务器之间通过基础 TCP 连接进行持续的全双工双向通信。该协议旨在允许客户端和服务器实时通信，从而在 Web 应用程序中实现高效且响应迅速的数据传输。
2011 年 12 月，互联网工程任务组 （IETF） 通过 RFC 6455 对 WebSocket 协议进行了标准化。互联网号码分配机构 （IANA） 与 IETF 协调维护 WebSocket 协议注册管理机构，该注册管理机构定义了协议使用的许多代码和参数标识符。
什么是 WebSocket API？ WebSocket API 包含在 HTML Living Standard 中，是一个编程接口，用于创建 WebSocket 连接并管理 Web 应用程序中客户端和服务器之间的数据交换。它为开发人员提供了一种简单且标准化的方法，可以在其应用程序中使用 WebSocket 协议。</description>
    </item>
    <item>
      <title>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</guid>
      <description>原文链接：https://ably.com/topic/websockets-vs-http
当谈到 WebSocket 与 HTTP 时，决定使用哪一种并不总是那么明确。哪一个更好？您的应用程序应该使用哪一款？
但问题的答案不一定是其中之一 - 开发人员经常根据场景在同一个应用程序中同时使用 WebSocket 和 HTTP。更重要的问题是 - 我如何确定 WebSockets 还是 HTTP 是特定类型通信的正确通信协议？
这是您需要了解的一切。
WebSocket 与 HTTP 概览 在此页面上，我们将探讨这些技术的工作原理、它们在实现实时通信方面的表现如何，并就在哪些场景中使用哪些技术提供具体指导。
如果您正在寻找高级比较，以下是主要差异一目了然：
请继续阅读以详细了解这两种流行协议的比较。
HTTP协议 什么是 HTTP？ 从根本上讲，HTTP 是一种通信协议，使客户端（例如 Web 浏览器）和服务器能够共享信息。
例如，HTML 文档、图像、应用程序数据 (JSON) 等。
很难想出比您现在正在阅读的此页面更好的 HTTP 实际示例。
当您加载此页面时，您的浏览器会发出 HTTP 请求，服务器会使用您当前正在阅读的 HTML 文档来响应该请求。
HTTP 是如何工作的？ HTTP 遵循请求-响应消息传递模式，其中客户端发出请求，Web 服务器发送响应，该响应不仅包括请求的内容，还包括有关请求的相关信息。
在底层，每个请求都会打开一个与服务器的短暂连接，然后关闭。
HTTP 示例
网页浏览。 下载图像、视频或二进制文件，例如桌面应用程序。 使用 JavaScript 中的 fetch 函数向 API 发出异步请求。 由于每个 HTTP 请求都包含处理它所需的所有信息，因此服务器无需跟踪连接和请求。
这种无状态设计是有利的，因为它使得可以部署额外的服务器来处理请求，而不需要在服务器之间同步状态逻辑。
此外，由于每个请求都是独立的，因此通过代理路由消息以执行缓存、加密和压缩等增值功能变得非常简单。
这种无状态方法的缺点是客户端打开一个临时连接并为每个请求发送元数据，从而产生少量开销。
当加载网页或下载文件时，这种开销可以忽略不计。但是，如果您发送负载较小的高频请求，它可能会对应用程序的性能产生显着影响。
通过 HTTP 进行实时更新 这种模式（客户端发出请求，服务器发出响应）非常适合网页、文件或应用程序数据等静态资源。
但是，请考虑这样一种情况：客户不知道新信息何时可用。
例如，假设您正在为 BBC 实施突发新闻功能。
在这种情况下，客户不知道故事的下一次更新何时会发生。
现在，您可以对客户端进行编码，以频繁地发出 HTTP 请求，以防万一发生某些情况，并且对于少数客户端来说，这可能工作得足够好。
但是假设您有成百上千个客户端（在 BBC 的情况下有数十万个）向服务器发送请求，而这些请求在更新之间没有产生任何新内容。
这不仅浪费带宽和服务器资源，而且在最近的请求完成后不久更新就会中断 - 可能需要几秒钟才能发送下一个请求并且用户获得更新。一般来说，这种方法称为HTTP 轮询，它既不高效也不实时！
相反，如果服务器能够在新信息可用时将数据推送到客户端，那就更好了，但这从根本上违背了请求-响应模式的原则。
或者确实如此？
HTTP 流式传输 尽管 HTTP 从根本上遵循请求-响应模式，但有一种解决方法可用于实现实时更新。
服务器不是发出完整的响应，而是发出部分 HTTP 响应并保持底层连接打开。
基于上一节的突发新闻示例，通过 HTTP 流，服务器可以在每次新闻更新中断时将部分响应（如果您愿意，可以是块）附加到响应流 - 连接无限期保持打开状态，使服务器能够推送当新信息可用时，以最短的延迟向客户端提供新信息。</description>
    </item>
    <item>
      <title>[译]WebSocket与REST</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</guid>
      <description>原文链接：https://ably.com/topic/websocket-vs-rest
无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。
好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。
在本文中，我们将阐明 REST 与 WebSocket，涵盖：
回顾一下 REST 和 WebSocket 是什么 他们的技术权衡，包括 WebSocket 与 REST 性能 何时应该使用 REST 以及何时 WebSocket 是更好的选择 如果您使用任一协议，则需要填补一些空白。 但如果您正在寻找快速摘要，那么您需要了解以下内容：
当您需要轻松扩展的基础架构来进行无状态 CRUD 操作并且您希望坚持使用标准 Web 工具时，REST 是理想的选择。例如，如果您正在构建一个 API 来将更新发布到社交网络 当您需要客户端和服务器之间进行实时、双向、低延迟通信时，WebSocket 是正确的选择。例如，如果您正在构建聊天应用程序。 什么是REST？ 表述性状态传输 (REST) 是一组原则，定义了通过 HTTP 构建 API 的一种方法。这很容易被忽视，但 REST 不是一种协议，这意味着您可以非常灵活地根据您的需求来塑造它。它的流行很大程度上是由于它的简单性以及它重用了已经用于网络的方法和技术。这在很大程度上定义了它表现良好的用例以及您需要寻找替代方案的用例。
让我们快速了解一下 REST 与其他方法的区别。
REST 的主要特征 **无状态：**对 REST API 发出的每个请求都是独立且自包含的。这使得扩展变得更加简单。当流量增加时，您可以在负载均衡器后面添加更多服务器，因为特定客户端不需要每次都连接到同一台服务器。尽管 HTTP 和 REST 是无状态的，但您可以通过使用客户端 cookie 来跟踪会话和登录状态来维护长时间运行的会话。 **CRUD：**每个 REST 请求都使用标准 HTTP 动词（GET、POST、PUT、PATCH 和 DELETE），与创建、读取、更新、删除操作对齐。 有效负载格式： REST 通常使用 JSON 或 XML 等标准化消息格式进行数据交换。但是您可以使用任何您喜欢的数据格式，只要您设置正确的Content-Type标头即可。 **可缓存：**您可以选择允许客户端和中间基础设施缓存响应。这有助于扩展和响应时间。 同步： REST 所依赖的 HTTP 请求-响应周期最适合短暂、简单的事务，其中客户端在继续下一个任务之前等待响应。 什么是 WebSocket？ REST 适用于短暂、无状态的通信，而 WebSocket 则提供持续、低延迟的双向通信通道。这意味着您与 WebSocket 交互的方式是不同的。因此，您无需使用特定端点构建“WebSocket API”，而是打开一个连接，双方可以在需要时交换消息。这使其成为实时应用程序的理想选择，例如聊天、体育或金融数据的实时流媒体，以及 Figma、Miro 和 Google Docs 等交互式实时协作环境。</description>
    </item>
    <item>
      <title>[译]什么是 HTTP？</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/http/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/http/</guid>
      <description>原文链接：https://www.pubnub.com/guides/http/
HTTP 概述 HTTP，即超文本传输协议，是互联网通信的基础。它在客户端-服务器模型上运行，其中前端客户端（例如网络浏览器）通过向服务器发送HTTP请求消息来发起请求，例如请求网页（例如搜索引擎）。然后，服务器使用包含所请求资源的 HTTP 响应消息进行响应，如果资源不可用，则使用错误消息进行响应。
HTTP 是一种无状态协议，这意味着每个请求都是独立的，与之前或将来的请求无关。这允许客户端和服务器之间进行有效的通信。
HTTP 于 1991 年首次引入，作为 Tim Berners-Lee 创建的万维网项目的一部分，并由互联网工程任务组 (IETF)进行标准化。 IETF 负责开发和维护 HTTP、TCP/IP、DNS 等协议，以及他们在 RFC 或“征求意见”中记录的许多其他协议。
早期，需要一种标准化协议来促进不同计算机和服务器之间的通信。这导致了各种协议的发展，包括 HTTP。
HTTP 0.9，该协议的第一个版本，是一个简单且有限的系统，仅支持超文本文档的检索。它不支持标头，只允许传输纯文本数据。
1996 年，HTTP 1.0 发布，引入了至今仍在使用的几个重要功能。它增加了对多种媒体类型的支持，允许传输图像、视频和其他文件格式。它还引入了使用标头来实现更高级的功能，例如缓存和身份验证。
1999 年发布的 HTTP 1.1 进一步改进了该协议。它引入了持久连接，允许通过单个 TCP 连接发送多个请求和响应。这极大地提高了客户端和服务器之间通信的效率和速度。
近年来，人们致力于增强和优化HTTP协议。这导致了HTTP/2的开发，并于 2015 年发布。HTTP/2 带来了多项改进，包括多路复用、标头压缩和服务器推送，以减少延迟并提高性能。
最后是 HTTP/3。HTTP/3也称为 HTTP over QUIC（快速 UDP Internet 连接），是最新的 HTTP 协议版本，旨在解决以前版本的一些限制并提高性能。
HTTP/3 构建在 QUIC 传输协议之上，该协议使用用户数据报协议 (UDP)而不是 TCP。与 TCP 相比，UDP 具有多种优势，例如减少延迟和改进拥塞控制。 HTTP/3 使用 UDP，旨在提供更快、更可靠、更安全的连接。
HTTP/3 的关键特性之一是它支持多路复用和流多路复用的能力。这允许通过单个连接同时发送多个请求和响应，从而提高效率并减少延迟。此外，HTTP/3 还包含零 RTT 连接建立、改进的拥塞控制以及通过加密提高安全性等功能。
HTTP 和服务器 服务器对于处理 HTTP 请求和提供相应的响应至关重要。以下是HTTP与服务器关系的几个要点：
请求-响应模型：如前所述，HTTP 遵循请求-响应模型。客户端向服务器发送 HTTP 请求，指定所需的操作，例如检索网页或提交表单数据。服务器处理请求并发回 HTTP 响应，其中包括状态代码、标头和请求的内容（如果适用）。 Web 服务器：Web 服务器是处理 HTTP 请求的软件应用程序或程序。它们侦听特定网络端口（通常为 HTTP 的端口 80）上的传入请求，并将它们路由到适当的资源或应用程序。流行的 Web 服务器软件包括 Apache、Nginx和 Microsoft IIS。 路由和资源处理：在 HTTP 服务器中，路由确定传入请求如何映射到特定资源或端点处理程序。例如，当接收到针对特定 URL 或路径的请求时，服务器使用路由规则来确定哪个代码或资源应处理该请求并生成适当的响应。 处理和生成响应：当 HTTP 请求到达服务器时，它会触发与所请求的资源关联的代码或资源处理程序的执行。这些处理程序可以从数据库检索数据、与外部服务交互或生成动态内容。服务器根据请求处理这些数据，并生成带有必要标头和内容的 HTTP 响应。 状态代码：HTTP 响应包括指示请求结果的状态代码。这些状态代码的范围从信息性 (1xx) 到成功 (2xx)、重定向 (3xx)、客户端错误 (4xx) 和服务器错误 (5xx)。常见状态代码包括 200（正常）、404（未找到）和 500（内部服务器错误）。 无状态：HTTP 是一种无状态协议，这意味着每个请求/响应交互都是独立的，并且不保留有关先前请求的信息。为了维护用户会话或跟踪用户交互，服务器通常使用 cookie 或会话管理技术。 HTTP 是如何工作的？ 当客户端想要从服务器检索网页或新资源时，它会发起 HTTP 请求。该请求由几个部分组成：</description>
    </item>
    <item>
      <title>[译]什么是 OAuth？</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/oauth/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/oauth/</guid>
      <description>原文链接：https://www.pubnub.com/guides/oauth/
什么是 OAuth？ OAuth（开放授权）是一种开放标准授权框架，允许第三方应用程序访问用户数据，而无需用户共享其登录凭据。它为用户提供了一种安全且标准化的方式，将其在一个网站上的资源的访问权限授予另一个网站或应用程序，而无需暴露其密码。
简单来说，OAuth 充当最终用户和他们想要授予访问权限的应用程序之间的中间人。用户不会直接向 Web 应用程序提供用户名和密码，而是会被重定向到授权服务器（例如 Google、Facebook 或 Twitter），在那里他们可以安全地验证自己的身份。经过身份验证后，用户可以授予或拒绝对其想要使用的应用程序上的数据的访问权限。
OAuth 是如何工作的？ OAuth 为用户提供了一种安全且标准化的方式来授权应用程序从各种来源（例如社交媒体平台或在线服务）访问其数据。
OAuth工作流程涉及三个主要方：用户、应用程序和服务提供商（也称为OAuth 服务器）。以下是 OAuth 流程的高级概述：
用户启动该过程：用户想要使用需要访问服务提供商上受保护资源的应用程序。用户首先向应用程序请求访问权限。 应用程序请求授权：应用程序将用户重定向到服务提供商的授权端点，以及必要的参数，例如应用程序的客户端 ID 和请求的访问范围。 用户授予授权：服务提供商在授权端点向用户显示登录屏幕。用户输入其凭据，如果有效，则系统会要求授予或拒绝应用程序访问其资源的请求。 服务提供商发出授权代码：如果用户授予授权，服务提供商会生成授权代码并将用户重定向回应用程序指定的重定向 URI。授权码是一个临时令牌，代表用户的同意。 应用程序用授权代码交换访问令牌：现在拥有授权代码的应用程序向服务提供商发送请求，以用代码交换访问令牌。该请求包括代码、应用程序的客户端 ID 和客户端密钥，它们用于向服务提供商验证应用程序的身份。 服务提供商验证授权代码：服务提供商对其进行验证并检查它是否与之前为用户生成的授权代码相匹配。如果代码有效，服务提供商将向应用程序颁发访问令牌。 应用程序使用访问令牌来访问受保护的资源：通过从服务提供商获得的访问令牌，应用程序现在可以代表用户发出请求以访问其受保护的资源。这些请求通常是向服务提供商的 API 端点发出的。 访问令牌过期和刷新：访问令牌的生命周期有限，过期后就会过期。要继续访问用户的资源，应用程序可以使用刷新令牌（如果提供）来获取新的访问令牌，而无需用户的参与。 使用 OAuth 有什么好处？ 这种广泛采用的协议为构建实时聊天和消息应用程序的开发人员提供了多种好处：
增强的安全性： OAuth 消除了应用程序需要存储用户凭据的情况，从而降低了未经授权访问的风险。通过利用 OAuth，开发人员可以对用户进行身份验证和授权，而无需处理用户的敏感信息（例如密码）。这显着降低了数据泄露的可能性并增强了整体应用程序的安全性。
简化的用户体验： OAuth 使用户能够向第三方应用程序授予权限而无需共享其凭据，从而提供无缝且用户友好的体验。这消除了为每个应用程序创建和管理单独帐户的麻烦，从而提高了便利性和用户采用率。
可扩展性和互操作性： OAuth 使开发人员能够构建集成多个平台和服务的应用程序。通过利用 OAuth，开发人员可以轻松地验证和访问来自不同提供商的资源，从而允许他们的聊天和消息应用程序与其他系统无缝交互。这增强了可扩展性，并使开发人员能够利用不同平台的现有用户群。
细粒度的访问控制： OAuth 允许开发人员为其聊天和消息应用程序实施细粒度的访问控制。可以为每个资源授予权限，确保第三方应用程序只能访问所需的资源。这种对访问的精细控制有助于维护数据隐私和控制，降低未经授权的数据泄露的风险。
开发人员友好： OAuth 提供了一个简单、开发人员友好的框架，用于在聊天和消息传递应用程序中实现身份验证和授权。该协议有详细的文档记录，并受到各种库和 SDK 的支持，使开发人员可以轻松地将 OAuth 集成到他们的应用程序中。此外，OAuth 通过内置的令牌过期和撤销机制简化了访问令牌的管理。这简化了开发流程并降低了处理用户身份验证和授权的复杂性。
使用 OAuth 有哪些缺点？ 虽然 OAuth 对于构建实时聊天和消息应用程序的开发人员来说具有众多优势，但也存在一些缺点。这些缺点包括：
**复杂性：**实施 OAuth 可能很复杂，尤其是对于不熟悉该协议的开发人员而言。该过程涉及多个步骤，包括注册应用程序、获取客户端凭据和处理授权流程。与多个身份提供商集成或处理刷新令牌时，复杂性可能会进一步增加。开发人员需要投入时间和精力来正确理解和实施 OAuth。
对第三方提供商的依赖： OAuth 依赖第三方身份提供商来对用户进行身份验证和授权。这种依赖性引入了潜在的单点故障。如果身份提供商遇到中断或更改其 API，则可能会中断聊天和消息传递应用程序的身份验证和授权过程。开发人员需要考虑所选身份提供商的可靠性和寿命。
用户隐私问题： OAuth 提供了一种安全的身份验证和授权机制，但一些用户可能担心与第三方应用程序共享其个人信息。尽管 OAuth 不会公开密码等敏感信息，但用户仍然需要授予访问其数据的权限。某些用户可能会犹豫是否授予这些权限，尤其是对于鲜为人知或不太受信任的应用程序。
**缺乏标准化：**尽管 OAuth 被广泛采用，但不同提供商和平台的实施可能存在差异。缺乏标准化可能会导致与多个系统集成时出现不一致和兼容性问题。开发人员可能需要额外的努力来处理这些变化并确保不同平台和提供商之间的兼容性。
**安全漏洞：**虽然 OAuth 的设计是安全的，但也存在发现和利用漏洞的情况。这些漏洞可能导致未经授权的用户数据访问或冒充攻击。开发人员必须及时了解最新的安全最佳实践，并定期修补 OAuth 实施中的任何漏洞。
OAuth 与 OpenID OAuth 和OpenID是广泛使用的身份验证和授权协议，但用途不同。
OAuth 主要是一种授权协议，允许应用程序访问另一个系统上的用户资源，而无需共享其凭据。它通常用于委托授权场景，即用户向第三方应用程序授予访问其在特定网站或服务上的数据的权限。例如，当您使用 Google 帐户登录第三方应用程序时，OAuth 通常用于授予该应用程序访问您的 Google 云端硬盘或 Gmail 数据的权限。</description>
    </item>
    <item>
      <title>[译]什么是HTTP/3？</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/http3/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/http3/</guid>
      <description>原文链接：https://www.pubnub.com/guides/http-3/
什么是 HTTP/3？ HTTP/3（或 HTTP-over-QUIC）是超文本传输协议 ( HTTP ) 的第三个主要版本。它是用于 Web 浏览器和服务器之间通信的应用层协议。 HTTP/3 旨在提高 Web 通信的性能和安全性。
HTTP/3的主要功能之一是它构建在用户数据报协议 (UDP)之上，而不是建立在 HTTP 早期版本中使用的传输控制协议(TCP) 之上。 UDP 是一种无连接协议，可为实时应用程序提供更低的延迟和更好的性能。
HTTP/3 还引入了一种新的传输协议，称为QUIC（快速 UDP 互联网连接）。与 TCP 相比，QUIC 具有多种优势，包括减少延迟、提高可靠性和更好的拥塞控制。它还包括内置加密，增强网页和通信安全性。
HTTP/3 的另一个重要特性是它对多路复用的支持。这意味着可以通过单个连接同时发送和接收多个请求和响应，从而提高数据传输效率。
HTTP/3 还包括其他优化以提高性能，例如标头压缩和流优先级。这些优化有助于减少开销并提高 Web 通信的整体速度。
总体而言，HTTP/3 在性能和安全性方面比其前身 HTTP/2 显着改进了功能。它对于构建实时聊天和消息传递应用程序的开发人员特别有利，因为它提供更低的延迟和更高的可靠性，使其成为需要快速交付实时数据的用例的理想选择。
让我们退一步看看这一切从第一个 HTTP 版本开始。
HTTP 简史 HTTP（超文本传输协议）协议有着长达数十年的丰富历史。它于 20 世纪 90 年代初首次推出，作为万维网上客户端和服务器之间的通信方式。
HTTP 最初是由Tim Berners-Lee和他在CERN（欧洲核研究组织）的团队开发的，旨在促进超文本文档的交换。第一个版本 HTTP/0.9 是一个简单的协议，仅支持用于检索 HTML 文档的 GET 请求。
1996 年，HTTP/1.0 协议由互联网工程任务组(IETF)标准化。该版本引入了几个重要的功能，包括对 POST 请求、响应状态代码和标头的支持。 HTTP/1.0 还允许传输不同的媒体类型，例如图像和视频以及 HTML 文档。
然而，随着网络变得更加复杂和交互，HTTP/1.0 的局限性变得明显。它是围绕请求-响应模型设计的，其中每个请求都需要与服务器的单独连接。这导致了高延迟和网络资源的低效使用。
HTTP/1.1 协议解决了这些问题。
HTTP/1.1 HTTP/1.1 是超文本传输协议 (HTTP) 的第二个主要版本，于 1999 年推出，如今在互联网上广泛使用。
HTTP/1.1 的关键功能之一是支持持久连接，也称为保持活动连接。在以前版本的 HTTP 中，必须为每个请求和响应建立一个新的 TCP 连接，这导致延迟和开销增加。使用 HTTP/1.1，可以通过单个连接发送多个请求和响应，从而减少建立新连接的需要并提高性能。
HTTP/1.1 的另一个重要特性是它对管道的支持。流水线允许发送多个请求而无需等待相应的响应，这有助于减少延迟并提高数据传输效率。
HTTP/1.1还引入了缓存的概念。缓存允许 Web 浏览器存储和重用以前访问的资源，例如图像和样式表，这可以显着缩短页面加载时间并减少带宽使用。
然而，尽管有这些改进，HTTP/1.1 仍然存在一些局限性。同时处理多个请求和响应可能效率低下，因为它需要严格的消息排序。这可能会导致性能问题，特别是对于需要低延迟和高并发的实时应用程序。
此外，HTTP/1.1 不支持标头压缩，这可能会导致开销增加和数据传输速度变慢。
HTTP/2 HTTP/2 是超文本传输协议 (HTTP)的最新主要版本，于 2015 年推出，作为对之前 HTTP/1.</description>
    </item>
    <item>
      <title>[译]什么是HTTP流式传输？</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/http-streaming/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/http-streaming/</guid>
      <description>原文链接：https://www.pubnub.com/guides/http-streaming/
什么是 HTTP 流式传输？ HTTP 流，也称为基于 HTTP 的流或 HTTP 实时流，是一种用于通过 Internet 传送实时多媒体内容（例如音频或视频）的技术。该协议允许从服务器到客户端设备的连续数据传输，使用户能够消费媒体内容而无需完整的文件下载。
与传统的文件下载方法不同，在开始播放之前需要下载整个文件，HTTP 流允许立即播放媒体内容。它的工作原理是将媒体文件分成更小的片段或块，然后将其连续传送到客户端设备。
HTTP 流利用超文本传输协议 (HTTP)作为其通信协议。它利用现有的 Web 基础设施并使用 HTTP 服务器的可扩展性、缓存和负载平衡功能。这使其成为向许多用户提供实时内容的高效且灵活的解决方案。
HTTP 流如何工作？ 从较高层面来看，HTTP 流式传输的工作原理是将媒体文件分成小块并通过 HTTP 连接将其传输到客户端。客户端（通常是网络浏览器或媒体播放器）不断请求和接收这些块，从而实现媒体的无缝播放。
HTTP 流式传输有两种主要方法：渐进式下载和自适应流式传输。
1.渐进式下载：
渐进式下载缺乏自适应流媒体提供的适应性。在客户端开始播放之前，会通过渐进式下载来下载整个媒体文件。这意味着，如果在下载过程中出现任何 Wi-Fi 网络中断或带宽波动，用户可能会遇到播放缓冲或延迟的情况。这可能会让用户感到沮丧，并可能导致糟糕的用户体验。
2.[自适应流媒体](https://www.cloudflare.com/learning/video/what-is-adaptive-bitrate-streaming/#:~:text=Adaptive bitrate streaming adjusts video,%2C location%2C or Internet speed.)：
自适应流媒体对于开发人员构建实时聊天和消息传递应用程序（提供视频或音频等媒体文件）来说是一项至关重要的技术。它确保无论用户的网络条件如何，媒体内容都可以流畅、高效地传输。这在当今的数字环境中尤其重要，用户期望高质量、不间断的媒体播放，但有时具有不同的互联网速度。
自适应流式传输通常涉及以下步骤：
内容编码：媒体文件被编码为具有不同比特率和质量级别的多种变体。这些变化存储在服务器上。 清单文件：创建一个清单文件，其中包含有关可用变体及其相应 URL 的信息。 初始请求：客户端向服务器请求清单文件，该文件提供有关媒体文件的可用变体的信息。 变体选择：客户端根据网络条件和设备功能选择所需的变体。然后它从服务器请求相应的媒体块。 块传送：服务器通过 HTTP 连接将分块媒体传送到客户端。客户端不断请求并接收这些块，并在必要时调整播放质量。 比特率适应：在播放期间，客户端监视网络状况并根据可用带宽动态调整所选变体。如果网络变得拥塞，它可能会切换到较低的比特率变体，或者如果网络状况改善，它可能会切换到较高的比特率变体。 无缝播放：通过连续接收和播放媒体块，自适应流媒体提供无缝播放体验，使用户能够在没有中断或缓冲的情况下享受内容。 HTTP 流有什么好处？ HTTP 流式传输为构建实时聊天和消息传递应用程序的开发人员提供了多种好处：
实时数据传送：HTTP流可以实现数据的实时传送，允许用户即时发送和接收消息。这确保用户可以进行实时对话，而不会出现任何明显的延迟。 可扩展性：HTTP 流具有高度可扩展性，能够处理许多并发连接并向多个用户实时传送消息。这对于支持不断增长的用户群和处理大量消息的应用程序至关重要。 减少网络开销：使用 HTTP 流式传输，当有新信息可用时，仅通过网络发送必要的数据，从而减少网络开销。这与轮询等其他方法形成鲜明对比，即使不存在新数据，也会不断发出请求。 高效的资源利用：HTTP 流可以有效地利用服务器资源，因为它消除了频繁的轮询请求。这可以减少服务器负载并提高性能，特别是在具有许多活跃用户的应用程序中。 更好的用户体验：HTTP 流通过提供实时更新和即时消息传递，增强了聊天和消息传递应用程序的用户体验。用户可以进行更具互动性和吸引力的对话，而不会因延迟或错过消息而感到沮丧。 安全性：HTTP 流可以利用 HTTPS 等现有安全措施提供安全的通信通道。这可确保敏感的用户数据和对话免受未经授权的访问和窃听。 使用 HTTP 流有哪些缺点？ 使用 HTTP 流进行实时聊天和消息传递应用程序有几个缺点：
延迟： HTTP 流媒体依赖于客户端和服务器之间的持续连接。这可能会引入延迟，因为服务器需要维持开放连接并以块的形式发送数据。因此，向用户发送实时消息可能会出现延迟，从而影响用户体验。
可扩展性： HTTP 流对于客户端和服务器来说可能是资源密集型的。维护大量打开的连接会给服务器带来压力并限制其可扩展性。此外，客户端需要处理传入的数据流，这也可能对其资源提出要求。
**兼容性：**所有设备或网络可能不支持 HTTP 流。某些防火墙或代理可能会阻止或干扰流连接，从而导致通信问题。这可能会将聊天应用程序的可用性限制为部分用户。
**可靠性：**由于 HTTP 流媒体依赖于长期连接，因此中断或网络故障可能会破坏流媒体过程。如果连接丢失，客户端可能需要重新建立连接，这可能会导致消息丢失或重复。
安全性： HTTP 流本身并不为数据传输提供加密或安全措施。如果没有额外的安全层，通过聊天应用程序交换的敏感信息可能容易遭到窃听或未经授权的访问。
**电池消耗：**连续连接和数据流会快速耗尽移动设备的电池。这可能是实时聊天应用程序的用户所关心的问题，尤其是在长时间使用这些应用程序时。
开发人员在选择实时聊天和消息应用程序技术时需要考虑这些缺点。虽然 HTTP 流提供了一些好处，例如利用现有的安全措施，但开发人员应该权衡这些优点与潜在的缺点，并评估它们是否符合其特定的用例和要求。
HTTP 流式传输有哪些替代方案？ HTTP 流的一些替代方案包括：</description>
    </item>
    <item>
      <title>[译]什么是Socket.IO？</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/socket-io/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/socket-io/</guid>
      <description>原文链接：https://www.pubnub.com/guides/socket-io/
什么是Socket.IO？ Socket.IO是一个开源的跨平台库，它提供客户端和服务器之间基于事件的全双工双向通信。它基于 WebSocket 协议构建，提供附加功能，例如自动重新连接以及在无法使用 WebSocket时回退到HTTP 长轮询。
Socket.IO 客户端由客户端和服务器端库组成。虽然最初在服务器上支持NodeJS ，在客户端支持JavaScript，但现在它支持各种服务器和客户端技术，包括Java、Python、Swift和Kotlin，它们都是官方代码库的一部分，由活跃社区贡献。
Socket.io 有何用途？ Socket.IO 允许您实现依赖于消息交换的各种应用程序，例如即时消息传递、多用户协作、实时分析、文件共享和通知。
Socket.io 适合实时应用程序吗？ 是的，Socket.IO 是构建实时 Web 应用程序的不错选择，因为它提供了许多对开发人员有用的开箱即用功能，包括：
房间和命名空间支持允许您将客户端分组到可以接收广播或多播消息的房间中。 自动重连意味着您无需担心客户端上线或离线。 二进制数据支持，使您不仅可以交换聊天消息，还可以交换图像或其他媒体。 Socket.io 是 API 吗？ Socket.IO不是传统意义上的API。它是一个库或框架，抽象了底层传输机制，并提供了一组用于在客户端和服务器之间构建实时双向通信的工具和实用程序。
Socket.IO 包含客户端和服务器组件，每个组件都公开其 API。
Socket.io是TCP还是UDP，有什么区别？ Socket.IO可以使用TCP和UDP作为底层传输协议，但它主要使用TCP。
TCP（传输控制协议）是一种可靠的、面向连接的协议，可确保数据按顺序且无错误地传送。
另一方面，UDP（用户数据报协议）是一种无连接、不可靠的协议，它发送数据时不检查数据是否已成功接收。
UDP 比 TCP 更轻量级，因为只有后者在客户端和服务器之间建立连接，但它只能由能够抵御丢失消息的应用程序使用。
Socket.io 与 Web Sockets 虽然 Socket.IO 明确不是WebSocket实现，但有一些相似之处。两者都是基于事件的，这意味着您可以“侦听”连接、断开连接或 new_message 等事件，并且都允许您发送JSON 对象等结构化数据。
您可以将 Socket.IO 视为底层传输协议之上的抽象层。除了底层通信层之外，该库还实现了其他功能，例如自动重新连接、数据包缓冲和消息确认，以及在 WebSocket 不可用时回退到 HTTP 长轮询，从而增加了鲁棒性。
Socket.io 示例：客户端/服务器 JavaScript 中 Socket.IO 的 Hello World 客户端/服务器实现将编写如下，摘自4.x Socket.IO 文档：
Socket.io 服务器示例：
Socket.io 客户端示例：
Socket.IO 是如何工作的？ 该库支持两种传输方法：HTTP 长轮询和 WebSockets。首先建立 HTTP 长轮询连接，然后在可能的情况下升级为 WebSocket 连接。 WebSocket 不能在任何地方运行，例如，它们被许多公司代理和防火墙阻止，因此首先发起 HTTP 长轮询，因为它更有可能成功。 HTTP 长轮询连接建立后，会在对最终用户完全透明的过程中“升级”为 WebSocket 连接。
Socket.IO的架构是怎样的？ Socket.IO 由两个不同的层组成，分别存在于客户端和服务器上：
底层管道由一个名为Engine.IO的单独库提供 Socket.IO 提供的高级 API 作为开发人员或用户，您通常不会直接与 Engine.IO 交互，但它在幕后运行以建立连接、协商传输机制并检测任何断开连接。将 Engine.IO 与 WebSocket 进行比较时，两者在功能上非常相似，只是 Engine.</description>
    </item>
    <item>
      <title>[译]什么是WebSocket？</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websockets/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websockets/</guid>
      <description>原文链接：https://www.pubnub.com/guides/websockets/
什么是 WebSocket？ WebSocket 是一种通过单个TCP连接提供全双工通信通道的通信协议。它支持客户端和服务器之间的实时、事件驱动的连接。
与遵循请求-响应模型的传统 HTTP 软件不同，WebSocket 允许双向（双向）通信。这意味着客户端和服务器可以随时向对方发送数据，而无需持续轮询。
WebSocket 有何用途？ WebSocket 用于客户端和服务器之间的实时、事件驱动的通信。它们对于构建需要即时更新的软件应用程序特别有用，例如实时聊天、消息传递和多人游戏。
在传统的 HTTP 中，客户端向服务器发送请求，服务器用请求的数据进行响应。这种请求-响应模型需要从客户端到服务器进行连续轮询，这可能会导致延迟增加和效率降低。
另一方面，WebSockets 在客户端和服务器之间建立持久连接。这意味着一旦建立连接，客户端和服务器就可以随时向对方发送数据，而无需不断轮询请求。这允许实时通信，可以立即发送和接收更新。
例如，当用户在聊天应用程序中发送消息时，该消息可以立即传递给所有其他用户，而无需刷新页面或发出频繁的 HTTP 请求。这将带来更加无缝和高效的用户体验。
此外，Web Sockets 还允许双向通信，这意味着客户端和服务器都可以相互发送数据。这为更具交互性和吸引力的应用程序提供了可能性，其中服务器可以处理向客户端推送更新或通知，而无需客户端明确请求它们。
Web 套接字的缺点 WebSocket 的缺点包括：
浏览器支持：虽然大多数现代浏览器支持 WebSocket，但一些旧浏览器不支持。这可能会限制应用程序的范围，并且需要针对旧版浏览器的额外后备机制。 代理和防火墙限制：某些代理服务器和防火墙可能会阻止或干扰 WebSocket 连接。这可能会导致连接问题，尤其是在安全的公司或受限的网络环境中。 可扩展性：Web Sockets 在客户端和服务器之间维护持久连接，这在处理许多并发连接时可能会导致服务器资源紧张。必须实施适当的负载平衡和资源管理技术以确保可扩展性。像 Socket.io 这样的开源资源不适合大规模运营或快速增长。 有状态性：与无状态的传统 HTTP 不同，WebSocket 是有状态的。这意味着服务器需要维护每个客户端的连接状态，从而导致内存使用量增加和潜在的可扩展性挑战。 安全注意事项：通过 WebSocket 建立持久连接，需要采取适当的安全措施来防止潜在的漏洞，例如跨站点脚本 (XSS) 和跨站点请求伪造(CSRF)。应实施使用SSL/TLS加密的安全 WebSocket 连接 (wss://)，以确保数据隐私和完整性。 如果通过 Web 套接字的连接丢失，则不包含负载平衡或重新连接机制。 在可能不支持 Web Sockets 的环境中，仍然需要有后备选项，例如HTTP 流或长轮询。 像Presence这样的功能在 WebSocket 连接上不能很好地工作，因为断开连接很难检测到。 WebSockets、HTTP、Web 服务器、轮询 HTTP 连接与 WebSockets 要了解WebSocket API，了解其构建基础 — HTTP（超文本传输协议）及其请求/响应模型也很重要。 HTTP 是一种应用层协议，是所有基于 Web 的通信和数据传输的基础。
使用 HTTP 时，客户端（例如 Web 浏览器）向服务器发送请求，然后服务器发回消息（称为响应）。我们今天所知道的网络是建立在这种基本的客户端-服务器循环之上的，尽管对 HTTP 进行了许多添加和更新以使其更具交互性。当前有一些可行且受支持的 HTTP 版本（HTTP/1.1 和 HTTP/2）以及称为 HTTPS 的安全版本。
基本 HTTP 请求适用于许多用例，例如当有人需要在网页上搜索并接收相关的、非时间敏感的信息时。然而，它并不总是最适合需要实时通信或需要以最小延迟快速更新的数据的 Web 应用程序。
每当客户端发出新的 HTTP 服务器请求时，默认行为是打开新的 HTTP 连接。这是低效的，因为它使用循环非有效负载数据的带宽并增加了数据传输之间的延迟。
此外，HTTP 请求只能从客户端向一个方向流动。传统上没有服务器发起与客户端通信的机制。除非服务器首先请求数据，否则服务器无法向客户端发送数据。这可能会给需要从服务器端实时发出消息的用例带来问题。
短轮询与 WebSockets HTTP 轮询是接收定期数据更新的第一个解决方案。轮询是一种客户端重复向服务器发送请求直到服务器更新的技术。例如，所有现代 Web 浏览器都提供对 XMLHttpRequest 的支持，这是轮询服务器的原始方法之一。</description>
    </item>
    <item>
      <title>[译]什么是长轮询？</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/long-polling/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/long-polling/</guid>
      <description>原文链接：https://www.pubnub.com/guides/long-polling/
什么是长轮询？ 长轮询用于实时 Web 应用程序，以实现客户端和 Web 服务器之间近乎即时的通信。它在实时更新至关重要的聊天和消息应用程序中特别有用。
在传统的HTTP通信中，客户端向服务器发送新请求并等待响应。这称为短轮询。然而，在实时场景中，短轮询可能效率不高，因为它需要频繁向服务器请求，导致不必要的网络开销和增加延迟。
另一方面，长轮询通过在新数据可用之前保持请求长时间打开来提高效率。服务器保持请求打开并等待，直到有新信息发送回客户端。一旦服务器有新数据，它就会响应客户端，然后客户端可以处理数据并发起新的长轮询请求。
通过维持客户端和服务器之间的长期连接，长轮询减少了请求数量，最大限度地减少了延迟，并提高了实时通信。这使得它非常适合需要有效技术来构建可扩展和响应式聊天和消息传递应用程序以及其他利用游戏等实时数据的应用程序的用例。
长轮询如何工作？ 长轮询是一种用于实时通信的技术，用于在客户端和服务器之间实现近乎即时的消息传递。它在构建低延迟和实时更新至关重要的聊天和消息传递应用程序时特别有用。
传统上，Web 浏览器使用基于拉取的方法从服务器获取数据。客户端向服务器发送请求，服务器以请求的数据进行响应。这种方法称为短轮询，可能会造成通信延迟，因为客户端必须重复发送请求来检查更新。
另一方面，长轮询是一种基于推送的方法，允许服务器在更新可用时立即向客户端发送更新。它的工作原理如下：
客户端向服务器发起请求，通常通过 HTTP 请求。 服务器不会立即响应，而是将请求保持打开状态，从而保持连接处于活动状态。 如果没有新数据可用，服务器将等待，直到有数据要发回。 一旦服务器有新的数据或者发生预定义的超时，它就会用最新的信息响应客户端。 客户端收到响应后，立即向服务器发送另一个请求以维持连接。 这种发送请求和接收响应的循环持续进行，确保实时更新。 长轮询通过长时间保持请求-响应周期打开来有效地模拟客户端和服务器之间的实时连接。它允许服务器在更新可用时立即将更新推送到客户端，并且无需客户端重复检查更新。
使用什么技术来实现长轮询？ 长轮询是一种实现客户端和服务器之间实时通信的技术。它通常用于即时更新至关重要的聊天和消息传递应用程序。可以使用多种技术来实现长轮询，每种技术都有优点和注意事项。让我们探讨一些用于实现长轮询的常用技术。
HTTP 长轮询：
这是实现长轮询的最基本、最广泛使用的方法。它利用 HTTP 协议建立并维护客户端和服务器之间的长期连接。客户端向服务器发送请求，服务器将请求保持打开状态，直到有新数据可用或达到某个超时。一旦有新数据可用，服务器就会用更新的信息进行响应，客户端立即发送另一个请求以继续循环。这种方法易于实现，不需要特殊的服务器端技术。
网络套接字：
WebSocket 是一种全双工通信协议，可通过单个长期连接在客户端和服务器之间实现实时通信。它提供了比长轮询更高效、低延迟的替代方案。 WebSocket 支持双向数据流，允许客户端和服务器异步发送消息。它消除了频繁的 HTTP 请求并减少了网络开销。 WebSocket 非常适合需要即时更新和实时交互的应用程序。
服务器发送的事件 (SSE)：
SSE 是一种单向通信技术，允许服务器通过单个长期 HTTP 连接将数据推送到客户端。通过SSE，服务器可以向客户端发送多个更新，而不需要客户端不断地发出请求。服务器启动连接并以一系列事件的形式发送数据。客户端接收这些事件并可以根据需要进行处理。
在选择在应用程序中实现长轮询的技术时，需要考虑以下几个因素：
可扩展性：确保所选技术可以处理大量并发连接，并且可以随着用户群的增长而扩展。 WebSocket 和 SSE 通常比基于 HTTP 的长轮询更具可扩展性，因为它们允许更有效地使用服务器资源。 安全性：考虑所选技术的安全影响。 WebSocket 和 SSE 可以使用SSL/TLS等加密协议进行保护，从而确保数据隐私和完整性。基于 HTTP 的长轮询也可以得到保护，但可能需要额外的身份验证和访问控制措施。 浏览器支持：检查所选技术的浏览器兼容性。 WebSocket 和 SSE 比基于 HTTP 的长轮询具有更好的浏览器支持，这可能需要额外的技术或针对旧浏览器的后备选项。 实施复杂性：评估所选技术的实施和维护难易程度。基于 HTTP 的长轮询相对简单，而 WebSocket 和 SSE 可能需要更高级的知识和基础设施。考虑开发团队可用的专业知识水平以及实施和维护所选技术所需的资源。 长轮询与 WebSockets 长轮询和 WebSocket是在客户端（例如 Web 浏览器）和服务器之间实现实时连接的技术。尽管它们的目的相似，但两者存在显着差异。
长轮询是一种技术，客户端向 Web 服务器发出请求，服务器保持连接打开，直到有新数据要发回。如果服务器有新数据可用，则可以立即响应，或者在发送空响应之前等待指定的超时时间。无论哪种情况，客户端一旦收到响应，就会立即向服务器发出另一个请求以建立新连接。此过程不断重复，允许服务器在更新可用时立即将更新推送到客户端。
另一方面，WebSockets 在客户端和服务器之间提供持久的双向通信通道。与长轮询不同的是，长轮询会为每个请求建立一个新连接，而 WebSocket 连接只会建立一次并无限期地保持打开状态。这允许双向实时、低延迟通信。服务器可以随时向客户端推送数据，客户端也可以不等待响应就向服务器发送数据。
长轮询和 Web Sockets 之间的相似之处： 1.实时更新：长轮询和WebSockets都可以实现服务器和客户端之间的实时通信，允许即时更新，无需连续轮询或刷新。
减少服务器负载：这两种技术都通过仅在数据可用时发送数据来最大程度地减少不必要的请求，从而减少服务器负载并提高可扩展性。 广泛的语言和框架支持：许多流行的编程语言和框架都支持长轮询和WebSocket，使不同生态系统的开发人员都可以使用它们。 长轮询和 Web Sockets 之间的区别： 1.延迟：长轮询会引入延迟，因为服务器发送响应和客户端接收响应之间存在延迟。 WebSocket 提供双向、低延迟通信，从而实现更快的实时功能。</description>
    </item>
    <item>
      <title>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</guid>
      <description>原文链接：https://ably.com/topic/websockets-kafka
Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。
由于 Kafka 如此受欢迎，我很好奇是否可以使用它通过互联网和 WebSockets 将实时数据直接流式传输给最终用户。毕竟，Kafka 具有一系列特征，似乎使其成为一个值得注意的选择，例如：
高通量 低延迟 高并发 容错能力 持久性（持久性） 用于将 Kafka 消息流式传输到面向互联网的客户端的现有解决方案 我开始研究实时开发社区对这个用例的看法。我很快发现 Kafka 最初设计用于安全网络内进行机器对机器通信。这让我想到，如果您想通过 WebSocket 将数据从 Kafka 流式传输到面向互联网的用户，您可能需要使用某种中间件。
我继续研究，希望找到一些可以充当中间件的开源解决方案。我发现了其中的几个，理论上可以用作 Kafka 和通过互联网连接数据流的客户端之间的中介：
transfers_websockets_service kafka-websocket kafka-proxy-ws 不幸的是，上面列出的所有解决方案都只是概念证明，仅此而已。它们的功能集有限，并且尚未做好生产准备（尤其是大规模生产）。
然后我研究了成熟的科技公司如何解决这个 Kafka 用例；看来他们确实在使用某种中间件。例如，Trello 开发了WebSocket 协议的简化版本，仅支持订阅和取消订阅命令。 Slack 提供了另一个例子。该公司构建了一个名为Flannel的代理，它本质上是部署到边缘存在点的应用程序级缓存服务。
当然，像 Trello 或 Slack 这样的公司有能力投资所需的资源来构建此类解决方案。然而，开发自己的中间件并不总是一个可行的选择——这是一项非常复杂的任务，需要大量的资源和时间。另一种选择（最方便、最常见的一种）是使用已建立的第三方解决方案。
正如我们所看到的，普遍的共识似乎是 Kafka 本身不适合通过互联网进行最后一英里交付；您需要将它与另一个组件结合使用：面向互联网的实时消息传递服务。
在 Ably，我们的许多客户都通过我们面向互联网的 pub/sub 实时消息服务传输 Kafka消息。为了演示它是多么简单，下面是如何从 Kafka 消费数据并将其发布到 Ably 的示例：
const kafka = require(&amp;#39;kafka-node&amp;#39;); const Ably = require(&amp;#39;ably&amp;#39;); const ably = new Ably.Realtime({{ABLY_API_KEY}}); const ablyChannel = ably.channels.get(&amp;#39;kafka-example&amp;#39;); const Consumer = kafka.Consumer; const client = new kafka.</description>
    </item>
    <item>
      <title>ThingsBoard的领域模型</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</guid>
      <description>ThingsBoard是一个开源的物联网平台，用于管理和监控物联网设备和数据。它提供了一个可扩展的架构，可以连接各种设备，并实时收集、处理和分析设备生成的数据。
领域模型 在ThingsBoard中，领域模型是一个关键概念，用于描述物联网系统中的物理实体、属性和行为。以下是ThingsBoard中的主要领域模型组件：
租户（Tenant）：租户是ThingsBoard中的顶级组织单位。它代表了一个独立的实体，可以是一个用户、组织或公司。租户拥有和管理自己的设备、客户、规则和仪表板等资源。租户之间的数据和配置是相互隔离的，每个租户都有自己的独立环境。租户由系统管理员创建和管理。
租户配置（TenantProfile）：用于定义租户级别的配置和属性。
客户（Customer）：客户是租户下的子级实体，代表了物联网系统中的用户或组织。一个租户可以包含多个客户，每个客户都有自己的访问权限和角色。客户可以访问和监控租户下的设备和数据。客户可以有自己的设备、规则和仪表板等资源，但这些资源受到租户级别的限制。客户由租户管理员创建和管理。
用户（User）：保存用户的基本信息
用户的角色（Authority）：SYS_ADMIN、TENANT_ADMIN、CUSTOMER_USER、REFRESH_TOKEN、PRE_VERIFICATION_TOKEN 用户凭证（UserCredentials）：保存用户的密码、激活用户 Token、重置密码 Token、密码使用历史 用户认证设置（UserAuthSettings）：保存用户 2FA 认证设置 用户设置（UserSettings）：保存用户的设置，包括：通用设置、通知、访问过的仪表盘等等 系统设置（AdminSettings）：是用于配置和管理整个系统的全局设置和参数，包括：通用设置、邮件、JWT、连接设置等等。
审计日志（AuditLog）
资产（Asset）：指在系统中表示和管理的物理或虚拟实体。资产可以是设备、传感器、设施、车辆、建筑物、人员或其他实体，其状态、属性和行为可以被监测、控制和管理。
资产配置（AssetProfile）：配置资产使用的默认规则链、队列、移动端仪表盘
设备（Device）：
遥测数据（TsKV）： 最新遥测数据： 属性（AttributeKvEntry）：属性类型分为客户端、服务端、共享 远程调用（Rpc） 设备凭证（DeviceCredentials）： OTA： 设备配置（DeviceProfile）：配置设备使用的默认规则链、队列、移动端仪表盘、边缘网关默认规则链、分配的固件、分配的软件、传输方式、告警规则、设置预配置
告警（Alarm）：包括字段：租户、客户、类型、明细、发起者、告警级别（严重、重要、次要、警告、不确定）、是否应答、是否清除、受理人、开始时间、结束时间、应答时间、清除时间、受理时间、是否传播、是否传播给所有者、是否传播给租户
告警评论（AlarmComment）：
实体告警（EntityAlarm）：
事件（Event）：分为异常事件、组件生命周期事件、规则链调试事件、规则节点事件、统计事件
通知（Notification）:
通知请求（NotificationRequest） 通知模版（NotificationTemplate）： 通知规则（NotificationRule） 通知对象（NotificationTarget） 流程 上报遥测数据 设备配置启用告警规则。温度大于 20 时，产生告警。温度小于 20 时，清除告警。
创建一个设备，设备凭证使用 AccessToken
使用 http api 发送遥测数据
curl -v -X POST http://localhost:8080/api/v1/gs76dj5m47yd3lm1wurd/telemetry --header Content-Type:application/json --data &amp;#34;{temperature:25}&amp;#34; 查看告警
再次发送遥测数据，可以清除告警
源码分析：
使用 http api 发送数据，入口类在 common/transport/http 模块下的 DeviceApiController 类。这个类提供了以下几个接口：
GET /api/v1/{deviceToken}/attributes POST /api/v1/{deviceToken}/attributes GET /api/v1/{deviceToken}/telemetry POST /api/v1/{deviceToken}/telemetry GET /api/v1/{deviceToken}/rpc POST /api/v1/{deviceToken}/rpc POST /api/v1/{deviceToken}/rpc/{requestId} POST /api/v1/{deviceToken}/claim GET /api/v1/{deviceToken}/firmware POST /api/v1/{deviceToken}/firmware GET /api/v1/{deviceToken}/software POST /api/v1/{deviceToken}/software POST /api/v1/provision POST /api/v1/{deviceToken}/telemetry 处理逻辑：
HttpTransportContext TransportService DefaultTransportService TbQueueProducer&amp;lt;TbProtoQueueMsg&amp;lt;ToRuleEngineMsg&amp;gt;&amp;gt; ruleEngineMsgProducer TbRuleEngineQueueConsumerManager TbRuleEngineConsumerContext ActorSystemContext TbActorRef TbActorMailbox AppActor TenantActor RuleChainActor	RuleChainActorMessageProcessor RuleNodeActor RuleNodeActorMessageProcessor TbDeviceProfileNode DeviceState AlarmState DefaultTbContext DefaultTbClusterService TbRuleEngineProducerProvider TbQueueProducer&amp;lt;TbProtoQueueMsg&amp;lt;ToRuleEngineMsg&amp;gt;&amp;gt; toRuleEngine 这里面用到了 Transport 、Queue、Actor ，调用链非常长。</description>
    </item>
    <item>
      <title>All things about ThingsBoard</title>
      <link>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</link>
      <pubDate>Mon, 29 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</guid>
      <description>thingsboard 是一款乌克兰团队基于java语言研发的开源物联网框架，开源的是ce版，企业版需要购买授权且无源码。
官方网站：
Thingsboard 官网：https://thingsboard.io/
Thingsboard社区免费版本：https://demo.thingsboard.io/
Thingsboard 企业付费版本：https://thingsboard.cloud/
Thingsboard 源码：https://github.com/thingsboard/thingsboard
TBMQ 源码：https://github.com/thingsboard/tbmq
中文网：http://www.ithingsboard.com/
ThingsBoard 中文社区：https://www.thingsboard.club/
博客：
What is ThingsBoard? An Overview of ThingsBoard in 2024
How to access MQTT data with ThingsBoard | EMQ
分享｜五分钟学会使用 ThingsBoard 规则链
分享｜五分钟了解 ThingsBoard 物联网平台多种部署场景
分享｜五分钟快速学会 ThingsBoard 打包镜像和 Docker 部署
分享｜五分钟快速学会 ThingsBoard 对接物联网网关
分享｜五分钟快速学会 ThingsBoard DashBoard 基本操作
分享｜五分钟学会 ThingsBoard 本地编译运行和 Linux 部署
分享｜五分钟熟悉 ThingsBoard 前端二次开发。
https://www.cnblogs.com/east196/tag/ThingsBoard/
物联网技术学习指南 https://iot.mushuwei.cn/
物联网开源框架Thingsboard使用总结
https://www.weishadian.com/index.php/tag/thingsboard/page/5/
thingskit博客
ThingsBoard二次开发之源码分析1- 基础知识
源码分析：
ThingsBoard 源码分析 thingsboard源码解析 精尽thingsboard源码解析 https://github.com/blackstar-baba/how-2-use-thingsboard https://chenzhifu.xyz/categories/thingsboard IOT 平台：
http://iot.bctools.cn/ ThingsKit 分布式规则引擎系统，重构于开源IOT项目thingboard </description>
    </item>
    <item>
      <title>TBMQ测试和源码分析</title>
      <link>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</link>
      <pubDate>Sun, 28 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</guid>
      <description>启动 TBMQ 程序，浏览器访问 http://localhost:8083，创建一个 Application，Credentials Type 为 BASIC，客户端 ID、用户名和密码均设置为 tbmq_app
使用 mosquitto 测试订阅消息
mosquitto_sub -d -q 1 -h localhost -p 1883 -t tbmq/demo/+ -i &amp;#39;tbmq_app&amp;#39; -u &amp;#39;tbmq_app&amp;#39; -P &amp;#39;tbmq_app&amp;#39; -c -v Debug 调试 MqttSessionHandler 类的 channelRead(ChannelHandlerContext ctx, Object msg) 方法
第一次连接，消息类型是 CONNECT
消息：
固定头：MqttFixedHeader[messageType=CONNECT, isDup=false, qosLevel=AT_MOST_ONCE, isRetain=false, remainingLength=40]
变量头：MqttConnectVariableHeader[name=MQTT, version=4, hasUserName=true, hasPassword=true, isWillRetain=false, isWillFlag=false, isCleanSession=false, keepAliveTimeSeconds=60]
负载：MqttConnectPayload[clientIdentifier=tbmq_app, willTopic=null, willMessage=null, userName=tbmq_app, password=[116, 98, 109, 113, 95, 97, 112, 112]]
address 为空，故从 ChannelHandlerContext 获取客户端地址，并将地址保持到客户端 Session 上下文 ClientSessionCtx
初始化 Session：获取 clientI、mqtt 版本，调用 ClientMqttActorManager 初始化 session：创建 clientActorRef，发送一个 SessionInitMsg 消息
调用 ClientMqttActorManager connect 方法，发送一个 MqttConnectMsg 消息
第二次连接，消息类型是 SUBSCRIBE
MqttSubscribeMessage[fixedHeader=MqttFixedHeader[messageType=SUBSCRIBE, isDup=false, qosLevel=AT_LEAST_ONCE, isRetain=false, remainingLength=16], variableHeader=MqttMessageIdAndPropertiesVariableHeader[messageId=1, properties=io.</description>
    </item>
    <item>
      <title>ThingsBoard TBMQ本地和通过Docker运行</title>
      <link>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</link>
      <pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</guid>
      <description>docker-compose 运行 参考：https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/
下载源代码
git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git cd tbmq/docker 创建逻辑卷并执行安装程序
./scripts/docker-create-volumes.sh ./scripts/docker-install-tbmq.sh 运行服务
./scripts/docker-start-services.sh 浏览器访问：http://localhost:8083，用户名/密码：sysadmin@thingsboard.org / sysadmin
查看 HaProxy 日志，发现出现异常：Error: Specified qdisc kind is unknown. 。
目前，尚未找到解决办法，只能不使用 HaProxy 而是直接访问 tbmq1，修改 docker-compose.yml ，暴露容器端口 8083 到本地的 8083：
tbmq1: restart: always container_name: &amp;#34;${TBMQ_1_NAME}&amp;#34; image: &amp;#34;${DOCKER_REPO}/${DOCKER_NAME}:${TBMQ_VERSION}&amp;#34; ports: - &amp;#34;1883&amp;#34; - &amp;#34;8083:8083&amp;#34; #修改这里 - &amp;#34;8084&amp;#34; 然后，通过浏览器访问 浏览器访问：http://localhost:8081
源码编译并运行 安装好 JDK 17+ 和 Maven3.6.3+
下载源代码
git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git cd tbmq 编译代码
mvn clean install -DskipTests 通过 docker-compose 本地安装 postgres、kafka、redis
参考 docker 目录下的文件新建 docker-compose.postgres.yml 文件：
version: &amp;#39;3.0&amp;#39; services: postgres: restart: always image: postgres:15 ports: - &amp;#34;5432:5432&amp;#34; environment: POSTGRES_DB: thingsboard_mqtt_broker POSTGRES_PASSWORD: postgres volumes: - postgres-data:/var/lib/postgresql/data volumes: postgres-data: 新建 docker-compose.</description>
    </item>
    <item>
      <title>All things about MicroProfile</title>
      <link>https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/</link>
      <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/</guid>
      <description>最近在一些开源项目中看到了 MicroProfile ，于是在网上查阅了相关资料加深对 MicroProfile 的理解，并做了笔记形成此文。
MicroProfile MicroProfile是一个开放的企业级Java微服务框架，旨在简化和标准化基于微服务架构的应用程序开发。它是由Eclipse Foundation主导的一个开源项目，致力于提供轻量级、可移植和可互操作的Java微服务规范和实现。
MicroProfile的目标是为Java开发人员提供一个规范集合，使他们能够更轻松地构建和部署云原生应用程序。它结合了Java EE、Jakarta EE和其他相关规范，为开发人员提供了一组核心功能和扩展，以支持构建可伸缩、弹性和高性能的微服务应用程序。
MicroProfile提供了一系列的规范，包括：
MicroProfile Config MicroProfile JWT RBAC MicroProfile Health MicroProfile Fault Tolerance MicroProfile Metrics MicroProfile OpenAPI MicroProfile OpenTracing MicroProfile REST Client MicroProfile Context Propagation MicroProfile Reactive Streams Operators MicroProfile Reactive Messaging MicroProfile GraphQL MicroProfile Long Running Actions MicroProfile Telemetry MicroProfile 实现：
Payara Micro：是一个用于容器化Jakarta EE应用部署的轻量级中间件平台，不需要安装、配置或重写代码，可以快速部署 WildFly by Redhat：是一个轻量级、模块化的微服务框架，集中、简单、以用户为中心，实现了Jakarta EE和Eclipse MicroProfile的最新企业Java标准。 Quarkus by RedHat：为GraalVM和OpenJDK HotSpot构建的Kubernetes Native Java堆栈，由最佳的Java库和标准精心打造。 Apache TomEE：这是Apache Tomcat Java企业版，它结合了几个Java企业项目，包括Apache OpenEJB、Apache OpenJPA、Apache OpenWebBeans、Apache MyFaces和其他许多项目。 Hammock：这是一个基于CDI的bootstrapping Java企业微服务框架，由于其灵活性和简单性，用于构建应用程序 Openliberty：是一个开源的轻量级Java EE微服务框架，用于构建快速高效的云原生Java微服务应用，只运行所需的服务，同时考虑最新的Eclipse MicroProfile标准 Helidon by Oracle：这是一个Java库的集合，用于编写在快速的Helidon Reactive WebServer上运行的Java微服务，这是一个由Netty驱动的Web核心，同时支持MicroProfile及其标准规范。 KumuluzEE：是一个轻量级框架，用于使用标准的Java/JavaEE/JakartaEE/EE4J技术和API开发微服务，可选择扩展，如使用Node.js、Go和其他语言，并将现有应用程序迁移到云原生架构和微服务，以便更容易地进行云原生微服务开发。 Launcher by Fujitsu：它由富士通公司开发，是一个支持某些MicroProfile规范的Java EE微服务框架，可以将应用捆绑到über-jar/fat文件（JAR文件，包含其所有需要的依赖项） ThornTail (过时的)：是一个Java企业级微服务框架，它只将需要的和指定的包捆绑到一个JAR文件中，并有足够的运行时间来运行它们 MicroProfile发展历史 Infoq 上有一段介绍：
2016 年年中，作为对 Oracle 在发布 Java EE 8 方面停滞不前的直接回应，社区发起了两个新的倡议，也就是MicroProfile和 Java EE Guardians（现在被称为Jakarta EE Ambassadors）。Java 社区认为，随着用于构建微服务应用的 web 服务技术的出现，企业级 Java 已经落后于时代了。</description>
    </item>
    <item>
      <title>JHipster安装和介绍</title>
      <link>https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/</guid>
      <description>JHipster 是一个开发平台，可以快速生成，开发和部署现代 Web 应用程序+微服务架构。
JHipster 或者称 Java Hipster，是一个应用代码产生器，能够创建 Spring Boot/Spring Cloud + React/VueJs/AngularJS 的应用。使用 JHipster，首先你要配置好 Java 、Git 以及 Maven 或者 Gradle 的环境，然后通过 NodeJs 管理工具安装 JHipster 。
介绍 JHipster 官网： https://www.jhipster.tech/ ，截止本文发布时，最新版本为 8.0.0 。
JHipster 客户端使用到的技术栈有：
服务端使用的技术栈有：
支持以下部署方式：
JHipster 提供了一个 CLI 工具 generator-jhipster 和在线网站 https://start.jhipster.tech/ ，来创建应用。generator-jhipster 支持本地安装和 docker 安装两种方式。另外，还有一个轻量级的定制工具 jhipseter-lite 可以更细力度的定制。
JHipster Pro 是一个 JHipster 国内落地方案，符合国情的代码生成器解决方案，支持 MyBatis、SMS、OSS。当前最新版本对应 JHipster 官方版本：v7.1.0，网站最近一次跟新是在 2021 年 8 月份。
安装 generator-jhipster 前提条件安装 Java 和 NodeJs，然后通过 npm 或者 yarn 安装 generator-jhipster。以下是通过 npm 安装：
npm install -g generator-jhipster 查看版本：
$ npx jhipster --version 8.0.0-rc.1 另外，可以在 docker 里面安装：
docker image pull jhipster/jhipster docker container run --name jhipster -v ~/jhipster:/home/jhipster/app -v ~/.</description>
    </item>
    <item>
      <title>Java设计模式：Circuit Breaker</title>
      <link>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</guid>
      <description>本文主要介绍 Circuit Breaker 断路器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。
在一个分布式系统中，不可避免地会出现许多外部依赖，如数据库、网络服务等。这些外部依赖可能会发生故障、延迟或不可用的情况。如果没有适当的措施，这些故障可能会导致整个系统的性能下降，甚至系统崩溃。
断路器模式通过在应用程序和外部依赖之间引入一个断路器接口来解决这个问题。断路器接口充当一个中间层，监视对外部依赖的调用。当外部依赖发生故障时，断路器可以迅速地中断对外部依赖的调用，避免资源的浪费和故障的传递。
除了断路器接口之外，断路器模式还涉及以下几个重要的知识点：
故障阈值（Failure Threshold）：断路器模式通过设置故障阈值来判断服务的健康状态。当服务的失败次数达到或超过故障阈值时，断路器会打开，阻止对服务的进一步调用。 回退响应（Fallback Response）：当断路器打开时，可以为调用方提供回退响应。回退响应是一个预定义的响应，用于代替无法正常调用的服务的响应。回退响应可以是事先定义好的静态响应，或者是通过调用备用服务来获取的响应。 断路器状态（Circuit Breaker State）：断路器可以处于不同的状态，如关闭（Closed）、打开（Open）和半开（Half-Open）。初始状态通常是关闭状态，表示服务正常可用。当服务的失败次数达到故障阈值时，断路器会打开，阻止对服务的进一步调用。在一定时间后，断路器会进入半开状态，允许发起一次测试调用。如果测试调用成功，断路器将重新关闭；如果测试调用仍然失败，断路器将重新打开。 断路器的自动恢复（Automatic Recovery）：断路器模式通常具有自动恢复功能。在断路器打开的状态下，一段时间过去后，断路器会尝试重新关闭，以允许对服务的正常调用。自动恢复可以防止长时间的服务中断，提供给服务一个机会来恢复正常运行。 健康检查（Health Check）：断路器模式可以通过定期的健康检查来监控服务的状态。健康检查可以是定期发送心跳请求或执行一些特定的健康检查操作。通过健康检查，可以及时发现服务的故障或不可用状态，并相应地打开断路器。 示例 首先，您需要创建一个监控服务类，它将使用断路器来包装远程服务的调用。以下是一个示例监控服务类的代码：
public class MonitoringService { private final CircuitBreaker delayedService; private final CircuitBreaker quickService; public MonitoringService(CircuitBreaker delayedService, CircuitBreaker quickService) { this.delayedService = delayedService; this.quickService = quickService; } public String localResourceResponse() { return &amp;#34;Local Service is working&amp;#34;; } public String delayedServiceResponse() { try { return this.delayedService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } public String quickServiceResponse() { try { return this.quickService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } } 在上述代码中，MonitoringService 类接受两个断路器对象作为参数，分别用于包装延迟服务和快速服务的远程调用。它还包含一个用于获取本地资源的方法。</description>
    </item>
    <item>
      <title>Java设计模式：Chain</title>
      <link>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</link>
      <pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</guid>
      <description>本文主要介绍 Chain 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
目的 通过给多个对象一个处理请求的机会，避免请求的发送者和它的接收者耦合。串联接收对象并在链条中传递请求直到一个对象处理它。
介绍 责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象按照顺序处理请求，直到其中一个对象能够处理该请求为止。该模式将请求发送者和接收者解耦，使多个对象都有机会处理请求，同时避免请求发送者与接收者之间的直接耦合。
在责任链模式中，通常会构建一个处理请求的链条，链条上的每个对象都有一个指向下一个对象的引用。当请求到达链条的起点时，它会依次经过链条上的每个对象，直到找到能够处理请求的对象为止。每个对象都可以决定是否处理请求，或者将请求传递给下一个对象。
以下是责任链模式的几个关键角色：
抽象处理器（Handler）：定义处理请求的接口，并包含一个指向下一个处理器的引用。通常会提供一个处理请求的方法。 具体处理器（ConcreteHandler）：实现抽象处理器的接口，具体处理请求的逻辑。如果自己无法处理请求，则将请求传递给下一个处理器。 客户端（Client）：创建责任链，并将请求发送给链条的起点。 下面是一个示例，说明如何使用责任链模式处理请求：
// 抽象处理器 public abstract class Handler { protected Handler nextHandler; public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } public abstract void handleRequest(Request request); } // 具体处理器 public class ConcreteHandler1 extends Handler { @Override public void handleRequest(Request request) { if (满足处理条件) { // 处理请求的逻辑 } else if (nextHandler != null) { // 将请求传递给下一个处理器 nextHandler.handleRequest(request); } } } // 具体处理器2和具体处理器3的定义与具体处理器1类似 // 客户端 public class Client { public static void main(String[] args) { Handler handler1 = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); Handler handler3 = new ConcreteHandler3(); // 构建责任链 handler1.</description>
    </item>
    <item>
      <title>[译]Spring Boot3和Spring6中的新特性</title>
      <link>https://blog.chensoul.cc/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/</link>
      <pubDate>Fri, 13 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/</guid>
      <description>Spring Boot 3.0 于 2022 年 11 月正式发布，包含一些新功能和改进。这是继大约 4.5 年前发布 Spring Boot 2.0 后 Spring Boot 的第一个主要版本。它也是第一个支持 Spring Framework 6.0 的 Spring Boot GA 版本。作为开发人员，我们需要了解这些更新，才能顺利使用 Spring Boot。毫无疑问，新版本中最大的转变之一是放弃了对旧版本 Java 的支持。
在本文中，我们将讨论“Spring Boot 3 和 Spring 6 中的新功能”。
Spring 3.0 版本有哪些主要亮点？ Spring 3.0 版本的亮点包括：
Java 17 基线 支持 Jakarta EE 10 和 EE 9 基线 支持使用 GraalVM 生成本机映像，取代实验性 Spring Native 项目 通过测微计和测微计追踪提高了可观测性 谁可以真正使用 Spring Boot 3？ 如前所述，Spring Boot 3.0 最大的转变是忽略了对旧版本 Java 的支持。是的，我们至少需要 Java 17 才能使用 Spring Boot 3.0。因此，在使用 Spring Boot 3.0 之前必须具备 JDK 17 环境。
Spring Boot 3 和 Spring 6 有哪些新功能？ 这里需要注意的重要一点是 Spring Boot 3.0 构建于 Spring Framework 6 之上并需要 Spring Framework 6。因此，如果您的 pom.</description>
    </item>
    <item>
      <title>Java设计模式：Callback</title>
      <link>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</link>
      <pubDate>Fri, 13 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</guid>
      <description>本文主要介绍 Callback 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 回调（Callback）是一种设计模式，在这种模式中，一个可执行的代码被作为参数传递给其他代码，接收方的代码可以在适当的时候调用它。
在真实世界的例子中，当我们需要在任务完成时被通知时，我们可以将一个回调方法传递给调用者，并等待它调用以通知我们。简单地说，回调是一个传递给调用者的方法，在定义的时刻被调用。
维基百科说
在计算机编程中，回调又被称为“稍后调用”函数，可以是任何可执行的代码用来作为参数传递给其他代码；其它代码被期望在给定时间内调用回调方法。
代码 回调是一个只有一个方法的简单接口。
public interface Callback { void call(); } 下面我们定义一个任务它将在任务执行完成后执行回调。
public abstract class Task { final void executeWith(Callback callback) { execute(); Optional.ofNullable(callback).ifPresent(Callback::call); } public abstract void execute(); } public final class SimpleTask extends Task { private static final Logger LOGGER = getLogger(SimpleTask.class); @Override public void execute() { LOGGER.info(&amp;#34;Perform some important activity and after call the callback method.&amp;#34;); } } 最后这里是我们如何执行一个任务然后接收一个回调当它完成时。
var task = new SimpleTask(); task.executeWith(() -&amp;gt; LOGGER.info(&amp;#34;I&amp;#39;m done now.&amp;#34;)); 类图 适用场景 回调模式适用于以下场景：
异步操作：当需要在异步操作完成后执行某些操作时，可以使用回调模式。例如，在网络请求中，可以传递一个回调函数，在请求完成后调用该函数处理响应数据。 事件处理：当需要对事件进行响应和处理时，可以使用回调模式。例如，在图形界面开发中，可以注册某个控件的回调函数，以便在用户触发事件时执行相应的操作。 插件扩展：当需要为应用程序提供扩展性，允许第三方插件在特定事件发生时进行自定义操作时，可以使用回调模式。例如，游戏引擎中的事件系统允许开发者注册回调函数以响应游戏中的特定事件。 回调链：当需要按特定顺序执行多个回调函数，并将前一个回调函数的结果传递给下一个回调函数时，可以使用回调模式。这种情况下，回调函数形成了一个回调链。 模板方法模式：回调模式常与模板方法模式结合使用。模板方法模式定义了一个算法的骨架，而具体的步骤由子类实现。可以使用回调模式将子类中的具体步骤作为回调函数传递给模板方法。 总的来说，回调模式适用于需要在特定事件发生后执行某些操作的情况，以及需要实现解耦和灵活性的场景。它提供了一种在代码间通信的方式，使得代码可以更加模块化和可复用。
Java 例子 CyclicBarrier 构造函数可以接受回调，该回调将在每次障碍被触发时触发。 FAQ 回调模式如何实现解耦和灵活性？ 回调模式通过将一个可执行的代码块（回调函数）作为参数传递给其他代码，实现了解耦和灵活性。
解耦性：回调模式可以将调用方与被调用方解耦，使它们之间的关系更加松散。调用方只需要知道回调函数的接口，而不需要了解具体的实现细节。被调用方在特定的时机调用回调函数，而不需要知道调用方的具体实现。这种解耦性使得系统中的不同部分可以独立地进行修改和扩展，而不会对彼此产生过多的依赖。
灵活性：回调模式提供了一种灵活的扩展机制。通过传递不同的回调函数，可以改变程序的行为或逻辑，而不需要修改原有的代码。这种灵活性使得系统可以适应不同的需求和变化，而不需要进行大规模的修改或重构。同时，回调模式也允许在运行时动态地修改回调函数，从而实现更高级的动态行为。</description>
    </item>
    <item>
      <title>[译]Spring Security 面试问题</title>
      <link>https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/</link>
      <pubDate>Thu, 12 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/</guid>
      <description>本面试准备指南将讨论一些常见的 Spring Security 面试问题。无论您是准备面试还是只是想增强对 Spring Security 的了解，这些问题都将帮助您理解关键概念并指导您设计常见安全问题的解决方案。
1. Spring Security 的核心特性是什么？ Spring Security 提供的两个最突出的功能是身份验证和授权。这些功能在确保应用程序的安全性方面发挥着至关重要的作用。然而，Spring Security 超越了身份验证和授权，还提供了额外的功能来防止漏洞利用并与其他框架集成。
1.1.验证 身份验证是验证尝试访问应用程序的用户身份的过程。 Spring Security 提供多种身份验证方法（基于表单的身份验证、HTTP 基本身份验证、OAuth2、Siteminder、OpenID Connect、LDAP、JDBC 等），允许应用程序使用各种方法对用户进行身份验证。
它还支持自定义，当默认选项不满足要求时，可以实现自定义的身份验证机制。
1.2.授权 授权是向经过身份验证的用户或实体授予许可或权利的过程。用户或实体成功通过身份验证后，授权将决定他们可以在应用程序中访问哪些操作或资源。 Spring Security 为开发人员提供了多种方法来实现授权并控制用户对应用程序不同部分的访问。以下是一些常见的方法：
基于 Web URL 的授权：可以根据特定的 URL 或 URL 模式实施访问控制，规范哪些用户可以访问某些资源。 方法级授权：如果需要，甚至可以对 Java Bean 中的方法进行访问控制，从而在方法级提供细粒度的授权。 域实例级授权：Spring Security 提供了控制对特定域实例的访问的能力，允许基于某些实体的所有权或关联进行授权。 1.3.防止漏洞利用 Spring Security 提供了多种功能来防范常见的 Web 应用程序安全漏洞。一些显着的功能包括：
跨站请求伪造 (CSRF) 保护：Spring Security 会自动将 CSRF 令牌添加到表单和 AJAX 请求中，从而防止 CSRF 攻击。 跨站脚本 (XSS) 保护：Spring Security 支持输出编码，并提供实用程序通过清理用户输入来防止 XSS 攻击。 点击劫持保护：Spring Security 包括 X-Frame-Options 支持，以防止点击劫持攻击。 1.4.集成 Spring Security 与其他框架和库无缝集成，以增强应用程序的安全性。一些关键的集成是：
Spring MVC：Spring Security 与 Spring MVC 集成，为 Web 应用程序提供无缝的安全功能。它可以安全地处理请求、身份验证、授权并防止常见的 Web 漏洞。 Spring Data：Spring Security 与 Spring Data 集成，以便在查询中引用当前用户。这种集成确保可以根据身份验证和授权规则轻松访问和过滤用户特定的数据。 Jackson：Jackson 的支持可以实现 Spring Security 相关类的高效序列化和反序列化，特别是在使用分布式会话或 Spring Session 等框架时，从而提高效率和可扩展性。 密码学：Spring Security 与各种密码库和算法集成，以提供敏感信息的安全存储和传输。这种集成包括密码散列、加密和安全通信协议等功能，以保护数据的机密性和完整性。 有关 Spring Security 功能的更详细信息，请参阅官方文档。</description>
    </item>
    <item>
      <title>Java设计模式：Caching</title>
      <link>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</guid>
      <description>本文主要介绍 Caching 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 缓存模式（Caching Pattern）是一种设计模式，旨在通过在资源使用后将其保留在某个快速访问的存储中，并在需要时重新使用资源，以避免昂贵的资源重新获取。
缓存模式的目的是减少重复获取、初始化和释放同一资源所带来的不必要性能开销。通过将资源保留在缓存中，可以避免再次获取资源，从而提高系统的响应速度和性能。
在缓存模式中，当需要访问资源时，首先检查缓存中是否存在该资源的副本。如果缓存中存在资源，则直接从缓存中获取并返回给调用方。如果缓存中不存在资源，则需要从原始数据源或其他途径获取资源，并将其存储在缓存中，以供后续使用。
缓存模式适用于那些需要频繁访问、计算成本较高的资源的情况，例如数据库查询、网络请求、文件读写等。通过使用缓存模式，可以显著提升系统的性能和响应速度，减少对原始数据源的访问次数，从而降低系统的负载。
关于缓存模式的更多信息和实现方式，您可以参考以下资源：
Write-Through, Write-Around, Write-Back: Cache Explained：对缓存模式进行了详细解释和说明，提供了不同的缓存策略和实现方式。 Read-Through, Write-Through, Write-Behind, and Refresh-Ahead Caching：介绍了不同类型的缓存操作和策略，包括读取、写入、刷新等。 Cache-Aside Pattern：介绍了缓存模式中的一种常见实现方式，即&amp;quot;Cache-Aside&amp;quot;模式，包括其工作原理和使用方法。 实现策略 缓存模式有多种常见的实现策略，以下是其中一些常见的实现策略：
写入穿透（Write-Through）：当从数据源获取数据时，将数据同时写入缓存。这样，在下一次需要相同数据时，可以从缓存中获取，避免再次访问数据源。写入穿透策略确保缓存中始终保持最新的数据。 写入回写（Write-Back）：在数据发生变化时，首先将数据写入缓存，然后再定期将缓存中的数据批量写回到数据源。写入回写策略可以减少对数据源的频繁写入操作，提高性能。 写入旁路（Write-Around）：将写操作直接发送到数据源，而不是通过缓存。这样可以避免将不经常访问的数据写入缓存，从而节省缓存空间。只有当数据被读取时，才会将其放入缓存。 刷新预取（Refresh-Ahead）：在缓存中存储数据的同时，预先获取和更新与当前数据相关的其他数据。这样，当需要访问相关数据时，可以直接从缓存中获取，减少等待时间。 最近最少使用（Least Recently Used, LRU）：根据数据的访问频率和时间进行缓存淘汰。当缓存空间不足时，优先淘汰最近最少被访问的数据，以保留最常用的数据。 固定时间过期（Time-To-Live, TTL）：为缓存中的每个数据项设置一个固定的过期时间。一旦数据项超过过期时间，将被视为过期并从缓存中移除。 异步刷新（Asynchronous Refresh）：在数据过期或无效时，通过异步方式从数据源获取新数据并更新缓存。这样可以避免阻塞调用方，提高系统的响应速度。 缓存框架 当涉及到缓存框架或工具时，有几个常见且广泛使用的选项可以考虑。以下是其中一些常见的缓存框架或工具：
Ehcache: Ehcache 是一个流行的开源 Java 缓存框架，提供了各种缓存策略和功能，包括内存缓存、磁盘缓存、分布式缓存等。它易于使用且性能优秀，可以轻松集成到 Java 应用程序中。 Redis: Redis 是一个开源的高性能内存数据结构存储系统，也可以用作缓存。它支持多种数据结构和丰富的缓存功能，如数据过期、持久化、分布式缓存等。Redis 可以作为独立的缓存服务器，也可以与应用程序集成使用。 Memcached: Memcached 是一个简单而高效的分布式内存对象缓存系统。它以键值对的形式存储数据，并提供了分布式缓存的支持。Memcached 适用于高并发环境下的缓存需求，可以减轻后端数据库的压力。 Caffeine: Caffeine 是一个基于 Java 的高性能缓存库，专注于提供快速的缓存访问和高效的内存管理。它支持各种缓存策略和功能，并提供了线程安全和异步加载等特性。 Hazelcast: Hazelcast 是一个开源的分布式数据存储和计算平台，其中包括了分布式缓存的功能。它提供了高可用性和可扩展性，并支持多种缓存策略和分布式缓存模式。 Guava Cache: Guava Cache 是 Google 的 Guava 库中提供的一个本地缓存实现。它提供了简单易用的 API，支持各种缓存策略和功能，如过期时间、最大缓存大小、缓存统计等。 Apache Ignite: Apache Ignite 是一个内存计算平台，提供了分布式缓存和计算能力。它可以作为一个分布式缓存存储数据，并支持 SQL 查询、分布式计算、流处理等功能。 Couchbase: Couchbase 是一个面向企业应用的 NoSQL 数据库和缓存平台。它提供了可扩展的内存缓存功能，并支持数据持久化和分布式缓存集群。 Aerospike: Aerospike 是一个高性能的 NoSQL 数据库和缓存平台，专注于提供低延迟和高吞吐量的数据访问。它支持内存和闪存存储，并具有分布式缓存的功能。 Oracle Coherence: Oracle Coherence 是一个企业级的分布式缓存和数据网格解决方案。它提供了高可用性、可扩展性和事务支持，并支持多种缓存策略和数据复制模式。 </description>
    </item>
    <item>
      <title>Java设计模式：Bytecode</title>
      <link>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</link>
      <pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</guid>
      <description>本文主要介绍 Bytecode 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 字节码设计模式是一种软件设计模式，它允许以数据驱动的方式定义和执行行为。在字节码设计模式中，行为被表示为一系列虚拟机指令，这些指令被编码为字节码，并在运行时执行。
字节码设计模式的目的是将行为与代码分离，使得行为可以在不修改源代码的情况下进行动态调整和扩展。通过将行为以数据的形式表示，并使用字节码指令进行执行，可以实现更灵活和可配置的行为逻辑。
下面是字节码设计模式的一些关键要点：
指令集：字节码设计模式通过定义一组指令集来表示不同的行为。每个指令都有自己的语义和操作方式，用于执行特定的行为逻辑。 虚拟机：字节码设计模式需要一个虚拟机来执行指令集。虚拟机负责解释和执行字节码指令，并根据指令的要求进行相应的操作。 数据驱动的行为：字节码设计模式的核心思想是将行为表示为数据而不是代码。行为逻辑由字节码指令和相关数据组成，这些数据可以在运行时进行修改和配置，从而改变程序的行为。 动态性和灵活性：由于行为以数据形式存在，并且可以在运行时进行调整，字节码设计模式具有很高的动态性和灵活性。这使得开发人员可以根据需要动态地配置和修改行为，而无需修改源代码。 可重用性和扩展性：字节码设计模式提供了一种可重用和可扩展的方式来定义行为。通过定义不同的指令和指令集，可以构建具有不同行为的模块，并在不同的上下文中重复使用这些模块。 字节码设计模式在游戏开发、模拟器、脚本引擎等领域中具有广泛的应用。它使得开发人员能够以更灵活和动态的方式定义和管理程序的行为，从而提供了更高的可配置性和可扩展性。
举例 一个常见的例子是在游戏开发中使用字节码设计模式来定义角色的行为。假设我们有一个角色类（Character），它具有各种行为，例如攻击、防御、移动等。而这些行为的具体逻辑可能会根据游戏的需求而变化。
使用字节码设计模式，我们可以将角色的行为表示为一系列字节码指令，并通过虚拟机来执行这些指令，以实现角色的行为逻辑。
下面是一个简化的示例：
定义指令集： 我们定义一组指令来表示角色的行为，例如： ATTACK：进行攻击操作 DEFEND：进行防御操作 MOVE：进行移动操作 创建虚拟机： 我们创建一个虚拟机（VirtualMachine）类，它接收字节码作为输入，并执行相应的指令。虚拟机可以解释字节码指令，并根据指令的要求执行相应的行为逻辑。
定义角色行为： 我们创建一个角色（Character）类，它包含一个字节码数组，用于表示角色的行为。例如：
byte[] bytecode = {ATTACK, MOVE, ATTACK, DEFEND}; 执行角色行为： 我们将角色的字节码传递给虚拟机，并执行角色的行为逻辑：
VirtualMachine vm = new VirtualMachine(); vm.execute(bytecode); 虚拟机会解释字节码指令，并根据指令执行相应的行为。例如，当遇到 ATTACK 指令时，虚拟机会执行攻击操作；当遇到 MOVE 指令时，虚拟机会执行移动操作，依此类推。
除了游戏开发之外，字节码设计模式还在其他领域中有一些应用。以下是一些常见的应用领域：
脚本引擎：字节码设计模式可用于实现脚本引擎，其中脚本语言的行为逻辑被表示为字节码指令。这种设计使得脚本的执行可以更高效和灵活，同时还可以提供动态性和扩展性。 模拟器：在模拟器开发中，字节码设计模式可以用于定义和执行模拟器的指令集。模拟器可以通过解释和执行字节码指令来模拟不同的操作和行为，从而实现对特定系统或环境的模拟。 动态编程语言：一些动态编程语言（如 Python、Ruby 等）使用字节码设计模式来实现动态性和灵活性。这些语言将代码编译为字节码，并使用虚拟机来执行字节码指令，从而提供动态类型、动态绑定和运行时修改代码等特性。 JIT 编译器：即时编译器（Just-in-Time Compiler）可以使用字节码设计模式来实现代码的即时编译和优化。在运行时，即时编译器将字节码转换为本地机器码，并对代码进行优化，以提高执行效率。 领域特定语言（DSL）：字节码设计模式可以用于开发领域特定语言，其中 DSL 的行为逻辑被表示为字节码指令。这种设计使得 DSL 的执行更高效，并提供了更大的灵活性和可配置性。 需要注意的是，字节码设计模式的应用不仅限于以上领域，它可以在需要动态性、灵活性和可配置性的任何领域中发挥作用。由于字节码设计模式提供了一种将行为表示为数据的方式，使得行为可以在运行时进行调整和修改，因此在许多软件开发和系统设计的场景中都具有潜在的应用价值。
适用场景 字节码设计模式适用于以下场景：
动态行为需求：当系统需要在运行时动态地定义、配置或修改行为时，字节码设计模式可以提供一种灵活的方式。它允许将行为表示为字节码指令，以便在需要时进行调整和修改，而无需修改源代码。 可配置性和可扩展性要求：如果系统需要具有高度可配置和可扩展的行为逻辑，字节码设计模式可以提供一种解决方案。通过将行为表示为字节码指令和相关数据，开发人员可以轻松地定义和管理不同的行为模块，并在不同的上下文中重复使用这些模块。 脚本引擎和动态语言实现：字节码设计模式可以用于实现脚本引擎或支持动态语言的运行时环境。它可以将脚本行为表示为字节码指令，从而提供动态性、灵活性和执行效率。 模拟和仿真系统：在模拟和仿真系统中，字节码设计模式可以用于定义和执行模拟器的行为。通过使用字节码指令来表示各种操作和行为，可以实现对特定系统或环境的准确模拟。 编译器和优化器开发：字节码设计模式可用于开发编译器、优化器和即时编译器。它提供了一种将源代码转换为字节码指令，并在运行时进行优化和执行的方式，以提高程序的性能和效率。 总的来说，字节码设计模式在需要动态性、灵活性、可配置性和可扩展性的场景中都有应用价值。它可以用于开发各种类型的系统，包括游戏引擎、脚本引擎、模拟器、编译器、优化器等。</description>
    </item>
    <item>
      <title>[译]SPRING BOOT JWT - 如何使用 SPRING SECURITY 和 JSON WEB 令牌保护您的 REST API</title>
      <link>https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/</guid>
      <description>如果您快速搜索如何使用 JSON Web Tokens 在 Spring Boot 中保护 REST API，您会发现很多相同的结果。这些结果包含一种方法，该方法涉及编写自定义过滤器链并引入第三方库来编码和解码 JWT。
在看完这些令人费解且令人困惑的教程后，我说必须有一种更简单的方法来做到这一点。我做了任何直接接触 Spring Security 团队的人都会做的事情，我向他们寻求帮助。他们告诉我，Spring Security 确实使用 oAuth2 资源服务器内置了对 JWT 的支持。
在本教程中，您将学习如何使用 JSON Web Tokens (JWT) 和 Spring Security 来保护您的 API。我并不是说这种方法无论如何都很容易，但对我来说，它比其他选择更有意义。
Github 存储库
应用架构 在我们开始编写一些代码之前，我想确保我们对于我们正在构建的内容都达成共识。在下面的示例中，您有一个客户端应用程序，它可以是一个简单的命令行应用程序、一个用 Angular 或 Vue 等编写的完整前端应用程序，或者系统中的其他一些服务。
该客户端应用程序将调用使用 Spring Boot 编写的服务器应用程序，该应用程序通过 REST API 公开数据。在下面的示例中，它是一个整体，但如果您有分布式架构，则同样适用。当前有 3 个 REST 控制器公开资源产品、订单和客户。
您要做的是保护所有资源，以便当客户端调用 REST API 时，客户端将收到 401（未经授权），这意味着客户端请求尚未完成，因为它缺少所请求资源的有效身份验证凭据。
JSON 网络令牌 (JWT) JSON Web 令牌是一种开放方法，用于在两方之间安全地表示声明。 JWT 是一组声明（JSON 属性-值对），它们共同构成一个 JSON 对象。它由三部分组成：
Header: 由两个属性组成：{ &amp;ldquo;alg&amp;rdquo;: &amp;ldquo;HS256&amp;rdquo;, &amp;ldquo;typ&amp;rdquo;: &amp;ldquo;JWT&amp;rdquo; }。 alg 是用于加密 JWT 的算法。 Payload: 这是存储要发送的数据的地方；该数据存储为 JSON 属性-值对。 Signature: 这是通过加密创建的，使用标头中指定的算法：（i）base64Url 编码的标头，（ii）base64Url 编码的有效负载，以及（iii）秘密（或私钥）： HMACSHA256(base64UrlEncode(header) + &amp;#34;.&amp;#34; + base64UrlEncode(payload), secret|privateKey) 最终的 JWT 由三部分组成。每个都是 base64Url 编码的，并且与下一个之间用点分隔。有关更多详细信息，请参阅 openid.net 和 jwt.io 网站。</description>
    </item>
    <item>
      <title>[译]Spring Security 与 JWT for REST API</title>
      <link>https://blog.chensoul.cc/posts/2023/09/19/spring-security-tutorial/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/19/spring-security-tutorial/</guid>
      <description>免责声明：Spring Security 5+ 已发布 OAuth JWT 支持。建议使用最新版本的 OAuth 来支持 JWT，而不是使用自定义安全性或过滤器。
Spring 被认为是 Java 生态系统中值得信赖的框架，并且被广泛使用。将 Spring 称为框架不再有效，因为它更多的是涵盖各种框架的总括术语。其中一个框架是 Spring Security，它是一个功能强大且可定制的身份验证和授权框架。它被认为是保护基于 Spring 的应用程序的事实标准，因此，如果您希望实现 Spring JWT 令牌解决方案，那么将其基于 Spring Security 是有意义的。
尽管它很受欢迎，但我必须承认，当涉及到单页应用程序时，Spring 的配置并不简单和直接。我怀疑原因是它更多地是作为一个面向应用程序的 MVC 框架开始的，其中网页渲染发生在服务器端，并且通信是基于会话的。
如果后端基于 Java 和 Spring，那么使用 Spring Security 和 JWT 进行身份验证/授权并将其配置为无状态通信是有意义的。虽然有很多文章解释了这是如何完成的，但对我来说，第一次设置它仍然令人沮丧，我必须阅读并总结来自多个来源的信息。这就是我决定编写这个 Spring Security 教程的原因，我将在其中尝试总结并涵盖您在配置过程中可能遇到的所有必需的微妙细节和缺陷。
术语定义 在深入探讨技术细节之前，我想明确定义 Spring Security 上下文中使用的术语，以确保我们都使用相同的语言。 这些是我们需要解决的术语：
Authentication 验证是指根据提供的凭据验证用户身份的过程。一个常见的示例是在登录网站时输入用户名和密码。您可以将其视为对“您是谁？”这个问题的答案。 Authorization 授权是指假设用户已成功通过身份验证，则确定用户是否具有执行特定操作或读取特定数据的适当权限的过程。您可以将其视为“用户可以执行/阅读此操作吗？”问题的答案。 Principle 原则是指当前经过身份验证的用户。 Granted authority 授予权限是指经过认证的用户的权限。 Role 角色是指经过身份验证的用户的一组权限。 创建基本的 Spring 应用程序 在开始配置 Spring Security 框架之前，让我们创建一个基本的 Spring Web 应用程序。为此，我们可以使用 Spring Initializr 并生成一个模板项目。对于一个简单的 Web 应用程序，只需要 Spring Web 框架依赖就足够了：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 创建项目后，我们可以向其中添加一个简单的 REST 控制器，如下所示：
@RestController @RequestMapping(&amp;#34;hello&amp;#34;) public class HelloRestController { @GetMapping(&amp;#34;user&amp;#34;) public String helloUser() { return &amp;#34;Hello User&amp;#34;; } @GetMapping(&amp;#34;admin&amp;#34;) public String helloAdmin() { return &amp;#34;Hello Admin&amp;#34;; } } 之后，如果我们构建并运行该项目，我们可以在 Web 浏览器中访问以下 URL：</description>
    </item>
    <item>
      <title>Java设计模式：Builder</title>
      <link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</link>
      <pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</guid>
      <description>本文主要介绍 Builder 构造器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 构造器模式（Builder Pattern）是一种创建型设计模式，用于将复杂对象的构建过程与其表示分离，从而可以使用相同的构建过程创建不同的表示。
在构造器模式中，通常有两个主要角色：产品（Product）和建造者（Builder）。产品是最终构建的对象，而建造者负责构建产品。
以下是构造器模式的类图示例：
+-------------------+ +----------------------+ | Director | | Builder | +-------------------+ +----------------------+ | construct() | | buildPartA() | | | | buildPartB() | +-------------------+ | getResult() | +----------+-----------+ | v +----------+-----------+ | Product | +----------------------+ | partA | | partB | +----------------------+ 在上述类图中，Director（指导者）负责定义构建产品的顺序和方式，而Builder（建造者）负责实际构建产品的具体步骤。Product（产品）是最终构建的对象。
以下是一个简单的示例，演示如何使用构造器模式创建一个角色生成器的例子：
// 产品类 public class Character { private String profession; private String name; private String hairColor; private String weapon; // 构造器私有化，只能通过建造者创建对象 private Character() {} // Getters public String getProfession() { return profession; } public String getName() { return name; } public String getHairColor() { return hairColor; } public String getWeapon() { return weapon; } // 建造者类 public static class CharacterBuilder { private Character character; public CharacterBuilder() { character = new Character(); } public CharacterBuilder withProfession(String profession) { character.</description>
    </item>
    <item>
      <title>Java设计模式：Business Delegate</title>
      <link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</link>
      <pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</guid>
      <description>本文主要介绍 Business Delegate 业务委托模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 业务委托模式（Business Delegate Pattern）在表示层和业务层之间引入了一个抽象层，旨在实现这两个层之间的松散耦合，并封装了有关如何定位、连接和交互业务对象的逻辑。
在该模式中，业务委托（Business Delegate）充当一个中间人角色，负责将表示层的调用委托给业务对象。它隐藏了具体业务对象的实现细节，包括底层服务的查找和可访问性，以提供简化的接口供表示层使用。
业务委托模式用于解耦表示层和业务层。它基本上用于减少表示层代码中业务层代码的通信或远程查找功能。在业务层，我们有以下实体。
Client - 表示层代码可以是 JSP、Servlet 或 UI java 代码。 Business Delegate -业务委托 - 客户端实体提供对业务服务方法的访问的单个入口点类。 LookUp Service - 查找服务对象负责获取相关业务实现并提供对业务委托对象的业务对象访问。 Business Service - 业务服务接口。具体类实现该业务服务以提供实际的业务实现逻辑。 以下是一个示例的程序代码，演示了业务委托模式的实现：
public interface VideoStreamingService { void doProcessing(); } @Slf4j public class NetflixService implements VideoStreamingService { @Override public void doProcessing() { LOGGER.info(&amp;#34;NetflixService is now processing&amp;#34;); } } @Slf4j public class YouTubeService implements VideoStreamingService { @Override public void doProcessing() { LOGGER.info(&amp;#34;YouTubeService is now processing&amp;#34;); } } @Setter public class BusinessLookup { private NetflixService netflixService; private YouTubeService youTubeService; public VideoStreamingService getBusinessService(String movie) { if (movie.toLowerCase(Locale.ROOT).contains(&amp;#34;die hard&amp;#34;)) { return netflixService; } else { return youTubeService; } } } @Setter public class BusinessDelegate { private BusinessLookup lookupService; public void playbackMovie(String movie) { VideoStreamingService videoStreamingService = lookupService.</description>
    </item>
    <item>
      <title>Java设计模式：Bridge</title>
      <link>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</link>
      <pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</guid>
      <description>本文主要介绍 Bridge 桥接模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 桥接模式（Bridge Pattern）是一种结构型设计模式，用于将抽象与其实现分离，使它们可以独立地变化。桥接模式通过创建两个独立的层次结构，一个是抽象部分，一个是实现部分，来实现这种分离。
在桥接模式中，抽象部分包含抽象类或接口，定义了高层逻辑和功能。实现部分包含具体实现类，负责实现抽象部分定义的接口或方法。通过桥接模式，可以在两个层次结构中独立地扩展和变化类，而不会相互影响。同时，抽象部分和实现部分之间的耦合度降低，使系统更加灵活和可维护。
举例 考虑一下你拥有一种具有不同附魔的武器，并且应该允许将具有不同附魔的不同武器混合使用。 你会怎么做？ 为每个附魔创建每种武器的多个副本，还是只是创建单独的附魔并根据需要为武器设置它？ 桥接模式使您可以进行第二次操作。
翻译一下上面的武器示例。下面我们有武器的类层级：
public interface Weapon { void wield(); void swing(); void unwield(); Enchantment getEnchantment(); } public class Sword implements Weapon { private final Enchantment enchantment; public Sword(Enchantment enchantment) { this.enchantment = enchantment; } @Override public void wield() { LOGGER.info(&amp;#34;The sword is wielded.&amp;#34;); enchantment.onActivate(); } @Override public void swing() { LOGGER.info(&amp;#34;The sword is swinged.&amp;#34;); enchantment.apply(); } @Override public void unwield() { LOGGER.info(&amp;#34;The sword is unwielded.&amp;#34;); enchantment.onDeactivate(); } @Override public Enchantment getEnchantment() { return enchantment; } } public class Hammer implements Weapon { private final Enchantment enchantment; public Hammer(Enchantment enchantment) { this.</description>
    </item>
    <item>
      <title>[译]REST API 的自定义错误消息处理</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/global-error-handler-in-a-spring-rest-api/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/global-error-handler-in-a-spring-rest-api/</guid>
      <description>1. 概述 在本教程中，我们将讨论如何为 Spring REST API 实现全局错误处理程序。
我们将使用每个异常的语义为客户端构建有意义的错误消息，其明确的目标是为客户端提供所有信息以轻松诊断问题。
2. 自定义错误消息 让我们首先实现一个用于通过线路发送错误的简单结构 — ApiError：
public class ApiError { private HttpStatus status; private String message; private List&amp;lt;String&amp;gt; errors; public ApiError(HttpStatus status, String message, List&amp;lt;String&amp;gt; errors) { super(); this.status = status; this.message = message; this.errors = errors; } public ApiError(HttpStatus status, String message, String error) { super(); this.status = status; this.message = message; errors = Arrays.asList(error); } } 这里的信息应该很简单：
status – HTTP 状态代码 message – 与异常相关的错误消息 error – 构建的错误消息列表 当然，对于 Spring 中的实际异常处理逻辑，我们将使用 @ControllerAdvice 注解：
@ControllerAdvice public class CustomRestExceptionHandler extends ResponseEntityExceptionHandler { ... } 3. 处理错误请求异常 3.1.处理异常 现在让我们看看如何处理最常见的客户端错误 - 基本上是客户端向 API 发送无效请求的情况：
BindException – 发生致命绑定错误时抛出此异常。 MethodArgumentNotValidException – 当使用 @Valid 注解的参数验证失败时抛出此异常： @Override protected ResponseEntity&amp;lt;Object&amp;gt; handleMethodArgumentNotValid( MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { List&amp;lt;String&amp;gt; errors = new ArrayList&amp;lt;String&amp;gt;(); for (FieldError error : ex.</description>
    </item>
    <item>
      <title>[译]Spring Events</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/spring-events/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/spring-events/</guid>
      <description>1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。
事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。
有一些简单的准则需要遵循：
如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。
2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。
在本例中，事件类保存一条字符串消息：
public class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。
要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：
@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System.out.println(&amp;#34;Publishing custom event. &amp;#34;); CustomSpringEvent customSpringEvent = new CustomSpringEvent(this, message); applicationEventPublisher.publishEvent(customSpringEvent); } } 或者，发布者类可以实现 ApplicationEventPublisherAware 接口，这也将在应用程序启动时注入事件发布者。通常，使用 @Autowire 注入发布者会更简单。</description>
    </item>
    <item>
      <title>[译]使用@Async进行Spring Security上下文传播</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/spring-security-async-principal-propagation/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/spring-security-async-principal-propagation/</guid>
      <description>1. 简介 在本教程中，我们将重点关注使用 @Async 传播 Spring Security 主体 默认情况下，Spring Security 身份验证绑定到 ThreadLocal - 因此，当执行流在带有 @Async 的新线程中运行时，它不会是经过身份验证的上下文。
这并不理想——让我们解决它。
2.Maven 依赖 为了在 Spring Security 中使用异步集成，我们需要在 pom.xml 的依赖项中包含以下部分：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-config&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.7.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 可以在此处找到最新版本的 Spring Security 依赖项。
3.使用@Async 进行 Spring Security 传播 我们先写一个简单的例子：
@RequestMapping(method = RequestMethod.GET, value = &amp;#34;/async&amp;#34;) @ResponseBody public Object standardProcessing() throws Exception { log.info(&amp;#34;Outside the @Async logic - before the async call: &amp;#34; + SecurityContextHolder.getContext().getAuthentication().getPrincipal()); asyncService.asyncCall(); log.info(&amp;#34;Inside the @Async logic - after the async call: &amp;#34; + SecurityContextHolder.getContext().getAuthentication().getPrincipal()); return SecurityContextHolder.getContext().getAuthentication().getPrincipal(); } 我们想要检查 Spring SecurityContext 是否传播到新线程。首先，我们在异步调用之前记录上下文，接下来我们运行异步方法，最后再次记录上下文。 asyncCall() 方法具有以下实现：
@Async @Override public void asyncCall() { log.info(&amp;#34;Inside the @Async logic: &amp;#34; + SecurityContextHolder.getContext().getAuthentication().getPrincipal()); } 正如我们所看到的，只有一行代码将输出异步方法的新线程内的上下文。</description>
    </item>
    <item>
      <title>[译]使用Spring进行REST的错误处理</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/exception-handling-for-rest-with-spring/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/exception-handling-for-rest-with-spring/</guid>
      <description>1. 概述 本教程将说明如何使用 Spring 为 REST API 实现异常处理。我们还将获得一些历史概述，并了解不同版本引入了哪些新选项。
在 Spring 3.2 之前，Spring MVC 应用程序中处理异常的两种主要方法是 HandlerExceptionResolver 或 @ExceptionHandler 注解。两者都有一些明显的缺点。
从 3.2 开始，我们使用了 @ControllerAdvice 注释来解决前两个解决方案的局限性，并促进整个应用程序的统一异常处理。
现在 Spring 5 引入了 ResponseStatusException 类，一种在 REST API 中进行基本错误处理的快速方法。
所有这些都有一个共同点：它们很好地处理了关注点分离。应用程序可以正常抛出异常来指示某种失败，然后将单独处理。
最后，我们将了解 Spring Boot 带来的功能以及如何配置它以满足我们的需求。
2.方案一：控制器级@ExceptionHandler 第一个解决方案在 @Controller 级别工作。我们将定义一个处理异常的方法并使用@ExceptionHandler 进行注释：
public class FooController{ //... @ExceptionHandler({ CustomException1.class, CustomException2.class }) public void handleException() { // } } 这种方法有一个主要缺点：· 注解的方法仅对特定的控制器有效，而不是对整个应用程序全局有效。当然，将其添加到每个控制器使其不太适合通用异常处理机制。
我们可以通过让所有控制器扩展基本控制器类来解决此限制。
然而，对于无论出于何种原因这是不可能的应用程序来说，此解决方案可能是一个问题。例如，控制器可能已经从另一个基类扩展，该基类可能位于另一个 jar 中或不可直接修改，或者本身可能不可直接修改。
接下来，我们将研究另一种解决异常处理问题的方法 - 一种全局的方法，不包括对现有工件（例如控制器）的任何更改。
3.解决方案 2：HandlerExceptionResolver 第二种解决方案是定义一个 HandlerExceptionResolver。这将解决应用程序抛出的任何异常。它还允许我们在 REST API 中实现统一的异常处理机制。
在选择自定义解析器之前，让我们先回顾一下现有的实现。
3.1.异常处理器异常解析器 该解析器是在 Spring 3.1 中引入的，并且在 DispatcherServlet 中默认启用。这实际上是前面介绍的 @ExceptionHandler 机制如何工作的核心组件。
3.2.默认处理程序异常解析器 这个解析器是在 Spring 3.0 中引入的，并且在 DispatcherServlet 中默认启用。
它用于将标准 Spring 异常解析为其相应的 HTTP 状态代码，即客户端错误 4xx 和服务器错误 5xx 状态代码。以下是它处理的 Spring 异常的完整列表以及它们如何映射到状态代码。</description>
    </item>
    <item>
      <title>[译]如何在Spring中执行@Async</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/spring-async/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/spring-async/</guid>
      <description>1. 概述 在本教程中，我们将探讨 Spring 中的异步执行支持和 @Async 注解。
简单地说，用 @Async 注解 bean 的方法将使其在单独的线程中执行。换句话说，调用者不会等待被调用方法的完成。
Spring 的一个有趣的方面是，框架中的事件支持还 支持异步处理（如果需要）。
2.启用异步支持 让我们首先通过 Java 注解启用异步处理。
我们将通过将 @EnableAsync 添加到配置类来完成此操作：
@Configuration @EnableAsync public class SpringAsyncConfig { ... } 启用注解就足够了。但也有一些简单的配置选项：
annotation 默认情况下，@EnableAsync 检测 Spring 的 @Async 注解和 EJB 3.1 javax.ejb.Asynchronous。我们也可以使用此选项来检测其他用户定义的注解类型。 mode 指示应使用的建议类型 - 基于 JDK 代理或 AspectJ 编织。 proxyTargetClass 指示应使用的代理类型 — CGLIB 或 JDK。仅当模式设置为 AdviceMode.PROXY 时，此属性才有效。 order 设置应用 AsyncAnnotationBeanPostProcessor 的顺序。默认情况下，它最后运行，以便它可以考虑所有现有代理。 我们还可以使用任务命名空间通过 XML 配置启用异步处理：
&amp;lt;task:executor id=&amp;#34;myexecutor&amp;#34; pool-size=&amp;#34;5&amp;#34; /&amp;gt; &amp;lt;task:annotation-driven executor=&amp;#34;myexecutor&amp;#34;/&amp;gt; 3.@Async 注解 首先，让我们回顾一下规则。 @Async 有两个限制：
它必须仅应用于公共方法。 自调用（从同一个类中调用异步方法）将不起作用。 原因很简单：该方法需要公开，以便可以被代理。并且自调用不起作用，因为它绕过代理并直接调用底层方法。
3.1.返回类型为 void 的方法 这是配置具有 void 返回类型的方法以异步运行的简单方法：
@Async public void asyncMethodWithVoidReturnType() { System.out.println(&amp;#34;Execute method asynchronously. &amp;#34; + Thread.currentThread().getName()); } 3.2.具有返回类型的方法 我们还可以通过将实际返回包装在 Future 中来将 @Async 应用于具有返回类型的方法：</description>
    </item>
    <item>
      <title>Java设计模式：Balking</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</guid>
      <description>本文主要介绍 Balking 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 止步模式（Balking）是一种在对象处于特定状态时才执行操作的设计模式。它用于防止对象在不完整或不合适的状态下执行某些代码，从而确保代码的正确性和一致性。
该模式的核心思想是，在执行操作之前，检查对象的状态，并只在特定的状态下才执行操作。如果对象不处于预期状态，操作将被忽略或推迟执行，从而避免了不必要的操作或不一致的状态转换。
以下是止步模式的要点和示例：
对象状态检查：在执行操作之前，对象会检查自身的状态。这可以通过使用条件语句或状态标志来实现。 特定状态执行：只有当对象处于特定状态时，操作才会被执行。如果对象不满足执行条件，操作将被忽略或推迟执行。 线程安全考虑：由于止步模式通常涉及多线程环境，需要确保对共享资源的访问是线程安全的。可以使用同步机制（如 synchronized 关键字）来保护共享资源。 解释 真实世界例子
洗衣机中有一个开始按钮，用于启动衣物洗涤。当洗衣机处于非活动状态时，按钮将按预期工作，但是如果已经在洗涤，则按钮将不起任何作用。
通俗地说
使用止步模式，仅当对象处于特定状态时才执行特定代码。
维基百科说
禁止模式是一种软件设计模式，仅当对象处于特定状态时才对对象执行操作。例如，一个对象读取 zip 压缩文件并在压缩文件没打开的时候调用 get 方法，对象将在请求的时候”止步“。
程序示例
在此示例中， WashingMachine是一个具有两个状态的对象，可以处于两种状态：ENABLED 和WASHING。 如果机器已启用，则使用线程安全方法将状态更改为 WASHING。 另一方面，如果已经进行了清洗并且任何其他线程执行 wash（），则它将不执行该操作，而是不执行任何操作而返回。
这里是 WashingMachine 类相关的部分。
@Slf4j public class WashingMachine { private final DelayProvider delayProvider; private WashingMachineState washingMachineState; public WashingMachine(DelayProvider delayProvider) { this.delayProvider = delayProvider; this.washingMachineState = WashingMachineState.ENABLED; } public WashingMachineState getWashingMachineState() { return washingMachineState; } public void wash() { synchronized (this) { var machineState = getWashingMachineState(); LOGGER.info(&amp;#34;{}: Actual machine state: {}&amp;#34;, Thread.currentThread().getName(), machineState); if (this.washingMachineState == WashingMachineState.WASHING) { LOGGER.error(&amp;#34;Cannot wash if the machine has been already washing!&amp;#34;); return; } this.</description>
    </item>
    <item>
      <title>[译]Spring Boot项目如何实现JWT认证？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/</guid>
      <description>没有人可以否认这样一个事实：安全性是生产就绪应用程序的一项重要功能。尽管我们可以使用内存身份验证、JDBC 身份验证或通过 UserDetailsS​​ervice 来保护一个 Web 应用程序的安全。但是，当一个应用程序在内部使用其他应用程序的服务时，使用 Web 服务概念实现安全性就变得很重要。在这种情况下，我们使用具有特定有效期的令牌来保护我们的应用程序。此外，我们将学习“如何在 Spring Boot 项目中实现 JWT 身份验证？”以整体了解 JWT（JSON Web Token）身份验证背后的概念。
由于 JWT 代表“JSON Web Token”，很明显，该令牌仅以 JSON 形式保存数据。
此外，与上述身份验证技术不同，JWT 属于无状态身份验证。简而言之，它没有数据。通常，这种类型的身份验证用于 Web 服务、服务器的水平扩展，甚至在某种程度上用于 OAuth 技术。为了说明该网络服务，让我们可视化从亚马逊预订订单的过程。在这里，用户与 Amazon 应用程序交互，而 Amazon 应用程序在内部通过 Web 服务调用与支付网关应用程序交互。
现在让我们开始讨论我们的主题“如何在 Spring Boot 项目中实现 JWT 身份验证？”以及相关点。
您对整篇文章有何期望？ 读完本文后，您将能够回答：
什么是安全上下文中的无状态和有状态身份验证？ 无状态认证和有状态认证有什么区别？ 那么什么是 Token，什么是 JWT(JSON Web Token)？
使用 JWT 认证有什么好处？
JWT 内部如何运作？
我们在什么情况下使用 JWT 身份验证？
此外，JWT 身份验证和状态身份验证之间有什么区别？
此外，如何生成 JWT 编码令牌以及如何将其解码回来？
如何在 Spring Boot 项目中逐步实现 JWT 认证？
在 Spring Boot 3.0 中，如何在不使用 WebSecurityConfigurerAdapter 的情况下编写安全配置类？
最后，如何测试启用 JWT 安全的应用程序？
什么是无状态和有状态身份验证？ 通常有两种类型的认证技术。两者都发生在客户端服务器概念中，服务器仅在身份验证后才向客户端提供服务。这里的客户端可以是浏览器，也可以是另一个服务器。
状态认证 在这种类型的身份验证中，客户端和服务器之间涉及会话管理。当客户端向服务器请求服务时，它首先登录到服务器。然后服务器创建一个会话并以键值对的形式存储该信息。这个会话是服务器端的一种内存。我们也称其为 HttpSession，因为 Http 协议管理它。
此外，为了响应客户端请求，服务器以 Cookie 的形式向客户端提供带有响应的会话 id。该 cookie 存储在客户端浏览器中。当同一个客户端第二次发出请求时，请求头中也会带有 cookie。因此，服务器会检查请求标头，如果在 cookie 中发现相同的 SID（会话 ID），则假定该请求来自同一客户端。通过这种方式，会话管理就发生了。
当客户端从服务器注销时，会话会相应地被销毁。结果，服务器相应地从内存中删除会话信息（键值）。同样重要的是，对于每个新客户端，服务器都会创建一个新会话（内存）。
无状态身份验证 当客户端向服务器发送服务请求时，它首先登录到服务器。因此，服务器生成一个令牌（编码格式的数据）并将响应发送到客户端。在发出第二个请求时，客户端将相同的令牌与请求一起发送到服务器。现在，服务器从请求中读取令牌并验证令牌。事实上，从第一个请求开始，服务器就检查客户端的有效登录（凭据）。</description>
    </item>
    <item>
      <title>[译]Spring Boot项目如何实现Security？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/</guid>
      <description>如今，几乎每个客户都要求在实时应用程序中实现强大的安全功能。安全功能对于保持机密性、完整性和可用性的需求是非常有效的。现实世界中有很多类型的安全性，但我们作为开发人员将重点关注应用程序/软件安全性。
此外，在应用程序安全方面，我们的工作基本上是确保两件事。首先，只有有效的用户才能访问该应用程序。其次，如果用户有效，他/她只能访问该应用程序中允许的数据/信息。我认为，没有什么可以解释它们，因为您必须已经了解这两个术语，即身份验证和授权。
您可能已经猜到我们将在当前主题“如何在 Spring Boot 项目中实现安全性？”中讨论什么内容。
在本文中，我们将从基本原理开始学习。接下来，我们将逐步结束它，直到我们有信心在 Spring Boot 应用程序中实现安全功能。因此，让我们开始逐步讨论“如何在 Spring Boot 项目中实现安全性？”。 Spring Boot 教程页面上有一系列有关 Spring Boot Security 的教程。
我们在本文中介绍了两个版本的“如何在 Spring Boot 项目中实现安全性？”的示例：使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。此外，还涵盖了使用 Spring Boot 3.0 及更高版本的“如何在 Spring Boot 项目中实现安全性？”的示例。
您将从本文中学到什么？ 为什么我们需要在 Spring Boot 应用程序中实现安全性？
Security 在 Spring Boot 应用程序内部如何工作？
javax.servlet.Filter 在 Spring Boot 应用程序中实现安全性方面的作用是什么？
Spring Boot 项目中使用了多少种授权类型？
Spring Boot 项目中有多少种实现安全性的方法？
在 Spring Boot 项目中实现 WebSecurity 的步骤是什么？
另外，如何在 Spring Boot 项目中使用@EnableWebSecurity、@Configuration、@Bean？
如何实现内存中身份验证安全示例
如何实现 JDBC 认证安全示例
如何在 Spring Boot 项目中使用 Thymeleaf ？
如何测试启用安全的功能？
相反，如何禁用应用程序的安全功能？
最后但并非最不重要的一点是，您将学习“如何在 Spring Boot 项目中实现安全性？”使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。
为什么我们需要应用程序中的安全性？ 现在，随着恶意攻击将重点从操作系统和网络转移到应用程序/软件和移动设备/设备，一天的数据面临最大的风险。此外，从业务/客户的角度来看，应用程序安全在维护信任、建立品牌形象和降低风险方面发挥着重要作用。事实上，没有其中任何一项，都无法想象一家成功的企业。
总之，无论您是为了内部使用、销售目的还是购买目的而创建应用程序，安全性都是每个应用程序最重要的功能。
根据最新的 2020 年 Verizon 数据泄露调查报告，所有数据泄露中有 43% 是针对 Web 应用程序的攻击。这一数字比 2019 年增加了一倍。此外，86% 的违规行为都是出于经济动机。</description>
    </item>
    <item>
      <title>[译]如何在Spring Boot2中使用UserDetailsService实现安全性？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot2-using-userdetailsservice/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot2-using-userdetailsservice/</guid>
      <description>继续上一篇关于实现 Spring Security 的两种不同方法的文章，在本文中，我们将学习第三种方法“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现 Security？”。经过上一篇文章后，我希望我们都非常熟悉安全性的基础知识，甚至是 Spring Boot 应用程序中的安全性基础知识。这次我们将创建一个用户注册表并将用户及其角色保存到数据库中。
然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
如果您正在寻找“如何在 Spring Boot 3 及以上版本中使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”，请访问有关使用 Spring Boot 3 的 Spring Security UserDetailsS​​ervice 的单独文章。
为了说明这一点，我们将把一些角色发挥作用，并在整个过程中围绕它们进行发挥，以使其变得清晰。此外，我们将有一些页面并限制它们仅可由某些特定角色访问。同样重要的是，我们必须创建一个小型 MVC Web 应用程序，以使注册过程向用户开放。用户在注册时将输入自己的角色。然后我们可以在其之上实现安全功能。
让我们开始相应的主题“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”。
总体而言，您对这篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 在 Spring Security 应用程序中如何内部工作并带有流程图？
另外，如何使用注解：@EnableWebSecurity、@Configuration、@Bean、@GetMapping、@Autowired、@Data、@Entity、@Table、@Id、@GenerateValue、@Column、@ElementCollection、@CollectionTable、@JoinColumn ， @服务
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 是做什么的？使用它有什么好处？ UserDetailsS​​ervice 是 Spring 中 org.springframework.security.core.userdetails 包下的预定义接口。我们的实现类实现了这个接口并重写了它的 loadUserByUsername(String username) 方法。此方法返回 UserDetails，它又是一个接口。预定义的 User 类（org.springframework.security.core.userdetails.User）是 UserDetails 接口的实现。总之，在 loadUserByUsername(String username) 方法中，我们传递用户名，它返回我们预定义的 User 对象（org.</description>
    </item>
    <item>
      <title>[译]如何在Spring Boot3中使用UserDetailsService实现安全性？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot3-using-userdetailsservice/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot3-using-userdetailsservice/</guid>
      <description>作为有关 Spring Security 的系列文章的继续，在本文中我们将学习“如何在 Spring Boot 3 中使用 UserDetailsService 实现 Spring Boot 中的安全性？”。经过前面的文章，我希望我们都非常熟悉安全性的基础知识，甚至 Spring Boot 应用程序中的安全性基础知识。 Spring Boot 3 发布后，我们将在这里实现“使用 Spring Boot 3 的 Spring Security UserDetailsService”。
在本文中，我们将创建一个用户注册表单并将用户及其角色保存在数据库中。然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
您对整篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 Spring Boot 3 实现 Spring Security UserDetailsService？
如何在基于 Spring 的应用程序中实现基于角色的安全性？
此外，如何以及在哪里使用注释：@EnableWebSecurity，@Configuration，@Bean，@GetMapping，@Autowired，@Data，@Entity，@Table，@Id，@GenerateValue，@Column，@ElementCollection，@CollectionTable， @JoinColumn，@Service
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
示例中使用的软件/技术 有时某些版本与其他版本冲突。因此，列出经过测试可以相互协作的组合。下面是经过测试的软件组合，用于使用 Spring Boot 3 开发 Spring Security UserDetailsS​​ervice。它也使实现完美无缺。
Spring Boot 3.0.0
JDK 17 or later
Maven 3.8.1 3）Maven 3.8.1
IDE – STS 4.7.1. RELEASE
IDE – STS 4.7.1。发布
Jars Used 下面是这些示例中 maven 使用 pom.</description>
    </item>
    <item>
      <title>[译]没有WebSecurityConfigurerAdapter的Spring Security.md</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/</guid>
      <description>在 Spring Security 模块的上下文中，WebSecurityConfigurerAdapter 是一个抽象类，根据 Spring 官方网站 2022 年 2 月 21 日发布的公告，该类已从 Spring Security 5.7.0-M2 中弃用。它通常用于扩展 configure() 方法由自定义配置子类实现。因此，它鼓励用户转向基于组件的安全配置。为了支持对这种新配置设计的更改，我们将讨论常见用例列表和未来建议的替代方案。因此，我们将讨论没有 WebSecurityConfigurerAdapter 的 Spring Security 用例的实现。
了解这一变化很重要，因为迟早我们将使用最新版本的 Spring Security 来开发安全功能。让我们讨论“没有 WebSecurityConfigurerAdapter 的 Spring Security”主题及其相关概念。
什么是 WebSecurityConfigurerAdapter？ WebSecurityConfigurerAdapter 是 Spring Security 模块提供的一个抽象类。一般来说，我们使用它来重写它的 configure()方法来定义我们的安全配置类。通常，我们在应用程序中实现 Spring Security 时使用两个具有不同参数的 configure() 方法。一种用于声明与身份验证相关的配置，另一种用于声明与授权相关的配置。该代码类似于下面的代码片段。
@Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // configure Authentication ...... } @Override protected void configure(HttpSecurity http) throws Exception { // configure Authorization ...... } } 为什么我们需要学习这个改变？ 如果您使用 Spring Boot 2.7.0 和 maven，它将自动下载 Spring Security 5.7.0 或更高版本。在这种情况下，您会发现 WebSecurityConfigurerAdapter 已被弃用。如果您仍然想使用此类而不弃用，您可以在 pom.xml 中将 Spring Boot 版本更改为较低版本（例如 2.6.6 ），如下所示。它将自动下载低于 5.</description>
    </item>
    <item>
      <title>[译]Spring Security - JWT</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-jwt/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-jwt/</guid>
      <description>简介和概述 JSON Web Token 或 JWT（更常见的名称）是一种开放的互联网标准 (RFC 7519)，用于以紧凑的方式在各方之间安全地传输可信信息。令牌包含编码为 JSON 对象的声明，并使用私有密钥或公钥/私钥对进行数字签名。它们是独立且可验证的，因为它们经过数字签名。 JWT 可以进行签名和/或加密。
签名的令牌验证令牌中包含的声明的完整性，而加密的令牌则向其他方隐藏声明。
JWT 也可用于信息交换，尽管它们更常用于授权，因为它们比使用内存中随机令牌的会话管理具有很多优势。其中最重要的是允许将身份验证逻辑委托给第三方服务器，例如 AuthO 等。
JWT 令牌分为 3 部分，即标头、有效负载和签名，格式为
[Header].[Payload].[Signature] Header − JWT 令牌的标头包含应用于 JWT 的加密操作列表。这可以是签名技术、有关内容类型的元数据信息等。标头以 JSON 对象的形式呈现，该对象被编码为 base64URL。有效 JWT 标头的示例是 { &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 这里，“alg”为我们提供了有关所用算法类型的信息，“typ”为我们提供了信息的类型。
Payload − JWT 的有效负载部分包含使用令牌传输的实际数据。这部分也称为 JWT 令牌的“声明”部分。索赔可以分为三种类型：注册索赔、公开索赔和私人索赔。 注册的声明是推荐的但不是强制的声明，例如 iss(发行者)、sub(主题)、aud(受众) 等。 公共声明是那些使用 JWT 的人定义的声明。 私人声明或自定义声明是为了在相关方之间共享信息而创建的用户定义的声明。 有效负载对象的示例可以是。
{ &amp;#34;sub&amp;#34;: &amp;#34;12345&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Johnny Hill&amp;#34;, &amp;#34;admin&amp;#34;: false } 有效负载对象与标头对象一样，也采用 base64Url 编码，并且该字符串构成 JWT 的第二部分。
Signature− JWT 的签名部分用于验证消息在此过程中没有更改。如果令牌是用私钥签名的，它还会验证发送者的身份。它是使用编码的标头、编码的有效负载、秘密和标头中指定的算法创建的。签名的一个例子是。 HMACSHA256(base64UrlEncode(header) + &amp;#34;.&amp;#34; + base64UrlEncode(payload), secret); 如果我们输入标头、有效负载和签名，我们会得到一个令牌，如下所示。
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6I kpvaG4gRG9lIiwiYWRtaW4iOmZhbHNlfQ.gWDlJdpCTIHVYKkJSfAVNUn0ZkAjMxskDDm-5Fhe WJ7xXgW8k5CllcGk4C9qPrfa1GdqfBrbX_1x1E39JY8BYLobAfAg1fs_Ky8Z7U1oCl6HL63yJq_ wVNBHp49hWzg3-ERxkqiuTv0tIuDOasIdZ5FtBdtIP5LM9Oc1tsuMXQXCGR8GqGf1Hl2qv8MCyn NZJuVdJKO_L3WGBJouaTpK1u2SEleVFGI2HFvrX_jS2ySzDxoO9KjbydK0LNv_zOI7kWv-gAmA j-v0mHdJrLbxD7LcZJEGRScCSyITzo6Z59_jG_97oNLFgBKJbh12nvvPibHpUYWmZuHkoGvuy5RLUA 现在，可以使用承载模式在授权标头中使用此令牌。
Authorization − Bearer 授权 - 持有者
使用 JWT 令牌进行授权是其最常见的应用。令牌通常在服务器中生成并发送到客户端，并存储在会话存储或本地存储中。要访问受保护的资源，客户端将在标头中发送 JWT，如上所述。我们将在下面的部分中看到 Spring Security 中的 JWT 实现。</description>
    </item>
    <item>
      <title>[译]Spring Security - OAuth2</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-oauth2/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-oauth2/</guid>
      <description>OAuth 2.0 基础知识 OAuth 2.0 由 IETF OAuth 工作组开发并于 2012 年 10 月发布。它作为一种开放授权协议，使第三方应用程序能够代表资源所有者对 HTTP 服务进行有限访问。它可以在不泄露用户身份或长期凭证的情况下做到这一点。第三方应用程序本身也可以代表其使用它。
OAuth 的工作原理包括将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问用户的帐户。
让我们考虑一个例子。假设我们要登录网站“clientsite.com”。我们可以通过 Facebook、Github、Google 或 Microsoft 登录。我们选择上面给出的选项中的任何选项，然后我们将被重定向到相应的网站进行登录。如果登录成功，系统会询问我们是否要授予 clientsite.com 访问其请求的特定数据的权限。
我们选择所需的选项，然后使用授权代码或错误代码重定向到 clientsite.com，登录是否成功取决于我们在第三方资源中的操作。这就是 OAuth 2 的基本工作原理。
OAuth 系统涉及五个关键角色。让我们把它们列出来 -
User / Resource Owner − 用户/资源所有者- 最终用户，负责身份验证并同意与客户端共享资源。 User-Agent − 用户代理- 用户使用的浏览器。 Client − 客户端 - 请求访问令牌的应用程序。 Authorization Server − 授权服务器- 用于验证用户/客户端的服务器。它颁发访问令牌并在其整个生命周期内对其进行跟踪。 Resource Server − 资源服务器- 提供对所请求资源的访问的 API。它验证访问令牌并提供授权。 入门 我们将使用 Spring Security 和 OAuth 2.0 开发一个 Spring Boot 应用程序来说明上述内容。我们现在将开发一个带有内存数据库的基本应用程序来存储用户凭据。该应用程序将使我们轻松了解 OAuth 2.0 与 Spring Security 的工作原理。
让我们使用 Spring 初始化程序在 Java 8 中创建一个 Maven 项目。让我们从 start.spring.io 开始。我们生成一个具有以下依赖项的应用程序 -
Spring Web Spring Security Cloud OAuth2 Spring Boot Devtools 通过上面的配置，我们点击 Generate 按钮生成一个项目。该项目将以 zip 文件形式下载。我们将 zip 解压到一个文件夹中。然后我们可以在我们选择的 IDE 中打开该项目。我在这里使用 Spring Tools Suite，因为它针对 Spring 应用程序进行了优化。我们也可以根据需要使用 Eclipse 或 IntelliJ Idea。</description>
    </item>
    <item>
      <title>[译]Spring Security - 使用数据库表单登录</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-with-database/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-with-database/</guid>
      <description>内容 简介和概述 Spring Security 的基本组件 AuthenticationFilter 认证过滤器 AuthenticationManager 认证管理器 AuthenticationProvider 认证提供者 UserDetailsService 用户详情服务 PasswordEncoder 密码编码器 Spring 安全上下文 表单登录 使用数据库登录 登录尝试限制 入门（实用指南） 简介和概述 除了提供各种内置的身份验证和授权选项之外，Spring Security 还允许我们根据需要自定义身份验证过程。从自定义登录页面到我们自己的自定义身份验证提供程序和身份验证过滤器，我们几乎可以自定义身份验证过程的各个方面。
我们可以定义自己的身份验证过程，范围可以从使用用户名和密码的基本身份验证到复杂的身份验证，例如使用令牌和 OTP 的双因素身份验证。此外，我们可以使用各种数据库 - 关系数据库和非关系数据库，使用各种密码编码器，将恶意用户锁定在其帐户之外，等等。
今天，我们将讨论三种此类自定义，即自定义表单登录、数据库提供的身份验证以及限制登录尝试。尽管这些都是非常基本的用例，但它们仍然可以让我们更仔细地了解 Spring Security 的身份验证和授权过程。我们还将建立一个注册页面，用户可以通过该页面在我们的应用程序中进行注册。
首先我们看一下 Spring Security 的架构。它从 servlet 过滤器开始。这些过滤器拦截请求，对其执行操作，然后将请求传递到过滤器链中的下一个过滤器或请求处理程序，或者在不满足某些条件时阻止它们。正是在这个过程中，Spring Security 可以对请求进行身份验证并对请求执行各种身份验证检查。
它还可以通过不允许未经身份验证或恶意请求访问我们受保护的资源来阻止它们通过。因此我们的应用程序和资源受到保护。
Spring Security 架构的组件 正如我们在上图中看到的那样，Spring Security 的基本组件如下所示。我们将在讨论过程中简要讨论它们。我们还将讨论它们在身份验证和授权过程中的角色。
AuthenticationFilter 认证过滤器 这是拦截请求并尝试对其进行身份验证的过滤器。在 Spring Security 中，它将请求转换为身份验证对象并将身份验证委托给 AuthenticationManager。
AuthenticationManager 认证管理器 它是身份验证的主要策略接口。它使用单独的方法 authenticate()来验证请求。 authenticate() 方法执行身份验证，并在身份验证成功时返回 Authentication 对象，或者在身份验证失败时抛出 AuthenticationException。如果该方法无法决定，它将返回 null。这个过程中的认证过程委托给了我们接下来要讨论的 AuthenticationProvider。
AuthenticationProvider 认证提供者 AuthenticationManager 由 ProviderManager 实现，后者将流程委托给一个或多个 AuthenticationProvider 实例。任何实现 AuthenticationProvider 接口的类都必须实现两个方法——authenticate() 和 supports()。首先，我们来谈谈 supports()方法。它用于检查我们的 AuthenticationProvider 实现类是否支持特定的身份验证类型。如果支持则返回 true，否则返回 false。
接下来是 authenticate() 方法。这是身份验证发生的地方。如果支持该认证类型，则启动认证过程。这里这个类可以使用 UserDetailsS​​ervice 实现的 loadUserByUsername() 方法。如果未找到用户，则会抛出 UsernameNotFoundException。
另一方面，如果找到用户，则使用该用户的身份验证详细信息来验证该用户。例如，在基本认证场景中，可以将用户提供的密码与数据库中的密码进行核对。如果发现它们彼此匹配，则说明成功。然后我们可以从此方法返回一个 Authentication 对象，该对象将存储在安全上下文中，我们将在稍后讨论。
UserDetailsService 用户详情服务 它是 Spring Security 的核心接口之一。任何请求的身份验证主要取决于 UserDetailsS​​ervice 接口的实现。它最常用于数据库支持的身份验证中以检索用户数据。通过单独的 loadUserByUsername() 方法的实现来检索数据，我们可以在其中提供逻辑来获取用户的用户详细信息。如果未找到用户，该方法将抛出 UsernameNotFoundException。</description>
    </item>
    <item>
      <title>[译]Spring Security - 表单登录、记住我和注销</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-remember-me-and-logout/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-remember-me-and-logout/</guid>
      <description>内容 简介和概述 入门（实用指南） 简介和概述 Spring Security 附带了大量内置功能和工具，为我们提供方便。在这个例子中，我们将讨论其中三个有趣且有用的功能 -
表单登录 记住账号 登出 表单登录 基于表单的登录是 Spring Security 提供支持的一种用户名/密码身份验证形式。这是通过 Html 表单提供的。
每当用户请求受保护的资源时，Spring Security 都会检查请求的身份验证。如果请求未经过身份验证/授权，用户将被重定向到登录页面。登录页面必须由应用程序以某种方式呈现。 Spring Security 默认提供该登录表单。
此外，如果需要，任何其他配置都必须明确提供，如下所示 -
protected void configure(HttpSecurity http) throws Exception { http // ... .formLogin( form -&amp;gt; form.loginPage(&amp;#34;/login&amp;#34;) .permitAll() ); } 此代码要求模板文件夹中存在一个 login.html 文件，该文件将在点击 /login 时返回。该 HTML 文件应包含一个登录表单。此外，该请求应该是对 /login 的 post 请求。参数名称应分别为用户名和密码的“username”和“password”。除此之外，表单中还需要包含 CSRF 令牌。
一旦我们完成了代码练习，上面的代码片段就会更加清晰。
记住账号 这种类型的身份验证需要将记住我的 cookie 发送到浏览器。该 cookie 存储用户信息/身份验证主体，并存储在浏览器中。因此，网站可以在下次会话启动时记住用户的身份。 Spring Security 已为此操作准备了必要的实现。
一种使用散列来保护基于 cookie 的令牌的安全性，而另一种使用数据库或其他持久存储机制来存储生成的令牌。
登出 默认 URL /logout 通过以下方式注销用户：
使 HTTP 会话失效 清除配置的所有 RememberMe 身份验证 清除 SecurityContextHolder 重定向到/login?logout WebSecurityConfigurerAdapter 自动将注销功能应用于 Spring Boot 应用程序。
Getting Started (Practical Guide) 像往常一样，我们首先访问 start.spring.io。这里我们选择一个 maven 项目。我们将项目命名为“formlogin”并选择所需的 Java 版本。我在此示例中选择 Java 8。我们还继续添加以下依赖项 -</description>
    </item>
    <item>
      <title>[译]Spring Security 和 Spring Boot 入门</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security/</guid>
      <description>Spring Security 是一个有助于保护企业应用程序安全的框架。通过与 Spring MVC、Spring Webflux 或 Spring Boot 集成，我们可以创建一个强大且高度可定制的身份验证和访问控制框架。在本文中，我们将解释核心概念并仔细研究 Spring Security 提供的默认配置及其工作原理。我们将进一步尝试自定义它们并分析它们对示例 Spring Boot 应用程序的影响。
示例代码 本文附有 GitHub 上的工作代码示例。
创建示例应用程序 让我们从头开始构建一个 Spring Boot 应用程序，看看 spring 如何配置和提供安全性。让我们从 spring starter 创建一个应用程序并添加所需的最少依赖项。
生成项目后，我们将其导入到 IDE 中并将其配置为在端口 8083 上运行。
mvnw clean verify spring-boot:run (for Windows) ./mvnw clean verify spring-boot:run (for Linux) 在应用程序启动时，我们应该看到一个登录页面。
控制台日志打印作为默认安全配置的一部分随机生成的默认密码：
使用默认用户名 user 和默认密码（来自日志），我们应该能够登录该应用程序。我们可以在 application.yml 中覆盖这些默认值：
spring: security: user: name: admin password: passw@rd 现在，我们应该能够使用用户 admin 和密码 passw@rd 登录。
依赖版本 在这里，我们使用了 Spring Boot 2.7.5 版本。基于此版本，Spring Boot 内部将 Spring Security 版本解析为 5.7.4。但是，如果需要，我们可以在 pom.xml 中覆盖这些版本，如下所示：
&amp;lt;properties&amp;gt; &amp;lt;spring-security.version&amp;gt;5.2.5.RELEASE&amp;lt;/spring-security.version&amp;gt; &amp;lt;/properties&amp;gt; 了解安全组件 要了解默认配置的工作原理，我们首先需要了解以下内容：
Servlet Filters 过滤器 Authentication 认证 Authorization 授权 Servlet Filters 让我们仔细看看应用程序启动时的控制台日志。我们看到 DefaultSecurityFilterChain 在请求到达 DispatcherServlet 之前触发一系列过滤器。 DispatcherServlet 是 Web 框架中的关键组件，用于处理传入的 Web 请求并将它们分派到适当的处理程序进行处理。</description>
    </item>
    <item>
      <title>[译]Spring Security：深入了解身份验证和授权</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-authentication-and-authorization/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-authentication-and-authorization/</guid>
      <description>您可以使用本指南来了解 Spring Security 是什么以及其核心功能（如身份验证、授权或常见漏洞保护）如何工作。此外，还有全面的常见问题解答。
（编者注：大约 6500 字，您可能不想尝试在移动设备上阅读本文。将其添加为书签，稍后再回来。）
介绍 迟早每个人都需要为其项目添加安全性，在 Spring 生态系统中，您可以借助 Spring Security 库来实现这一点。
因此，您继续将 Spring Security 添加到您的 Spring Boot（或普通 Spring）项目中，然后突然……​
&amp;hellip;您有自动生成的登录页面。 &amp;hellip;您无法再执行 POST 请求。 &amp;hellip;​ 您的整个应用程序处于锁定状态，并提示您输入用户名和密码。 在经历了随后的精神崩溃之后，您可能会对这一切是如何运作的感兴趣。
什么是 Spring Security 以及它是如何工作的？ 简短的回答： 从本质上讲，Spring Security 实际上只是一堆 servlet 过滤器，可帮助您向 Web 应用程序添加身份验证和授权。 它还与 Spring Web MVC（或 Spring Boot）等框架以及 OAuth2 或 SAML 等标准很好地集成。它会自动生成登录/注销页面并防止 CSRF 等常见漏洞。 现在，这并没有什么帮助，不是吗？ 幸运的是，还有一个很长的答案：本文的其余部分。
网络应用程序安全：101 在成为 Spring Security 大师之前，您需要了解三个重要概念：
Authentication 验证 Authorization 授权 Servlet Filters 过滤器 建议：不要跳过本节，因为它是 Spring Security 所做的一切的基础。另外，我会让它尽可能有趣。
1. 认证 首先，如果您正在运行典型的（Web）应用程序，您需要用户进行身份验证。这意味着您的应用程序需要验证用户是否是他所声称的人，通常通过用户名和密码检查来完成。
用户：“我是美国总统。我的 *username* 是：potus！” 您的网络应用程序：“当然可以，那么您的 *password* 是什么，总统先生？” 用户：“我的密码是：th3don4ld”。 您的网络应用程序：“正确。欢迎，先生！”
2、授权 在更简单的应用程序中，身份验证可能就足够了：用户经过身份验证后，她就可以访问应用程序的每个部分。
但大多数应用程序都有权限（或角色）的概念。想象一下：可以访问您的网上商店面向公众的前端的客户，以及可以访问单独管理区域的管理员。
两种类型的用户都需要登录，但身份验证这一事实并不能说明他们可以在系统中执行哪些操作。因此，您还需要检查经过身份验证的用户的权限，即您需要授权该用户。
用户：“让我玩那个核足球&amp;hellip;&amp;hellip;”。 您的网络应用程序：“等一下，我需要先检查您的 *permissions* ……是的，总统先生，您拥有正确的许可级别。尽情享受吧。” 用户：“那个红色按钮又是什么……​？”
3.Servlet 过滤器 最后但并非最不重要的一点是，让我们看一下 Servlet 过滤器。它们与身份验证和授权有什么关系？ （如果您对 Java Servlet 或 Filter 完全陌生，我建议您阅读旧的但仍然非常有效的 Head First Servlets 书。）</description>
    </item>
    <item>
      <title>[译]为 Spring Boot 应用程序创建优化的 Docker 映像</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-boot-docker/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-boot-docker/</guid>
      <description>容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。
本文着眼于容器化 Spring Boot 应用程序的不同方法：
使用 Docker 文件构建 Docker 镜像， 使用 Cloud-Native Buildpack 从源代码构建 OCI 映像， 通过使用分层工具将 JAR 的各个部分拆分为不同的层，在运行时优化映像。 示例代码 本文附有 GitHub 上的工作代码示例。
容器术语 我们将从整篇文章中使用的容器术语开始：
Container image: 具有特定格式的文件。我们通过运行构建工具将应用程序转换为容器映像。 Container: 容器镜像的运行时实例。 Container engine: t 负责运行 Container 的守护进程。 Container host: 容器引擎运行的主机。 Container registry: 用于发布和分发容器映像的共享位置。 OCI Standard: 开放容器倡议 (OCI) 是在 Linux 基金会下形成的一个轻量级、开放的治理结构。 OCI 镜像规范定义了容器镜像格式和运行时的行业标准，以确保所有容器引擎都可以运行任何构建工具生成的容器镜像。 为了容器化应用程序，我们将应用程序封装在容器映像中，并将该映像发布到共享注册表。容器运行时从注册表中提取该映像，解压该映像，然后在其中运行应用程序。
Spring Boot 2.3 版本提供了用于构建 OCI 映像的插件。
Docker 恰好是最常用的容器实现，并且我们在示例中使用 Docker，因此本文中所有后续对容器的引用都将指 Docker。
以传统方式构建容器镜像 通过向 Docker 文件添加一些指令，可以非常轻松地创建 Spring Boot 应用程序的 Docker 镜像。
我们首先构建一个可执行 JAR，并作为 Docker 文件指令的一部分，在应用必要的自定义后将可执行 JAR 复制到基本 JRE 映像上。
让我们从 Spring Initializr 创建带有 web 、 lombok 和 actuator 依赖项的 Spring Boot 应用程序。我们还添加了一个休息控制器来使用 GET 方法公开 API。
创建 Docker 文件 接下来，我们通过添加 Dockerfile 来容器化该应用程序：</description>
    </item>
    <item>
      <title>[译]深入了解Spring事务管理：@Transactional</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/</guid>
      <description>您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。
唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。
介绍 在本指南中，您将了解 Spring 核心事务抽象框架的主要支柱（这是一个令人困惑的术语，不是吗？） - 用大量代码示例进行描述：
@Transactional （声明式事务管理）与编程式事务管理。 物理事务与逻辑事务。 Spring @Transactional 与 JPA/Hibernate 集成。 Spring @Transactional 与 Spring Boot 或 Spring MVC 集成。 回滚、代理、常见陷阱等等。 与 Spring 官方文档相反，本指南不会直接深入探讨 Spring-first 主题，从而让您感到困惑。
相反，您将以非常规的方式学习 Spring 事务管理：从头开始，一步一步。这意味着，从普通的老式 JDBC 事务管理开始。
Why? 为什么？
因为 Spring 所做的一切都是基于这些 JDBC 基础知识。如果您掌握了这些基础知识，稍后您将可以使用 Spring 的 @Transactional 注释节省大量时间。
普通 JDBC 事务管理的工作原理 如果您在不完全了解 JDBC 事务的情况下考虑跳过本节：请不要这样做。
如何启动、提交或回滚 JDBC 事务 第一个重要的收获是：无论您使用 Spring 的 @Transactional 注释、普通 Hibernate、jOOQ 还是任何其他数据库库，都没有关系。
最后，它们都执行相同的操作来打开和关闭（我们称之为“管理”）数据库事务。普通的 JDBC 事务管理代码如下所示：
import java.sql.Connection; Connection connection = dataSource.getConnection(); // (1) try (connection) { connection.setAutoCommit(false); // (2) // execute some SQL statements... connection.commit(); // (3) } catch (SQLException e) { connection.</description>
    </item>
    <item>
      <title>Spring Security和OAuth2发展过程</title>
      <link>https://blog.chensoul.cc/posts/2023/08/15/spring-security-oauth2-history/</link>
      <pubDate>Tue, 15 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/15/spring-security-oauth2-history/</guid>
      <description>Spring Security 的发展过程 Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分，于 2004 年发布，现在已经成为 Spring 生态系统的核心组件。 Spring Security 的发展过程可以分为三个阶段：
第一阶段：Spring Security 起源于一个名为 Acegi Security 的开源项目，初期重点实现了 Spring 应用的身份认证和授权服务功能。2003 年，Acegi Security 作为一个孵化项目被捐献给 Spring 社区。2004 年，正式作为 Spring 框架的核心组件之一 Absorbed 进 Spring。并更名为 Spring Security。Spring Security 1.0 版本 Spring Security 1.0 版本发布于 2004 年。它提供了最基本的安全功能，包括身份验证和授权。身份验证是验证用户是否是他们所声称的人的过程。授权是确定用户是否有权访问特定资源的过程。 Spring Security 1.0 版本使用了以下技术来实现身份验证和授权：
表单身份验证：表单身份验证是通过用户提交表单来验证用户身份的过程。 基于角色的访问控制 (RBAC)：RBAC 是一种授权模型，它将用户分配到角色，然后这些角色被授予对特定资源的访问权限。 第二阶段：Spring Security 2.0 版本 Spring Security 2.0 版本发布于 2006 年。它提供了更多的安全功能，包括加密和会话管理。加密是将数据转换成无法被他人理解的形式的过程。会话管理是跟踪用户会话的状态的过程。 Spring Security 2.0 版本使用了以下技术来实现加密和会话管理：
安全套接字层 (SSL)：SSL 是一种加密协议，它可以保护数据在传输过程中不被窃听。 会话管理：Spring Security 提供了自己的会话管理实现，它可以跟踪用户会话的状态。 第三阶段：Spring Security 3.0 版本 Spring Security 3.0 版本发布于 2008 年。它是一个重大的版本更新，它提供了许多新的安全功能，包括 OAuth、SAML 和 OpenID。 OAuth 是一种授权框架，它允许第三方应用程序访问用户的资源。SAML 是一种单点登录 (SSO) 协议，它允许用户在一个地方登录，然后访问多个网站。OpenID 是一种开放的身份验证协议，它允许用户使用他们选择的身份提供商来验证他们的身份。 Spring Security 3.0 版本使用了以下技术来实现 OAuth、SAML 和 OpenID：</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记17：减少可变性</title>
      <link>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</link>
      <pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</guid>
      <description>本文是 《Effective Java 3》第四章《类和接口》的学习笔记：减少可变性。
原文 不可变类是实例不能被修改的类。每个实例中包含的所有信息在对象的生命周期内都是固定的，因此永远不会观察到任何更改。Java 库包含许多不可变的类，包括 String、基本类型的包装类、BigInteger 和 BigDecimal。这么做有很好的理由：不可变类比可变类更容易设计、实现和使用。它们不太容易出错，而且更安全。
要使类不可变，请遵循以下 5 条规则：
1、不要提供修改对象状态的方法（这类方法也被称为修改器）
2、确保类不能被继承。 这可以防止粗心或恶意的通过子类实例对象状态可改变的方式，损害父类的不可变行为。防止子类化通常用 final 修饰父类，但是还有一种替代方法，我们将在后面讨论。
3、所有字段用 final 修饰。 这清楚地表达了意图，并由系统强制执行。同样，如果在没有同步的情况下，引用新创建的实例并从一个线程传递到另一个线程，那么就有必要确保正确的行为，就像内存模型中描述的那样。
4、所有字段设为私有。 这将阻止客户端访问字段引用的可变对象并直接修改这些对象。虽然在技术上允许不可变类拥有包含基本类型或对不可变对象的引用的公共 final 字段，但不建议这样做，因为在以后的版本中无法更改内部表示。
5、确保对任何可变组件的独占访问。 如果你的类有任何引用可变对象的字段，请确保该类的客户端无法获得对这些对象的引用。永远不要向提供对象引用的客户端初始化这样的字段，也不要从访问器返回字段。在构造函数、访问器和 readObject 方法中创建防御性副本。
前面条目中的许多示例类都是不可变的。其中一个类是 PhoneNumber，它的每个属性都有访问器，但没有对应的修改器。下面是一个稍微复杂的例子：
// Immutable complex number class public final class Complex { private final double re; private final double im; public Complex(double re, double im) { this.re = re; this.im = im; } public double realPart() { return re; } public double imaginaryPart() { return im; } public Complex plus(Complex c) { return new Complex(re + c.re, im + c.im); } public Complex minus(Complex c) { return new Complex(re - c.</description>
    </item>
    <item>
      <title>Java设计模式：Async Method Invocation</title>
      <link>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</link>
      <pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</guid>
      <description>本文主要介绍 Async Method Invocation 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 Async Method Invocation（异步方法调用）是一种编程模式，用于处理异步操作和并发执行。它允许在执行某个操作时不阻塞主线程，而是将操作委托给另一个线程或处理程序，并在操作完成后获取结果或执行回调。
异步方法调用的主要目的是提高应用程序的性能和响应能力。通过将耗时的操作（如网络请求、文件读写、数据库查询等）置于后台线程或异步任务中，可以使主线程能够继续执行其他任务，而不会被阻塞。
异步方法调用可以在不同的编程语言和框架中以不同的方式实现，包括以下几种常见的形式：
回调函数（Callback）：通过定义回调函数，将异步操作的结果传递给调用方。当异步操作完成时，回调函数会被调用并处理结果。 Future/Promise（Future/Deferred）：通过 Future 或 Promise 对象表示异步操作的结果，调用方可以在需要时获取结果或添加回调函数来处理结果。 异步/await：异步/await 是一种语法糖，用于简化异步代码的编写和理解。它允许以同步的方式编写异步操作，使代码更具可读性。 观察者模式（Observer）：通过定义观察者对象，异步操作的结果可以被观察者订阅。当结果可用时，观察者会被通知并执行相应的操作。 使用异步方法调用可以提高应用程序的并发性能和用户体验。它可以在后台执行耗时的操作，使主线程保持响应，并允许应用程序同时处理多个并发请求。然而，对于并发操作的正确处理和管理资源的安全性仍然需要仔细考虑和实施。
举例 AsyncResult（用于异步评估值的中间容器），AsyncCallback（可以在任务完成时被执行）和AsyncExecutor（用于管理异步任务的执行）。
public interface AsyncResult&amp;lt;T&amp;gt; { boolean isCompleted(); T getValue() throws ExecutionException; void await() throws InterruptedException; } public interface AsyncCallback&amp;lt;T&amp;gt; { void onComplete(T value, Optional&amp;lt;Exception&amp;gt; ex); } public interface AsyncExecutor { &amp;lt;T&amp;gt; AsyncResult&amp;lt;T&amp;gt; startProcess(Callable&amp;lt;T&amp;gt; task); &amp;lt;T&amp;gt; AsyncResult&amp;lt;T&amp;gt; startProcess(Callable&amp;lt;T&amp;gt; task, AsyncCallback&amp;lt;T&amp;gt; callback); &amp;lt;T&amp;gt; T endProcess(AsyncResult&amp;lt;T&amp;gt; asyncResult) throws ExecutionException, InterruptedException; } ThreadAsyncExecutor是AsyncExecutor的实现。 接下来将突出显示其一些关键部分。
public class ThreadAsyncExecutor implements AsyncExecutor { @Override public &amp;lt;T&amp;gt; AsyncResult&amp;lt;T&amp;gt; startProcess(Callable&amp;lt;T&amp;gt; task) { return startProcess(task, null); } @Override public &amp;lt;T&amp;gt; AsyncResult&amp;lt;T&amp;gt; startProcess(Callable&amp;lt;T&amp;gt; task, AsyncCallback&amp;lt;T&amp;gt; callback) { var result = new CompletableResult&amp;lt;&amp;gt;(callback); new Thread( () -&amp;gt; { try { result.</description>
    </item>
    <item>
      <title>Java设计模式：API Gateway </title>
      <link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</link>
      <pubDate>Sun, 13 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</guid>
      <description>本文主要介绍 API Gateway 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
目的 API 网关设计模式旨在将所有对微服务的调用聚合到一起。客户端通过调用 API 网关来实现对多个微服务的访问，而不是直接调用每个微服务。这种模式的目的是解决以下问题：
减少客户端的网络请求：如果客户端直接调用每个微服务，会导致额外的网络请求，增加加载时间。通过使用 API 网关，客户端只需要进行一次调用，而不是多次调用。 解耦客户端和微服务：如果客户端直接与每个微服务进行通信，客户端与微服务之间的耦合度很高。当微服务的实现发生变化或位置发生变化时，需要更新所有客户端。使用 API 网关可以将客户端与具体的微服务解耦，客户端只需要与 API 网关通信。 提供集中化的功能和服务：API 网关可以实现一些通用的功能和服务，例如限流、认证、授权、安全性等。这样可以避免每个微服务都实现这些功能，减少重复代码。 解释 在实际应用中，API 网关通常包括一个转换引擎，用于实时地编排和修改请求和响应。它还可以提供收集分析数据和提供缓存等功能。另外，API 网关还可以支持身份验证、授权、安全性、审计和法规遵从性等功能。
假设你正在开发一个电子商务平台，其中包含多个微服务，如用户服务、产品服务、图片服务、订单服务和支付服务等。每个微服务都有自己的 API 和数据库。
在这种情况下，你可以引入一个 API 网关来处理对这些微服务的访问。API 网关作为一个入口点，接收来自客户端的请求，并将请求转发到适当的微服务。
例如，当一个客户端需要获取某个产品的详细信息时，他们可以发送一个 HTTP 请求到 API 网关的特定端点。API 网关会验证请求并将其转发到产品服务。产品服务将查询数据库获取产品信息，并将响应返回给 API 网关。然后，API 网关将产品信息返回给客户端。
API 网关可以实现以下功能：
认证和授权：API 网关可以验证客户端的身份和权限，确保只有经过授权的用户能够访问特定的微服务。 请求转发和路由：API 网关根据请求的路径和参数将请求转发到适当的微服务。它可以执行负载均衡和路由策略，确保请求被正确地分发到相应的微服务实例。 响应聚合：如果一个请求需要从多个微服务获取数据，API 网关可以将这些请求发送给相应的微服务，并将它们的响应聚合到一个响应中返回给客户端。 缓存和性能优化：API 网关可以缓存常用的请求和响应，以提高性能并减轻后端微服务的负载。 安全性和监控：API 网关可以实施安全策略，例如防止恶意请求和 DDoS 攻击。它还可以监控请求和响应，收集应用程序的指标和日志数据。 程序示例
此实现展示了电子商务站点的 API 网关模式。 ApiGateway分别使用 ImageClientImpl和 PriceClientImpl来调用 Image 和 Price 微服务。 在桌面设备上查看该网站的客户可以看到价格信息和产品图片，因此 ApiGateway会调用这两种微服务并在DesktopProduct模型中汇总数据。 但是，移动用户只能看到价格信息。 他们看不到产品图片。 对于移动用户，ApiGateway仅检索价格信息，并将其用于填充MobileProduct模型。
这个是图像微服务的实现。
public interface ImageClient { String getImagePath(); } public class ImageClientImpl implements ImageClient { @Override public String getImagePath() { var httpClient = HttpClient.newHttpClient(); var httpGet = HttpRequest.newBuilder() .</description>
    </item>
    <item>
      <title>Java设计模式：Arrange/Act/Assert</title>
      <link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</link>
      <pubDate>Sun, 13 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</guid>
      <description>本文主要介绍 Arrange/Act/Assert 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 Arrange/Act/Assert（安排/执行/断言）又称 Given/When/Then，是一种测试设计模式，用于组织和编写单元测试的结构。它提供了一种清晰的测试布局，使得测试代码易于理解和维护。
该模式的三个阶段如下：
Arrange（安排）：在这个阶段，你准备测试环境和设置测试数据。这包括创建对象、设置输入参数、模拟依赖项等。你的目标是为将要进行的测试创建一个合适的环境。 Act（执行）：在这个阶段，你执行要测试的操作或调用要测试的方法。这是你对被测试代码进行实际调用的地方。 Assert（断言）：在这个阶段，你验证测试的结果是否符合预期。你会检查实际的输出、状态变化或异常情况，并使用断言语句来断言测试的期望结果。 这种测试结构的优势在于它提供了清晰的分离和组织测试代码的方式，并使得测试的目的和预期结果更容易理解。它也有助于减少测试代码中的重复和冗余。
以下是一个使用 Arrange/Act/Assert 模式编写的示例测试方法的伪代码：
public void testCalculateTotalPrice() { // Arrange ShoppingCart cart = new ShoppingCart(); cart.addItem(new Item(&amp;#34;Item 1&amp;#34;, 10.0)); cart.addItem(new Item(&amp;#34;Item 2&amp;#34;, 15.0)); // Act double totalPrice = cart.calculateTotalPrice(); // Assert assertEquals(25.0, totalPrice, 0.01); } 在上述示例中，首先在 Arrange 阶段创建了一个购物车对象，并添加了两个商品。然后，在 Act 阶段调用了calculateTotalPrice()方法来计算总价格。最后，在 Assert 阶段使用断言语句来验证计算的结果是否等于预期的总价格。
适用性 Arrange/Act/Assert（安排/执行/断言）设计模式适用于编写单元测试，特别是针对函数、方法或类的单元测试。它在以下情况下特别有用：
单元测试：Arrange/Act/Assert 模式适用于对单个函数或方法进行测试。它帮助你组织测试代码，使其结构清晰，并确保每个测试只关注一个特定的功能或行为。 易于理解和维护：这种模式提供了一种一致的测试结构，使得测试代码易于理解和维护。通过明确的安排、执行和断言阶段，你可以更清楚地了解测试的目的和预期结果。 测试代码可读性：Arrange/Act/Assert 模式可以使测试代码更具可读性。通过按照统一的结构组织测试代码，使得测试逻辑更加清晰可见，易于他人理解和参与。 提高可维护性：使用这种模式可以减少测试代码中的重复和冗余，使得测试代码更易于维护。在 Arrange 阶段设置测试环境和准备数据，可以减少在每个测试中重复的代码。 测试结果验证：Arrange/Act/Assert 模式明确了测试结果的验证过程。在 Assert 阶段使用断言语句来验证实际结果与预期结果的一致性，帮助你确保被测试代码的正确性。 需要注意的是，Arrange/Act/Assert 模式主要适用于单元测试，而对于集成测试或端到端测试等更大范围的测试，可能需要使用其他测试设计模式或框架来进行组织和管理测试代码。
除了 Arrange/Act/Assert 模式，以下是一些适用于集成测试或端到端测试的设计模式或框架：
Page Object 模式：Page Object 模式是一种用于管理用户界面元素和操作的设计模式。它将页面的元素和操作封装到可重用的对象中，使得测试代码更具可读性和可维护性。Page Object 模式特别适用于 Web 应用程序的端到端测试。 数据构建器模式：数据构建器模式用于生成测试数据，以便在集成测试或端到端测试中使用。它提供了一种灵活的方式来创建测试数据，包括复杂的数据结构和关联关系。 数据准备和清理模式：在集成测试或端到端测试中，通常需要准备测试数据和环境，并在测试完成后进行清理。数据准备和清理模式提供了一种结构化的方法来管理这些操作，确保测试的一致性和可重复性。 Mock 对象模式：Mock 对象模式用于模拟或替代外部依赖项，以便进行集成测试或端到端测试。通过使用 Mock 对象，你可以隔离被测试代码与外部系统的交互，使得测试更加可控和独立。 BDD（行为驱动开发）框架：BDD 框架（如 Cucumber、SpecFlow 等）提供了一种以自然语言编写测试用例和规范的方式。它将测试用例描述为可读性强的场景和步骤，帮助开发人员、测试人员和业务利益相关者之间的沟通和理解。 参考 Arrange, Act, Assert: What is AAA Testing?</description>
    </item>
    <item>
      <title>[译]Spring Boot异常处理完整指南</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-exception-handling/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-exception-handling/</guid>
      <description>处理异常是构建健壮应用程序的重要部分。 Spring Boot 提供了不止一种方法。
本文将探讨这些方法，并提供一些关于何时某种给定方法可能优于另一种方法的指导。
示例代码 本文附有 GitHub 上的工作代码示例。
介绍 Spring Boot 为我们提供了处理异常的工具，而不仅仅是简单的“try-catch”块。为了使用这些工具，我们应用了一些注释，使我们能够将异常处理视为横切关注点：
@ResponseStatus @ExceptionHandler @ControllerAdvice 在深入了解这些注释之前，我们将首先了解 Spring 如何处理 Web 控制器抛出的异常——这是捕获异常的最后一道防线。
我们还将查看 Spring Boot 提供的一些配置来修改默认行为。
我们将确定这样做时面临的挑战，然后我们将尝试使用这些注释来克服这些挑战。
Spring Boot 默认的异常处理机制 假设我们有一个名为 ProductController 的控制器，当未找到具有给定 id 的 Product 时，其 getProduct(...) 方法会抛出 NoSuchElementFoundException 运行时异常：
@RestController @RequestMapping(&amp;#34;/product&amp;#34;) public class ProductController { private final ProductService productService; //constructor omitted for brevity... @GetMapping(&amp;#34;/{id}&amp;#34;) public Response getProduct(@PathVariable String id){ // this method throws a &amp;#34;NoSuchElementFoundException&amp;#34; exception return productService.getProduct(id); } } 如果我们使用无效的 id 调用 /product API，服务将抛出 NoSuchElementFoundException 运行时异常，我们将得到以下响应：
{ &amp;#34;timestamp&amp;#34;: &amp;#34;2020-11-28T13:24:02.239+00:00&amp;#34;, &amp;#34;status&amp;#34;: 500, &amp;#34;error&amp;#34;: &amp;#34;Internal Server Error&amp;#34;, &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;path&amp;#34;: &amp;#34;/product/1&amp;#34; } 我们可以看到，除了格式良好的错误响应之外，有效负载没有为我们提供任何有用的信息。甚至 message 字段也是空的，我们可能希望包含“未找到 id 1 的项目”之类的内容。
让我们从修复错误消息问题开始。
Spring Boot 提供了一些属性，我们可以使用它们添加异常消息、异常类，甚至堆栈跟踪作为响应负载的一部分：</description>
    </item>
    <item>
      <title>[译]Spring Boot授权服务器 - 使用 Java 的资源服务器和客户端凭证示例</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-authorization-server/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-authorization-server/</guid>
      <description>概述 在本文中，我们将创建一个授权服务器，为任何客户端生成 access_token。这称为 OAuth2 的 client_credentials 流程。它主要用于服务间通信。
我们将使用 spring boot oauth2 授权服务器依赖项来创建身份验证服务器。我们还将创建一个资源服务器和客户端来对其进行端到端测试。
Spring 授权服务器 我们首先创建授权服务器。
依赖项： 让我们将以下依赖项添加到我们的项目中。
implementation &amp;#39;org.springframework.security:spring-security-oauth2-authorization-server:1.0.0&amp;#39; implementation &amp;#39;org.springframework.boot:spring-boot-starter-security&amp;#39; implementation &amp;#39;org.springframework.boot:spring-boot-starter-web&amp;#39; testImplementation &amp;#39;org.springframework.boot:spring-boot-starter-test&amp;#39; testImplementation &amp;#39;org.springframework.security:spring-security-test&amp;#39; 我们正在使用 spring oauth2 依赖项的最新（当时）稳定版本。
Java 实现： 让我们创建一个名为 AuthorizationServerConfig 的配置类，并向该类添加 @Configuration 注解。现在让我们创建以下 bean 来完成配置：
SecurityFilterChain @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SecurityFilterChain authServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); return http.build(); } 我们将把 bean 的顺序设置为最高，因为我们想首先执行它。
RegisteredClientRepository @Bean public RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(&amp;#34;oauth-client&amp;#34;) .clientSecret(&amp;#34;{noop}oauth-secret&amp;#34;) .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .scope(OidcScopes.OPENID) .scope(&amp;#34;articles.read&amp;#34;) .build(); return new InMemoryRegisteredClientRepository(registeredClient); } 现在让我们使用内存存储库对内容进行硬编码。我们可以根据我们的需要更新这些。
JwtDecoder @Bean public JwtDecoder jwtDecoder(JWKSource&amp;lt;SecurityContext&amp;gt; jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } 我们将使用它来解码令牌以进行验证。
JWKSource @Bean public JWKSource&amp;lt;SecurityContext&amp;gt; jwkSource() throws NoSuchAlgorithmException { RSAKey rsaKey = generateRsa(); JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -&amp;gt; jwkSelector.</description>
    </item>
    <item>
      <title>[译]使用 Spring Boot 和 Spring Security 配置 CORS</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-cors/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-cors/</guid>
      <description>跨源资源共享 (CORS) 是一种基于 HTTP 标头的机制，允许服务器显式将某些源列入白名单，并帮助绕过同源策略。
这是必需的，因为浏览器默认应用同源策略以确保安全。通过在 Web 应用程序中实施 CORS，网页可以请求额外的资源并从其他域加载到浏览器中。
本文将重点介绍在基于 Spring 的应用程序中实现 CORS 的各种方式。要详细了解 CORS 的工作原理，请参阅这篇优秀的介绍性文章。
示例代码 本文附有 GitHub 上的工作代码示例。
CORS 特定 HTTP 响应标头概述 CORS 规范定义了服务器返回的一组响应标头，这将是后续部分的重点。
响应头 描述 Access-Control-Allow-Origin 以逗号分隔的白名单来源列表或“*”。 Access-Control-Allow-Methods Web 服务器允许跨源请求的 HTTP 方法的逗号分隔列表。 Access-Control-Allow-Headers Web 服务器允许跨源请求的 HTTP 标头的逗号分隔列表。 Access-Control-Expose-Headers 客户端脚本认为可以安全显示的以逗号分隔的 HTTP 标头列表。 Access-Control-Allow-Credentials 如果浏览器通过传递凭据（以 cookie 或授权标头的形式）向服务器发出请求，则其值设置为 true 。 Access-Control-Max-Age 指示预检请求的结果可以缓存多长时间。 设置示例客户端应用程序 我们将使用一个简单的角度应用程序来调用 REST 端点，我们可以使用浏览器开发人员工具检查这些端点。您可以在 GitHub 上查看源代码。
ng serve --open 我们应该能够成功启动客户端应用程序。
设置示例服务器应用程序 我们将使用一个基于 Spring 的示例应用程序，其中包含客户端应用程序可以调用的 GET 和 POST 请求。请注意，您会发现两个独立的应用程序：一个使用 Spring MVC (REST)，另一个使用 Spring Reactive 堆栈。
为简单起见，两个应用程序之间的 CORS 配置相同，并且定义了相同的端点。两台服务器都从不同的端口 8091 和 8092 启动。
与应用程序捆绑在一起的 Maven Wrapper 将用于启动服务。您可以查看 Spring REST 源代码和 Spring Reactive 源代码。
mvnw clean verify spring-boot:run (for Windows) ./mvnw clean verify spring-boot:run (for Linux) 一旦 Spring 应用程序成功启动，客户端应用程序应该能够成功从服务器加载数据。</description>
    </item>
    <item>
      <title>[译]使用 Spring 的 Null-Safety 注解保护您的代码免受 NullPointerExceptions 的影响</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-null-safety-annotations/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-null-safety-annotations/</guid>
      <description>NullPointerExceptions （通常缩写为“NPE”）对于每个 Java 程序员来说都是一场噩梦。
我们可以在互联网上找到大量解释如何编写空安全代码的文章。空安全确保我们在代码中添加了适当的检查，以保证对象引用不能为空，或者毕竟在对象为空时采取可能的安全措施。
由于 NullPointerException 是一个运行时异常，因此在代码编译过程中很难找出这种情况。 Java 的类型系统没有办法快速消除危险的空对象引用。
幸运的是，Spring 框架提供了一些注释来解决这个问题。在本文中，我们将学习如何使用这些注释通过 Spring Boot 编写空安全代码。
示例代码 本文附有 GitHub 上的工作代码示例。
Spring 中的空安全注解 在 Spring 核心包 org.springframework.lang 下，有 4 个这样的注解：
@NonNull, @NonNull ， @NonNullFields, @NonNullFields ， @Nullable, @NonNullApi. Eclipse 和 IntelliJ IDEA 等流行的 IDE 可以理解这些注释。它们可以在编译期间警告开发人员潜在的问题。
我们将在本教程中使用 IntelliJ IDEA。让我们通过一些代码示例来了解更多信息。
要创建基础项目，我们可以使用 Spring Initializr。 Spring Boot 启动器就是我们所需要的，不需要添加任何额外的依赖项。
IDE 配置 请注意，并非所有开发工具都可以显示这些编译警告。如果您没有看到相关警告，请检查 IDE 中的编译器设置。
IntelliJ 对于 IntelliJ，我们可以在“Build, Execution, Deployment -&amp;gt; Compiler”下激活注释检查：
Eclipse 对于 Eclipse，我们可以在“Java -&amp;gt; Compiler -&amp;gt; Errors/Warnings”下找到设置：
示例代码 让我们使用一个简单的 Employee 类来理解注释：
package io.reflectoring.nullsafety; // imports class Employee { String id; String name; LocalDate joiningDate; String pastEmployment; // standard constructor, getters, setters } @NonNull 大多数情况下， id 字段（在 Employee 类中）将是一个不可为 null 的值。因此，为了避免任何潜在的 NullPointerException 我们可以将此字段标记为 @NonNull ：</description>
    </item>
    <item>
      <title>[译]使用Spring Boot Actuator公开有用的信息端点</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-info-endpoint/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-info-endpoint/</guid>
      <description>在分布式、快节奏的环境中，开发团队通常希望了解他们部署应用程序的时间、部署的应用程序版本、部署的 Git 提交等等。
Spring Boot Actuator 帮助我们监控和管理应用程序。它公开了提供应用程序运行状况、指标和其他相关信息的各种端点。
在本文中，我们将了解如何使用 Spring Boot Actuator 和 Maven/Gradle 构建插件将此类信息添加到我们的项目中。
示例代码 本文附有 GitHub 上的工作代码示例。
启用 Spring Boot 执行器 Spring Boot Actuator 是 Spring Boot 的一个子项目。在本节中，我们将快速了解如何引导示例项目并启用 /info 端点。如果您想了解更多有关 Spring Boot Actuator 的信息，已经有一个很棒的教程了。
让我们使用 Spring Initializr 快速创建一个 Spring Boot 项目。我们将需要以下依赖项：
依赖性 目的 Spring Boot Actuator 公开应用程序管理端点，例如 info 。 Spring Web 启用 Web 应用程序行为。 如果有帮助，这里是 Maven 和 Gradle 中预填充项目的链接。
项目构建后，我们将通过 HTTP 公开内置的 /info 端点。默认情况下， /info Web 端点处于禁用状态。我们可以通过在 application.properties 配置中添加 management.endpoints.web.exposure.include 属性来简单地启用它：
management.endpoints.web.exposure.include=health,info 让我们运行 Spring Boot 应用程序并在浏览器中打开 URL http://localhost:8080/actuator/info 。目前还看不到任何有用的东西，因为我们仍然需要进行一些配置更改。在下一节中，我们将了解如何在此响应中添加信息丰富的构建信息。
保护端点 如果您公开公开端点，请确保适当保护它们。我们不应在不知情的情况下泄露任何敏感信息。
Spring Boot 应用程序信息 Spring 从应用程序上下文中定义的各种 InfoContributor bean 收集有用的应用程序信息。下面是默认 InfoContributor beans 的摘要：
ID Bean Name 用法 build BuildInfoContributor 公开构建信息。 env EnvironmentInfoContributor 公开 Environment 中名称以 info.</description>
    </item>
    <item>
      <title>[译]在 Spring 中实现 OAuth2：使用范围（第 2 部分）</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring-scopes/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring-scopes/</guid>
      <description>我们在上一篇文章中了解了基本的 OAuth2 概念以及如何在 Spring 中实现和执行不同的授权。在这篇文章中，我们将介绍 OAuth2 的另一个重要概念：范围。
OAuth 范围 保护对应用程序的访问通常分两个步骤进行：身份验证和授权。要理解这两个概念，假设您在绝密政府大楼工作。在开始之前，你会得到一张卡片，可以让你进入建筑物。 OAuth 令牌可以看作是允许您访问的卡片。
一旦你进去，你决定去三楼见你的一位同事，在尝试使用你的卡打开三楼的门后，你听到一声嘟嘟声，告诉你你没有被授权。在 OAuth 中，范围是一种定义令牌可以访问哪些资源以及不能访问哪些资源的方法。范围允许访问控制，并且可以被视为相当于传统身份验证中的用户角色。
实现 为了演示范围，我们将使用第 1 部分中的示例。
在资源服务器的控制器中，我们有以下端点：
@RestController(&amp;#34;/&amp;#34;) public class ResourceController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(){ return &amp;#34;hello&amp;#34;; } @GetMapping(&amp;#34;/foo&amp;#34;) public String foo(){ return &amp;#34;foo&amp;#34;; } @PostMapping(&amp;#34;/bar&amp;#34;) public String bar(){ return &amp;#34;bar&amp;#34;; } @DeleteMapping(&amp;#34;/test&amp;#34;) public String test(){ return &amp;#34;test&amp;#34;; } } 第一步是使用所需的范围配置授权服务器：
clients.inMemory().withClient(&amp;#34;my-trusted-client&amp;#34;) .authorizedGrantTypes(&amp;#34;password&amp;#34;, &amp;#34;refresh_token&amp;#34;, &amp;#34;implicit&amp;#34;, &amp;#34;client_credentials&amp;#34;, &amp;#34;authorization_code&amp;#34;) .authorities(&amp;#34;CLIENT&amp;#34;) .scopes(&amp;#34;read&amp;#34;, &amp;#34;write&amp;#34;, &amp;#34;trust&amp;#34;) .accessTokenValiditySeconds(60) .redirectUris(&amp;#34;http://localhost:8081/test.html&amp;#34;) .resourceIds(&amp;#34;resource&amp;#34;) .secret(&amp;#34;mysecret&amp;#34;); 要在资源服务器中启用范围检查，我们有两个选项：使用安全配置或使用方法安全性。
使用安全配置： @Override public void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(HttpMethod.GET,&amp;#34;/hello&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) .antMatchers(HttpMethod.GET,&amp;#34;/foo&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) .antMatchers(HttpMethod.POST,&amp;#34;/bar&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;write&amp;#39;)&amp;#34;) .antMatchers(HttpMethod.DELETE,&amp;#34;/test&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;trust&amp;#39;)&amp;#34;) .anyRequest().authenticated(). and().csrf().disable(); } 使用方法安全性： @PreAuthorize(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(){ return &amp;#34;hello&amp;#34;; } @PreAuthorize(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) @GetMapping(&amp;#34;/foo&amp;#34;) public String foo(){ return &amp;#34;foo&amp;#34;; } @PreAuthorize(&amp;#34;#oauth2.</description>
    </item>
    <item>
      <title>[译]在 Spring 中实现 OAuth2：第 1 部分</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring/</guid>
      <description>OAuth2 是一组规范，主要提供对 Rest API 的安全访问的方法。 OAuth 的主要目的是允许通过使用令牌来执行身份验证和授权，而不必为每个操作提供凭据。由于本文的重点是实现，并且为了不重新发明轮子，可以查看 OAuth RFC 或维基百科以获取更多理论背景。在这篇文章中，我们将深入探讨 Spring 中的 OAuth2 实现以及如何使用不同的授权类型，但在此之前值得提供一些重要概念的简要定义。
访问令牌和刷新令牌 身份验证成功后将提供访问令牌以及刷新令牌。访问令牌有一个有限的有效期（标准为 1 小时），之后需要刷新令牌才能获取新的访问令牌和新的刷新令牌。 Referesh 令牌通常会在使用后过期。
资源服务器和授权服务器 OAuth 引入了授权服务器的概念，授权服务器是发出访问和刷新令牌的实体，并在每个操作中进行咨询以查看令牌是否有效。资源服务器只是由不同客户端应用程序（前端应用程序、移动设备、其他后端服务&amp;hellip;&amp;hellip;）访问的实际 Rest API。资源服务器和授权服务器可以是不同的实体，也可以是同一实体。
授权类型 OAuth 中最常用的授权有：客户端凭据、密码、授权码和隐式授权。每项资助都有特定的流程和用例，但由于本文的重点不是理论，因此我们将重点关注其实施。有关授权及其用途的更多详细信息，请参阅 OAuth RFC。
实现 在实现方面，我们将使用 Spring Boot 来利用其自动配置和引导功能，并更多地关注我们的核心主题。
资源服务器： 我们有一个资源服务器，其中包含我们希望保护的以下端点：
@RestController(&amp;#34;/&amp;#34;) public class ResourceController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(){ return &amp;#34;hello&amp;#34;; } @GetMapping(&amp;#34;/foo&amp;#34;) public String foo(){ return &amp;#34;foo&amp;#34;; } @GetMapping(&amp;#34;/bar&amp;#34;) public String bar(){ return &amp;#34;bar&amp;#34;; } @GetMapping(&amp;#34;/test&amp;#34;) public String test(){ return &amp;#34;test&amp;#34;; } } 为此，我们需要配置一个用 @EnableResourceServer 注释的 ResourceServerConfigurerAdapter bean：
@Configuration @EnableResourceServer public class ResourceSecurityConfiguration extends ResourceServerConfigurerAdapter { @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(&amp;#34;resource&amp;#34;); } @Override public void configure(HttpSecurity http) throws Exception { http .</description>
    </item>
    <item>
      <title>[译]使用Spring Boot2和Spring Security 5以及JDBC令牌存储进行Oauth2集中授权</title>
      <link>https://blog.chensoul.cc/posts/2023/07/14/oauth-2-centralized-authorization-with-spring-boot-2-and-spring-security-5-and-jdbc-token-store/</link>
      <pubDate>Fri, 14 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/14/oauth-2-centralized-authorization-with-spring-boot-2-and-spring-security-5-and-jdbc-token-store/</guid>
      <description>在这篇文章中，我们将了解如何使用 Spring Boot 2 和 Spring Security 5 OAuth2 来实现集中授权的授权服务器以及如何通过 GUI 对其进行管理，还将提供资源服务器演示以及 github 下的整个项目。
很多示例涵盖了基于早期版本的 Spring boot 2 和 Spring Security 5 使用内存令牌实现 Oauth2，因此想法是使用 MySql 数据库作为令牌存储。
为了深入探讨这个主题，我们必须：
配置 Spring 安全。 配置数据库。 创建授权服务器。 创建资源服务器。 使用 curl 客户端使用访问令牌获取安全资源。 什么是 Oauth 2？ OAuth 2.0 是行业标准授权协议。 OAuth 2.0 取代了 2006 年创建的原始 OAuth 协议上所做的工作。OAuth 2.0 注重客户端开发人员的简单性，同时为 Web 应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。
该规范及其扩展正在 IETF OAuth 工作组内开发。
Oauth 2 角色 OAuth2 定义了 4 个角色：
资源所有者：通常是您自己。
资源服务器：托管受保护数据的服务器（例如 Google 托管您的个人资料和个人信息）。
客户端：请求访问资源服务器的应用程序（网站、Javascript 应用程序或移动应用程序&amp;hellip;&amp;hellip;）。
授权服务器：向客户端颁发访问令牌的服务器。该令牌将用于客户端请求资源服务器。该服务器可以与资源服务器相同（相同的物理服务器和相同的应用程序），而且经常是这种情况。
下图说明了角色流程：
授权类型 OAuth 2 为不同的用例提供了多种“授权类型”。定义的授权类型型有：
授权码：授权码授予是使用您的 Facebook 或 Google 帐户登录应用程序的功能。 密码：旨在用于基于用户代理的客户端。其次，授权服务器不会像授权代码授予那样返回授权代码来交换访问令牌，而是返回访问令牌。 客户端凭据：客户端可以仅使用其客户端凭据（或其他支持的身份验证方式）请求访问令牌，当客户端请求访问其下的受保护资源控制权，或先前已被其他资源所有者控制的与授权服务器安排。 隐式授权：隐式授权是一种简化的授权代码流，针对使用 JavaScript 等脚本语言在浏览器中实现的客户端进行了优化。在隐式流程中，而不是向客户端发出授权代码，直接向客户端颁发访问令牌。 示范 让我们动手吧
业务层 为简单起见，我们的主要业务应用程序将是使用一个实体的产品 API，我们的访问规则将是：
PRODUCT_CREATE PRODUCT_UPDATE PRODUCT_DISPLAY PRODUCT_ADMIN OAuth2 客户端设置 要设置 Oauth 2 客户端，我们需要创建下表 [有关更多详细信息，请参阅链接]</description>
    </item>
    <item>
      <title>Java设计模式：Ambassador</title>
      <link>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</link>
      <pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</guid>
      <description>本文主要介绍 Ambassador 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 在客户端上提供帮助程序服务实例，并从共享资源上转移常用功能。
Ambassador 设计模式的主要目的是将客户端应用程序与远程服务器之间的通信细节隔离开来，从而使客户端应用程序可以专注于自己的业务逻辑，而不必关注网络通信细节和错误处理。
在传统的客户端应用程序中，通常需要处理大量的网络通信细节和错误处理，这会使代码变得复杂且难以维护。而使用 Ambassador 设计模式可以将这些细节和处理逻辑集中在一个单独的类中，从而使客户端应用程序的代码更加简洁、易于维护和扩展。
此外，使用 Ambassador 设计模式还可以提高客户端应用程序与远程服务器之间的通信安全性和可靠性。例如，Ambassador 类可以负责统一处理所有的网络通信，从而可以更轻松地实现安全性和可靠性控制。
解释 假设有一个旧版的远程服务，该服务提供了许多客户端访问的功能，但由于用户的大量请求，导致连接问题变得普遍。此外，新的请求频率规则需要同时实现延迟检测和客户端日志功能。为了解决这些问题，可以使用 Ambassador 设计模式。
微软文档 做了如下阐述
可以将大使服务视为与客户端位于同一位置的进程外代理。 此模式对于以语言不可知的方式减轻常见的客户端连接任务（例如监视，日志记录，路由，安全性（如 TLS）和弹性模式）的工作很有用。 它通常与旧版应用程序或其他难以修改的应用程序一起使用，以扩展其网络功能。 它还可以使专业团队实现这些功能。
在该模式中，可以创建一个 Ambassador 类来充当客户端应用程序和远程服务之间的代理。Ambassador 类负责处理所有的网络通信细节和错误处理，并实现新的请求频率规则，包括延迟检测和客户端日志功能。
具体来说，Ambassador 类可以实现以下功能：
延迟检测：在请求到达远程服务之前，Ambassador 类可以检测请求的时间戳，并计算出请求的延迟时间。如果请求的延迟时间超过了预设的阈值，Ambassador 类可以将请求拒绝。 客户端日志功能：Ambassador 类可以记录请求的时间戳、请求的内容和响应的内容，并将这些信息保存到客户端的日志文件中。这样可以帮助客户端应用程序进行调试和故障排除。 连接问题处理：Ambassador 类可以监控远程服务的连接状态，并在连接出现问题时进行自动重试。同时，Ambassador 类还可以实现一些优化策略，例如使用连接池等，以提高连接的可靠性和性能。 程序示例
有了上面的介绍我们将在这个例子中模仿功能。我们有一个用远程服务实现的接口，同时也是大使服务。
interface RemoteServiceInterface { long doRemoteFunction(int value) throws Exception; } 表示为单例的远程服务。
public class RemoteService implements RemoteServiceInterface { private static final Logger LOGGER = LoggerFactory.getLogger(RemoteService.class); private static RemoteService service = null; static synchronized RemoteService getRemoteService() { if (service == null) { service = new RemoteService(); } return service; } private RemoteService() {} @Override public long doRemoteFunction(int value) { long waitTime = (long) Math.</description>
    </item>
    <item>
      <title>Java设计模式：Aggregator Microservices</title>
      <link>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</link>
      <pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</guid>
      <description>本文主要介绍 Aggregator Microservices 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
意图 用户对聚合器服务进行一次调用，然后聚合器将调用每个相关的微服务。
Aggregator Microservices 是一种微服务架构模式，用于解决大型分布式系统中的数据聚合问题。该模式通常用于有多个数据源的场景，例如电子商务网站中的产品列表页面，其中需要从多个服务中获取产品信息并组合在一起显示。
Aggregator Microservices 模式包括一个聚合器服务和多个后端服务。聚合器服务负责从多个后端服务中收集数据，并将数据组合成一个聚合的响应。后端服务则负责提供特定的数据源，例如产品信息、库存信息、价格信息等。
解释 真实世界例子
我们的网络市场需要有关产品及其当前库存的信息。 它调用聚合服务，聚合服务依次调用产品信息微服务和产品库存微服务，返回组合信息。
通俗地说
聚合器微服务从各种微服务中收集数据，并返回一个聚合数据以进行处理。
Stack Overflow 上说
聚合器微服务调用多个服务以实现应用程序所需的功能。
程序示例
让我们从数据模型开始。 这是我们的产品。
public class Product { private String title; private int productInventories; // getters and setters -&amp;gt; ... } 接下来，我们将介绍我们的聚合器微服务。 它包含用于调用相应微服务的客户端ProductInformationClient和 ProductInventoryClient。
@RestController public class Aggregator { @Resource private ProductInformationClient informationClient; @Resource private ProductInventoryClient inventoryClient; @RequestMapping(path = &amp;#34;/product&amp;#34;, method = RequestMethod.GET) public Product getProduct() { var product = new Product(); var productTitle = informationClient.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记15：尽量减少类和成员的可访问性</title>
      <link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link>
      <pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid>
      <description>本文是 《Effective Java 3》第四章《类和接口》的学习笔记：尽量减少类和成员的可访问性。
类和接口是 Java 编程语言的核心。它们是抽象的基本单位。该语言提供了许多强大的元素，你可以使用它们来设计类和接口。
介绍 《Effective Java, Third Edition》这本书中的第四章主要讲述了如何尽量减少类和成员的可访问性，以提高代码的封装性、安全性和可维护性。
尽量减少类和成员的可访问性是面向对象编程中的一个基本原则，也被称为 &amp;ldquo;最小化可访问性原则&amp;rdquo;。这个原则的核心思想是，将类和成员的访问级别限制在最小范围内，从而提高代码的安全性、可维护性和可复用性。
在 Java 中，类和成员的访问级别有四种：public、protected、default 和 private。其中，public 级别是最高的，可以被任何类访问；private 级别是最低的，只能被同一个类内部的成员访问。在应用最小化可访问性原则时，应该尽可能地将类和成员的访问级别设置为最低的级别，即 private 或 default 级别。
尽量减少类和成员的可访问性是一种良好的编程实践，可以提高代码的安全性和可维护性。以下是一些建议：
将类和成员的可见性设置为最小化的级别，即只有必要的代码可以访问它们。这将减少不必要的依赖关系，并使代码更加模块化和可重用。
使用访问修饰符以限制类和成员的可见性。例如，如果一个成员只能在类内部使用，可以考虑将其转换为私有静态嵌套类。如果一个成员需要在类的子类中使用，可以使用 protected 修饰符。
下面是一个示例，演示如何将包级私有顶级类转换为私有静态嵌套类：
// 包级私有顶级类 class MyTopLevelClass { // ... } public class MyClass { private static class MyPrivateNestedClass { // 使用 MyTopLevelClass 的代码 } // 使用 MyPrivateNestedClass 的代码 } 在上面的示例中，MyTopLevelClass 被转换为了 MyPrivateNestedClass，它被声明为 MyClass 的私有静态嵌套类。这样，MyTopLevelClass 就只能被 MyPrivateNestedClass 使用，而 MyPrivateNestedClass 只能被 MyClass 使用，达到了安全和清晰的目标。
避免使用公共成员或公共方法。公共成员和方法可以被任何代码访问，这可能会导致安全问题和不必要的代码耦合。相反，应该使用封装的方式来隐藏类的实现细节，并在需要时提供公共接口。
在需要使用公共接口时，使用接口或抽象类来定义公共契约。这样可以使代码更加灵活，并使实现细节能够独立于公共契约进行修改。
使用 final 关键字来限制类和成员的可变性。这可以提高代码的安全性和可维护性，并避免在不必要的情况下修改代码。
扩展 设计公共接口需要考虑接口的简洁性、易用性和一致性，同时避免暴露过多的底层实现细节。下面是一个简单的示例，展示了如何设计一个公共接口。
/** * This interface provides a simple way to perform arithmetic operations. * @author chensoul * @since 1.0.0 */ public interface Arithmetic { /** * Adds two integers and returns the result.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记16：在公共类中，使用访问器方法，而不是公共字段</title>
      <link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link>
      <pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid>
      <description>本文是 《Effective Java 3》第四章《类和接口》的学习笔记：在公共类中，使用访问器方法，而不是公共字段。
介绍 与其直接将类的内部字段公开为公共字段，推荐使用访问器方法（也称为 getter 和 setter）来访问和修改对象的状态。这样可以使类对其内部表示保持控制，并为类的客户端提供一种抽象程度。
通过使用访问器方法，您可以实现以下目标：
封装内部表示（Encapsulate Internal Representation）： Getter 方法：Getter 方法用于获取私有字段的值。通过使用 getter 方法，可以将字段的访问限制在类的内部，从而隐藏了字段的具体实现细节。客户端只能通过调用 getter 方法来获取字段的值，而无法直接访问字段本身。 Setter 方法：Setter 方法用于设置私有字段的值。使用 setter 方法，可以对字段进行验证、约束和逻辑处理。这样，类可以对字段的修改进行控制，并确保只有经过验证的值才能被设置。 控制访问和修改（Control Access and Modification）： Getter 方法：通过 getter 方法，可以对字段的访问进行控制。例如，可以在 getter 方法中添加权限检查，只允许特定的用户或角色获取字段的值。还可以在 getter 方法中进行计算或转换，以便返回不同于字段本身的值。 Setter 方法：Setter 方法允许对字段的修改进行控制。在 setter 方法中，可以进行输入验证、范围检查和其他逻辑处理。这样可以确保只有符合规定的值才能被设置到字段中，从而保持类的状态的一致性和完整性。 促进演化和兼容性：如果使用公共字段，并且以后需要更改表示方式或添加附加逻辑，则很难保持向后兼容性。然而，通过使用访问器方法，可以修改内部表示或添加新行为，而不会影响类的客户端。 反例 Java 库中的几个类违反了公共类不应该直接公开字段的建议。突出的例子包括 java.awt 包中的 Point 和 Dimension。
在 Java 的早期版本中，一些类设计并没有遵循现代的面向对象设计原则和最佳实践。这些类中的字段被直接声明为公共（public），而没有提供相应的访问器方法。
例如，java.awt 包中的 Point 类和 Dimension 类提供了公共的 x、y 和 width、height 字段来表示点的坐标和矩形的宽度和高度。这意味着客户端代码可以直接访问和修改这些字段，绕过了封装和控制的机制。
这种设计方式存在一些问题：
缺乏封装：直接公开字段破坏了封装的原则，使得类的内部表示暴露给外部，导致了不可预测的行为和潜在的错误。 限制扩展性：如果需要在这些类中添加验证逻辑、计算属性或实现其他行为，会面临困难，因为不能在字段被直接访问的情况下进行控制和修改。 除了 java.awt 包中的 Point 和 Dimension 类之外，还有其他一些 Java 库中的类违反了&amp;quot;公共类不应该直接公开字段&amp;quot;的建议。以下是一些例子：
java.util 包中的 Date 类：在早期版本的 Java 中，Date 类的字段（如年、月、日、小时等）是公共的，可以直接访问和修改。这种设计导致了 Date 类的可变性和线程安全性问题。随后，Java 引入了新的日期和时间 API（java.time 包），其中封装了更好的设计原则，遵循了使用访问器方法的建议。 java.util 包中的 Vector 类：Vector 类是一个动态数组，它在早期版本中使用了公共字段来表示元素数量（elementCount）和容量（capacity）。这种设计违反了封装性和控制访问的原则。随着 Java 集合框架的发展，推荐使用 ArrayList 等更现代的集合类，它们使用私有字段并提供了相应的访问器方法。 扩展 如何确保字段的可见性限定为包级私有？ 在一些特定的情况下，对于包级私有或私有嵌套类，有时候需要公开字段，无论这个类是可变的还是不可变的。以下是这种情况的一些例子：</description>
    </item>
    <item>
      <title>Java设计模式：Adapter</title>
      <link>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</link>
      <pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</guid>
      <description>本文主要介绍 Adapter 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。
适配器模式(Adapter Pattern)是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一种接口。适配器模式通常用于连接两个不兼容的接口或类，以便它们可以协同工作。
解释 现实世界例子
考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。
用直白的话来说
适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。
维基百科中说
在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。
适配器模式由三个主要角色组成：
目标接口(Target Interface)：客户端所期望的接口。适配器模式会创建一个实现目标接口的新类，以便客户端可以通过该接口调用它。
适配器(Adapter)：该类实现了目标接口，并将客户端的请求转换为对适配者的调用。适配器通常会聚合一个适配者对象，以便将请求委托给它。
适配者(Adapteree)：适配器模式的实际工作内容。适配者是客户端所期望的接口之外的类，它实现了客户端需要的功能，但其接口与客户端所期望的接口不兼容。
编程样例(对象适配器)
假如有一个船长他只会划船，但不会航行。
首先我们有接口RowingBoat和FishingBoat
public interface RowingBoat { void row(); } @Slf4j public class FishingBoat { public void sail() { LOGGER.info(&amp;#34;The fishing boat is sailing&amp;#34;); } } 船长希望有一个RowingBoat接口的实现，这样就可以移动
public class Captain { private final RowingBoat rowingBoat; // default constructor and setter for rowingBoat public Captain(RowingBoat rowingBoat) { this.rowingBoat = rowingBoat; } public void row() { rowingBoat.</description>
    </item>
    <item>
      <title>Java设计模式：Visitor</title>
      <link>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</link>
      <pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</guid>
      <description>本文主要介绍 Visitor 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 表示要在对象结构的元素上执行的操作。访问者可让你定义新操作，而无需更改其所操作元素的类。
访问者模式的主要目的是在不改变对象结构的前提下，对对象结构中的元素进行新的操作。它通过将操作从对象结构中分离出来，使得可以独立地添加、修改或删除对元素的操作，而不需要修改元素类或对象结构。
访问者模式的另一个目的是将对象结构与操作解耦。在访问者模式中，元素和操作分别由不同的类来实现，并且元素只暴露出接受访问者对象的接口，而不是暴露出具体的实现细节。这样可以避免在元素类中添加过多的行为，从而提高代码的可扩展性和可维护性。
最后，访问者模式还可以用于实现对复杂对象结构的遍历。通过访问者对象的递归调用，可以遍历整个对象结构，并对每个元素执行相应的操作。这种遍历方式可以方便地实现对复杂对象结构的分析和处理。
解释 真实世界例子
考虑有一个带有军队单位的树形结构。指挥官下有两名中士，每名中士下有三名士兵。基于这个层级结构实现访问者模式，我们可以轻松创建与指挥官，中士，士兵或所有人员互动的新对象
通俗的说
访问者模式定义可以在数据结构的节点上执行的操作。
维基百科说
在面向对象的程序设计和软件工程中，访问者设计模式是一种将算法与操作对象的结构分离的方法。这种分离的实际结果是能够在不修改结构的情况下向现有对象结构添加新操作。
访问者模式是一种行为型设计模式，它允许在不改变对象结构的情况下定义新的操作。该模式的核心思想是将操作从对象结构中分离出来，并在独立的访问者对象中进行实现。
访问者模式由以下几个关键元素组成：
抽象访问者（Visitor）：定义可以访问不同类型元素的方法，该方法的参数类型为具体元素类型。 具体访问者（ConcreteVisitor）：实现抽象访问者中定义的方法，以实现对元素的不同操作。 抽象元素（Element）：定义接受访问者对象的方法。 具体元素（ConcreteElement）：实现抽象元素中定义的方法，以便可以接受访问者对象的访问。 对象结构（Object Structure）：包含一组具体元素，可以被访问者对象遍历。 程序示例
使用上面的军队单元的例子，我们首先由单位和单位访问器类型。
public abstract class Unit { private final Unit[] children; public Unit(Unit... children) { this.children = children; } public void accept(UnitVisitor visitor) { Arrays.stream(children).forEach(child -&amp;gt; child.accept(visitor)); } } public interface UnitVisitor { void visitSoldier(Soldier soldier); void visitSergeant(Sergeant sergeant); void visitCommander(Commander commander); } 然后我们有具体的单元。
public class Commander extends Unit { public Commander(Unit.</description>
    </item>
    <item>
      <title>Java设计模式：Acyclic Visitor</title>
      <link>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</link>
      <pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</guid>
      <description>本文主要介绍 Acyclic Visitor 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 允许将新功能添加到现有的类层次结构中，而不会影响这些层次结构，也不会有四人帮访客模式中那样循环依赖的问题。
在 Acyclic Visitor 模式中，我们通过引入一个可选操作接口来实现这一点。当数据结构类需要访问访问者类的某些操作时，它可以通过调用 visit 方法来访问可选操作接口中定义的操作，而不需要直接依赖于访问者类中的成员变量。
解释 真实世界例子
我们有一个调制解调器类的层次结构。 需要使用基于过滤条件的外部算法（是 Unix 或 DOS 兼容的调制解调器）来访问此层次结构中的调制解调器。
程序示例
这是调制解调器的层次结构。
public interface Modem { void accept(ModemVisitor modemVisitor); } public class Hayes implements Modem { @Override public void accept(ModemVisitor modemVisitor) { if (modemVisitor instanceof HayesVisitor) { ((HayesVisitor) modemVisitor).visit(this); } else { System.out.println(&amp;#34;Only HayesVisitor is allowed to visit Hayes modem&amp;#34;); } } } public class Zoom implements Modem { @Override public void accept(ModemVisitor modemVisitor) { if (modemVisitor instanceof ZoomVisitor) { ((ZoomVisitor) modemVisitor).</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记12：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</guid>
      <description>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：始终覆盖 toString 方法。
介绍 虽然 Object 提供 toString 方法的实现，但它返回的字符串通常不是类的用户希望看到的。它由后跟「at」符号（@）的类名和 hash 代码的无符号十六进制表示（例如 PhoneNumber@163b91）组成。toString 的通用约定是这么描述的，返回的字符串应该是「简洁但信息丰富的表示，易于阅读」。虽然有人认为 PhoneNumber@163b91 简洁易懂，但与 707-867-5309 相比，它的信息量并不大。toString 约定接着描述，「建议所有子类覆盖此方法。」好建议，确实！
虽然它不如遵守 equals 和 hashCode 约定那么重要，但是 提供一个好的 toString 实现（能）使类更易于使用，使用该类的系统（也）更易于调试。 当对象被传递给 println、printf、字符串连接操作符或断言或由调试器打印时，将自动调用 toString 方法。即使你从来没有调用 toString 对象，其他人也可能（使用）。例如，有对象引用的组件可以在日志错误消息中包含对象的字符串表示。如果你未能覆盖 toString，则该消息可能完全无用。
如果你已经为 PhoneNumber 提供了一个好的 toString 方法，那么生成一个有用的诊断消息就像这样简单：
System.out.println(&amp;#34;Failed to connect to &amp;#34; + phoneNumber); 无论你是否覆盖 toString，程序员都会以这种方式生成诊断消息，但是除非你（覆盖 toString），否则这些消息不会有用。提供好的 toString 方法的好处不仅仅是将类的实例扩展到包含对这些实例的引用的对象，特别是集合。在打印 map 时，你更愿意看到哪个，{Jenny=PhoneNumber@163b91} 还是 {Jenny=707-867-5309}？
当实际使用时，toString 方法应该返回对象中包含的所有有趣信息， 如电话号码示例所示。如果对象很大，或者包含不利于字符串表示的状态，那么这种方法是不切实际的。在这种情况下，toString 应该返回一个摘要，例如曼哈顿住宅电话目录（1487536 号清单）或 Thread[main,5,main]。理想情况下，字符串应该是不言自明的。（线程示例未能通过此测试。）如果没有在字符串表示中包含所有对象的有趣信息，那么一个特别恼人的惩罚就是测试失败报告，如下所示：
Assertion failure: expected {abc, 123}, but was {abc, 123}. 在实现 toString 方法时，你必须做的一个重要决定是是否在文档中指定返回值的格式。建议你针对值类（如电话号码或矩阵）这样做。指定格式的优点是，它可以作为对象的标准的、明确的、人类可读的表示。这种表示可以用于输入和输出，也可以用于持久的人类可读数据对象，比如 CSV 文件。如果指定了格式，提供一个匹配的静态工厂或构造函数通常是一个好主意，这样程序员就可以轻松地在对象及其字符串表示之间来回转换。Java 库中的许多值类都采用这种方法，包括 BigInteger、BigDecimal 和大多数包装类。
指定 toString 返回值的格式的缺点是，一旦指定了它，就会终生使用它，假设你的类被广泛使用。程序员将编写代码来解析表示、生成表示并将其嵌入持久数据中。如果你在将来的版本中更改了表示形式，你将破坏它们的代码和数据，它们将发出大量的消息。通过选择不指定格式，你可以保留在后续版本中添加信息或改进格式的灵活性。
无论你是否决定指定格式，你都应该清楚地记录你的意图。 如果指定了格式，则应该精确地指定格式。例如，这里有一个 toString 方法用于 PhoneNumber 类：
/** * Returns the string representation of this phone number. * The string consists of twelve characters whose format is * &amp;#34;XXX-YYY-ZZZZ&amp;#34;, where XXX is the area code, YYY is the * prefix, and ZZZZ is the line number.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记13：明智地覆盖 clone 方法</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</guid>
      <description>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：明智地覆盖 clone 方法。
介绍 Cloneable 接口的目的是作为 mixin 接口，用于让类来宣称它们允许克隆。不幸的是，它没有达到这个目的。它的主要缺点是缺少 clone 方法，并且 Object 类的 clone 方法是受保护的。如果不求助于反射，就不能仅仅因为对象实现了 Cloneable 接口就能调用 clone 方法。即使反射调用也可能失败，因为不能保证对象具有可访问的 clone 方法。尽管存在多种缺陷，但该机制的使用范围相当广泛，因此理解它是值得的。本条目将告诉你如何实现行为良好的 clone 方法，讨论什么时候应该这样做，并提供替代方案。
既然 Cloneable 接口不包含任何方法，用它来做什么呢？它决定了 Object 类受保护的 clone 实现的行为：如果一个类实现了 Cloneable 接口，Object 类的 clone 方法则返回该类实例的逐字段拷贝；否则它会抛出 CloneNotSupportedException。这是接口非常不典型的一种使用方式，不应该效仿。通常，类实现接口可以表明类能够为其客户端做些什么。在本例中，它修改了超类上受保护的方法的行为。
虽然规范没有说明，但是在实践中，实现 Cloneable 接口的类应该提供一个功能正常的公共 clone 方法。为了实现这一点，类及其所有超类必须遵守复杂的、不可强制执行的、文档很少的协议。产生的机制是脆弱的、危险的和非语言的：即它创建对象而不调用构造函数。
clone 方法的一般约定很薄弱。下面的内容是从 Object 规范复制过来的：
创建并返回此对象的副本。&amp;ldquo;副本&amp;rdquo; 的确切含义可能取决于对象的类。通常的意图是，对于任何对象 x，表达式
x.clone() != x 将为 true，并且表达式
x.clone().getClass() == x.getClass() 将为 true，但这并不是绝对要求。一般来说，对于任何对象 x 和 y，如果它们的 equals 方法返回 true，则表达式
x.clone().equals(x) 也应返回 true。
clone 方法创建并返回对象的副本。「副本」的确切含义可能取决于对象的类别。通常，对于任何对象 x，表达式 x.clone() != x、x.clone().getClass() == x.getClass() 以及 x.clone().equals(x) 的值都将为 true，但都不是绝对的。
按照惯例，此方法返回的对象应通过调用 super.clone() 来获取。如果一个类及其所有父类（除了 Object）都遵循这个惯例，那么就会有以下情况：
x.clone().getClass() == x.getClass(). 按照约定，clone 方法返回的对象应该通过调用 super.clone() 来获得。如果一个类和它的所有超类（Object 类除外）都遵守这个约定，在这种情况下，表达式 x.clone().getClass() == x.getClass() 则为 true。
按照约定，返回的对象应该独立于被克隆的对象。为了实现这种独立性，可能需要在 super.clone() 返回前，修改对象的一个或多个字段。</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记14：考虑实现 Comparable 接口</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</guid>
      <description>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。
介绍 与本章讨论的其他方法不同，compareTo 方法不是在 Object 中声明的。相反，它是 Comparable 接口中的唯一方法。它在性质上类似于 Object 的 equals 方法，除了简单的相等比较之外，它还允许顺序比较，而且它是通用的。一个类实现 Comparable，表明实例具有自然顺序。对实现 Comparable 的对象数组进行排序非常简单：
Arrays.sort(a); 类似地，搜索、计算极值和维护 Comparable 对象的自动排序集合也很容易。例如，下面的程序依赖于 String 实现 Comparable 这一事实，将命令行参数列表按字母顺序打印出来，并消除重复：
public class WordList { public static void main(String[] args) { Set&amp;lt;String&amp;gt; s = new TreeSet&amp;lt;&amp;gt;(); Collections.addAll(s, args); System.out.println(s); } } 通过让类实现 Comparable，就可与依赖于此接口的所有通用算法和集合实现进行互操作。你只需付出一点点努力就能获得强大的功能。实际上，Java 库中的所有值类以及所有枚举类型都实现了 Comparable。如果编写的值类具有明显的自然顺序，如字母顺序、数字顺序或时间顺序，则应实现 Comparable 接口：
public interface Comparable&amp;lt;T&amp;gt; { int compareTo(T t); } compareTo 方法的一般约定类似于 equals 方法：
将一个对象与指定的对象进行顺序比较。当该对象小于、等于或大于指定对象时，对应返回一个负整数、零或正整数。如果指定对象的类型阻止它与该对象进行比较，则抛出 ClassCastException。
在下面的描述中，sgn(expression) 表示数学中的符号函数，它被定义为：根据传入表达式的值是负数、零或正数，对应返回 -1、0 或 1。
实现者必须确保所有 x 和 y 满足 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))（这意味着 x.compareTo(y) 当且仅当 y.compareTo(x) 抛出异常时才抛出异常）。 实现者还必须确保关系是可传递的：(x.compareTo(y) &amp;gt; 0 &amp;amp;&amp;amp; y.compareTo(z) &amp;gt; 0) 意味着 x.compareTo(z) &amp;gt; 0。 最后，实现者必须确保 x.compareTo(y) == 0 时，所有的 z 满足 sgn(x.</description>
    </item>
    <item>
      <title>Java设计模式：Active Object</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</guid>
      <description>本文主要介绍 Active Object 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 活动对象（Active Object）是一种设计模式，其主要目的是将并发和异步处理的问题从客户端代码中分离出来，从而提高系统的性能、可靠性和可维护性。活动对象模式是一种能够帮助开发人员处理多线程、异步和并发问题的设计模式。
在传统的并发编程模型中，客户端代码需要直接管理线程和锁等细节，这样会导致代码复杂度和维护成本的增加，同时也容易出现各种问题，如死锁、竞态条件等。活动对象模式通过引入活动对象来解决这些问题，活动对象将客户端代码发送的消息添加到内部的消息队列中，并使用单独的线程异步处理这些消息。这种模式可以提高系统的性能和可扩展性，同时使得客户端代码更加简单和易于维护。
活动对象模式的目的包括：
将并发和异步处理的问题从客户端代码中分离出来，从而使得客户端代码更加简单和易于维护。客户端代码只需要发送消息即可，不需要关心异步处理的细节，活动对象将并发和异步处理的问题封装起来，提供简单的接口供客户端使用。 提高系统的性能和可扩展性。活动对象使用单独的线程池异步处理消息，可以更好地利用系统资源，提高系统的性能和可扩展性。 提高系统的可靠性和健壮性。活动对象将消息添加到内部的消息队列中，避免了竞态条件和死锁等问题，从而提高了系统的可靠性和健壮性。 将多线程和异步处理的细节封装起来，使得客户端代码更加抽象和通用。客户端代码可以使用相同的接口来访问不同的服务，从而提高代码的复用性和可维护性。 解释 活动对象模式的核心思想是将并发和异步处理的问题从客户端代码中分离出来。具体来说，活动对象模式包含以下几个关键组件：
活动对象（Active Object）：活动对象是一个封装了某种服务的对象，它将客户端代码发送的消息添加到内部的消息队列中，并使用单独的线程异步处理这些消息。活动对象通常包含一个消息队列和一个线程池，用于异步处理消息。 方法调用请求（Method Invocation Request）：客户端代码向活动对象发送方法调用请求，包括方法名和参数列表等信息。活动对象将方法调用请求封装为一个消息对象，并添加到内部的消息队列中。 消息队列（Message Queue）：消息队列是活动对象内部用于存储方法调用请求的队列。活动对象将客户端代码发送的消息添加到消息队列中，并使用单独的线程异步处理这些消息。 线程池（Thread Pool）：线程池是活动对象用于异步处理消息的线程池。活动对象从消息队列中取出消息，并使用线程池中的线程异步处理这些消息。 程序示例
public abstract class ActiveCreature{ private final Logger logger = LoggerFactory.getLogger(ActiveCreature.class.getName()); private BlockingQueue&amp;lt;Runnable&amp;gt; requests; private String name; private Thread thread; public ActiveCreature(String name) { this.name = name; this.requests = new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(); thread = new Thread(new Runnable() { @Override public void run() { while (true) { try { requests.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title>
      <link>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</link>
      <pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</guid>
      <description>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。
介绍 在覆盖了 equals 方法的类中，必须覆盖 hashCode 方法。 如果你没有这样做，该类将违反 hashCode 方法的一般约定，这将阻止该类在 HashMap 和 HashSet 等集合中正常运行。以下是根据 Object 规范修改的约定：
应用程序执行期间对对象重复调用 hashCode 方法时，它必须一致地返回相同的值，前提是不对 equals 方法中用于比较的信息进行修改。这个值不需要在应用程序的不同执行之间保持一致。 如果根据 equals(Object) 方法判断出两个对象是相等的，那么在两个对象上调用 hashCode 方法必须产生相同的整数结果。 如果根据 equals(Object) 方法判断出两个对象不相等，则不需要在每个对象上调用 hashCode 方法时必须产生不同的结果。但是，程序员应该知道，为不相等的对象生成不同的结果可能会提高散列表的性能。
当你无法覆盖 hashCode 方法时，将违反第二个关键条款：相等的对象必须具有相等的散列码。 根据类的 equals 方法，两个不同的实例在逻辑上可能是相等的，但是对于对象的 hashCode 方法来说，它们只是两个没有共同之处的对象。因此，Object 的 hashCode 方法返回两个看似随机的数字，而不是约定要求的两个相等的数字。例如：
Map&amp;lt;PhoneNumber, String&amp;gt; m = new HashMap&amp;lt;&amp;gt;(); m.put(new PhoneNumber(707, 867, 5309), &amp;#34;Jenny&amp;#34;); 此时，你可能期望 m.get(new PhoneNumber(707, 867,5309)) 返回「Jenny」，但是它返回 null。注意，这里涉及到两个 PhoneNumber 实例：一个用于插入到 HashMap 中，另一个相等的实例（被试图）用于检索。由于 PhoneNumber 类未能覆盖 hashCode 方法，导致两个相等的实例具有不相等的散列码，这违反了 hashCode 方法约定。因此，get 方法查找电话号码的散列桶可能会与 put 方法存储电话号码的散列桶不同。即使这两个实例碰巧分配在同一个散列桶上，get 方法几乎肯定会返回 null，因为 HashMap 有一个优化，它缓存每个条目相关联的散列码，如果散列码不匹配，就不会检查对象是否相等。
解决这个问题就像为 PhoneNumber 编写一个正确的 hashCode 方法一样简单。那么 hashCode 方法应该是什么样的呢？写一个反面例子很容易。例如，以下方法是合法的，但是不应该被使用：
// The worst possible legal hashCode implementation - never use! @Override public int hashCode() { return 42; } 它是合法的，因为它确保了相等的对象具有相同的散列码。同时它也很糟糕，因为它使每个对象都有相同的散列码。因此，每个对象都分配到同一个桶中，散列表退化为链表。这样，原本应该在线性阶 O(n) 运行的程序将在平方阶 O(n^2) 运行。对于大型散列表，这是工作和不工作的区别。</description>
    </item>
    <item>
      <title>Java设计模式：Abstract Document</title>
      <link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</link>
      <pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</guid>
      <description>本文主要介绍 Abstract Document 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 使用动态属性，并在保持类型安全的同时实现非类型化语言的灵活性。
抽象文档模式中的属性对象可以动态添加和删除属性，并且属性类型是在运行时确定的，这使得抽象文档模式具有一定的灵活性和可扩展性。
在抽象文档模式中，属性对象通常使用 Map 或者 List 等数据结构来实现。动态属性的添加和删除可以通过 Map 的 put 和 remove 方法实现，而属性的类型可以通过泛型来确定。
解释 抽象文档模式使您能够处理其他非静态属性。 此模式使用特征的概念来实现类型安全，并将不同类的属性分离为一组接口。
真实世界例子
考虑由多个部分组成的汽车。 但是，我们不知道特定汽车是否真的拥有所有零件，或者仅仅是零件中的一部分。 我们的汽车是动态而且非常灵活的。
通俗的说
抽象文档模式允许在对象不知道的情况下将属性附加到对象。
维基百科说
面向对象的结构设计模式，用于组织松散类型的键值存储中的对象并使用类型化的视图公开数据。 该模式的目的是在强类型语言中实现组件之间的高度灵活性，在这种语言中，可以在不丢失类型安全支持的情况下，将新属性动态地添加到对象树中。 该模式利用特征将类的不同属性分成不同的接口。
程序示例
让我们首先定义基类Document和AbstractDocument。 它们基本上使对象拥有属性映射和任意数量的子对象。
以下代码在 java 8 中编译正常。
Document 接口：
public interface Document { Void put(String key, Object value); Object get(String key); &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; children(String key, Function&amp;lt;Map&amp;lt;String, Object&amp;gt;, T&amp;gt; constructor); } 以下接口不使用 Java 8 的 Stream API：
public interface Document { Object get(String key); void put(String key, Object value); List&amp;lt;Document&amp;gt; children(String key); } AbstractDocument 抽象类：</description>
    </item>
    <item>
      <title>Java设计模式：Abstract Factory</title>
      <link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</link>
      <pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</guid>
      <description>本文主要介绍 Abstract Factory 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 抽象工厂（Abstract Factory）是一种创建型设计模式，它提供了一种方式来创建一系列相关或依赖对象的家族，而无需指定它们具体的类。
抽象工厂模式使用一个抽象工厂接口来定义一组相关的工厂方法，每个工厂方法都能够创建一组相关的产品。具体的工厂实现了这个接口，并能够创建具体的产品。客户端代码只需要使用抽象工厂接口来创建产品，而不需要关心具体的产品实现。
解释 真实世界例子
要创建一个王国，我们需要具有共同主题的对象。精灵王国需要精灵国王、精灵城堡和精灵军队，而兽人王国需要兽人国王、兽人城堡和兽人军队。王国中的对象之间存在依赖关系。
通俗的说
工厂的工厂； 一个将单个但相关/从属的工厂分组在一起而没有指定其具体类别的工厂。
维基百科上说
抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法
程序示例
翻译上面的王国示例。 首先，我们为王国中的对象提供了一些接口和实现。
public interface Castle { String getDescription(); } public interface King { String getDescription(); } public interface Army { String getDescription(); } // Elven implementations -&amp;gt; public class ElfCastle implements Castle { static final String DESCRIPTION = &amp;#34;This is the Elven castle!&amp;#34;; @Override public String getDescription() { return DESCRIPTION; } } public class ElfKing implements King { static final String DESCRIPTION = &amp;#34;This is the Elven king!</description>
    </item>
    <item>
      <title>JSR 166规范</title>
      <link>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</link>
      <pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</guid>
      <description>JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。
JSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。
J.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。
Doug Lea 主页：Doug Lea&amp;rsquo;s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：
JSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定</title>
      <link>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</link>
      <pubDate>Wed, 17 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</guid>
      <description>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：覆盖 equals 方法时应遵守的约定。
介绍 覆盖 equals 方法似乎很简单，但是有很多覆盖的方式会导致出错，而且后果可能非常严重。避免问题的最简单方法是不覆盖 equals 方法，在这种情况下，类的每个实例都只等于它自己。如果符合下列任何条件，就是正确的做法：
类的每个实例本质上都是唯一的。 对于像 Thread 这样表示活动实体类而不是值类来说也是如此。Object 提供的 equals 实现对于这些类具有完全正确的行为。
该类不需要提供「逻辑相等」测试。 例如，java.util.regex.Pattern 可以覆盖 equals 来检查两个 Pattern 实例是否表示完全相同的正则表达式，但设计人员认为客户端不需要或不需要这个功能。在这种情况下，从 Object 继承的 equals 实现是理想的。
超类已经覆盖了 equals，超类行为适合于这个类。 例如，大多数 Set 的实现从 AbstractSet 继承其对等实现，List 从 AbstractList 继承实现，Map 从 AbstractMap 继承实现。
类是私有的或包私有的，并且你确信它的 equals 方法永远不会被调用。 如果你非常厌恶风险，你可以覆盖 equals 方法，以确保它不会意外调用：
@Override public boolean equals(Object o) { throw new AssertionError(); // Method is never called } 什么时候覆盖 equals 方法是合适的？当一个类有一个逻辑相等的概念，而这个概念不同于仅判断对象的同一性（相同对象的引用），并且超类还没有覆盖 equals。对于值类通常是这样。值类只是表示值的类，例如 Integer 或 String。使用 equals 方法比较引用和值对象的程序员希望发现它们在逻辑上是否等价，而不是它们是否引用相同的对象。覆盖 equals 方法不仅是为了满足程序员的期望，它还使实例能够作为 Map 的键或 Set 元素时，具有可预测的、理想的行为。
有一个表示状态的内部类。没有覆盖 equals 方法时，equals 的结果与 s1==s2 相同，为 false，即两者并不是相同对象的引用。
public static void main(String[] args) { class Status { public String status; } Status s1 = new Status(); Status s2 = new Status(); System.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记8：避免使用终结器和清除器</title>
      <link>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</link>
      <pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记：避免使用终结器和清除器。
介绍 终结器是不可预测的、常常是危险的，通常也是不必要的。 它们的使用可能导致不稳定的行为、低效率和可移植性问题。终结器有一些有效的用途，我们稍后会介绍，但通常情况下应该避免使用它们。从 Java 9 开始，终结器已经被弃用，但它们仍然被 Java 库使用。Java 9 中终结器的替代品是清除器。 清除器的危险比终结器小，但仍然不可预测、缓慢，而且通常是不必要的。
终结器是通过在对象上实现 finalize() 方法来实现的，而清除器是通过使用 Cleaner 类来实现的。它们的工作方式有所不同：
终结器是由垃圾回收器自动执行的，无法预测何时执行，也无法保证一定会执行。当垃圾回收器决定将对象回收时，它会调用对象的 finalize() 方法，以便对象在被销毁之前执行一些清理操作。
清除器是由 Java 9 虚拟机通过引用队列和 Cleaner 对象执行的，可以在对象被回收之前或之后执行。在对象被垃圾回收之前，Java 虚拟机会将该对象的引用添加到一个引用队列中，然后在某些时刻，Java 虚拟机会创建一个 Cleaner 对象，并将该引用队列与 Cleaner 对象关联起来。当该对象被垃圾回收时，它的引用将被添加到与 Cleaner 对象关联的引用队列中，Cleaner 对象会在某些时刻自动执行，以便对象在被销毁之前或之后执行一些清理操作。
在 Java 9 中，引入了 java.lang.ref.Cleaner 类，作为终结器的替代品，用于执行对象清理操作。相比终结器，Cleaner 具有以下优点：
显式管理：Cleaner 使用明确的代码路径来管理清理操作，而不是使用隐式的终结器机制。 可控性：Cleaner 允许开发人员控制何时执行清理操作，而不是完全依赖于垃圾回收器的行为。 安全性：Cleaner 执行清理操作时，会确保类加载器已准备好，因此可以安全地执行本地清理操作。 Cleaner 通过注册一个任务来执行清理操作。该任务可以是 Runnable 或者继承自 PhantomReference 类的子类对象。当对象被垃圾回收器回收时，Cleaner 将自动执行注册的任务。
终结器和清除器的使用场景非常有限，因为它们的执行时间不可预测，可能会导致一些问题，例如性能问题、不稳定的行为、低效率和可移植性问题。
终结器和清除器的主要问题是：
它们无法可靠地及时执行，甚至可能根本不会执行。当对象变得不可访问，终结器或清除器对它进行操作的时间是不确定的。这意味着永远不应该在终结器或清除器中执行任何对时间要求很严格的操作。例如，依赖终结器或清除器关闭文件就是一个严重错误，因为打开的文件描述符是有限的资源。如果由于系统在运行终结器或清除器的延迟导致许多文件处于打开状态，程序可能会运行失败，因为它不能再打开其他文件。
终结器的另一个问题是，在终结期间抛出的未捕获异常被忽略，该对象的终结终止。未捕获的异常可能会使其他对象处于损坏状态。如果另一个线程试图使用这样一个损坏的对象，可能会导致任意的不确定性行为。正常情况下，未捕获的异常将终止线程并打印堆栈跟踪，但如果在终结器中出现，则不会打印警告。清除器没有这个问题，因为使用清除器的库可以控制它的线程。
它们可能会导致性能问题。终结器由垃圾回收器执行，这可能会导致垃圾回收过程中的延迟。另一方面，清除器使用单独的线程执行，这可能会导致额外的开销和同步问题。
《Effective Java》第三版建议使用显式终止方法，例如 close()，释放系统资源。当应用程序完成对资源的使用时，可以显式调用这些方法，而不依赖于垃圾回收器来执行它们。
如果必须使用终结器或清除器， 《Effective Java》第三版建议使用防御性编程实现它们，即使用 try-finally 块确保执行关键的清理操作，并避免引用其他可能已被垃圾回收的对象或资源。
扩展 System.gc() System.gc() 方法是 Java 中的一种垃圾回收机制，它可以在请求垃圾回收器运行时强制进行一次垃圾回收。
System.gc() 方法不是强制垃圾回收的方法，因为 Java 虚拟机可以忽略它。Java 编程语言规范要求 System.gc() 方法只是一个建议，不能保证它一定会导致垃圾回收器运行。因此，它不应该被频繁地调用，因为这可能会导致性能问题。
System.gc() 方法的使用场景非常有限。通常情况下，应该让垃圾回收器自行管理内存，而不是使用 System.gc() 方法来强制进行垃圾回收。如果需要确保某些对象在垃圾回收之前被释放，可以使用弱引用或软引用来管理这些对象，或使用显式终止方法来释放系统资源。
需要注意的是，System.gc() 方法可能会耗费较长时间，因为它可能会强制回收所有未使用的对象。因此，在实际使用中，应该谨慎使用 System.gc() 方法，并仅在必要时使用它。
System.runFinalization() System.runFinalization() 方法是在 Java 1.2 版本中引入的。在 Java 1.2 中，引入了垃圾回收器的改进，包括使用引用类型、终结器和垃圾回收器性能的提升。System.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记9：使用 try-with-resources 优于 try-finally</title>
      <link>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</link>
      <pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记：使用 try-with-resources 优于 try-finally。
介绍 Java 库包含许多必须通过调用 close 方法手动关闭的资源。常见的有 InputStream、OutputStream 和 java.sql.Connection。关闭资源常常会被客户端忽略，这会导致可怕的性能后果。虽然这些资源中的许多都使用终结器作为安全网，但终结器并不能很好地工作。
从历史上看，try-finally 语句是确保正确关闭资源的最佳方法，即使在出现异常或返回时也是如此：
// try-finally - No longer the best way to close resources! static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } 这可能看起来不坏，但添加第二个资源时，情况会变得更糟：
// try-finally is ugly when used with more than one resource! static void copy(String src, String dst) throws IOException { InputStream in = new FileInputStream(src); try { OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) &amp;gt;= 0) out.write(buf, 0, n); } finally { out.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记4：用私有构造函数使类不可实例化</title>
      <link>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</link>
      <pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记：用私有构造函数使类不可实例化。
介绍 使用私有构造函数强制实现不可实例化的主要原因是防止类被意外地实例化，以使代码更加健壮和可靠。在某些情况下，我们只需要使用类中的静态方法和静态字段，而不需要创建该类的实例。如果类中没有显式地定义私有构造函数，Java 编译器将会自动为该类生成一个默认的公共构造函数，这意味着该类可以在其他类中被实例化。如果这不是我们想要的，为了防止其他人意外地实例化我们的类，我们可以将构造函数设置为私有。
此外，使用私有构造函数强制实现不可实例化还有以下优点：
明确表明该类不可被实例化，提高了代码的可读性和可维护性。 防止类被子类化，从而避免了继承所带来的副作用和不必要的复杂性。 提高了代码的安全性，防止其他类在不合适的情况下实例化该类。 这是一个实现了私有构造函数强制实现不可实例化的类的示例：
public class UtilityClass { // 禁止默认构造函数防止实例化 private UtilityClass() { throw new AssertionError(); } // 其他静态方法和字段 // ... } 这个类中的私有构造函数会在被调用时抛出AssertionError。这样做可以确保构造函数永远不会从类内部或外部调用。
通过将构造函数设置为私有，这个类就不能从外部被实例化。这个习惯用法也防止了类被子类化。如果一个类的构造函数是私有的，那么它不能被子类调用，因为子类必须调用父类的构造函数来完成初始化。因此，如果一个类的构造函数是私有的，它就不能被子类化，因为子类不能调用父类的构造函数来完成初始化。
以下是一个示例，展示了如何使用私有构造函数防止类被子类化：
public final class FinalClass { private FinalClass() { // private constructor } public static void doSomething() { // do something } } 在这个示例中，FinalClass被声明为final，因此不能被子类化。此外，它的构造函数是私有的，因此不能从子类中被调用。由于该类不能被子类化，因此它的行为不会受到子类的影响，从而避免了继承所带来的副作用和不必要的复杂性。
在某些情况下，将类设置为不能被实例化，但可以被子类化是有用的。这通常是因为我们希望子类化的类能够继承父类的行为和属性，同时又不希望外部能够实例化该类。以下是一个例子：
public abstract class Animal { private String name; protected Animal(String name) { this.name = name; } public String getName() { return name; } public abstract void makeSound(); } public class Dog extends Animal { public Dog(String name) { super(name); } @Override public void makeSound() { System.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记7：排除过时的对象引用</title>
      <link>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</link>
      <pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。
介绍 &amp;ldquo;Eliminate obsolete object references&amp;rdquo; 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。
考虑以下简单的堆栈实现：
import java.util.Arrays; import java.util.EmptyStackException; // Can you spot the &amp;#34;memory leak&amp;#34;? public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; } /** * Ensure space for at least one more element, roughly * doubling the capacity each time the array needs to grow. */ private void ensureCapacity() { if (elements.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记6：避免创建不必要的对象</title>
      <link>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</link>
      <pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记：避免创建不必要的对象。
介绍 创建对象时，经常会复用对象。如果对象是不可变的，那么它总是可以被复用的。
下面一个例子：
String s = new String(&amp;#34;bikini&amp;#34;); // DON&amp;#39;T DO THIS! 该语句每次执行时都会创建一个新的 String 实例，而这些对象创建都不是必需的。String 构造函数的参数 (&amp;quot;bikini&amp;quot;) 本身就是一个 String 实例，在功能上与构造函数创建的所有对象相同。如果这种用法发生在循环或频繁调用的方法中，创建大量 String 实例是不必要的。
改进后的版本如下：
String s = &amp;#34;bikini&amp;#34;; 这个版本使用单个 String 实例，而不是每次执行时都创建一个新的实例。此外，可以保证在同一虚拟机中运行的其他代码都可以复用该对象，只要恰好包含相同的字符串字面量。
通常可以通过使用静态工厂方法来避免创建不必要的对象，而不是在提供这两种方法的不可变类上使用构造函数。例如，工厂方法 Boolean.valueOf(String) 比构造函数 Boolean(String) 更可取，后者在 Java 9 中被弃用了。构造函数每次调用时都必须创建一个新对象，而工厂方法从来不需要这样做，在实际应用中也不会这样做。除了复用不可变对象之外，如果知道可变对象不会被修改，也可以复用它们。
有些对象的创建的代价相比而言要昂贵得多。如果你需要重复地使用这样一个「昂贵的对象」，那么最好将其缓存以供复用。
下面是使用正则表达式最简单的方法：
// Performance can be greatly improved! static boolean isRomanNumeral(String s) { return s.matches(&amp;#34;^(?=.)M*(C[MD]|D?C{0,3})&amp;#34; + &amp;#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&amp;#34;); } 这个实现的问题是它依赖于 String.matches 方法。虽然 String.matches 是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能关键的情况下重复使用。 问题在于，它在内部为正则表达式创建了一个 Pattern 实例，并且只使用一次，之后就进行垃圾收集了。创建一个 Pattern 实例是很昂贵的，因为它需要将正则表达式编译成有限的状态机。
为了提高性能，将正则表达式显式编译为 Pattern 实例（它是不可变的），作为类初始化的一部分，缓存它，并在每次调用 isRomanNumeral 方法时复用同一个实例：
// Reusing expensive object for improved performance public class RomanNumerals { private static final Pattern ROMAN = Pattern.compile(&amp;#34;^(?=.)M*(C[MD]|D?C{0,3})&amp;#34; + &amp;#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&amp;#34;); static boolean isRomanNumeral(String s) { return ROMAN.</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记5：依赖注入优于硬编码资源</title>
      <link>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</link>
      <pubDate>Mon, 17 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。
介绍 依赖注入是软件工程中使用的一种设计模式，用于将组件和依赖项相互解耦。而不是在组件内部创建和管理依赖项，我们从外部传递它们。这种方法可以帮助创建更模块化和灵活的代码。
相比之下，硬编码资源涉及在组件内部直接创建和管理依赖项。这种方法可能会使代码不太灵活，难以维护。
举例 许多类依赖于一个或多个底层资源。例如，拼写检查程序依赖于字典。常见做法是，将这种类实现为静态实用工具类：
// Inappropriate use of static utility - inflexible &amp;amp; untestable! public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() {} // Noninstantiable public static boolean isValid(String word) { ... } public static List&amp;lt;String&amp;gt; suggestions(String typo) { ... } } 类似地，我们也经常看到它们的单例实现：
// Inappropriate use of singleton - inflexible &amp;amp; untestable! public class SpellChecker { public static INSTANCE = new SpellChecker(...); private final Lexicon dictionary = ...; private SpellChecker(...) {} public boolean isValid(String word) { ... } public List&amp;lt;String&amp;gt; suggestions(String typo) { ... } } 这两种方法都不令人满意，因为它们假设只使用一个字典。在实际应用中，每种语言都有自己的字典，特殊的字典用于特殊的词汇表。另外，最好使用一个特殊的字典进行测试。
你可以尝试让 SpellChecker 支持多个字典：首先取消 dictionary 字段的 final 修饰，并在现有的拼写检查器中添加更改 dictionary 的方法。但是在并发环境中这种做法是笨拙的、容易出错的和不可行的。静态实用工具类和单例不适用于由底层资源参数化的类。</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记3：使用私有构造函数或枚举类型创建单例</title>
      <link>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</link>
      <pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。
介绍 单例是一个只实例化一次的类。单例通常表示无状态对象，比如函数或系统组件，它们在本质上是唯一的。将一个类设计为单例会使它的客户端测试时变得困难， 除非它实现了作为其类型的接口，否则无法用模拟实现来代替单例。
实现 实现单例有两种常见的方法。两者都基于保持构造函数私有和导出公共静态成员以提供对唯一实例的访问。
在第一种方法中，成员是一个 final 字段：
// Singleton with public final field public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() { ... } public void leaveTheBuilding() { ... } } 私有构造函数只调用一次，用于初始化 public static final 修饰的 Elvis 类型字段 INSTANCE。不使用 public 或 protected 的构造函数保证了「独一无二」的空间：一旦初始化了 Elvis 类，就只会存在一个 Elvis 实例，不多也不少。客户端所做的任何事情都不能改变这一点，但有一点需要注意：拥有特殊权限的客户端可以借助 AccessibleObject.setAccessible 方法利用反射调用私有构造函数。
Constructor&amp;lt;?&amp;gt;[] constructors = Elvis.class.getDeclaredConstructors(); AccessibleObject.setAccessible(constructors, true); Arrays.stream(constructors).forEach(name -&amp;gt; { if (name.toString().contains(&amp;#34;Elvis&amp;#34;)) { Elvis instance = (Elvis) name.newInstance(); instance.leaveTheBuilding(); } }); 如果需要防范这种攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。
在实现单例的第二种方法中，公共成员是一种静态工厂方法：
// Singleton with static factory public class Elvis { private static final Elvis INSTANCE = new Elvis(); private Elvis() { .</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记1：静态工厂方法代替构造函数</title>
      <link>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。
介绍 静态工厂方法是指在类中定义一个静态方法，用于创建该类的实例。示例：
public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Boolean.FALSE; } 与构造函数不同的是，静态工厂方法可以有自己的名称，并且可以根据参数的不同返回不同的对象实例。
优点 这本书中提到了一些静态工厂方法的优点，包括：
静态工厂方法可以有意义的名称：与构造函数不同，静态工厂方法可以有自己的名称，这使得代码更具有可读性和可维护性。
例如，BigInteger 类提供了一个返回素数的静态工厂方法 BigInteger.probablePrime 。
静态工厂方法可以隐藏实现细节：静态工厂方法可以隐藏对象的创建和初始化过程，使客户端代码更加简洁和易于维护。
这是服务提供者框架的基础。
服务提供者框架中有三个基本组件：服务接口，代表要实现的服务；提供者注册 API，提供者使用它来注册实现，以及服务访问 API，客户端使用它来获取服务的实例。服务访问 API 允许客户端指定选择实现的标准。在没有这些条件的情况下，API 返回一个默认实现的实例，或者允许客户端循环使用所有可用的实现。服务访问 API 是灵活的静态工厂，它构成了服务提供者框架的基础。
服务提供者框架的第四个可选组件是服务提供者接口，它描述了产生服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须以反射的方式实例化实现。
在 JDBC 中，Connection 扮演服务接口的角色。DriverManager.registerDriver 是提供者注册的 API，DriverManager.getConnection 是服务访问 API，Driver 是服务提供者接口。
服务提供者框架模式有许多变体。例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口，这是桥接模式。依赖注入框架可以看作是强大的服务提供者。由于是 Java 6，该平台包括一个通用服务提供者框架 Java.util.ServiceLoader，所以你不需要，通常也不应该自己写。JDBC 不使用 ServiceLoader，因为前者比后者要早。
静态工厂方法可以返回缓存的对象：静态工厂方法可以返回缓存的对象，这避免了创建新对象的开销，提高了性能。
这种技术类似于享元模式。如果经常请求相同的对象，特别是在创建对象的代价很高时，它可以极大地提高性能。
举例 1：使用 ConcurrentHashMap
public class ThreadSafeCache { private static final Map&amp;lt;String, ThreadSafeCache&amp;gt; instances = new ConcurrentHashMap&amp;lt;&amp;gt;(); private ThreadSafeCache() {} public static ThreadSafeCache getInstance(String key) { return instances.computeIfAbsent(key, k -&amp;gt; new ThreadSafeCache()); } } 在上面的示例中，computeIfAbsent 方法用于计算缓存对象。如果 key 在 instances 中不存在，则使用 lambda 表达式 k -&amp;gt; new ThreadSafeCache() 创建一个新的 ThreadSafeCache 对象，并将该对象与 key 关联。如果 key 已经存在，则直接返回与之关联的 ThreadSafeCache 对象。</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记2：使用构造器代替构造方法</title>
      <link>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。
介绍 当一个类需要多个构造函数参数时，可以考虑使用构建器模式来创建对象。构建器模式是一种创建对象的设计模式，它可以通过链式调用方法的方式来设置对象的构造参数，并最终返回一个构造完整的对象。
优点 使用构建器模式的原因有以下几点：
避免构造函数参数过多的问题：当一个类需要多个构造函数参数时，构造函数的参数列表可能会变得很长，这会导致代码难以理解和维护。使用构建器模式可以将构造函数参数拆分成多个方法，从而使代码更加清晰易懂。 提高代码的可读性和可维护性：使用构建器模式可以使代码更加易懂和易维护，因为可以通过方法名来清晰地表达每个参数的含义。 提供更多的灵活性和可定制性：构建器模式可以提供更多的灵活性和可定制性，因为可以在构造对象时进行更多的逻辑处理和判断。例如，可以在构建器中添加验证逻辑，以确保参数的有效性。 支持多线程环境：构建器模式可以支持多线程环境，因为每个构建器都是独立的，不会受到其他线程的影响。 以下是一个例子：
public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; private NutritionFacts(Builder builder) { this.servingSize = builder.servingSize; this.servings = builder.servings; this.calories = builder.calories; this.fat = builder.fat; this.sodium = builder.sodium; this.carbohydrate = builder.carbohydrate; } //省略 get set public static class Builder { // Required parameters private final int servingSize; private final int servings; // Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) { this.</description>
    </item>
  </channel>
</rss>
