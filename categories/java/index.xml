<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on ChenSoul</title><link>https://blog.chensoul.cc/categories/java/</link><description>Recent content in Java on ChenSoul</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 04 Nov 2024 21:00:00 +0800</lastBuildDate><atom:link href="https://blog.chensoul.cc/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Tutorials</title><link>https://blog.chensoul.cc/tutorials/</link><pubDate>Mon, 04 Nov 2024 21:00:00 +0800</pubDate><guid>https://blog.chensoul.cc/tutorials/</guid><description>&lt;h3 id="java">Java&lt;/h3>
&lt;h3 id="kubernetes">Kubernetes&lt;/h3>
&lt;h3 id="microservices">Microservices&lt;/h3>
&lt;h3 id="spring-boot">Spring Boot&lt;/h3>
&lt;h3 id="spring-cloud">Spring Cloud&lt;/h3>
&lt;h3 id="spring-security-oauth-20">Spring Security OAuth 2.0&lt;/h3>
&lt;h3 id="heading">&lt;/h3></description></item><item><title>ActiveMQ源码-BrokerService和PersistenceAdapter</title><link>https://blog.chensoul.cc/posts/2024/08/27/activemq-source-code-broker-service/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/27/activemq-source-code-broker-service/</guid><description>&lt;p>activemq-broker 模块 test/java 目录下有个 IDERunner 类：&lt;/p></description></item><item><title>ThingsBoard源码编译和Idea运行</title><link>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</guid><description>&lt;p>ThingsBoard 源码地址：&lt;a href="https://github.com/thingsboard/thingsboard" target="_blank">https://github.com/thingsboard/thingsboard&lt;/a>，从 &lt;a href="https://github.com/thingsboard/thingsboard/releases/tag/v3.7" target="_blank">3.7&lt;/a> 版本之后，要求 JDK17。官方提供了源码编译的文档：&lt;a href="https://thingsboard.io/docs/user-guide/install/building-from-source/" target="_blank">Building from sources&lt;/a>&lt;/p></description></item><item><title>ActiveMQ源码本地调试运行</title><link>https://blog.chensoul.cc/posts/2024/08/09/debug-activemq-source-code/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/09/debug-activemq-source-code/</guid><description>&lt;h2 id="源码构建">源码构建&lt;/h2>
&lt;p>1、从 &lt;a href="https://github.com/apache/activemq" target="_blank">https://github.com/apache/activemq&lt;/a> 下载源码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/apache/activemq
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2、切换至 activemq-5.18.x 分支&lt;/p></description></item><item><title>Github Action 发布 Jar 到 Maven 中央仓库</title><link>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</link><pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</guid><description>&lt;p>作为一名 Java 开发者,将自己的项目发布到 Maven 中央仓库是一个非常重要的步骤。这不仅可以让更多的开发者发现和使用您的项目,也可以提高项目的知名度和影响力。&lt;/p></description></item><item><title>[译]JMS 2.0 中的新增功能</title><link>https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/</guid><description>&lt;p>原文链接：&lt;a href="https://hasithah.medium.com/what-is-new-in-jms-2-0-821266fc1bf0" target="_blank">What is new in JMS 2.0&lt;/a>&lt;/p></description></item><item><title>[译]JMS 2.0 中的新增功能（第一部分）- 易于使用</title><link>https://blog.chensoul.cc/posts/2024/07/24/jms20/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/jms20/</guid><description>&lt;p>原文链接：&lt;a href="https://www.oracle.com/technical-resources/articles/java/jms20.html" target="_blank">https://www.oracle.com/technical-resources/articles/java/jms20.html&lt;/a>&lt;/p>
&lt;p>&lt;em>作者：Nigel Deakin&lt;/em>
出版日期：2013 年 5 月&lt;/p></description></item><item><title>[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能</title><link>https://blog.chensoul.cc/posts/2024/07/24/jms20/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/jms20/</guid><description>&lt;p>原文链接：&lt;a href="https://www.oracle.com/technical-resources/articles/java/jms2messaging.html" target="_blank">https://www.oracle.com/technical-resources/articles/java/jms2messaging.html&lt;/a>&lt;/p>
&lt;p>&lt;em>作者：Nigel Deakin&lt;/em>
出版日期：2013 年 5 月&lt;/p></description></item><item><title>[译]JMS 2.0 的十个好处意味着可以减少代码编写量</title><link>https://blog.chensoul.cc/posts/2024/07/24/jms20-means-less-code/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/jms20-means-less-code/</guid><description>&lt;p>原文链接：&lt;a href="https://javaee.github.io/jms-spec/pages/JMS20MeansLessCode" target="_blank">Ten ways in which JMS 2.0 means writing less code&lt;/a>&lt;/p></description></item><item><title>[译]JMS 事务的实际应用</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-transactions-in-action/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-transactions-in-action/</guid><description>&lt;p>在本文中，您将了解如何选择性地使用 JMS 事务。在 JMS 中，您可以选择控制一个会话的原子操作。每个会话都支持一系列事务。每个事务将一组生成或使用的消息分组为一个原子工作单元。确保您已经理解了&lt;a href="https://jstobigdata.com/jms/guaranteed-delivery-using-jms-message-acknowledgement/" target="_blank">JMS 中的消息确认&lt;/a>。&lt;/p></description></item><item><title>[译]JMS 发布-订阅消息模型</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-pub-sub-messaging-model/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-pub-sub-messaging-model/</guid><description>&lt;p>在本文中，您将了解 JMS 发布-订阅 (publish-subscribe) 消息传递模型。正如您在&lt;a href="https://jstobigdata.com/jms/jms-introduction-java-message-service/" target="_blank">JMS 简介文章&lt;/a>中所读到的，在发布/订阅模型中，客户端通过称为主题的中介将消息发送给多个接收者。发送者通常称为发布者，接收者称为订阅者。&lt;/p></description></item><item><title>[译]JMS 消息优先级</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/</guid><description>&lt;p>我们将通过示例详细讨论 JMS 消息优先级。每条消息的标头字段代表其优先级。我在消息模型教程&lt;code>JMSPriority&lt;/code>中讨论过消息优先级。&lt;/p>
&lt;p>JMS 有 10 个优先级，从 0 到 9。0 是最低优先级，9 是最高优先级。根据 JMS 标准，优先级为 0-4 的消息为正常优先级，优先级为 5-9 的消息被视为加急优先级。&lt;/p></description></item><item><title>[译]JMS 消息模型</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/</guid><description>&lt;p>消息是 JMS 的核心，无论是事件还是业务数据。消息由标头、自定义属性和正文组成。这是您将在 JMS 消息模型（JMS 消息剖析）中学习的内容。&lt;/p></description></item><item><title>[译]JMS 消息选择器在过滤消息中的应用</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-message-selectors-in-action-to-filter-messages/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-message-selectors-in-action-to-filter-messages/</guid><description>&lt;p>发送给接收方的消息通常需要根据某些标准进行过滤。JMS 提供消息选择器，允许 JMS 消费者根据消息头指定其感兴趣的消息。在本文中，您将学习使用 JMS 消息选择器来过滤消息。&lt;/p></description></item><item><title>[译]JMS 点对点消息传递的实际应用</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/</guid><description>&lt;p>点对点系统使用队列进行消息传递。客户端将消息发送到特定队列，特定订阅者监听或接收来自该队列的消息。在 JMS 点对点消息传递系统中，队列用于处理单个发送者和单个消费者。确保您已经阅读了有关&lt;a href="https://jstobigdata.com/jms/jms-message-model/" target="_blank">JMS 消息模型&lt;/a>以及&lt;a href="https://jstobigdata.com/jms/send-and-receive-message-in-jms/" target="_blank">如何在 JMS 中发送和接收消息的&lt;/a>先前教程。&lt;/p></description></item><item><title>[译]JMS介绍 – Java消息服务</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/</guid><description>&lt;p>JMS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。这是一个 JMS 介绍教程，为您提供消息传递和 JMS 的简要概述。您将了解使用 JMS 的优势以及 JMS 中的不同消息传递模型。&lt;/p></description></item><item><title>[译]为 JMS 安装和设置 Glassfish</title><link>https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/</guid><description>&lt;p>在本文中，我们将为 JMS 2.0 设置 Glassfish，创建一个 Java 项目并添加必要的依赖项。&lt;/p></description></item><item><title>[译]使用 JMS 消息确认保证传送</title><link>https://blog.chensoul.cc/posts/2024/07/23/guaranteed-delivery-using-jms-message-acknowledgement/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/guaranteed-delivery-using-jms-message-acknowledgement/</guid><description>&lt;p>JMS 通过 JMS 消息确认（确认模式）确保消息传递的可靠性。如果会话已进行事务处理，则该&lt;code>commit()&lt;/code>方法会自动处理消息确认。否则，该方法将处理恢复&lt;code>rollback()&lt;/code>。在本文中，我们将假设会话未进行事务处理。这是一个高级主题，请确保您对 JMS 有基本的了解。如果您是 JMS 新手，可以参考使用 JMS&lt;a href="https://jstobigdata.com/jms/send-and-receive-message-in-jms/" target="_blank">发送和接收消息。&lt;/a>&lt;/p></description></item><item><title>[译]在 JMS 中发送和接收消息</title><link>https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/</guid><description>&lt;p>您将了解 JMS 架构，学习如何在 JMS 中发送和接收消息。我将介绍管理对象、JMS 1.1 API 和 JMS 2.0 API。我们还将看到与 JMS 1.1 API 相比，JMS 2.0 API 的使用有多么简单。在继续学习本课程之前，请确保您已完成 JMS 设置。如果您是初学者，请确保您已了解&lt;a href="https://jstobigdata.com/jms/jms-introduction-java-message-service/" target="_blank">JMS 的基础知识&lt;/a>。&lt;/p></description></item><item><title>[译]完整的 JMS 2.0 教程</title><link>https://blog.chensoul.cc/posts/2024/07/23/a-complete-jms-2-0-tutorial/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/a-complete-jms-2-0-tutorial/</guid><description>&lt;p>JMS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。消息传递是在各种应用程序或服务之间交换业务数据的过程。这是&lt;strong>一个完整的 JMS 2.0 教程，&lt;/strong> 其中包含大量代码示例。完整的代码示例可在 GitHub 上找到，请下载并运行示例。本教程使用 Glassfish 开源服务器作为 JMS 提供程序的示例。&lt;/p></description></item><item><title>将 Maven 站点发布到 GitHub Pages</title><link>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</guid><description>&lt;p>本文源代码：&lt;a href="https://github.com/chensoul/maven-site-github-example/" target="_blank">https://github.com/chensoul/maven-site-github-example/&lt;/a> 。&lt;/p>
&lt;h2 id="创建-java-maven-项目">创建 Java Maven 项目&lt;/h2>
&lt;p>让我们使用 Maven 创建一个简单的 Java 项目&lt;/p></description></item><item><title>All things about OAuth</title><link>https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/</guid><description>&lt;p>OAuth 是一种&lt;strong>开放协议&lt;/strong>，允许通过网络、移动和桌面应用程序以&lt;strong>简单&lt;/strong>、&lt;strong>标准的方式进行&lt;/strong>安全授权。&lt;/p>
&lt;h2 id="oauth-2-入门">OAuth 2 入门&lt;/h2>
&lt;p>以下是一些 OAuth 2.0 指南，涵盖了理解和实现客户端和服务器所需的许多主题。&lt;/p></description></item><item><title>JWT</title><link>https://blog.chensoul.cc/posts/2024/06/06/jwt/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/06/jwt/</guid><description>&lt;h2 id="什么是-jwt">什么是 JWT？&lt;/h2>
&lt;p>JWT（JSON Web Token）是一种开放标准(RFC 7519)，用于在网络应用程序之间安全地传输信息。它被设计用于在两方之间传输声明，这些声明可以是身份验证和授权信息，也可以是任何其他类型的信息。&lt;/p></description></item><item><title>OAuth2和OIDC区别</title><link>https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/</guid><description>&lt;h2 id="认证和授权">认证和授权&lt;/h2>
&lt;p>&lt;strong>认证 (Authentication)&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>认证是验证用户、设备或系统身份的过程。&lt;/li>
&lt;li>常见的认证方式包括用户名/密码、生物特征(如指纹、人脸)、单点登录(SSO)等。&lt;/li>
&lt;li>认证确保只有被授权的实体才能访问系统或资源。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>授权 (Authorization)&lt;/strong>：&lt;/p></description></item><item><title>[译]OAuth2.0服务器</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-server/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-server/</guid><description>&lt;h1 id="背景">背景&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>&lt;em>作者：&lt;a href="https://aaronparecki.com/" target="_blank">Aaron Parecki&lt;/a>&lt;/em>&lt;/p>
&lt;p>我第一次接触 OAuth 是在 2010 年，当时我正在构建一个 API，我知道我希望第三方开发人员能够在其基础上构建应用程序。当时，OAuth 看起来令人生畏。OAuth 1 的实现只有少数几个，而 OAuth 2.0 仍是一个草稿。一天晚上，我决定坐下来，拿着精酿啤酒和最新草案的纸质副本，从头到尾阅读它，直到我理解它。&lt;/p></description></item><item><title>[译]OAuth2简化版</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth-2-simplified/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth-2-simplified/</guid><description>&lt;p>这篇文章以简化的格式描述了 OAuth 2.0，以帮助开发人员和服务提供商实现该协议。&lt;/p>
&lt;p>&lt;a href="https://oauth.net/2/" target="_blank">OAuth 2 规范&lt;/a>读起来可能有点混乱，所以我写了这篇文章来帮助以简化的格式描述术语。核心规范将许多决策留给实现者，通常基于实现的安全权衡。这篇文章没有描述成功实施 OAuth 2 所需的所有可能决策，而是做出适用于大多数实现的决策。&lt;/p></description></item><item><title>RFC6749 | OAuth2.0授权框架中文版</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;h3 id="摘要">摘要&lt;/h3>
&lt;p>OAuth2.0 授权框架允许第三方应用获取对 HTTP 服务的有限的访问权限，既可以以资源所有者名义在资源所有者和 HTTP 服务之间进行允许的交互，也可以允许第三方应用以自己的名义进行访问。本规范取代并淘汰 RFC 5849 中描述的 OAuth 1.0 协议。&lt;/p></description></item><item><title>All things about WebSocket</title><link>https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/</link><pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/</guid><description>&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank">Wikipedia：WebSocket&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank">WebSocket - Web APIs | MDN&lt;/a>&lt;/p></description></item><item><title>All things about Spring Modulith</title><link>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</link><pubDate>Thu, 09 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</guid><description>&lt;p>VMware 推出了一个实验性的项目&lt;a href="https://spring.io/projects/spring-modulith" target="_blank">Spring Modulith&lt;/a>，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。&lt;/p></description></item><item><title>[译]探索 http2（第 1 部分）：概述</title><link>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/</guid><description>&lt;p>原文链接：&lt;a href="https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f" target="_blank">https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>让我们来谈谈&lt;/em> &lt;strong>http2 的内容、原因、时间和方式&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>完整的代码可以在&lt;a href="https://github.com/noobg1/http1_vs_http2" target="_blank">github&lt;/a>上找到。&lt;/p></description></item><item><title>[译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</title><link>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/</guid><description>&lt;p>原文链接：&lt;a href="https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249" target="_blank">https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://miro.medium.com/v2/resize:fit:1400/1*AI-qItSMJDSBxEhk8XMyIw.png" alt="img">&lt;/p>
&lt;p>来源：&lt;a href="https://www.thewebmaster.com/hosting/2015/dec/14/what-is-http2-and-how-does-it-compare-to-http1-1/" target="_blank">https://www.thewebmaster.com/&lt;/a>&lt;/p>
&lt;p>&lt;strong>先决条件&lt;/strong>：了解 javascript、客户端-服务器架构。&lt;/p></description></item><item><title>[译]比较 Socket.IO 和 HTTP：主要区别和用例</title><link>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/socketio-vs-http" target="_blank">https://ably.com/topic/socketio-vs-http&lt;/a>&lt;/p>
&lt;p>在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对&lt;a href="https://ably.com/topic/socketio" target="_blank">Socket.IO&lt;/a>实时库和&lt;a href="https://ably.com/topic/websockets-vs-http#http" target="_blank">HTTP&lt;/a>协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。&lt;/p>
&lt;h2 id="什么是socketio">什么是Socket.IO？&lt;/h2>
&lt;p>Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。&lt;/p></description></item><item><title>[译]2024年最好的WebSocket替代品</title><link>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websocket-alternatives" target="_blank">https://ably.com/topic/websocket-alternatives&lt;/a>&lt;/p>
&lt;h2 id="什么是-websocket">什么是 WebSocket？&lt;/h2>
&lt;p>简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。&lt;/p></description></item><item><title>[译]Apache Kafka、RabbitMQ 与 AWS SNSSQS：哪个消息代理最好？</title><link>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs" target="_blank">https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs&lt;/a>&lt;/p>
&lt;p>将消息从一个组件获取到另一个组件是微服务架构中最重要的部分之一。每个服务必须能够与任何其他服务异步、可靠且大规模地通信。&lt;/p>
&lt;p>这就是消息代理的用武之地。消息代理（例如 Apache Kafka、RabbitMQ 和&lt;a href="https://ably.com/topic/aws-sns-vs-sqs" target="_blank">AWS SNS/SQS&lt;/a>）为您提供一个通用接口和一组保证，而不是手动协调可能数千个微服务之间的通信。这简化了集成并更容易推理您的系统。&lt;/p></description></item><item><title>[译]HTTP 的演变 – HTTP2 深入探讨</title><link>https://blog.chensoul.cc/posts/2024/05/07/http2/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http2/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/http2" target="_blank">https://ably.com/topic/http2&lt;/a>&lt;/p>
&lt;p>可以毫不夸张地说，超文本传输协议 (HTTP) 造就了我们所熟知的互联网。 HTTP 最初是由万维网的发明者蒂姆·伯纳斯·李 (Tim Berners-Lee) 于 1989 年提出的应用程序协议。第一个记录版本 HTTP/0.9 被称为单行协议。鉴于它催生了万维网，它现在可以被描述为有史以来最伟大的俏皮话。&lt;/p></description></item><item><title>[译]Java和WebSockets：构建可靠的实时应用程序</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</guid><description>&lt;p>原文：&lt;a href="https://ably.com/topic/websockets-java" target="_blank">https://ably.com/topic/websockets-java&lt;/a>&lt;/p>
&lt;p>在全球范围内，人们对实时传输数据的需求不断增长，&lt;a href="https://ably.com/topic/websockets" target="_blank">WebSocket&lt;/a>可能是此类用例中最流行的传输协议。在 WebSocket 出现之前，“实时”网络已经存在，但它很难实现，通常速度较慢，并且是通过破解现有的网络技术来实现的，而这些技术并不是为实时应用程序设计的。 WebSocket 协议为真正的实时网络铺平了道路。&lt;/p></description></item><item><title>[译]WebSocket API和协议说明</title><link>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</guid><description>&lt;p>原文地址：&lt;a href="https://ably.com/topic/websockets" target="_blank">https://ably.com/topic/websockets&lt;/a>&lt;/p>
&lt;p>WebSocket 标志着 Web 开发的转折点。 WebSocket 技术旨在以事件为驱动，并针对低延迟进行了优化，已成为许多寻求构建交互式实时数字体验以提供令人愉悦的用户体验的组织和开发人员的首选。本文探讨了与 WebSocket 相关的关键主题：&lt;/p></description></item><item><title>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websockets-vs-http" target="_blank">https://ably.com/topic/websockets-vs-http&lt;/a>&lt;/p>
&lt;p>当谈到 WebSocket 与 HTTP 时，决定使用哪一种并不总是那么明确。哪一个更好？您的应用程序应该使用哪一款？&lt;/p></description></item><item><title>[译]WebSocket与REST</title><link>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websocket-vs-rest" target="_blank">https://ably.com/topic/websocket-vs-rest&lt;/a>&lt;/p>
&lt;p>无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。&lt;/p>
&lt;p>好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。&lt;/p></description></item><item><title>[译]什么是 HTTP？</title><link>https://blog.chensoul.cc/posts/2024/05/07/http/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/http/" target="_blank">https://www.pubnub.com/guides/http/&lt;/a>&lt;/p>
&lt;h2 id="http-概述">HTTP 概述&lt;/h2>
&lt;p>HTTP，即超文本传输协议，是互联网通信的基础。它在客户端-服务器模型上运行，其中前端客户端（例如网络浏览器）通过向服务器发送HTTP请求消息来发起请求，例如请求网页（例如搜索引擎）。然后，服务器使用包含所请求资源的 HTTP 响应消息进行响应，如果资源不可用，则使用错误消息进行响应。&lt;/p></description></item><item><title>[译]什么是 OAuth？</title><link>https://blog.chensoul.cc/posts/2024/05/07/oauth/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/oauth/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/oauth/" target="_blank">https://www.pubnub.com/guides/oauth/&lt;/a>&lt;/p>
&lt;h2 id="什么是-oauth">什么是 OAuth？&lt;/h2>
&lt;p>&lt;a href="https://oauth.net/" target="_blank">OAuth（开放授权）&lt;/a>是一种开放标准授权框架，允许第三方应用程序访问用户数据，而无需用户共享其登录凭据。它为用户提供了一种安全且标准化的方式，将其在一个网站上的资源的访问权限授予另一个网站或应用程序，而无需暴露其密码。&lt;/p>
&lt;p>简单来说，OAuth 充当最终用户和他们想要授予访问权限的应用程序之间的中间人。用户不会直接向 Web 应用程序提供用户名和密码，而是会被重定向到授权服务器（例如 Google、Facebook 或 Twitter），在那里他们可以安全地验证自己的身份。经过身份验证后，用户可以授予或拒绝对其想要使用的应用程序上的数据的访问权限。&lt;/p></description></item><item><title>[译]什么是HTTP/3？</title><link>https://blog.chensoul.cc/posts/2024/05/07/http3/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http3/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/http-3/" target="_blank">https://www.pubnub.com/guides/http-3/&lt;/a>&lt;/p>
&lt;h2 id="什么是-http3">什么是 HTTP/3？&lt;/h2>
&lt;p>HTTP/3（或 HTTP-over-QUIC）是超文本传输协议 ( &lt;a href="https://www.pubnub.com/guides/http/" target="_blank">HTTP&lt;/a> ) 的第三个主要版本。它是用于 Web 浏览器和服务器之间通信的应用层协议。 HTTP/3 旨在提高 Web 通信的性能和安全性。&lt;/p></description></item><item><title>[译]什么是HTTP流式传输？</title><link>https://blog.chensoul.cc/posts/2024/05/07/http-streaming/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http-streaming/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/http-streaming/" target="_blank">https://www.pubnub.com/guides/http-streaming/&lt;/a>&lt;/p>
&lt;h2 id="什么是-http-流式传输">什么是 HTTP 流式传输？&lt;/h2>
&lt;p>HTTP 流，也称为基于 HTTP 的流或 HTTP 实时流，是一种用于通过 Internet 传送实时多媒体内容（例如音频或视频）的技术。该协议允许从服务器到客户端设备的连续数据传输，使用户能够消费媒体内容而无需完整的文件下载。&lt;/p></description></item><item><title>[译]什么是Socket.IO？</title><link>https://blog.chensoul.cc/posts/2024/05/07/socket-io/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/socket-io/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/socket-io/" target="_blank">https://www.pubnub.com/guides/socket-io/&lt;/a>&lt;/p>
&lt;h1 id="什么是socketio">什么是Socket.IO？&lt;/h1>
&lt;p>&lt;a href="https://socket.io/" target="_blank">Socket.IO&lt;/a>是一个开源的跨平台库，它提供客户端和服务器之间基于事件的&lt;a href="https://www.geeksforgeeks.org/transmission-modes-computer-networks/" target="_blank">全双工双向通信&lt;/a>。它基于 WebSocket 协议构建，提供附加功能，例如自动重新连接以及在无法使用 &lt;a href="https://www.pubnub.com/guides/what-are-websockets-and-when-should-you-use-them/" target="_blank">WebSocket时回退到&lt;/a>&lt;a href="https://www.pubnub.com/blog/http-long-polling/" target="_blank">HTTP 长轮询。&lt;/a>&lt;/p></description></item><item><title>[译]什么是WebSocket？</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/websockets/" target="_blank">https://www.pubnub.com/guides/websockets/&lt;/a>&lt;/p>
&lt;h2 id="什么是-websocket">什么是 WebSocket？&lt;/h2>
&lt;p>&lt;a href="https://www.pubnub.com/guides/tcp-ip/" target="_blank">WebSocket 是一种通过单个TCP&lt;/a>连接提供全双工通信通道的通信协议。它支持客户端和服务器之间的实时、事件驱动的连接。&lt;/p></description></item><item><title>[译]什么是长轮询？</title><link>https://blog.chensoul.cc/posts/2024/05/07/long-polling/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/long-polling/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/long-polling/" target="_blank">https://www.pubnub.com/guides/long-polling/&lt;/a>&lt;/p>
&lt;h2 id="什么是长轮询">什么是长轮询？&lt;/h2>
&lt;p>长轮询用于实时 Web 应用程序，以实现客户端和 Web 服务器之间近乎即时的通信。它在实时更新至关重要的聊天和消息应用程序中特别有用。&lt;/p></description></item><item><title>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websockets-kafka" target="_blank">https://ably.com/topic/websockets-kafka&lt;/a>&lt;/p>
&lt;p>Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。&lt;/p></description></item><item><title>ThingsBoard的领域模型</title><link>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</guid><description>&lt;p>ThingsBoard是一个开源的物联网平台，用于管理和监控物联网设备和数据。它提供了一个可扩展的架构，可以连接各种设备，并实时收集、处理和分析设备生成的数据。&lt;/p>
&lt;h2 id="领域模型">领域模型&lt;/h2>
&lt;p>在ThingsBoard中，领域模型是一个关键概念，用于描述物联网系统中的物理实体、属性和行为。以下是ThingsBoard中的主要领域模型组件：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>租户（Tenant）：租户是ThingsBoard中的顶级组织单位。它代表了一个独立的实体，可以是一个用户、组织或公司。租户拥有和管理自己的设备、客户、规则和仪表板等资源。租户之间的数据和配置是相互隔离的，每个租户都有自己的独立环境。租户由系统管理员创建和管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>租户配置（TenantProfile）：用于定义租户级别的配置和属性。&lt;/p></description></item><item><title>All things about ThingsBoard</title><link>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</link><pubDate>Mon, 29 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</guid><description>&lt;p>thingsboard 是一款乌克兰团队基于java语言研发的开源物联网框架，开源的是ce版，企业版需要购买授权且无源码。&lt;/p>
&lt;p>官方网站：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Thingsboard 官网：&lt;a href="https://thingsboard.io/" target="_blank">https://thingsboard.io/&lt;/a>&lt;/p></description></item><item><title>TBMQ测试和源码分析</title><link>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</link><pubDate>Sun, 28 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</guid><description>&lt;ol>
&lt;li>
&lt;p>启动 TBMQ 程序，浏览器访问 http://localhost:8083，创建一个 Application，Credentials Type 为 BASIC，客户端 ID、用户名和密码均设置为 tbmq_app&lt;/p></description></item><item><title>ThingsBoard TBMQ本地和通过Docker运行</title><link>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</guid><description>&lt;h2 id="docker-compose-运行">docker-compose 运行&lt;/h2>
&lt;p>参考：&lt;a href="https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/" target="_blank">https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>下载源代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd tbmq/docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建逻辑卷并执行安装程序&lt;/p></description></item><item><title>All things about MicroProfile</title><link>https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/</link><pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/</guid><description>&lt;p>最近在一些开源项目中看到了 MicroProfile ，于是在网上查阅了相关资料加深对 MicroProfile 的理解，并做了笔记形成此文。&lt;/p></description></item><item><title>JHipster安装和介绍</title><link>https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/</link><pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/</guid><description>&lt;p>JHipster 是一个开发平台，可以快速生成，开发和部署现代 Web 应用程序+微服务架构。&lt;/p>
&lt;p>JHipster 或者称 Java Hipster，是一个应用代码产生器，能够创建 Spring Boot/Spring Cloud + React/VueJs/AngularJS 的应用。使用 JHipster，首先你要配置好 Java 、Git 以及 Maven 或者 Gradle 的环境，然后通过 NodeJs 管理工具安装 JHipster 。&lt;/p></description></item><item><title>Java设计模式：Circuit Breaker</title><link>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</link><pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/circuit-breaker/" target="_blank">Circuit Breaker&lt;/a> 断路器模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Chain</title><link>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/chain/" target="_blank">Chain&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Callback</title><link>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</link><pubDate>Fri, 13 Oct 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/callback/" target="_blank">Callback&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Caching</title><link>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</link><pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/caching/" target="_blank">Caching&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Bytecode</title><link>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/bytecode/" target="_blank">Bytecode&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Builder</title><link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/builder/" target="_blank">Builder&lt;/a> 构造器模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Business Delegate</title><link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/business-delegate/" target="_blank">Business Delegate&lt;/a> 业务委托模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Bridge</title><link>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/bridge/" target="_blank">Bridge&lt;/a> 桥接模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Balking</title><link>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/balking/" target="_blank">Balking&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>《Effective Java 3》笔记17：减少可变性</title><link>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</guid><description>&lt;p>本文是 《Effective Java 3》第四章《类和接口》的学习笔记：减少可变性。&lt;/p>
&lt;h2 id="原文">原文&lt;/h2>
&lt;p>不可变类是实例不能被修改的类。每个实例中包含的所有信息在对象的生命周期内都是固定的，因此永远不会观察到任何更改。Java 库包含许多不可变的类，包括 String、基本类型的包装类、BigInteger 和 BigDecimal。这么做有很好的理由：不可变类比可变类更容易设计、实现和使用。它们不太容易出错，而且更安全。&lt;/p></description></item><item><title>Java设计模式：Async Method Invocation</title><link>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</guid><description>&lt;p>本文主要介绍 Async Method Invocation 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：API Gateway</title><link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</link><pubDate>Sun, 13 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</guid><description>&lt;p>本文主要介绍 API Gateway 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Arrange/Act/Assert</title><link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</link><pubDate>Sun, 13 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</guid><description>&lt;p>本文主要介绍 Arrange/Act/Assert 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Ambassador</title><link>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</guid><description>&lt;p>本文主要介绍 Ambassador 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Aggregator Microservices</title><link>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</guid><description>&lt;p>本文主要介绍 Aggregator Microservices 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>《Effective Java 3》笔记15：尽量减少类和成员的可访问性</title><link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid><description>&lt;p>本文是 《Effective Java 3》第四章《类和接口》的学习笔记：尽量减少类和成员的可访问性。&lt;/p>
&lt;p>类和接口是 Java 编程语言的核心。它们是抽象的基本单位。该语言提供了许多强大的元素，你可以使用它们来设计类和接口。&lt;/p></description></item><item><title>《Effective Java 3》笔记16：在公共类中，使用访问器方法，而不是公共字段</title><link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid><description>&lt;p>本文是 《Effective Java 3》第四章《类和接口》的学习笔记：在公共类中，使用访问器方法，而不是公共字段。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>与其直接将类的内部字段公开为公共字段，推荐使用访问器方法（也称为 getter 和 setter）来访问和修改对象的状态。这样可以使类对其内部表示保持控制，并为类的客户端提供一种抽象程度。&lt;/p></description></item><item><title>Java设计模式：Adapter</title><link>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</link><pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</guid><description>&lt;p>本文主要介绍 Adapter 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Visitor</title><link>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</link><pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</guid><description>&lt;p>本文主要介绍 Visitor 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Acyclic Visitor</title><link>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</guid><description>&lt;p>本文主要介绍 Acyclic Visitor 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>《Effective Java 3》笔记12：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title><link>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：始终覆盖 toString 方法。&lt;/p></description></item><item><title>《Effective Java 3》笔记13：明智地覆盖 clone 方法</title><link>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：明智地覆盖 clone 方法。&lt;/p></description></item><item><title>《Effective Java 3》笔记14：考虑实现 Comparable 接口</title><link>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。&lt;/p></description></item><item><title>Java设计模式：Active Object</title><link>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</guid><description>&lt;p>本文主要介绍 Active Object 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title><link>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</link><pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。&lt;/p></description></item><item><title>Java设计模式：Abstract Document</title><link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</guid><description>&lt;p>本文主要介绍 Abstract Document 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Abstract Factory</title><link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</guid><description>&lt;p>本文主要介绍 Abstract Factory 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>JSR 166规范</title><link>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</guid><description>&lt;h2 id="jsr-介绍">JSR 介绍&lt;/h2>
&lt;p>JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=335" target="_blank">JSR 335&lt;/a>，新的日期和时间 API 对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=310" target="_blank">JSR 310&lt;/a>。&lt;/p></description></item><item><title>《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定</title><link>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</link><pubDate>Wed, 17 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：覆盖 equals 方法时应遵守的约定。&lt;/p></description></item><item><title>《Effective Java 3》笔记8：避免使用终结器和清除器</title><link>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</link><pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：避免使用终结器和清除器。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>&lt;strong>终结器是不可预测的、常常是危险的，通常也是不必要的。&lt;/strong> 它们的使用可能导致不稳定的行为、低效率和可移植性问题。终结器有一些有效的用途，我们稍后会介绍，但通常情况下应该避免使用它们。从 Java 9 开始，终结器已经被弃用，但它们仍然被 Java 库使用。Java 9 中终结器的替代品是清除器。 &lt;strong>清除器的危险比终结器小，但仍然不可预测、缓慢，而且通常是不必要的。&lt;/strong>&lt;/p></description></item><item><title>《Effective Java 3》笔记9：使用 try-with-resources 优于 try-finally</title><link>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</link><pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：使用 try-with-resources 优于 try-finally。&lt;/p></description></item><item><title>《Effective Java 3》笔记4：用私有构造函数使类不可实例化</title><link>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</link><pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：用私有构造函数使类不可实例化。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>使用私有构造函数强制实现不可实例化的主要原因是防止类被意外地实例化，以使代码更加健壮和可靠。在某些情况下，我们只需要使用类中的静态方法和静态字段，而不需要创建该类的实例。如果类中没有显式地定义私有构造函数，Java 编译器将会自动为该类生成一个默认的公共构造函数，这意味着该类可以在其他类中被实例化。如果这不是我们想要的，为了防止其他人意外地实例化我们的类，我们可以将构造函数设置为私有。&lt;/p></description></item><item><title>《Effective Java 3》笔记7：排除过时的对象引用</title><link>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</link><pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>&amp;ldquo;Eliminate obsolete object references&amp;rdquo; 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。&lt;/p></description></item><item><title>《Effective Java 3》笔记6：避免创建不必要的对象</title><link>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：避免创建不必要的对象。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>创建对象时，经常会复用对象。如果对象是不可变的，那么它总是可以被复用的。&lt;/p></description></item><item><title>《Effective Java 3》笔记5：依赖注入优于硬编码资源</title><link>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</link><pubDate>Mon, 17 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p></description></item><item><title>《Effective Java 3》笔记3：使用私有构造函数或枚举类型创建单例</title><link>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</link><pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p></description></item><item><title>《Effective Java 3》笔记1：静态工厂方法代替构造函数</title><link>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p></description></item><item><title>《Effective Java 3》笔记2：使用构造器代替构造方法</title><link>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p></description></item></channel></rss>