<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | ChenSoul</title>
<meta name=keywords content><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/categories/java/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/categories/java/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/categories/java/><meta name=twitter:title content="Java | ChenSoul"><meta name=twitter:description content><meta property="og:title" content="Java | ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/categories/java/"><meta property="og:site_name" content="ChenSoul"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-categories kind-term layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类 class=active>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><header class=page-header><h1>category: Java</h1><div class=inline-links><span><a href=https://blog.chensoul.cc/categories/java/index.xml target=_blank>RSS</a></span></div></header><article class="post-entry tag-entry"><header class=entry-header><h2>[译]JMS 点对点消息传递的实际应用</h2></header><section class=entry-content><p>点对点系统使用队列进行消息传递。客户端将消息发送到特定队列，特定订阅者监听或接收来自该队列的消息。在 JMS 点对点消息传递系统中，队列用于处理单个发送者和单个消费者。确保您已经阅读了有关JMS 消息模型以及如何在 JMS 中发送和接收消息的先前教程。
使用队列进行 PTP 消息传送 您现在知道点对点消息传递完全是利用队列。JMS 提供javax.jms.Queue表示队列对象的功能。我将利用 JMS 2.0 API 来javax.jms.JMSProducer发送javax.jms.JMSConsumer和接收消息。
我已经向您展示了多个使用 JMS 队列的示例。以下代码表示在 JMS 2.0 API 中使用 JMS 队列的步骤，只是为了再次刷新一下概念。
package lab00.simple.helloworld; import javax.jms.*; import javax.naming.InitialContext; import javax.naming.NamingException; public class TestHelloWorld { public static void main(String[] args) { ConnectionFactory connectionFactory = null; Queue queue = null; try { InitialContext initialContext = new InitialContext(); //Step-1 Create ConnectionFactory connectionFactory = (ConnectionFactory) initialContext.lookup("jms/__defaultConnectionFactory"); //Step-2 Get the Destination queue = (Queue) initialContext.lookup("jms/PTPQueue"); } catch (NamingException e) { e.printStackTrace(); } //Step-3 Create J MSContext try (JMSContext jmsContext = connectionFactory.createContext()) { //Step-4a Create a Text Message and send TextMessage textMessage = jmsContext.createTextMessage("Message using JMS 2....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>4 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 点对点消息传递的实际应用" href=https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]JMS 消息优先级</h2></header><section class=entry-content><p>我们将通过示例详细讨论 JMS 消息优先级。每条消息的标头字段代表其优先级。我在消息模型教程JMSPriority中讨论过消息优先级。
JMS 有 10 个优先级，从 0 到 9。0 是最低优先级，9 是最高优先级。根据 JMS 标准，优先级为 0-4 的消息为正常优先级，优先级为 5-9 的消息被视为加急优先级。
JMS 优先级示例 在下面的例子中，具有不同优先级的消息被发送给接收方。但是，优先级最高的消息（9）最先到达，同样，优先级最低的消息最后到达。
package lab01.message.model; import labxx.common.settings.CommonSettings; import javax.jms.*; public class MessagePriorityTest { public static void main(String[] args) throws JMSException { ConnectionFactory connectionFactory = CommonSettings.getConnectionFactory(); Queue queue = CommonSettings.getDefaultQueue(); try (JMSContext jmsContext = connectionFactory.createContext()) { JMSProducer producer = jmsContext.createProducer(); String[] messages = {"Msg One", "Msg two", "Msg three", "Msg four", "Msg five"}; producer.setPriority(0).send(queue, messages[0]); producer.setPriority(9).send(queue, messages[1]); producer.setPriority(4).send(queue, messages[2]); producer.setPriority(2).send(queue, messages[3]); producer.send(queue, messages[4]); JMSConsumer consumer = jmsContext.createConsumer(queue); for (int i = 0; i &lt; messages.length; i++) { Message message = consumer.receive(); System.out.println("Priority: " + message....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 消息优先级" href=https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]JMS 消息模型</h2></header><section class=entry-content><p>消息是 JMS 的核心，无论是事件还是业务数据。消息由标头、自定义属性和正文组成。这是您将在 JMS 消息模型（JMS 消息剖析）中学习的内容。
JMS 消息由 Header、Properties 和 Body（Payload）组成。我们将在下面详细讨论它们。
消息 头是有关消息的元数据。消息头有两种类型：开发人员设置的头和 JMS 提供商设置的头。
消息属性
是用于向消息添加可选标头字段的附加标头字段。属性字段基本上有 3 种类型。
应用程序特定属性 - 允许设置应用程序特定的自定义标题。 标准属性 – JMS 定义的标准属性。 JMS-Provider 特定属性。 消息主体是发送到目的地的有效负载。JMS 支持多种类型（格式）的有效负载。
1. 消息头字段 一些消息头由程序员设置，一些由 JMS 提供商内部设置。消息头是 JMS 消息模型中首先要探讨的内容。
1.1. JMS 目标 此标头包含消息发送的目的地。收到消息时，目的地必须与分配的值相等。
javax.jms.Message#setJMSDestination(Destination) javax.jms.Message#getJMSDestination() 1.2. JMS交付模式 JMS 支持PERSISTENT和 NON_PERSISTENT 消息传输模式。此标头表示传递模式。
javax.jms.Message#setJMSDeliveryMode（int） javax.jms.Message#getJMSDeliveryMode() javax.jms.DeliveryMode 1.3. JMS消息ID 此标头字段值唯一标识提供商发送的每个消息。它是一个字符串值。程序员不需要处理它。
javax.jms.Message#getJMSMessageID() javax.jms.Message#setJMSMessageID(String) javax.jms.MessageProducer#setDisableMessageID(boolean) 1.4. JMS时间戳 消息被交给提供商处理的时间戳。
javax.jms.Message#setJMSTimestamp(long) javax.jms.MessageProducer#setDisableMessageTimestamp(boolean) 1.5. JMS重新交付 当客户端收到带有此标头的消息时，很可能该消息已在过去送达，但未收到确认。程序员无法更改此值。
javax.jms.Message#setJMSRedelivered（boolean） javax.jms.Message#getJMSRedelivered() 1.6. JMSExpiration – 设置消息生存时间 JMS 通过添加生存时间值来为每条消息设置过期值。生存时间值在方法中指定send()。如果生存时间值设置为零，则 JMSExpiration 标头值也会变为零，这意味着消息不会过期。
jmsProducer.setTimeToLive(long timeToLive); javax.jms.Message#setJMSExpiration(long) javax.jms.Message#getJMSExpiration() 下面的示例演示了如何使用producer.setTimeToLive()方法来设置消息过期时间。正如您在输出中看到的那样，消息的生命周期只有 2 秒，5 秒后它将从队列中删除。因此，消费者不会收到该消息并记录 NullPointer 异常。
package lab01.message.model; import labxx.common.settings.CommonSettings; import javax.jms.*; public class MessageExpirationTest { public static void main(String[] args) throws InterruptedException, JMSException { ConnectionFactory connectionFactory = CommonSettings....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 消息模型" href=https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]在 JMS 中发送和接收消息</h2></header><section class=entry-content><p>您将了解 JMS 架构，学习如何在 JMS 中发送和接收消息。我将介绍管理对象、JMS 1.1 API 和 JMS 2.0 API。我们还将看到与 JMS 1.1 API 相比，JMS 2.0 API 的使用有多么简单。在继续学习本课程之前，请确保您已完成 JMS 设置。如果您是初学者，请确保您已了解JMS 的基础知识。
请记住，当您使用 JMS 时，需要在 JMS 提供程序中配置ConnectionFactory和Destination对象（队列和主题）。这就是它们被称为受管理对象的原因。 您通常会执行 JNDI 查找以获取ConnectionFactory，然后从 ConnectionFactory获取物理Connection对象。 获得连接后，您将需要打开一个会话来发送/接收消息。 JMS API 版本 您需要了解基本上有两组用于发送和接收消息的主要接口。
JMS 1.1 – 也称为经典 API，这是遗留 API。 JMS 2.0 – 被称为简化 API，提供更简单的 API，需要更少的接口。这正是您在新项目中需要使用的。 通用接口 队列– 用于点对点消息传递的受管理对象。单个生产者和单个接收者。 主题– 用于发布/订阅消息的受管对象。单个生产者，但多个接收者。 目的地– 队列和主题的共同超类型。 Message、ByteMessage、MapMessage、ObjectMessage、StreamMessage和StreamMessage – 表示发送到 JMS 提供程序或从 JMS 提供程序接收的消息类型。 使用 JMS 发送和接收消息 我们将看到使用 JMS 1.1（经典 API）和 JMS 2.0（简化 API）发送和接收文本消息的简单示例。我建议使用 JMS 2.0 API，本教程将对此进行更多讨论。但是，如果您碰巧使用的是旧版应用程序，最好也关注一下旧版 API。
使用 JMS 1.1 开发客户端 下面是一个示例，演示了如何使用经典 API。它创建一条简单的文本消息并将其发送到队列。然后，消息消费者从同一队列读取同一条消息。
package lab00.classic.helloworld; import javax.jms.*; import javax.naming.InitialContext; import javax.naming.NamingException; public class TestHelloWorldQueue { public static void main(String[] args) throws NamingException { InitialContext initialContext = null; try { initialContext = new InitialContext(); //Step-1 Create ConnectionFactory ConnectionFactory connectionFactory = (ConnectionFactory) initialContext....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]在 JMS 中发送和接收消息" href=https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]为 JMS 安装和设置 Glassfish</h2></header><section class=entry-content><p>在本文中，我们将为 JMS 2.0 设置 Glassfish，创建一个 Java 项目并添加必要的依赖项。
先决条件 请确保您的系统上安装了以下工具。
已安装JDK 8。尚未使用任何更高版本的 Java 进行测试。 Eclipse、STS 或 IntelliJ IDEA。 Glassfish 安装和设置步骤 步骤 1，下载 Glassfish 并解压缩 您需要从 Glassfish GitHub repo下载开源 Glassfish 版本，然后将其解压缩到我们将运行服务器的文件夹中。我使用的是带有 JDK 8 的 GlassFish 5.0。
步骤2，启动服务器 cd glassfish5\glassfish\bin\从终端导航到解压的文件夹内以启动服务器。
sh startserv如果您使用的是 Mac 或 Linux，请从终端运行。或者，startserv.bat如果您使用的是 Windows，请运行。让服务器有时间进行引导。
步骤 3，打开管理控制台 完成上述步骤后，接下来访问管理控制台http://localhost:4848。
现在，查看“ JMS 资源/连接工厂”，您可以看到 Glassfish 为您创建的默认 JMS 工厂。我们将jms/__defaultConnectionFactory在整个课程中使用它。
步骤 4，创建 JMS 目标资源 默认情况下，Glassfish 管理控制台上不会列出任何目标资源。请记住，您需要先创建这些资源，然后编写代码以通过这些资源发送或接收消息。
点击新建按钮添加新的目标资源，我们将创建 2 个Queue和一个Topic供示例工作，如下所示。
创建队列 1，其 JNDI 名称为jms/PTPQueue，目标名称为PTPQueue。 创建队列2，其JNDI名称为jms/ReplyQueue，目标名称为ReplyQueue。 然后，创建 pub-sub 主题，其 JNDI 名称为jms/PubSubTopic，目标名称为PubSubTopic。 理想情况下，目标资源和 ConnectionFactory 由服务器管理员创建。作为开发人员，您无需在现实世界中创建它们。但出于开发或测试目的，您需要在本地计算机上创建它们。
只是重申上面的引述。无论您使用哪个 JMS 提供程序，它们始终需要提供ConnectionFactory和Destination 。这意味着在我们编写 Java 代码之前，需要在 JMS 提供程序中配置它们。您将在本教程的后半部分详细了解它们。有一些例外，例如 ActiveMQ，允许在运行时创建Destination。
一旦创建目标资源，JMS 目标资源将如下面的屏幕截图所示。
配置 IDE 的步骤 所有代码示例均可在 GitHub 上下载。或者，您可以按照以下步骤创建一个具有下面列出的依赖项的 Maven 项目。
步骤 1，创建一个 Maven 项目 在你的 IDE（Eclipse、STS 或 IntelliJ）中创建一个 maven 项目&lt;packaging>jar&lt;/packaging> 打开pom....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]为 JMS 安装和设置 Glassfish" href=https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]JMS介绍 – Java消息服务</h2></header><section class=entry-content><p>MS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。这是一个 JMS 介绍教程，为您提供消息传递和 JMS 的简要概述。您将了解使用 JMS 的优势以及 JMS 中的不同消息传递模型。
什么是消息传递？ 消息传递是跨各种应用程序或服务交换业务数据的过程。消息通常是其他应用程序或服务使用的异步请求、响应、报告或事件。这些消息包含重要信息。
消息传递为微服务架构提供了可扩展性。消息传递也传统上用于面向服务的架构，以在它们之间建立异步且可靠的通信。
消息系统也称为面向消息的中间件产品。目前有多种消息中间件可供选择，例如 ActiveMQ、RabbitMQ、ActiveMQ Artemis、Apache Kafka、应用服务器（Glassfish、Wildfly、WebsphereMQ）等。
使用消息中间件的优点 可靠性– 消息中间件保证交付。如果消费者因某种原因宕机，消息系统会存储消息，直到其再次启动。 异步– JMS 是异步的，发送者和接收者不需要互相等待。 易于集成– 多个应用程序可以用不同的编程语言编写或运行在不同的服务器上。只要它们使用相同的协议，就可以使用消息中间件在它们之间建立通信。 可扩展性——消息传递有助于向多个接收者广播，从而有助于实现可扩展性。 灵活性——您可以为不同的消息分配不同的协议，这使您在设计架构时具有很大的灵活性。 什么是 JMS（Java 消息服务）？ 目前有几种企业消息中间件（面向消息的中间件）产品，如 TIBCO MQ、Apache ActiveMQ、Apache Kafka、RabbitMQ、ActiveMQ Artemis、IBM MQ 等。
JMS 提供了标准的 Java API，这意味着 Java 程序可以创建、发送、接收和读取企业消息系统的消息。我们将探讨 JMS 1.x 和 2.0 API 标准。
并非所有企业消息中间件都实现 JMS 标准。实现 JMS 标准的中间件称为 JMS 提供程序。其中包括 Apache ActiveMQ、Apache ActiveMQ Artem、Oracle WebLogic Server、Glassfish、IBM MQ、Jboss Wildfly、Apache Qpid 等。无论您使用哪种实现，如果您坚持 JMS 标准，切换供应商都很简单。
JMS 不可互操作，这意味着它主要用于用 Java 或 JVM 语言编写的应用程序。如果您想使用具有更好互操作性支持的消息传递协议（可以在 NodeJS、Python、C# 等中工作），请查看AMQP（高级消息队列协议），例如RabbitMQ。
JMS 标准的局限性 JMS 标准不包括以下功能，因为 JMS 仅用于发送和接收消息。
负载平衡/容错 错误/建议通知 JMS 提供程序的管理 API 安全 没有消息类型存储库定义 JMS 中的消息传递模型 JMS 支持两种主要的消息传递样式，如下所示。作为 JMS 介绍的一部分，我们在此仅讨论这些类型，本教程的后面部分将通过几个示例介绍每种类型。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS介绍 – Java消息服务" href=https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>将 Maven 站点发布到 GitHub Pages</h2></header><section class=entry-content><p>本文源代码：https://github.com/chensoul/maven-site-github-example/ 。
创建 Java Maven 项目 让我们使用 Maven 创建一个简单的 Java 项目
mvn archetype:generate \ -DgroupId=com.mycompany.app \ -DartifactId=maven-site-github-example \ -DarchetypeArtifactId=maven-archetype-quickstart \ -DarchetypeVersion=1.4 \ -DinteractiveMode=false 这将创建包含 Maven 项目的my-app文件夹。让我们进入该文件夹并确保它编译正常：
cd maven-site-github-example mvn clean verify 我们还可以生成该项目的站点：
mvn clean site 该站点将在target/site文件夹中生成，可以使用浏览器打开；例如，让我们打开它的 index.html：
chrome target/site/index.html 创建 github 项目 在你的 github 上创建一个项目 maven-site-github-example，然后在本地的 maven-site-github-example 目录提交代码：
echo "# maven-site-github-example" >> README.md git init git add . git commit -m "first commit" git branch -M main git remote add origin git@github.com:chensoul/maven-site-github-example.git git push -u origin main GitHub Page 设置 现在我们必须在 Git 存储库上创建 gh-pages分支。
git checkout --orphan gh-pages rm .git/index ; git clean -fdx echo "It works" > index.html git add ....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-18</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/maven/>Maven</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to 将 Maven 站点发布到 GitHub Pages" href=https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Spring Boot集成SpringDoc生成Api文档</h2></header><section class=entry-content><p>以下以 Maven 为例介绍 Spring Boot集成SpringDoc生成Api文档。
添加依赖 &lt;dependency> &lt;groupId>org.springdoc&lt;/groupId> &lt;artifactId>springdoc-openapi-starter-webmvc-ui&lt;/artifactId> &lt;/dependency> 配置 annotationProcessor，实现通过 javadoc 生成文档。 每个 maven 模块都需要配置：
&lt;properties> &lt;therapi-runtime-javadoc.version>0.15.0&lt;/therapi-runtime-javadoc.version> &lt;maven-compiler-plugin.version>3.13.0&lt;/maven-compiler-plugin.version> &lt;/properties> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>${maven-compiler-plugin.version}&lt;/version> &lt;configuration> &lt;annotationProcessorPaths> &lt;!-- https://springdoc.org/#javadoc-support --> &lt;path> &lt;groupId>com.github.therapi&lt;/groupId> &lt;artifactId>therapi-runtime-javadoc-scribe&lt;/artifactId> &lt;version>${therapi-runtime-javadoc.version}&lt;/version> &lt;/path> &lt;/annotationProcessorPaths> &lt;/configuration> &lt;/plugin> 配置 spring boot 插件，生成 build.properties &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;executions> &lt;execution> &lt;goals> &lt;goal>repackage&lt;/goal> &lt;goal>build-info&lt;/goal> &lt;/goals> &lt;/execution> &lt;/executions> &lt;/plugin> 自动装配 @Configuration(proxyBeanMethods = false) @ConditionalOnProperty(name = SPRINGDOC_ENABLED, matchIfMissing = true) @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) public class SpringdocConfig { @Value("${server.port}") private String port; @Value("${openapi.prod-url:https://localhost}") private String prodUrl; @Bean public OpenAPI openAPI() { Server devServer = new Server(); devServer.setUrl("http://localhost:" + port); devServer.setDescription("Server URL in Development environment"); Server prodServer = new Server(); prodServer....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-10</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/springdoc/>Springdoc</a><a href=https://blog.chensoul.cc/tags/spring-boot/>Spring-Boot</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to Spring Boot集成SpringDoc生成Api文档" href=https://blog.chensoul.cc/posts/2024/07/10/springdoc-with-spring-boot/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>All things about OAuth</h2></header><section class=entry-content><p>OAuth 是一种开放协议，允许通过网络、移动和桌面应用程序以简单、标准的方式进行安全授权。
OAuth 2 入门 以下是一些 OAuth 2.0 指南，涵盖了理解和实现客户端和服务器所需的许多主题。
OAuth 2.0 简化版 由 Aaron Parecki 编写的*《OAuth 2.0 Simplified*》是一份专注于编写客户端的 OAuth 2.0 指南，它在入门级别上清晰地概述了规范。
角色：应用程序、API 和用户
创建应用程序
授权
：获取访问令牌
Web 服务器应用程序 单页应用程序 移动应用程序 其他的 发出经过身份验证的请求
与 OAuth 1.0 的区别
身份验证和签名 用户体验和替代授权流程 规模性能 资源
OAuth 2.0 服务器 OAuth 2.0 服务器，由Aaron Parecki编写并由Okta发布，是构建 OAuth 2.0 服务器的指南，其中包括许多不属于规范的细节。
代码和库 有多种语言的客户端和服务器库可以帮助您快速入门。
图书 您可以找到一些有关 OAuth 2.0 的优秀书籍。
咨询 寻找一位OAuth 顾问来帮助您的组织。
Spring Authorization Server Spring Authorization Server官方文档
Spring Authorization Server 配置模型
Spring Authorization Server （如何使用具有 PKCE 的单页应用程序进行身份验证-1）
Spring Authorization Server （如何使用具有 PKCE 的单页应用程序进行身份验证-2）
Spring Authorization Server相关文章</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-06-06</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/oauth2/>Oauth2</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to All things about OAuth" href=https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>JWT</h2></header><section class=entry-content><p>什么是 JWT？ JWT（JSON Web Token）是一种开放标准(RFC 7519)，用于在网络应用程序之间安全地传输信息。它被设计用于在两方之间传输声明，这些声明可以是身份验证和授权信息，也可以是任何其他类型的信息。
设计目的：不需要服务器端存储状态，安全地传递非敏感信息。
JWT 特点 可扩展性：可以在 payload 中携带任意的 JSON 数据 自包含性：所有用户相关信息都在 JWT 中，不需要依赖数据库 无状态性：服务器不需要保存会话状态，提高了系统的可扩展性 跨域支持：可以跨域传递，因为是 JSON 格式 安全性：通过签名确保数据不被篡改 JWT 组成 eyJraWQiOiJmYTNkZmZjMS0xZmQ3LTRhM2QtYTEyMC1mNjY4OWE4NDM5YjQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJjbGllbnQiLCJhdWQiOiJjbGllbnQiLCJuYmYiOjE3MTc1NDk5NDMsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MCIsImV4cCI6MTcxNzU1MDI0MywiaWF0IjoxNzE3NTQ5OTQzLCJqdGkiOiJiMjU0ZGVhMi1kMWE2LTQxNzEtYjEyYy1lNmYzYzZjMDJkMGQifQ.eRiS0H2E-h5PiDEfJikjoPGH1DCqWVt4VIzLtPoSOaIK6jBIaw0h5m-reZVUyZPNYZG68Ymhey17aZBMveirqCxN-lNcPMIGfuqMptfsD9E6Hfam6bEMgpEAOQsQ6Ruk3vGtdmjnEC2h9ZStoqT5-C6JgArwFLGgX92LXrRYz7-60n0I6EAB07u9kxc6FQKLow90RiyXi2YLur-ttOUQpecf8zHi48zRc-HLLoWAMaNddT-4hg4v0Qts4DultpxZB_Xu7DRc91G_8M6sYFSvFSVFHlcWFgKNLZqUYwepLHX2LxoXdbTLGqV9x__-J8UO0TO3TkpC2BaZAiseYcpYMw JWT 主要有以下三个部分通过 base64 加密组成:
Header（头部）：描述 JWT 的元数据，通常包含两部分信息:
声明类型，通常是 “JWT” 所使用的哈希算法，如 HMAC SHA256 或 RSA Payload（负载）：包含声明，即一些跟当前用户相关的重要信息，如用户 ID、用户角色等。
Signature（签名）：由 header 和 payload 使用密钥进行签名而组成，用于验证消息不被篡改。
HMAC_SHA256( secret, base64urlEncoding(header) + '.' + base64urlEncoding(payload) ) HMAC-SHA256 是一种基于加密哈希函数的消息认证码（HMAC）算法，是对称算法，它结合使用了 HMAC 和 SHA-256 哈希函数。
Header base64解密后：
{ "kid": "fa3dffc1-1fd7-4a3d-a120-f6689a8439b4", "alg": "RS256" } Payload 解密后：
{ "sub": "client", "aud": "client", "nbf": 1717549943, "iss": "http://localhost:8080", "exp": 1717550243, "iat": 1717549943, "jti": "b254dea2-d1a6-4171-b12c-e6f3c6c02d0d" } JWS 和 JWE JWS（JSON Web Signature）是 JSON Web Token (JWT) 规范的一个子规范，它定义了使用 JSON 数据结构表示签名或未签名的内容。
只对内容做签名，确保其不被篡改，但内容本身并没有加密。 JWS 主要包含以下三个部分:...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-06-06</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jwt/>Jwt</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to JWT" href=https://blog.chensoul.cc/posts/2024/06/06/jwt/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/categories/java/>« Prev Page</a>
<a class=next href=https://blog.chensoul.cc/categories/java/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>