<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | ChenSoul</title>
<meta name=keywords content><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/categories/java/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/categories/java/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/categories/java/><meta name=twitter:title content="Java | ChenSoul"><meta name=twitter:description content><meta property="og:title" content="Java | ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/categories/java/"><meta property="og:site_name" content="ChenSoul"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-categories kind-term layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类 class=active>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><header class=page-header><h1>category: Java</h1><div class=inline-links><span><a href=https://blog.chensoul.cc/categories/java/index.xml target=_blank>RSS</a></span></div></header><article class="post-entry tag-entry"><header class=entry-header><h2>[译]JMS 消息优先级</h2></header><section class=entry-content><p>我们将通过示例详细讨论 JMS 消息优先级。每条消息的标头字段代表其优先级。我在消息模型教程JMSPriority中讨论过消息优先级。
JMS 有 10 个优先级，从 0 到 9。0 是最低优先级，9 是最高优先级。根据 JMS 标准，优先级为 0-4 的消息为正常优先级，优先级为 5-9 的消息被视为加急优先级。
JMS 优先级示例 在下面的例子中，具有不同优先级的消息被发送给接收方。但是，优先级最高的消息（9）最先到达，同样，优先级最低的消息最后到达。
package lab01.message.model; import labxx.common.settings.CommonSettings; import javax.jms.*; public class MessagePriorityTest { public static void main(String[] args) throws JMSException { ConnectionFactory connectionFactory = CommonSettings.getConnectionFactory(); Queue queue = CommonSettings.getDefaultQueue(); try (JMSContext jmsContext = connectionFactory.createContext()) { JMSProducer producer = jmsContext.createProducer(); String[] messages = {"Msg One", "Msg two", "Msg three", "Msg four", "Msg five"}; producer.setPriority(0).send(queue, messages[0]); producer.setPriority(9).send(queue, messages[1]); producer.setPriority(4).send(queue, messages[2]); producer.setPriority(2).send(queue, messages[3]); producer.send(queue, messages[4]); JMSConsumer consumer = jmsContext.createConsumer(queue); for (int i = 0; i &lt; messages.length; i++) { Message message = consumer.receive(); System.out.println("Priority: " + message....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 消息优先级" href=https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]JMS 消息模型</h2></header><section class=entry-content><p>消息是 JMS 的核心，无论是事件还是业务数据。消息由标头、自定义属性和正文组成。这是您将在 JMS 消息模型（JMS 消息剖析）中学习的内容。
JMS 消息由 Header、Properties 和 Body（Payload）组成。我们将在下面详细讨论它们。
消息 头是有关消息的元数据。消息头有两种类型：开发人员设置的头和 JMS 提供商设置的头。
消息属性
是用于向消息添加可选标头字段的附加标头字段。属性字段基本上有 3 种类型。
应用程序特定属性 - 允许设置应用程序特定的自定义标题。 标准属性 – JMS 定义的标准属性。 JMS-Provider 特定属性。 消息主体是发送到目的地的有效负载。JMS 支持多种类型（格式）的有效负载。
1. 消息头字段 一些消息头由程序员设置，一些由 JMS 提供商内部设置。消息头是 JMS 消息模型中首先要探讨的内容。
1.1. JMS 目标 此标头包含消息发送的目的地。收到消息时，目的地必须与分配的值相等。
javax.jms.Message#setJMSDestination(Destination) javax.jms.Message#getJMSDestination() 1.2. JMS交付模式 JMS 支持PERSISTENT和 NON_PERSISTENT 消息传输模式。此标头表示传递模式。
javax.jms.Message#setJMSDeliveryMode（int） javax.jms.Message#getJMSDeliveryMode() javax.jms.DeliveryMode 1.3. JMS消息ID 此标头字段值唯一标识提供商发送的每个消息。它是一个字符串值。程序员不需要处理它。
javax.jms.Message#getJMSMessageID() javax.jms.Message#setJMSMessageID(String) javax.jms.MessageProducer#setDisableMessageID(boolean) 1.4. JMS时间戳 消息被交给提供商处理的时间戳。
javax.jms.Message#setJMSTimestamp(long) javax.jms.MessageProducer#setDisableMessageTimestamp(boolean) 1.5. JMS重新交付 当客户端收到带有此标头的消息时，很可能该消息已在过去送达，但未收到确认。程序员无法更改此值。
javax.jms.Message#setJMSRedelivered（boolean） javax.jms.Message#getJMSRedelivered() 1.6. JMSExpiration – 设置消息生存时间 JMS 通过添加生存时间值来为每条消息设置过期值。生存时间值在方法中指定send()。如果生存时间值设置为零，则 JMSExpiration 标头值也会变为零，这意味着消息不会过期。
jmsProducer.setTimeToLive(long timeToLive); javax.jms.Message#setJMSExpiration(long) javax.jms.Message#getJMSExpiration() 下面的示例演示了如何使用producer.setTimeToLive()方法来设置消息过期时间。正如您在输出中看到的那样，消息的生命周期只有 2 秒，5 秒后它将从队列中删除。因此，消费者不会收到该消息并记录 NullPointer 异常。
package lab01.message.model; import labxx.common.settings.CommonSettings; import javax.jms.*; public class MessageExpirationTest { public static void main(String[] args) throws InterruptedException, JMSException { ConnectionFactory connectionFactory = CommonSettings....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 消息模型" href=https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]在 JMS 中发送和接收消息</h2></header><section class=entry-content><p>您将了解 JMS 架构，学习如何在 JMS 中发送和接收消息。我将介绍管理对象、JMS 1.1 API 和 JMS 2.0 API。我们还将看到与 JMS 1.1 API 相比，JMS 2.0 API 的使用有多么简单。在继续学习本课程之前，请确保您已完成 JMS 设置。如果您是初学者，请确保您已了解JMS 的基础知识。
请记住，当您使用 JMS 时，需要在 JMS 提供程序中配置ConnectionFactory和Destination对象（队列和主题）。这就是它们被称为受管理对象的原因。 您通常会执行 JNDI 查找以获取ConnectionFactory，然后从 ConnectionFactory获取物理Connection对象。 获得连接后，您将需要打开一个会话来发送/接收消息。 JMS API 版本 您需要了解基本上有两组用于发送和接收消息的主要接口。
JMS 1.1 – 也称为经典 API，这是遗留 API。 JMS 2.0 – 被称为简化 API，提供更简单的 API，需要更少的接口。这正是您在新项目中需要使用的。 通用接口 队列– 用于点对点消息传递的受管理对象。单个生产者和单个接收者。 主题– 用于发布/订阅消息的受管对象。单个生产者，但多个接收者。 目的地– 队列和主题的共同超类型。 Message、ByteMessage、MapMessage、ObjectMessage、StreamMessage和StreamMessage – 表示发送到 JMS 提供程序或从 JMS 提供程序接收的消息类型。 使用 JMS 发送和接收消息 我们将看到使用 JMS 1.1（经典 API）和 JMS 2.0（简化 API）发送和接收文本消息的简单示例。我建议使用 JMS 2.0 API，本教程将对此进行更多讨论。但是，如果您碰巧使用的是旧版应用程序，最好也关注一下旧版 API。
使用 JMS 1.1 开发客户端 下面是一个示例，演示了如何使用经典 API。它创建一条简单的文本消息并将其发送到队列。然后，消息消费者从同一队列读取同一条消息。
package lab00.classic.helloworld; import javax.jms.*; import javax.naming.InitialContext; import javax.naming.NamingException; public class TestHelloWorldQueue { public static void main(String[] args) throws NamingException { InitialContext initialContext = null; try { initialContext = new InitialContext(); //Step-1 Create ConnectionFactory ConnectionFactory connectionFactory = (ConnectionFactory) initialContext....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]在 JMS 中发送和接收消息" href=https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]为 JMS 安装和设置 Glassfish</h2></header><section class=entry-content><p>在本文中，我们将为 JMS 2.0 设置 Glassfish，创建一个 Java 项目并添加必要的依赖项。
先决条件 请确保您的系统上安装了以下工具。
已安装JDK 8。尚未使用任何更高版本的 Java 进行测试。 Eclipse、STS 或 IntelliJ IDEA。 Glassfish 安装和设置步骤 步骤 1，下载 Glassfish 并解压缩 您需要从 Glassfish GitHub repo下载开源 Glassfish 版本，然后将其解压缩到我们将运行服务器的文件夹中。我使用的是带有 JDK 8 的 GlassFish 5.0。
步骤2，启动服务器 cd glassfish5\glassfish\bin\从终端导航到解压的文件夹内以启动服务器。
sh startserv如果您使用的是 Mac 或 Linux，请从终端运行。或者，startserv.bat如果您使用的是 Windows，请运行。让服务器有时间进行引导。
步骤 3，打开管理控制台 完成上述步骤后，接下来访问管理控制台http://localhost:4848。
现在，查看“ JMS 资源/连接工厂”，您可以看到 Glassfish 为您创建的默认 JMS 工厂。我们将jms/__defaultConnectionFactory在整个课程中使用它。
步骤 4，创建 JMS 目标资源 默认情况下，Glassfish 管理控制台上不会列出任何目标资源。请记住，您需要先创建这些资源，然后编写代码以通过这些资源发送或接收消息。
点击新建按钮添加新的目标资源，我们将创建 2 个Queue和一个Topic供示例工作，如下所示。
创建队列 1，其 JNDI 名称为jms/PTPQueue，目标名称为PTPQueue。 创建队列2，其JNDI名称为jms/ReplyQueue，目标名称为ReplyQueue。 然后，创建 pub-sub 主题，其 JNDI 名称为jms/PubSubTopic，目标名称为PubSubTopic。 理想情况下，目标资源和 ConnectionFactory 由服务器管理员创建。作为开发人员，您无需在现实世界中创建它们。但出于开发或测试目的，您需要在本地计算机上创建它们。
只是重申上面的引述。无论您使用哪个 JMS 提供程序，它们始终需要提供ConnectionFactory和Destination 。这意味着在我们编写 Java 代码之前，需要在 JMS 提供程序中配置它们。您将在本教程的后半部分详细了解它们。有一些例外，例如 ActiveMQ，允许在运行时创建Destination。
一旦创建目标资源，JMS 目标资源将如下面的屏幕截图所示。
配置 IDE 的步骤 所有代码示例均可在 GitHub 上下载。或者，您可以按照以下步骤创建一个具有下面列出的依赖项的 Maven 项目。
步骤 1，创建一个 Maven 项目 在你的 IDE（Eclipse、STS 或 IntelliJ）中创建一个 maven 项目&lt;packaging>jar&lt;/packaging> 打开pom....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]为 JMS 安装和设置 Glassfish" href=https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]JMS介绍 – Java消息服务</h2></header><section class=entry-content><p>MS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。这是一个 JMS 介绍教程，为您提供消息传递和 JMS 的简要概述。您将了解使用 JMS 的优势以及 JMS 中的不同消息传递模型。
什么是消息传递？ 消息传递是跨各种应用程序或服务交换业务数据的过程。消息通常是其他应用程序或服务使用的异步请求、响应、报告或事件。这些消息包含重要信息。
消息传递为微服务架构提供了可扩展性。消息传递也传统上用于面向服务的架构，以在它们之间建立异步且可靠的通信。
消息系统也称为面向消息的中间件产品。目前有多种消息中间件可供选择，例如 ActiveMQ、RabbitMQ、ActiveMQ Artemis、Apache Kafka、应用服务器（Glassfish、Wildfly、WebsphereMQ）等。
使用消息中间件的优点 可靠性– 消息中间件保证交付。如果消费者因某种原因宕机，消息系统会存储消息，直到其再次启动。 异步– JMS 是异步的，发送者和接收者不需要互相等待。 易于集成– 多个应用程序可以用不同的编程语言编写或运行在不同的服务器上。只要它们使用相同的协议，就可以使用消息中间件在它们之间建立通信。 可扩展性——消息传递有助于向多个接收者广播，从而有助于实现可扩展性。 灵活性——您可以为不同的消息分配不同的协议，这使您在设计架构时具有很大的灵活性。 什么是 JMS（Java 消息服务）？ 目前有几种企业消息中间件（面向消息的中间件）产品，如 TIBCO MQ、Apache ActiveMQ、Apache Kafka、RabbitMQ、ActiveMQ Artemis、IBM MQ 等。
JMS 提供了标准的 Java API，这意味着 Java 程序可以创建、发送、接收和读取企业消息系统的消息。我们将探讨 JMS 1.x 和 2.0 API 标准。
并非所有企业消息中间件都实现 JMS 标准。实现 JMS 标准的中间件称为 JMS 提供程序。其中包括 Apache ActiveMQ、Apache ActiveMQ Artem、Oracle WebLogic Server、Glassfish、IBM MQ、Jboss Wildfly、Apache Qpid 等。无论您使用哪种实现，如果您坚持 JMS 标准，切换供应商都很简单。
JMS 不可互操作，这意味着它主要用于用 Java 或 JVM 语言编写的应用程序。如果您想使用具有更好互操作性支持的消息传递协议（可以在 NodeJS、Python、C# 等中工作），请查看AMQP（高级消息队列协议），例如RabbitMQ。
JMS 标准的局限性 JMS 标准不包括以下功能，因为 JMS 仅用于发送和接收消息。
负载平衡/容错 错误/建议通知 JMS 提供程序的管理 API 安全 没有消息类型存储库定义 JMS 中的消息传递模型 JMS 支持两种主要的消息传递样式，如下所示。作为 JMS 介绍的一部分，我们在此仅讨论这些类型，本教程的后面部分将通过几个示例介绍每种类型。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS介绍 – Java消息服务" href=https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>将 Maven 站点发布到 GitHub Pages</h2></header><section class=entry-content><p>本文源代码：https://github.com/chensoul/maven-site-github-example/ 。
创建 Java Maven 项目 让我们使用 Maven 创建一个简单的 Java 项目
mvn archetype:generate \ -DgroupId=com.mycompany.app \ -DartifactId=maven-site-github-example \ -DarchetypeArtifactId=maven-archetype-quickstart \ -DarchetypeVersion=1.4 \ -DinteractiveMode=false 这将创建包含 Maven 项目的my-app文件夹。让我们进入该文件夹并确保它编译正常：
cd maven-site-github-example mvn clean verify 我们还可以生成该项目的站点：
mvn clean site 该站点将在target/site文件夹中生成，可以使用浏览器打开；例如，让我们打开它的 index.html：
chrome target/site/index.html 创建 github 项目 在你的 github 上创建一个项目 maven-site-github-example，然后在本地的 maven-site-github-example 目录提交代码：
echo "# maven-site-github-example" >> README.md git init git add . git commit -m "first commit" git branch -M main git remote add origin git@github.com:chensoul/maven-site-github-example.git git push -u origin main GitHub Page 设置 现在我们必须在 Git 存储库上创建 gh-pages分支。
git checkout --orphan gh-pages rm .git/index ; git clean -fdx echo "It works" > index.html git add ....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-18</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/maven/>Maven</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to 将 Maven 站点发布到 GitHub Pages" href=https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Spring Boot集成SpringDoc生成Api文档</h2></header><section class=entry-content><p>以下以 Maven 为例介绍 Spring Boot集成SpringDoc生成Api文档。
添加依赖 &lt;dependency> &lt;groupId>org.springdoc&lt;/groupId> &lt;artifactId>springdoc-openapi-starter-webmvc-ui&lt;/artifactId> &lt;/dependency> 配置 annotationProcessor，实现通过 javadoc 生成文档。 每个 maven 模块都需要配置：
&lt;properties> &lt;therapi-runtime-javadoc.version>0.15.0&lt;/therapi-runtime-javadoc.version> &lt;maven-compiler-plugin.version>3.13.0&lt;/maven-compiler-plugin.version> &lt;/properties> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>${maven-compiler-plugin.version}&lt;/version> &lt;configuration> &lt;annotationProcessorPaths> &lt;!-- https://springdoc.org/#javadoc-support --> &lt;path> &lt;groupId>com.github.therapi&lt;/groupId> &lt;artifactId>therapi-runtime-javadoc-scribe&lt;/artifactId> &lt;version>${therapi-runtime-javadoc.version}&lt;/version> &lt;/path> &lt;/annotationProcessorPaths> &lt;/configuration> &lt;/plugin> 配置 spring boot 插件，生成 build.properties &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;executions> &lt;execution> &lt;goals> &lt;goal>repackage&lt;/goal> &lt;goal>build-info&lt;/goal> &lt;/goals> &lt;/execution> &lt;/executions> &lt;/plugin> 自动装配 @Configuration(proxyBeanMethods = false) @ConditionalOnProperty(name = SPRINGDOC_ENABLED, matchIfMissing = true) @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) public class SpringdocConfig { @Value("${server.port}") private String port; @Value("${openapi.prod-url:https://localhost}") private String prodUrl; @Bean public OpenAPI openAPI() { Server devServer = new Server(); devServer.setUrl("http://localhost:" + port); devServer.setDescription("Server URL in Development environment"); Server prodServer = new Server(); prodServer....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-10</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/springdoc/>Springdoc</a><a href=https://blog.chensoul.cc/tags/spring-boot/>Spring-Boot</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to Spring Boot集成SpringDoc生成Api文档" href=https://blog.chensoul.cc/posts/2024/07/10/springdoc-with-spring-boot/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>All things about OAuth</h2></header><section class=entry-content><p>OAuth 是一种开放协议，允许通过网络、移动和桌面应用程序以简单、标准的方式进行安全授权。
OAuth 2 入门 以下是一些 OAuth 2.0 指南，涵盖了理解和实现客户端和服务器所需的许多主题。
OAuth 2.0 简化版 由 Aaron Parecki 编写的*《OAuth 2.0 Simplified*》是一份专注于编写客户端的 OAuth 2.0 指南，它在入门级别上清晰地概述了规范。
角色：应用程序、API 和用户
创建应用程序
授权
：获取访问令牌
Web 服务器应用程序 单页应用程序 移动应用程序 其他的 发出经过身份验证的请求
与 OAuth 1.0 的区别
身份验证和签名 用户体验和替代授权流程 规模性能 资源
OAuth 2.0 服务器 OAuth 2.0 服务器，由Aaron Parecki编写并由Okta发布，是构建 OAuth 2.0 服务器的指南，其中包括许多不属于规范的细节。
代码和库 有多种语言的客户端和服务器库可以帮助您快速入门。
图书 您可以找到一些有关 OAuth 2.0 的优秀书籍。
咨询 寻找一位OAuth 顾问来帮助您的组织。
Spring Authorization Server Spring Authorization Server官方文档
Spring Authorization Server 配置模型
Spring Authorization Server （如何使用具有 PKCE 的单页应用程序进行身份验证-1）
Spring Authorization Server （如何使用具有 PKCE 的单页应用程序进行身份验证-2）
Spring Authorization Server相关文章</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-06-06</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/oauth2/>Oauth2</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to All things about OAuth" href=https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>JWT</h2></header><section class=entry-content><p>什么是 JWT？ JWT（JSON Web Token）是一种开放标准(RFC 7519)，用于在网络应用程序之间安全地传输信息。它被设计用于在两方之间传输声明，这些声明可以是身份验证和授权信息，也可以是任何其他类型的信息。
设计目的：不需要服务器端存储状态，安全地传递非敏感信息。
JWT 特点 可扩展性：可以在 payload 中携带任意的 JSON 数据 自包含性：所有用户相关信息都在 JWT 中，不需要依赖数据库 无状态性：服务器不需要保存会话状态，提高了系统的可扩展性 跨域支持：可以跨域传递，因为是 JSON 格式 安全性：通过签名确保数据不被篡改 JWT 组成 eyJraWQiOiJmYTNkZmZjMS0xZmQ3LTRhM2QtYTEyMC1mNjY4OWE4NDM5YjQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJjbGllbnQiLCJhdWQiOiJjbGllbnQiLCJuYmYiOjE3MTc1NDk5NDMsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MCIsImV4cCI6MTcxNzU1MDI0MywiaWF0IjoxNzE3NTQ5OTQzLCJqdGkiOiJiMjU0ZGVhMi1kMWE2LTQxNzEtYjEyYy1lNmYzYzZjMDJkMGQifQ.eRiS0H2E-h5PiDEfJikjoPGH1DCqWVt4VIzLtPoSOaIK6jBIaw0h5m-reZVUyZPNYZG68Ymhey17aZBMveirqCxN-lNcPMIGfuqMptfsD9E6Hfam6bEMgpEAOQsQ6Ruk3vGtdmjnEC2h9ZStoqT5-C6JgArwFLGgX92LXrRYz7-60n0I6EAB07u9kxc6FQKLow90RiyXi2YLur-ttOUQpecf8zHi48zRc-HLLoWAMaNddT-4hg4v0Qts4DultpxZB_Xu7DRc91G_8M6sYFSvFSVFHlcWFgKNLZqUYwepLHX2LxoXdbTLGqV9x__-J8UO0TO3TkpC2BaZAiseYcpYMw JWT 主要有以下三个部分通过 base64 加密组成:
Header（头部）：描述 JWT 的元数据，通常包含两部分信息:
声明类型，通常是 “JWT” 所使用的哈希算法，如 HMAC SHA256 或 RSA Payload（负载）：包含声明，即一些跟当前用户相关的重要信息，如用户 ID、用户角色等。
Signature（签名）：由 header 和 payload 使用密钥进行签名而组成，用于验证消息不被篡改。
HMAC_SHA256( secret, base64urlEncoding(header) + '.' + base64urlEncoding(payload) ) HMAC-SHA256 是一种基于加密哈希函数的消息认证码（HMAC）算法，是对称算法，它结合使用了 HMAC 和 SHA-256 哈希函数。
Header base64解密后：
{ "kid": "fa3dffc1-1fd7-4a3d-a120-f6689a8439b4", "alg": "RS256" } Payload 解密后：
{ "sub": "client", "aud": "client", "nbf": 1717549943, "iss": "http://localhost:8080", "exp": 1717550243, "iat": 1717549943, "jti": "b254dea2-d1a6-4171-b12c-e6f3c6c02d0d" } JWS 和 JWE JWS（JSON Web Signature）是 JSON Web Token (JWT) 规范的一个子规范，它定义了使用 JSON 数据结构表示签名或未签名的内容。
只对内容做签名，确保其不被篡改，但内容本身并没有加密。 JWS 主要包含以下三个部分:...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-06-06</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jwt/>Jwt</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to JWT" href=https://blog.chensoul.cc/posts/2024/06/06/jwt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>OAuth2和OIDC区别</h2></header><section class=entry-content><p>认证和授权 认证 (Authentication)：
认证是验证用户、设备或系统身份的过程。 常见的认证方式包括用户名/密码、生物特征(如指纹、人脸)、单点登录(SSO)等。 认证确保只有被授权的实体才能访问系统或资源。 授权 (Authorization)：
授权是确定已认证的实体被允许执行哪些操作或访问哪些资源的过程。 授权通常基于预定义的策略和规则，如角色、权限、访问控制列表(ACL)等。 授权决定了经过身份验证的实体可以执行的操作和访问的资源。 认证和授权的关系：
认证是先决条件，在授权之前必须先完成用户或实体的身份验证。 认证确保只有合法的实体可以访问系统，授权则决定了这些实体可以执行哪些操作。 认证和授权通常结合使用，共同构成完整的访问控制机制。 在实际应用中，认证和授权通常遵循以下流程:
用户或客户端提供身份凭证进行认证。 系统验证用户或客户端的身份，确认其身份有效。 根据已验证的身份，授予用户或客户端相应的访问权限和操作权限。 用户或客户端可以在授权范围内执行操作和访问资源。 OIDC OAuth 2.0 代表开放授权，是一种标准，旨在代表用户提供对资源的同意访问，而无需共享用户的凭据。OAuth 2.0 是一种授权协议，而不是身份验证协议，它主要被设计为授予对一组资源（例如远程 API 或用户数据）的访问权限的一种方式。
OAuth 2.0 仅用于授权，用于授予从一个应用程序到另一个应用程序的数据和功能的访问权限。OpenID Connect (OIDC) 是一个位于 OAuth 2.0 之上的薄层，它添加了有关登录人员的登录和个人资料信息。
​ 图片来自Azure 文档
OIDC 的工作原理 授权码流程 要验证用户身份，应用程序首先将用户的浏览器重定向到 OpenID 提供商。OpenID 提供商验证用户身份，并使用授权码将用户的浏览器重定向回应用程序。然后，应用程序使用授权码获取ID Token和Access Token：
隐式流 传统上，无法安全存储机密的应用程序会使用隐式流程。使用此流程不再被视为请求访问令牌的最佳实践。
混合流 混合流程是一种 OpenID Connect 流程，它结合了隐式流程和授权码流程的特征。它使客户端能够直接从授权端点获取一些令牌，同时仍然可以从令牌端点获取其他令牌。
OpenID 演示 您可以使用以下网站来玩自己的：https://openidconnect.net/
OAuth2 和 OIDC OAuth 2.0 和 OpenID Connect (OIDC) 是两个不同但相关的协议，它们之间有以下主要区别:
目的不同： OAuth 2.0 是一种授权框架，目的是授予第三方应用程序有限的访问权限，而不需要共享用户的凭证。 OIDC 是构建在 OAuth 2.0 之上的身份验证协议，目的是提供安全的身份验证和用户信息交换。 认证和授权的区别： OAuth 2.0 主要处理授权，即允许第三方应用程序访问受保护资源的过程。 OIDC 在 OAuth 2.0 的基础上增加了认证功能，即验证用户身份的过程。 返回的数据不同： OAuth 2.0 返回的是访问令牌(Access Token)，用于访问受保护资源。 OIDC 返回的是 ID 令牌(ID Token)，包含了有关已验证用户的声明信息。 协议流程不同： OAuth 2.0 定义了四种授权许可类型，如授权码、隐式、客户端凭证等。 OIDC 在 OAuth 2....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-06-06</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/oauth2/>Oauth2</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to OAuth2和OIDC区别" href=https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/categories/java/>« Prev Page</a>
<a class=next href=https://blog.chensoul.cc/categories/java/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>