<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | ChenSoul</title>
<meta name=keywords content><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/categories/java/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/categories/java/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/categories/java/><meta name=twitter:title content="Java | ChenSoul"><meta name=twitter:description content><meta property="og:title" content="Java | ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/categories/java/"><meta property="og:site_name" content="ChenSoul"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-categories kind-term layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类 class=active>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><header class=page-header><h1>category: Java</h1><div class=inline-links><span><a href=https://blog.chensoul.cc/categories/java/index.xml target=_blank>RSS</a></span></div></header><article class="post-entry tag-entry"><header class=entry-header><h2>[译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端</h2></header><section class=entry-content><p>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a
在上一篇文章中，我们讨论了使用 client_credential 的 OAuth2 授权服务器配置。在本文中，我们将讨论使用 authorization_code 授予类型的授权服务器配置。此授权流程将有一个 OIDC 客户端，它将通过使用授权码进行请求来获取 JWT 令牌。
如今，社交登录非常流行，它已由 OAuth2 和 OIDC 规范标准化。我们今天的讨论主题是设置我们的社交登录客户端 (oidc-client) 应用程序，将其注册到 Spring Boot 授权服务器，使用授权服务器登录并从 OIDC 客户端应用程序访问安全资源。
今天的演示将包含 2 个应用程序：
授权服务器（端口 8080） 社交登录客户端（端口 8081） 由于这是一个复杂的主题，让我们首先查看 UI 中的应用程序身份验证和授权流程，然后再讨论配置。
要继续阅读本文，请从此处获取项目源代码。首先启动授权服务器应用程序，然后在您最喜欢的 IDE 上启动社交登录客户端应用程序。
我们的社交登录客户端有 2 个端点：
“/” 将使我们能够访问公共数据 “/private-data” 将为我们提供 JWT 令牌 在浏览器上，导航到“ http://127.0.0.1:8081/private-data ”。这将带我们进入客户端应用程序的登录页面。
由于我们对社交登录感兴趣，因此不要在此登录页面中输入您的用户名和密码，而是单击oidc-client。它将带您进入授权服务器的登录页面。
在下面的屏幕中输入“ user”作为用户名，输入“ secret”作为密码，然后单击“登录”。
这将带您进入同意页面。请注意同意页面的以下 URL：
http://localhost:8080/oauth2/authorize?response_type=code&amp;client_id=oidc-client&amp;scope=openid%20profile%20read%20write&amp;state=PcF7UjHDmYvmhwpKfv9zVosy0ZBIA2pZe7HHPixZ76E%3D&amp;redirect_uri=http://127.0.0.1:8081/login/oauth2/code/oidc-client&amp;nonce=_KHIsN6mNur-AFQz5KNK0TnZi3VPmj567qbe8-4zPMo&amp;continue
从上面的URL我们可以找到几条信息：
response_type=code client_id=oidc-client scope = openid, profile, read, write redirect_uri=http://127.0.0.1:8081/login/oauth2/code/oidc-client 现在，从上面的页面提供您想要允许客户端应用程序的同意。
如果最初请求的URL（/private-data）具有您刚刚提供的正确同意，它将向我们提供访问令牌和刷新令牌，否则它将显示403错误页面。
现在让我们深入研究代码。
授权服务器配置 在这个应用程序中，所有的事情都在 application.yml 文件中完成。Java 方面没有什么内容，除了主类。
spring: security: user: # Definition of the user details that we will use for login # in the authorization server name: user password: "{noop}secret" roles: USER # Oauth2 client registration starts from here oauth2: authorization-server: client: # We have defined only one client: oidc-client # This client information was also mentioned # in the above URL: client_id=oidc-client oidc-client: registration: # The following client ID and client secret will be matched with the # provided client credentials from client application client-id: oidc-client client-secret: "{noop}secret2" # The following authorization-grant-type will be matched with the # provided authorization-grant-type from the client application authorization-grant-types: - "authorization_code" - "refresh_token" client-authentication-methods: - client_secret_basic # This following redirect URI will be used to redirect the resource owner to the # Client application after the resource owner (user) provides necessary consents....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-06-05</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/oauth2/>Oauth2</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>4 min</span></span></footer><a class=entry-link aria-label="post link to [译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]OAuth2 with Spring 第2部分：授权服务器入门</h2></header><section class=entry-content><p>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-2-getting-started-with-authorization-server-13804910cb2a
Spring 团队最近发布了他们的授权服务器。OAuth2 一直是一个热门话题，而构建或理解授权服务器一直是一个谜。在本系列的第 1 部分中，我描述了几乎所有您需要了解的有关 OAuth2 的概念性内容。在本系列的这篇文章中，我将尝试演示如何构建具有client_credential授权类型的授权服务器。我将从使用配置属性进行自动配置开始解释它们，并通过编写 Java 代码自定义配置。让我们开始吧。
设置授权服务器 让我们转到Spring Initializr并生成项目。
为了创建授权服务器，我们需要 Oauth2 授权服务器依赖。
&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-oauth2-authorization-server&lt;/artifactId> &lt;/dependency> 生成项目并导入到您最喜欢的 IDE。
现在让我们在application.yml中添加我们想要的配置。
在第 1 部分中，我们了解到我们需要一个客户端来从授权服务器获取令牌。因此，我们需要授权服务器有一些客户端信息。在 application.yml 中，我将放置获取令牌和其他授权信息所需的最少客户端信息。
spring: security: oauth2: authorization-server: client: client-1: registration: client-id: client client-secret: "{noop}secret" client-authentication-methods: client_secret_basic authorization-grant-types: client_credentials 根据上面的配置属性，我们注册了一个客户端client-1。
对于client-1，我们定义了 4 个属性：
clientId client-secret client-authentication-methods：本例中为基本身份验证（client_secret_basic） authorization-grant-types：用于请求新令牌的授予类型。在本例中为 client_credentials。 现在，我们必须启动授权服务器应用程序。
接下来，在 postman 中，我们向*/oauth2/token端点发出 POST 请求以获取令牌。为什么是/oauth2/token*端点？
我们可以看到，一旦我们提交请求，我们就会收到详细的令牌信息。
瞧，我们最小的授权服务器现在已经启动并运行了。
该项目的链接可以在这里找到。
问题 1. 我们在哪里找到默认令牌端点？
答：在 OAuth2 的 RFC 中，它提到默认令牌端点应该是*/token*。但是，很难找到 Spring Boot 授权服务器的默认令牌端点。我不得不浏览源代码。在类OAuth2TokenEndpointFilter中，提到了默认令牌端点。
感谢您的耐心阅读。在下一篇文章中，我们将尝试创建一个资源服务器，使用authorization_code授权获取令牌以访问一些私人数据。</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-06-05</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/oauth2/>Oauth2</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]OAuth2 with Spring 第2部分：授权服务器入门" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-2-getting-started-with-authorization-server/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]OAuth2 with Spring 第1部分：了解基本概念</h2></header><section class=entry-content><p>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a
在本系列关于 Spring 的 OAuth2的文章中，我将尝试介绍和解释与 OAuth2 相关的每一个问题以及如何在 Spring 框架中实现这些问题。请记住，OAuth2 完全是一个概念性的东西，在不同的框架中，它有自己的实现。此外，许多应用程序开发人员开发自己的 OAuth2 实现，而不使用 Spring 框架提供的 OAuth2 框架支持。因此，我将就这个主题撰写一系列文章。
什么是 OAuth2 以及为什么？ 根据Octa的说法，OAuth2 是一种用于身份验证和授权的开放标准。它实际上不是一种服务，但它通过 TLS 提供基于令牌的安全性来保护服务。它使用令牌而不是凭据来授权设备、服务器、API 和应用程序。
OAuth2 的主要目的是让用户能够从单个点或提供商访问多个应用程序，这些应用程序可以使用相同的身份验证和授权信息。这意味着，并不总是需要使用用户 ID 和密码登录。相反，用户将被重定向到拥有用户身份的授权服务器，用户只需单击一下即可允许其他应用程序使用其身份验证信息。一旦获得授权，用户就可以使用来自授权服务器的相同 ID。
OAuth2 参与者和授权类型 a) 参与者
对于 OAuth2 架构，有 4 个参与者 -
资源所有者——在授权服务器中拥有自己的授权信息（通常是用户名、密码、角色等）的用户 客户端——客户端可以被视为资源所有者能够请求资源服务器中受保护资源的应用程序 授权服务器——位于客户端和资源所有者中间，检查身份验证和授权的服务器 资源服务器——包含资源 所有者想要访问的资源。 b) 授权类型
OAuth2 有几种授权类型来请求访问令牌。授权类型的唯一目的是生成访问令牌。授权类型包括：
授权码— 为了接收访问令牌，授权客户端向授权服务器发送请求以及先前从授权服务器收到的授权码。本系列的第 3 部分专门介绍此授权码授予。 **PKCE —**代码交换证明密钥 (PKCE) 是授权代码授予的扩展版本，旨在支持单页应用程序或移动应用程序，以防止 CSRF 或授权代码注入攻击。PKCE 最初旨在保护移动应用程序中的授权代码流，但其防止授权代码注入的能力使其适用于每种类型的 OAuth 客户端，甚至是使用客户端身份验证的 Web 应用程序。本系列的第 5 部分描述了此流程的代码示例。 客户端凭证— 在此流程中，客户端应用程序使用 client_id 和 client_secret 进行请求，授权类型为 client_credential。这通常发生在使用服务的第三方应用程序中。本系列的第 2 部分专门介绍此客户端凭证。 刷新令牌授权— 此授权类型由客户端使用。当访问令牌过期时，存储在客户端内存中的刷新令牌将以授权类型 refresh_token 发送到授权服务器。服务器将返回一个新的 access_token。我们不会专门写一篇文章，因为它主要由应用程序内部处理。 了解接收访问令牌的工作流程 OAuth 工作流
为了请求资源服务器中的某些资源，资源所有者需要访问令牌 资源所有者打开一个应用程序（可能是授权服务器的客户端，在上图中为 BusinessClient）来请求资源服务器中的一些安全资源。 当资源所有者请求没有任何令牌的资源时，他/她可以选择授权服务器。 选择后，客户端将被重定向到授权服务器 (OAuthSercer)。授权服务器要求输入用户名和密码（以及grant_type）。 资源所有者提供所需信息并提交。如果信息真实，授权服务器将访问令牌（以及其他信息，可选）发送给客户端。 客户端保存令牌并在内部创建对资源的请求，这是资源所有者在没有令牌时提出的。 收到令牌后，资源服务器将其发送到授权服务器以验证令牌。 如果授权服务器向资源服务器提供了肯定的响应，资源服务器将响应资源所有者请求的信息。 这就是整个过程的工作原理。在我的下一篇文章中，我将深入研究代码并演示使用内存客户端的 OAuth2 实现。
参考： OAuth2 授权类型 — https://oauth.net/2/grant-types/ OAuth2 角色 - http://websystique....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-06-05</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/oauth2/>Oauth2</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]OAuth2 with Spring 第1部分：了解基本概念" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]使用 Spring Boot 构建 RESTful API：集成 DDD 和六边形架构</h2></header><section class=entry-content><p>原文链接：Building a RESTful API with Spring Boot: Integrating DDD and Hexagonal Architecture
介绍 在快节奏的软件开发世界中，API 扮演着至关重要的角色，可以有效地促进不同系统之间的交互和数据交换。API 创建最突出的技术之一是 Spring Boot，它是一种强大的工具，可以简化 Java 应用程序的开发，使开发人员可以专注于业务逻辑而不是环境设置。
在本文中，我们将探讨如何使用 Spring Boot 设计和构建 RESTful API，但我们将超越单纯的开发。我们将集成领域驱动设计 (DDD) 和六边形架构等高级概念，这些概念对于创建强大、可扩展且易于维护的应用程序至关重要。这些方法不仅可以改善代码结构和关注点分离，还可以促进技术团队和利益相关者之间的协作，使软件设计与业务需求保持一致。
在本文中，我们将把这些复杂的概念分解为简单的解释和实际示例，确保即使是初学者也可以遵循这些高级实践并将其应用到自己的项目中。无论您是希望增强应用程序架构的经验丰富的开发人员，还是 Spring Boot 世界的新手，您都可以在本文中找到适合您的开发需求的宝贵经验和技巧。
让我们深入了解构建 API 的迷人过程，该 API 不仅运行良好，而且从概念到实现都设计精良。
第 0 节：什么是 REST API？ 什么是 API？ API（应用程序编程接口）是一组规则和规范，允许不同的应用程序或软件组件相互交互。它充当中介，使开发人员能够访问软件服务中的特定功能或数据，而无需了解该软件的内部细节。
REST API 的起源 REST（表述性状态转移）架构由 Roy Fielding 于 2000 年在其博士论文中定义。REST 是一套原则，概述了应如何设计客户端和服务器之间的交互。它的创建是出于对标准的需求，该标准可以提高互联网通信的可扩展性，从而提供比当时可用的接口（例如被认为过于复杂和僵化的 SOAP）更简单、更高效的接口。
REST 旨在解决什么问题？ REST 的出现是为了应对现有架构的复杂性，这些复杂性使 Web 应用程序的开发和可扩展性变得复杂。通过采用无状态模型并使用标准 HTTP 方法（GET、POST、PUT、DELETE），REST 简化了客户端与服务器交互的实现。这种简单性使开发人员能够创建更高效、更易于维护的 Web 和移动应用程序。
REST基于六个基本原则：
**统一接口：**确保客户端和服务器之间的接口一致、标准化。 **无状态：**每个客户端对服务器的请求都必须包含理解和完成请求所需的所有信息。 **可缓存：**响应必须隐式或显式地定义它们是否可缓存。 **分层系统：**客户端不需要知道它是直接与终端服务器通信还是与中介通信。 **客户端-服务器：**用户界面（客户端）和数据存储（服务器）之间的职责分离，通过简化服务器组件增强了用户界面跨多个平台的可移植性和可扩展性。 **按需代码（可选）：**服务器可以通过发送可执行代码来扩展或定制客户端的功能。 结合这些原则不仅解决了可扩展性和维护问题，而且还促进了更为健壮、交互和高效的 Web 应用程序的创建。
现在，如果你已经读到这里，你可能会想，“HTTP 到底是什么？”好吧，让我们开始吧。
HTTP 简介 HTTP（超文本传输协议）是互联网工程任务组（IETF）定义的网络交互中使用的底层协议。它是浏览器（客户端）和网络服务器之间传输数据的手段。该协议基于请求-响应模型，对于 RESTful 通信至关重要，因为它的方法促进了 REST API 中基本的 CRUD（创建、读取、更新、删除）操作。
HTTP 方法及其使用时机 HTTP 方法定义您想要对已识别的资源执行的操作。以下是 REST API 中最常用的方法：
**GET：**用于从服务器检索信息。它不应修改资源的状态，因此非常适合无副作用的读取操作。示例：获取用户列表或特定用户的详细信息。 **POST：**用于创建新资源。当请求结果导致服务器状态改变或产生副作用时，此方法非常有用。例如：添加新用户。 **PUT：**用于更新/替换现有资源。在请求中发送完整实体很重要。示例：更新现有用户的姓名和年龄。 **DELETE：**用于删除资源。例如：删除用户。 **PATCH：**与 PUT 不同，PATCH 用于对资源进行部分更新。例如：仅更新用户的名称而不触及其他字段。 HTTP 方法的最佳实践 在设计 RESTful API 时，遵循一些最佳实践以确保 API 易于理解和使用至关重要：...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-30</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/spring-boot/>Spring-Boot</a><a href=https://blog.chensoul.cc/tags/java/>Java</a><a href=https://blog.chensoul.cc/tags/ddd/>Ddd</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>6 min</span></span></footer><a class=entry-link aria-label="post link to [译]使用 Spring Boot 构建 RESTful API：集成 DDD 和六边形架构" href=https://blog.chensoul.cc/posts/2024/05/30/building-a-restful-api-with-spring-boot-integrating-ddd-and-hexagonal-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]如何组织代码</h2></header><section class=entry-content><p>原文链接：How to Structure Code
软件设计最佳实践，逐层发现包、按功能发现包以及六角形架构/端口和适配器。
在这篇博文中，我将探讨如何构建我们的代码并讨论最佳实践，涵盖三种不同的方法：按层打包、按功能打包以及六边形架构/端口和适配器及其优缺点。
在探索构建代码的不同方法之前，我们需要了解基本的软件设计原则：
内聚力：指模块内各类之间的相互关联程度。 耦合度：指不同模块之间的依赖程度。 模块化：指软件系统被划分为独立模块的程度。每个模块都封装了一组特定的功能，并设计为独立工作，同时通过明确定义的接口相互交互。 抽象：隐藏实现细节并仅通过接口公开必要的功能。 关注点分离：设有不同的部分，每个部分解决一个特定的关注点。 封装：将数据和方法捆绑到单个模块或类中以隐藏内部细节。 让我们仔细看看内聚力和耦合力？
内聚力描述了软件的集中程度。它与单一责任原则密切相关。
高内聚力意味着模块内的类紧密相关并具有共同的、明确定义的目的。 低内聚力意味着模块内的类之间关系松散，缺乏明确的目的且职责不相关。 要遵循的最佳实践是实现模块之间的高内聚和松散耦合。
松耦合被认为是结构良好和设计良好的计算机系统的标志，与高内聚力相结合，可带来较高的可读性和可维护性。
现在，让我们探索构建代码的不同方式。首先，我将逐层介绍包，然后逐功能介绍包，并比较两者。之后，我们将探索端口和适配器模式。
层封装 它代表一个项目结构，其中类被组织成多个层，每个层负责一组特定的功能。
src ├── main │ ├── java │ │ └── com │ │ └── app │ │ ├── service │ │ │ └── UserService.java │ │ │ └── OrderService.java │ │ │ └── ProductService.java │ │ ├── domain │ │ │ └── User.java │ │ │ └── Order.java │ │ │ └── Product.java │ │ ├── repository │ │ │ └── UserRepository.java │ │ │ └── OrderRepository.java │ │ │ └── ProductRepository.java │ │ ├── controller │ │ │ └── UserController....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-30</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/ddd/>Ddd</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]如何组织代码" href=https://blog.chensoul.cc/posts/2024/05/30/how-to-structure-our-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>All things about WebSocket</h2></header><section class=entry-content><p>Wikipedia：WebSocket
WebSocket - Web APIs | MDN
PubNub：什么是 WebSocket？
What are WebSockets?
websocket protocol - RFC6455 - tools.ietf.org
WebSocket
Ably：What are WebSockets used for? Pusher：What are WebSockets?
WebSocket vs. HTTP communication protocols
What are WebSockets? | Web Security Academy
Educative：What is WebSocket?
Spring：WebSocket
Writing a WebSocket server in Java - Web APIs
Baeldung：A Guide to the Java API for WebSocket
Baeldung：A Java Client for a WebSockets API
WebSocket Implementation with Spring Boot and STOMP
ApiFox：WebSocket协议入门到精通
JSR 356, Java API for WebSocket
WebSocket 协议解析 [RFC 6455]
WebSocket原理及技术简介
【NO.23】一篇文章彻底搞懂websocket协议的原理与应用（一）
WebSocket 协议详解
WebSocket 协议（RFC 6455 中文版）
用JAVA分别实现WebSocket客户端与服务端
WebSocket Programming with Java
MQTT Websocket Client</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-10</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>Java</a><a href=https://blog.chensoul.cc/tags/websocket/>Websocket</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to All things about WebSocket" href=https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>All things about Spring Modulith</h2></header><section class=entry-content><p>VMware 推出了一个实验性的项目Spring Modulith，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。
2022 年 11 月推出的Spring Boot 3会是 Spring Modulith 的基础。所以它的基线是 Spring Framework 6、Java 17 和 Jakarta EE 9。Spring Modulith 是Moduliths（其名字有个“s”后缀）项目的继承者。该项目使用 Spring Boot 2.7，目前已经退役，只接收缺陷修正，直至 2023 年 11 月份。
https://spring.io/blog/2022/10/21/introducing-spring-modulith
https://www.baeldung.com/spring-modulith
https://www.baeldung.com/spring-modulith-event-externalization
https://piotrminkowski.com/2023/10/13/guide-to-modulith-with-spring-boot/
https://springdoc.cn/guide-to-modulith-with-spring-boot/
https://medium.com/andamp/event-sourcing-with-spring-modulith-2b35b0569dbb
https://www.geeksforgeeks.org/what-is-spring-modulith/
https://github.com/xsreality/spring-modulith-with-ddd
https://riteshshergill.medium.com/the-spring-modulith-monolithic-but-manageable-ca1532a1e585
https://www.infoq.com/news/2022/11/spring-modulith-launch/
https://dzone.com/articles/architecture-style-modulith-vs-microservices
https://speakerdeck.com/olivergierke/spring-modulith-a-deep-dive
https://www.jappware.com/proffesional-activity/make-monolithic-apps-great-again-with-spring-modulith-coffeejug/
https://blog.worldline.tech/2024/01/23/modulith.html
https://springdoc.cn/spring-modulith-intro/
https://dimitri.codes/checking-out-spring-modulith/
https://www.lefer.cn/posts/29752/
https://www.jdon.com/63003.html
https://blog.csdn.net/cfy_banq/article/details/132185951
https://www.zhihu.com/question/567053421</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-09</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/spring/>Spring</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to All things about Spring Modulith" href=https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</h2></header><section class=entry-content><p>原文链接：https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249
来源：https://www.thewebmaster.com/
先决条件：了解 javascript、客户端-服务器架构。
完整的代码可以在github上找到。
第 1 部分：概述（http2 的原因、内容、时间、方式）第 2 部分：使用 node-http2 核心和 hapijs 进行探索
免责声明：本文将使用node@v9+附带的http2模块。这里列出了其他几个 http2 客户端-服务器库实现。
让我们开始创建一个具有单一路由的简单 http1.1 服务器。
mkdir hapijs-http2 && \ cd hapijs-http2 && \ npm init -y && \ npm i hapi@^16.6 -s && \ touch http1Server.js 将下面的代码复制到此处或从此处http1Server.js克隆整个存储库。
const Hapi = require('hapi'); const server = new Hapi.Server(); // define server config server.connection({ port: '8000' }); // define route config server.route([{ method: 'GET', path: '/ping', handler: (request, reply) => { reply('pong'); } }]); // start server server.start(err => { if (err) console.error(err) console.log(`Started ${server.connections.length} connections`) }); 现在，让我们进行健全性检查。
启动服务器，node http1Server.js
⇒ http://127.0.0.1:8000/ping pong 凉爽的！如果我们得到 pong 的 ping，让我们尝试将http2集成到我们的 hapijs 服务器中。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-08</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/http/>Http</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs" href=https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]探索 http2（第 1 部分）：概述</h2></header><section class=entry-content><p>原文链接：https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f
让我们来谈谈 http2 的内容、原因、时间和方式
完整的代码可以在github上找到。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
什么是http2？ **http2*是自 1999 年以来使用的http1.1***之后的最新更新
http2协议注重性能；具体来说，最终用户感知的延迟、网络和服务器资源的使用情况。 （在此处阅读有关规格的信息*）*
为什么是http2？ 换句话说http1.1有什么问题
加载网页是一项资源密集型工作，因为 HTTP/1.1 只允许每个 TCP 连接有一个未完成的请求。网络需要进行更新，以提高效率、安全性和速度。
http2如何解决性能问题？
http2 带来的改进：
**单一连接：**仅使用一个与服务器的连接来加载网站，并且只要网站打开，该连接就保持打开状态。这减少了建立多个 TCP 连接所需的往返次数。（更多信息在这里） **多路复用：**同一连接上同时允许多个请求。以前，在 HTTP/1.1 中，每个传输都必须等待其他传输完成。（更多信息在这里） **服务器推送：**可以将其他资源发送到客户端以供将来使用。（更多信息在这里） **优先级：**请求被分配依赖级别，服务器可以使用它来更快地交付更高优先级的资源。（更多信息在这里） **二进制：**使 HTTP/2 更易于服务器解析、更紧凑且不易出错。将信息从文本转换为二进制不会浪费额外的时间。（更多信息在这里） 标头压缩： HTTP/2 使用HPACK压缩，从而减少开销。在 HTTP/1.1 中，每个请求中的许多标头都使用相同的值发送。（更多信息在这里） 我们什么时候可以开始使用http2？ 现在！
这是时间线，
来源：https://www.polyglotdeveloper.com/
是的，从 1999 年到今天，我们（大多数）都在使用同样好的旧 http1.1； 15年！
如何开始使用http2？ 以下是各种语言的 http2 库实现列表。
根据Can I Use的统计，大约 83% 的在线浏览器已经支持 http2
查看实际情况，http1.1 与 http2（网络节流：快速 3g）
http1.1（左）与http2（右）；让我们在下一节中构建它
在下一部分中，我们将构建一个支持 http2 的简单服务器；具有http1.1向后兼容性；一步一步使用http2-node core 和hapi js。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
完整的代码可以在github上找到。</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-08</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/http/>Http</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]探索 http2（第 1 部分）：概述" href=https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]比较 Socket.IO 和 HTTP：主要区别和用例</h2></header><section class=entry-content><p>原文链接：https://ably.com/topic/socketio-vs-http
在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。
什么是Socket.IO？ Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。
Socket.IO 需要两个库 - 一个在服务器上，一个在客户端上。 Socket.IO 创建者维护以下“官方”：
Socket.IO是 Node.js 服务器组件。 Socket.IO-client是客户端 JavaScript 库。 一些 Socket.IO 客户端和服务器实现可以用其他语言实现。请阅读Socket.IO 是什么来获取列表。
下图总结了典型的 Socket.IO 设置：
Socket.IO 主要特性 Socket.IO 具有以下主要特性：
**向后兼容性：**在现代浏览器中，Socket.IO 使用WebSocket API提供所需的连接并发送消息。 WebSocket 在服务器和浏览器之间提供全双工、低延迟、事件驱动的连接。它也是有状态的。如果需要旧版浏览器支持，或者 WebSocket 连接无法使用（由于防火墙或公司代理），Socket.IO 可以回退到 HTTP 和长轮询。 重连和缓冲： Socket.IO提供自动重连功能。当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送。 多种数据格式： Socket.IO 支持任何可序列化格式的数据传输，包括Buffer或TypedArray等二进制对象。 **致谢：**使用 Socket.IO，一旦成功接收到消息就可以发送响应消息。 命名空间： Socket.IO 使您能够设置具有不同客户端、房间、事件和应用程序逻辑的不同通道。 **广播到不同的客户端组：**从服务器，您可以向所有连接的客户端或子集发送消息。 Socket.IO 的优缺点 Socket.IO 专业人士 连接效率： Socket.IO 使用 HTTP 长轮询发起连接，一旦建立可用性就升级到 WebSocket（有关更多详细信息，请参阅升级机制）。当发生这种情况时，客户端-服务器连接使用单个 WebSocket，而不必启动多个连接，从而减少延迟并改善用户体验。 **客户端和服务器发起的通信：**由于WebSocket提供了全双工、双向的通信通道，因此服务器可以向客户端发送消息，并且两者可以同时发送消息。 事件驱动的通信： WebSocket是一种事件驱动的协议，这意味着您可以在收到消息后立即监听并响应消息，而不是使用轮询机制来检查更新，这样既浪费又低效。 丰富的功能集： Socket.IO 提供了实现实时应用程序所需的一切。当使用原始 HTTP 甚至原始 WebSocket 时，您必须自己实现其中大部分功能。 有状态： Socket.IO 使用 WebSocket，它是有状态的。该状态一直持续到连接关闭为止。 Socket.IO 缺点 **有限的平台支持：**我们之前提到，Socket.IO 在不同的平台和语言上有多种服务器和客户端实现。值得一提的是，其中一些没有得到积极维护，或者功能集有限，因此在考虑使用它们之前请仔细检查它们。此外，Socket.IO 实现与本机 WebSocket 不兼容，因为 Socket.IO 会向其发送的每个数据包添加额外的元数据。 可扩展性： Socket.IO 非常适合有限数量用户的实时通信应用程序。但是，如果您的用户数量和数据量开始变大，您的服务器可能会过载。当您的服务器达到最大负载时，您将需要将连接拆分到多个服务器上，否则可能会丢失重要信息。这种增加的架构复杂性带来了更多问题。阅读Scaling Socket.IO - 实际注意事项以获取更多信息。 **内存泄漏：**已知 Socket.IO 存在一些与内存泄漏相关的问题。内存泄漏不太可能导致任何直接问题，但如果您的应用程序使用了很长一段时间，它们最终可能会导致用户的设备冻结或崩溃。 什么是 HTTP？ HTTP 是一种请求/响应协议，作为 Web 的主要通信机制，构建在 TCP 网络协议之上。有限版本最初由 Tim Berners-Lee 于 1989 年提出，随后经过快速修改以支持更广泛的浏览器和服务器功能。 HTTP 工作组于 1996 年将这些修改记录为 HTTP/1....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-08</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/socketio/>Socketio</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]比较 Socket.IO 和 HTTP：主要区别和用例" href=https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/categories/java/>« Prev Page</a>
<a class=next href=https://blog.chensoul.cc/categories/java/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>