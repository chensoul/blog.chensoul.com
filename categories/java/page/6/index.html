<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | ChenSoul</title>
<meta name=keywords content><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/categories/java/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/categories/java/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/categories/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Java"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/categories/java/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Java
<a href=/categories/java/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]什么是Socket.IO？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/socket-io/
什么是Socket.IO？ Socket.IO是一个开源的跨平台库，它提供客户端和服务器之间基于事件的全双工双向通信。它基于 WebSocket 协议构建，提供附加功能，例如自动重新连接以及在无法使用 WebSocket时回退到HTTP 长轮询。
Socket.IO 客户端由客户端和服务器端库组成。虽然最初在服务器上支持NodeJS ，在客户端支持JavaScript，但现在它支持各种服务器和客户端技术，包括Java、Python、Swift和Kotlin，它们都是官方代码库的一部分，由活跃社区贡献。
Socket.io 有何用途？ Socket.IO 允许您实现依赖于消息交换的各种应用程序，例如即时消息传递、多用户协作、实时分析、文件共享和通知。
Socket.io 适合实时应用程序吗？ 是的，Socket.IO 是构建实时 Web 应用程序的不错选择，因为它提供了许多对开发人员有用的开箱即用功能，包括：
房间和命名空间支持允许您将客户端分组到可以接收广播或多播消息的房间中。 自动重连意味着您无需担心客户端上线或离线。 二进制数据支持，使您不仅可以交换聊天消息，还可以交换图像或其他媒体。 Socket.io 是 API 吗？ Socket.IO不是传统意义上的API。它是一个库或框架，抽象了底层传输机制，并提供了一组用于在客户端和服务器之间构建实时双向通信的工具和实用程序。
Socket.IO 包含客户端和服务器组件，每个组件都公开其 API。
Socket.io是TCP还是UDP，有什么区别？ Socket.IO可以使用TCP和UDP作为底层传输协议，但它主要使用TCP。
TCP（传输控制协议）是一种可靠的、面向连接的协议，可确保数据按顺序且无错误地传送。
另一方面，UDP（用户数据报协议）是一种无连接、不可靠的协议，它发送数据时不检查数据是否已成功接收。
UDP 比 TCP 更轻量级，因为只有后者在客户端和服务器之间建立连接，但它只能由能够抵御丢失消息的应用程序使用。
Socket.io 与 Web Sockets 虽然 Socket.IO 明确不是WebSocket实现，但有一些相似之处。两者都是基于事件的，这意味着您可以“侦听”连接、断开连接或 new_message 等事件，并且都允许您发送JSON 对象等结构化数据。
您可以将 Socket.IO 视为底层传输协议之上的抽象层。除了底层通信层之外，该库还实现了其他功能，例如自动重新连接、数据包缓冲和消息确认，以及在 WebSocket 不可用时回退到 HTTP 长轮询，从而增加了鲁棒性。
Socket.io 示例：客户端/服务器 JavaScript 中 Socket.IO 的 Hello World 客户端/服务器实现将编写如下，摘自4.x Socket.IO 文档：
Socket.io 服务器示例：
Socket.io 客户端示例：
Socket.IO 是如何工作的？ 该库支持两种传输方法：HTTP 长轮询和 WebSockets。首先建立 HTTP 长轮询连接，然后在可能的情况下升级为 WebSocket 连接。 WebSocket 不能在任何地方运行，例如，它们被许多公司代理和防火墙阻止，因此首先发起 HTTP 长轮询，因为它更有可能成功。 HTTP 长轮询连接建立后，会在对最终用户完全透明的过程中“升级”为 WebSocket 连接。
Socket.IO的架构是怎样的？ Socket.IO 由两个不同的层组成，分别存在于客户端和服务器上：
底层管道由一个名为Engine.IO的单独库提供 Socket.IO 提供的高级 API 作为开发人员或用户，您通常不会直接与 Engine.IO 交互，但它在幕后运行以建立连接、协商传输机制并检测任何断开连接。将 Engine.IO 与 WebSocket 进行比较时，两者在功能上非常相似，只是 Engine....</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;128 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是Socket.IO？" href=https://blog.chensoul.cc/posts/2024/05/07/socket-io/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]什么是WebSocket？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/websockets/
什么是 WebSocket？ WebSocket 是一种通过单个TCP连接提供全双工通信通道的通信协议。它支持客户端和服务器之间的实时、事件驱动的连接。
与遵循请求-响应模型的传统 HTTP 软件不同，WebSocket 允许双向（双向）通信。这意味着客户端和服务器可以随时向对方发送数据，而无需持续轮询。
WebSocket 有何用途？ WebSocket 用于客户端和服务器之间的实时、事件驱动的通信。它们对于构建需要即时更新的软件应用程序特别有用，例如实时聊天、消息传递和多人游戏。
在传统的 HTTP 中，客户端向服务器发送请求，服务器用请求的数据进行响应。这种请求-响应模型需要从客户端到服务器进行连续轮询，这可能会导致延迟增加和效率降低。
另一方面，WebSockets 在客户端和服务器之间建立持久连接。这意味着一旦建立连接，客户端和服务器就可以随时向对方发送数据，而无需不断轮询请求。这允许实时通信，可以立即发送和接收更新。
例如，当用户在聊天应用程序中发送消息时，该消息可以立即传递给所有其他用户，而无需刷新页面或发出频繁的 HTTP 请求。这将带来更加无缝和高效的用户体验。
此外，Web Sockets 还允许双向通信，这意味着客户端和服务器都可以相互发送数据。这为更具交互性和吸引力的应用程序提供了可能性，其中服务器可以处理向客户端推送更新或通知，而无需客户端明确请求它们。
Web 套接字的缺点 WebSocket 的缺点包括：
浏览器支持：虽然大多数现代浏览器支持 WebSocket，但一些旧浏览器不支持。这可能会限制应用程序的范围，并且需要针对旧版浏览器的额外后备机制。 代理和防火墙限制：某些代理服务器和防火墙可能会阻止或干扰 WebSocket 连接。这可能会导致连接问题，尤其是在安全的公司或受限的网络环境中。 可扩展性：Web Sockets 在客户端和服务器之间维护持久连接，这在处理许多并发连接时可能会导致服务器资源紧张。必须实施适当的负载平衡和资源管理技术以确保可扩展性。像 Socket.io 这样的开源资源不适合大规模运营或快速增长。 有状态性：与无状态的传统 HTTP 不同，WebSocket 是有状态的。这意味着服务器需要维护每个客户端的连接状态，从而导致内存使用量增加和潜在的可扩展性挑战。 安全注意事项：通过 WebSocket 建立持久连接，需要采取适当的安全措施来防止潜在的漏洞，例如跨站点脚本 (XSS) 和跨站点请求伪造(CSRF)。应实施使用SSL/TLS加密的安全 WebSocket 连接 (wss://)，以确保数据隐私和完整性。 如果通过 Web 套接字的连接丢失，则不包含负载平衡或重新连接机制。 在可能不支持 Web Sockets 的环境中，仍然需要有后备选项，例如HTTP 流或长轮询。 像Presence这样的功能在 WebSocket 连接上不能很好地工作，因为断开连接很难检测到。 WebSockets、HTTP、Web 服务器、轮询 HTTP 连接与 WebSockets 要了解WebSocket API，了解其构建基础 — HTTP（超文本传输协议）及其请求/响应模型也很重要。 HTTP 是一种应用层协议，是所有基于 Web 的通信和数据传输的基础。
使用 HTTP 时，客户端（例如 Web 浏览器）向服务器发送请求，然后服务器发回消息（称为响应）。我们今天所知道的网络是建立在这种基本的客户端-服务器循环之上的，尽管对 HTTP 进行了许多添加和更新以使其更具交互性。当前有一些可行且受支持的 HTTP 版本（HTTP/1.1 和 HTTP/2）以及称为 HTTPS 的安全版本。
基本 HTTP 请求适用于许多用例，例如当有人需要在网页上搜索并接收相关的、非时间敏感的信息时。然而，它并不总是最适合需要实时通信或需要以最小延迟快速更新的数据的 Web 应用程序。
每当客户端发出新的 HTTP 服务器请求时，默认行为是打开新的 HTTP 连接。这是低效的，因为它使用循环非有效负载数据的带宽并增加了数据传输之间的延迟。
此外，HTTP 请求只能从客户端向一个方向流动。传统上没有服务器发起与客户端通信的机制。除非服务器首先请求数据，否则服务器无法向客户端发送数据。这可能会给需要从服务器端实时发出消息的用例带来问题。
短轮询与 WebSockets HTTP 轮询是接收定期数据更新的第一个解决方案。轮询是一种客户端重复向服务器发送请求直到服务器更新的技术。例如，所有现代 Web 浏览器都提供对 XMLHttpRequest 的支持，这是轮询服务器的原始方法之一。...</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;329 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是WebSocket？" href=https://blog.chensoul.cc/posts/2024/05/07/websockets/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]什么是长轮询？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/long-polling/
什么是长轮询？ 长轮询用于实时 Web 应用程序，以实现客户端和 Web 服务器之间近乎即时的通信。它在实时更新至关重要的聊天和消息应用程序中特别有用。
在传统的HTTP通信中，客户端向服务器发送新请求并等待响应。这称为短轮询。然而，在实时场景中，短轮询可能效率不高，因为它需要频繁向服务器请求，导致不必要的网络开销和增加延迟。
另一方面，长轮询通过在新数据可用之前保持请求长时间打开来提高效率。服务器保持请求打开并等待，直到有新信息发送回客户端。一旦服务器有新数据，它就会响应客户端，然后客户端可以处理数据并发起新的长轮询请求。
通过维持客户端和服务器之间的长期连接，长轮询减少了请求数量，最大限度地减少了延迟，并提高了实时通信。这使得它非常适合需要有效技术来构建可扩展和响应式聊天和消息传递应用程序以及其他利用游戏等实时数据的应用程序的用例。
长轮询如何工作？ 长轮询是一种用于实时通信的技术，用于在客户端和服务器之间实现近乎即时的消息传递。它在构建低延迟和实时更新至关重要的聊天和消息传递应用程序时特别有用。
传统上，Web 浏览器使用基于拉取的方法从服务器获取数据。客户端向服务器发送请求，服务器以请求的数据进行响应。这种方法称为短轮询，可能会造成通信延迟，因为客户端必须重复发送请求来检查更新。
另一方面，长轮询是一种基于推送的方法，允许服务器在更新可用时立即向客户端发送更新。它的工作原理如下：
客户端向服务器发起请求，通常通过 HTTP 请求。 服务器不会立即响应，而是将请求保持打开状态，从而保持连接处于活动状态。 如果没有新数据可用，服务器将等待，直到有数据要发回。 一旦服务器有新的数据或者发生预定义的超时，它就会用最新的信息响应客户端。 客户端收到响应后，立即向服务器发送另一个请求以维持连接。 这种发送请求和接收响应的循环持续进行，确保实时更新。 长轮询通过长时间保持请求-响应周期打开来有效地模拟客户端和服务器之间的实时连接。它允许服务器在更新可用时立即将更新推送到客户端，并且无需客户端重复检查更新。
使用什么技术来实现长轮询？ 长轮询是一种实现客户端和服务器之间实时通信的技术。它通常用于即时更新至关重要的聊天和消息传递应用程序。可以使用多种技术来实现长轮询，每种技术都有优点和注意事项。让我们探讨一些用于实现长轮询的常用技术。
HTTP 长轮询：
这是实现长轮询的最基本、最广泛使用的方法。它利用 HTTP 协议建立并维护客户端和服务器之间的长期连接。客户端向服务器发送请求，服务器将请求保持打开状态，直到有新数据可用或达到某个超时。一旦有新数据可用，服务器就会用更新的信息进行响应，客户端立即发送另一个请求以继续循环。这种方法易于实现，不需要特殊的服务器端技术。
网络套接字：
WebSocket 是一种全双工通信协议，可通过单个长期连接在客户端和服务器之间实现实时通信。它提供了比长轮询更高效、低延迟的替代方案。 WebSocket 支持双向数据流，允许客户端和服务器异步发送消息。它消除了频繁的 HTTP 请求并减少了网络开销。 WebSocket 非常适合需要即时更新和实时交互的应用程序。
服务器发送的事件 (SSE)：
SSE 是一种单向通信技术，允许服务器通过单个长期 HTTP 连接将数据推送到客户端。通过SSE，服务器可以向客户端发送多个更新，而不需要客户端不断地发出请求。服务器启动连接并以一系列事件的形式发送数据。客户端接收这些事件并可以根据需要进行处理。
在选择在应用程序中实现长轮询的技术时，需要考虑以下几个因素：
可扩展性：确保所选技术可以处理大量并发连接，并且可以随着用户群的增长而扩展。 WebSocket 和 SSE 通常比基于 HTTP 的长轮询更具可扩展性，因为它们允许更有效地使用服务器资源。 安全性：考虑所选技术的安全影响。 WebSocket 和 SSE 可以使用SSL/TLS等加密协议进行保护，从而确保数据隐私和完整性。基于 HTTP 的长轮询也可以得到保护，但可能需要额外的身份验证和访问控制措施。 浏览器支持：检查所选技术的浏览器兼容性。 WebSocket 和 SSE 比基于 HTTP 的长轮询具有更好的浏览器支持，这可能需要额外的技术或针对旧浏览器的后备选项。 实施复杂性：评估所选技术的实施和维护难易程度。基于 HTTP 的长轮询相对简单，而 WebSocket 和 SSE 可能需要更高级的知识和基础设施。考虑开发团队可用的专业知识水平以及实施和维护所选技术所需的资源。 长轮询与 WebSockets 长轮询和 WebSocket是在客户端（例如 Web 浏览器）和服务器之间实现实时连接的技术。尽管它们的目的相似，但两者存在显着差异。
长轮询是一种技术，客户端向 Web 服务器发出请求，服务器保持连接打开，直到有新数据要发回。如果服务器有新数据可用，则可以立即响应，或者在发送空响应之前等待指定的超时时间。无论哪种情况，客户端一旦收到响应，就会立即向服务器发出另一个请求以建立新连接。此过程不断重复，允许服务器在更新可用时立即将更新推送到客户端。
另一方面，WebSockets 在客户端和服务器之间提供持久的双向通信通道。与长轮询不同的是，长轮询会为每个请求建立一个新连接，而 WebSocket 连接只会建立一次并无限期地保持打开状态。这允许双向实时、低延迟通信。服务器可以随时向客户端推送数据，客户端也可以不等待响应就向服务器发送数据。
长轮询和 Web Sockets 之间的相似之处： 1.实时更新：长轮询和WebSockets都可以实现服务器和客户端之间的实时通信，允许即时更新，无需连续轮询或刷新。
减少服务器负载：这两种技术都通过仅在数据可用时发送数据来最大程度地减少不必要的请求，从而减少服务器负载并提高可扩展性。 广泛的语言和框架支持：许多流行的编程语言和框架都支持长轮询和WebSocket，使不同生态系统的开发人员都可以使用它们。 长轮询和 Web Sockets 之间的区别： 1.延迟：长轮询会引入延迟，因为服务器发送响应和客户端接收响应之间存在延迟。 WebSocket 提供双向、低延迟通信，从而实现更快的实时功能。...</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;205 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是长轮询？" href=https://blog.chensoul.cc/posts/2024/05/07/long-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/websockets-kafka
Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。
由于 Kafka 如此受欢迎，我很好奇是否可以使用它通过互联网和 WebSockets 将实时数据直接流式传输给最终用户。毕竟，Kafka 具有一系列特征，似乎使其成为一个值得注意的选择，例如：
高通量 低延迟 高并发 容错能力 持久性（持久性） 用于将 Kafka 消息流式传输到面向互联网的客户端的现有解决方案 我开始研究实时开发社区对这个用例的看法。我很快发现 Kafka 最初设计用于安全网络内进行机器对机器通信。这让我想到，如果您想通过 WebSocket 将数据从 Kafka 流式传输到面向互联网的用户，您可能需要使用某种中间件。
我继续研究，希望找到一些可以充当中间件的开源解决方案。我发现了其中的几个，理论上可以用作 Kafka 和通过互联网连接数据流的客户端之间的中介：
transfers_websockets_service kafka-websocket kafka-proxy-ws 不幸的是，上面列出的所有解决方案都只是概念证明，仅此而已。它们的功能集有限，并且尚未做好生产准备（尤其是大规模生产）。
然后我研究了成熟的科技公司如何解决这个 Kafka 用例；看来他们确实在使用某种中间件。例如，Trello 开发了WebSocket 协议的简化版本，仅支持订阅和取消订阅命令。 Slack 提供了另一个例子。该公司构建了一个名为Flannel的代理，它本质上是部署到边缘存在点的应用程序级缓存服务。
当然，像 Trello 或 Slack 这样的公司有能力投资所需的资源来构建此类解决方案。然而，开发自己的中间件并不总是一个可行的选择——这是一项非常复杂的任务，需要大量的资源和时间。另一种选择（最方便、最常见的一种）是使用已建立的第三方解决方案。
正如我们所看到的，普遍的共识似乎是 Kafka 本身不适合通过互联网进行最后一英里交付；您需要将它与另一个组件结合使用：面向互联网的实时消息传递服务。
在 Ably，我们的许多客户都通过我们面向互联网的 pub/sub 实时消息服务传输 Kafka消息。为了演示它是多么简单，下面是如何从 Kafka 消费数据并将其发布到 Ably 的示例：
const kafka = require('kafka-node'); const Ably = require('ably'); const ably = new Ably.Realtime({{ABLY_API_KEY}}); const ablyChannel = ably.channels.get('kafka-example'); const Consumer = kafka.Consumer; const client = new kafka....</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;549 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端" href=https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ThingsBoard的领域模型</h2></header><div class=entry-content><p>ThingsBoard是一个开源的物联网平台，用于管理和监控物联网设备和数据。它提供了一个可扩展的架构，可以连接各种设备，并实时收集、处理和分析设备生成的数据。
领域模型 在ThingsBoard中，领域模型是一个关键概念，用于描述物联网系统中的物理实体、属性和行为。以下是ThingsBoard中的主要领域模型组件：
租户（Tenant）：租户是ThingsBoard中的顶级组织单位。它代表了一个独立的实体，可以是一个用户、组织或公司。租户拥有和管理自己的设备、客户、规则和仪表板等资源。租户之间的数据和配置是相互隔离的，每个租户都有自己的独立环境。租户由系统管理员创建和管理。
租户配置（TenantProfile）：用于定义租户级别的配置和属性。
客户（Customer）：客户是租户下的子级实体，代表了物联网系统中的用户或组织。一个租户可以包含多个客户，每个客户都有自己的访问权限和角色。客户可以访问和监控租户下的设备和数据。客户可以有自己的设备、规则和仪表板等资源，但这些资源受到租户级别的限制。客户由租户管理员创建和管理。
用户（User）：保存用户的基本信息
用户的角色（Authority）：SYS_ADMIN、TENANT_ADMIN、CUSTOMER_USER、REFRESH_TOKEN、PRE_VERIFICATION_TOKEN 用户凭证（UserCredentials）：保存用户的密码、激活用户 Token、重置密码 Token、密码使用历史 用户认证设置（UserAuthSettings）：保存用户 2FA 认证设置 用户设置（UserSettings）：保存用户的设置，包括：通用设置、通知、访问过的仪表盘等等 系统设置（AdminSettings）：是用于配置和管理整个系统的全局设置和参数，包括：通用设置、邮件、JWT、连接设置等等。
审计日志（AuditLog）
资产（Asset）：指在系统中表示和管理的物理或虚拟实体。资产可以是设备、传感器、设施、车辆、建筑物、人员或其他实体，其状态、属性和行为可以被监测、控制和管理。
资产配置（AssetProfile）：配置资产使用的默认规则链、队列、移动端仪表盘
设备（Device）：
遥测数据（TsKV）： 最新遥测数据： 属性（AttributeKvEntry）：属性类型分为客户端、服务端、共享 远程调用（Rpc） 设备凭证（DeviceCredentials）： OTA： 设备配置（DeviceProfile）：配置设备使用的默认规则链、队列、移动端仪表盘、边缘网关默认规则链、分配的固件、分配的软件、传输方式、告警规则、设置预配置
告警（Alarm）：包括字段：租户、客户、类型、明细、发起者、告警级别（严重、重要、次要、警告、不确定）、是否应答、是否清除、受理人、开始时间、结束时间、应答时间、清除时间、受理时间、是否传播、是否传播给所有者、是否传播给租户
告警评论（AlarmComment）：
实体告警（EntityAlarm）：
事件（Event）：分为异常事件、组件生命周期事件、规则链调试事件、规则节点事件、统计事件
通知（Notification）:
通知请求（NotificationRequest） 通知模版（NotificationTemplate）： 通知规则（NotificationRule） 通知对象（NotificationTarget） 流程 上报遥测数据 设备配置启用告警规则。温度大于 20 时，产生告警。温度小于 20 时，清除告警。
创建一个设备，设备凭证使用 AccessToken
使用 http api 发送遥测数据
curl -v -X POST http://localhost:8080/api/v1/gs76dj5m47yd3lm1wurd/telemetry --header Content-Type:application/json --data "{temperature:25}" 查看告警
再次发送遥测数据，可以清除告警
源码分析：
使用 http api 发送数据，入口类在 common/transport/http 模块下的 DeviceApiController 类。这个类提供了以下几个接口：
GET /api/v1/{deviceToken}/attributes POST /api/v1/{deviceToken}/attributes GET /api/v1/{deviceToken}/telemetry POST /api/v1/{deviceToken}/telemetry GET /api/v1/{deviceToken}/rpc POST /api/v1/{deviceToken}/rpc POST /api/v1/{deviceToken}/rpc/{requestId} POST /api/v1/{deviceToken}/claim GET /api/v1/{deviceToken}/firmware POST /api/v1/{deviceToken}/firmware GET /api/v1/{deviceToken}/software POST /api/v1/{deviceToken}/software POST /api/v1/provision POST /api/v1/{deviceToken}/telemetry 处理逻辑：
HttpTransportContext TransportService DefaultTransportService TbQueueProducer&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg>> ruleEngineMsgProducer TbRuleEngineQueueConsumerManager TbRuleEngineConsumerContext ActorSystemContext TbActorRef TbActorMailbox AppActor TenantActor RuleChainActor RuleChainActorMessageProcessor RuleNodeActor RuleNodeActorMessageProcessor TbDeviceProfileNode DeviceState AlarmState DefaultTbContext DefaultTbClusterService TbRuleEngineProducerProvider TbQueueProducer&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg>> toRuleEngine 这里面用到了 Transport 、Queue、Actor ，调用链非常长。</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;126 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to ThingsBoard的领域模型" href=https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>All things about ThingsBoard</h2></header><div class=entry-content><p>thingsboard 是一款乌克兰团队基于java语言研发的开源物联网框架，开源的是ce版，企业版需要购买授权且无源码。
官方网站：
Thingsboard 官网：https://thingsboard.io/
Thingsboard社区免费版本：https://demo.thingsboard.io/
Thingsboard 企业付费版本：https://thingsboard.cloud/
Thingsboard 源码：https://github.com/thingsboard/thingsboard
TBMQ 源码：https://github.com/thingsboard/tbmq
中文网：http://www.ithingsboard.com/
ThingsBoard 中文社区：https://www.thingsboard.club/
博客：
What is ThingsBoard? An Overview of ThingsBoard in 2024
How to access MQTT data with ThingsBoard | EMQ
分享｜五分钟学会使用 ThingsBoard 规则链
分享｜五分钟了解 ThingsBoard 物联网平台多种部署场景
分享｜五分钟快速学会 ThingsBoard 打包镜像和 Docker 部署
分享｜五分钟快速学会 ThingsBoard 对接物联网网关
分享｜五分钟快速学会 ThingsBoard DashBoard 基本操作
分享｜五分钟学会 ThingsBoard 本地编译运行和 Linux 部署
分享｜五分钟熟悉 ThingsBoard 前端二次开发。
https://www.cnblogs.com/east196/tag/ThingsBoard/
物联网技术学习指南 https://iot.mushuwei.cn/
物联网开源框架Thingsboard使用总结
https://www.weishadian.com/index.php/tag/thingsboard/page/5/
thingskit博客
ThingsBoard二次开发之源码分析1- 基础知识
源码分析：
ThingsBoard 源码分析 thingsboard源码解析 精尽thingsboard源码解析 https://github.com/blackstar-baba/how-2-use-thingsboard https://chenzhifu.xyz/categories/thingsboard IOT 平台：
http://iot.bctools.cn/ ThingsKit 分布式规则引擎系统，重构于开源IOT项目thingboard</p></div><footer class=entry-footer><span title='2024-04-29 00:00:00 +0000 UTC'>2024-04-29</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;80 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to All things about ThingsBoard" href=https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>TBMQ测试和源码分析</h2></header><div class=entry-content><p>启动 TBMQ 程序，浏览器访问 http://localhost:8083，创建一个 Application，Credentials Type 为 BASIC，客户端 ID、用户名和密码均设置为 tbmq_app
使用 mosquitto 测试订阅消息
mosquitto_sub -d -q 1 -h localhost -p 1883 -t tbmq/demo/+ -i 'tbmq_app' -u 'tbmq_app' -P 'tbmq_app' -c -v Debug 调试 MqttSessionHandler 类的 channelRead(ChannelHandlerContext ctx, Object msg) 方法
第一次连接，消息类型是 CONNECT
消息：
固定头：MqttFixedHeader[messageType=CONNECT, isDup=false, qosLevel=AT_MOST_ONCE, isRetain=false, remainingLength=40]
变量头：MqttConnectVariableHeader[name=MQTT, version=4, hasUserName=true, hasPassword=true, isWillRetain=false, isWillFlag=false, isCleanSession=false, keepAliveTimeSeconds=60]
负载：MqttConnectPayload[clientIdentifier=tbmq_app, willTopic=null, willMessage=null, userName=tbmq_app, password=[116, 98, 109, 113, 95, 97, 112, 112]]
address 为空，故从 ChannelHandlerContext 获取客户端地址，并将地址保持到客户端 Session 上下文 ClientSessionCtx
初始化 Session：获取 clientI、mqtt 版本，调用 ClientMqttActorManager 初始化 session：创建 clientActorRef，发送一个 SessionInitMsg 消息
调用 ClientMqttActorManager connect 方法，发送一个 MqttConnectMsg 消息
第二次连接，消息类型是 SUBSCRIBE
MqttSubscribeMessage[fixedHeader=MqttFixedHeader[messageType=SUBSCRIBE, isDup=false, qosLevel=AT_LEAST_ONCE, isRetain=false, remainingLength=16], variableHeader=MqttMessageIdAndPropertiesVariableHeader[messageId=1, properties=io....</p></div><footer class=entry-footer><span title='2024-04-28 00:00:00 +0000 UTC'>2024-04-28</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;393 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to TBMQ测试和源码分析" href=https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ThingsBoard TBMQ本地和通过Docker运行</h2></header><div class=entry-content><p>docker-compose 运行 参考：https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/
下载源代码
git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git cd tbmq/docker 创建逻辑卷并执行安装程序
./scripts/docker-create-volumes.sh ./scripts/docker-install-tbmq.sh 运行服务
./scripts/docker-start-services.sh 浏览器访问：http://localhost:8083，用户名/密码：sysadmin@thingsboard.org / sysadmin
查看 HaProxy 日志，发现出现异常：Error: Specified qdisc kind is unknown. 。
目前，尚未找到解决办法，只能不使用 HaProxy 而是直接访问 tbmq1，修改 docker-compose.yml ，暴露容器端口 8083 到本地的 8083：
tbmq1: restart: always container_name: "${TBMQ_1_NAME}" image: "${DOCKER_REPO}/${DOCKER_NAME}:${TBMQ_VERSION}" ports: - "1883" - "8083:8083" #修改这里 - "8084" 然后，通过浏览器访问 浏览器访问：http://localhost:8081
源码编译并运行 安装好 JDK 17+ 和 Maven3.6.3+
下载源代码
git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git cd tbmq 编译代码
mvn clean install -DskipTests 通过 docker-compose 本地安装 postgres、kafka、redis
参考 docker 目录下的文件新建 docker-compose.postgres.yml 文件：
version: '3.0' services: postgres: restart: always image: postgres:15 ports: - "5432:5432" environment: POSTGRES_DB: thingsboard_mqtt_broker POSTGRES_PASSWORD: postgres volumes: - postgres-data:/var/lib/postgresql/data volumes: postgres-data: 新建 docker-compose....</p></div><footer class=entry-footer><span title='2024-04-17 00:00:00 +0000 UTC'>2024-04-17</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;191 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to ThingsBoard TBMQ本地和通过Docker运行" href=https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>All things about MicroProfile</h2></header><div class=entry-content><p>最近在一些开源项目中看到了 MicroProfile ，于是在网上查阅了相关资料加深对 MicroProfile 的理解，并做了笔记形成此文。
MicroProfile MicroProfile是一个开放的企业级Java微服务框架，旨在简化和标准化基于微服务架构的应用程序开发。它是由Eclipse Foundation主导的一个开源项目，致力于提供轻量级、可移植和可互操作的Java微服务规范和实现。
MicroProfile的目标是为Java开发人员提供一个规范集合，使他们能够更轻松地构建和部署云原生应用程序。它结合了Java EE、Jakarta EE和其他相关规范，为开发人员提供了一组核心功能和扩展，以支持构建可伸缩、弹性和高性能的微服务应用程序。
MicroProfile提供了一系列的规范，包括：
MicroProfile Config MicroProfile JWT RBAC MicroProfile Health MicroProfile Fault Tolerance MicroProfile Metrics MicroProfile OpenAPI MicroProfile OpenTracing MicroProfile REST Client MicroProfile Context Propagation MicroProfile Reactive Streams Operators MicroProfile Reactive Messaging MicroProfile GraphQL MicroProfile Long Running Actions MicroProfile Telemetry MicroProfile 实现：
Payara Micro：是一个用于容器化Jakarta EE应用部署的轻量级中间件平台，不需要安装、配置或重写代码，可以快速部署 WildFly by Redhat：是一个轻量级、模块化的微服务框架，集中、简单、以用户为中心，实现了Jakarta EE和Eclipse MicroProfile的最新企业Java标准。 Quarkus by RedHat：为GraalVM和OpenJDK HotSpot构建的Kubernetes Native Java堆栈，由最佳的Java库和标准精心打造。 Apache TomEE：这是Apache Tomcat Java企业版，它结合了几个Java企业项目，包括Apache OpenEJB、Apache OpenJPA、Apache OpenWebBeans、Apache MyFaces和其他许多项目。 Hammock：这是一个基于CDI的bootstrapping Java企业微服务框架，由于其灵活性和简单性，用于构建应用程序 Openliberty：是一个开源的轻量级Java EE微服务框架，用于构建快速高效的云原生Java微服务应用，只运行所需的服务，同时考虑最新的Eclipse MicroProfile标准 Helidon by Oracle：这是一个Java库的集合，用于编写在快速的Helidon Reactive WebServer上运行的Java微服务，这是一个由Netty驱动的Web核心，同时支持MicroProfile及其标准规范。 KumuluzEE：是一个轻量级框架，用于使用标准的Java/JavaEE/JakartaEE/EE4J技术和API开发微服务，可选择扩展，如使用Node.js、Go和其他语言，并将现有应用程序迁移到云原生架构和微服务，以便更容易地进行云原生微服务开发。 Launcher by Fujitsu：它由富士通公司开发，是一个支持某些MicroProfile规范的Java EE微服务框架，可以将应用捆绑到über-jar/fat文件（JAR文件，包含其所有需要的依赖项） ThornTail (过时的)：是一个Java企业级微服务框架，它只将需要的和指定的包捆绑到一个JAR文件中，并有足够的运行时间来运行它们 MicroProfile发展历史 Infoq 上有一段介绍：
2016 年年中，作为对 Oracle 在发布 Java EE 8 方面停滞不前的直接回应，社区发起了两个新的倡议，也就是MicroProfile和 Java EE Guardians（现在被称为Jakarta EE Ambassadors）。Java 社区认为，随着用于构建微服务应用的 web 服务技术的出现，企业级 Java 已经落后于时代了。...</p></div><footer class=entry-footer><span title='2023-12-14 00:00:00 +0000 UTC'>2023-12-14</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;366 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to All things about MicroProfile" href=https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JHipster安装和介绍</h2></header><div class=entry-content><p>JHipster 是一个开发平台，可以快速生成，开发和部署现代 Web 应用程序+微服务架构。
JHipster 或者称 Java Hipster，是一个应用代码产生器，能够创建 Spring Boot/Spring Cloud + React/VueJs/AngularJS 的应用。使用 JHipster，首先你要配置好 Java 、Git 以及 Maven 或者 Gradle 的环境，然后通过 NodeJs 管理工具安装 JHipster 。
介绍 JHipster 官网： https://www.jhipster.tech/ ，截止本文发布时，最新版本为 8.0.0 。
JHipster 客户端使用到的技术栈有：
服务端使用的技术栈有：
支持以下部署方式：
JHipster 提供了一个 CLI 工具 generator-jhipster 和在线网站 https://start.jhipster.tech/ ，来创建应用。generator-jhipster 支持本地安装和 docker 安装两种方式。另外，还有一个轻量级的定制工具 jhipseter-lite 可以更细力度的定制。
JHipster Pro 是一个 JHipster 国内落地方案，符合国情的代码生成器解决方案，支持 MyBatis、SMS、OSS。当前最新版本对应 JHipster 官方版本：v7.1.0，网站最近一次跟新是在 2021 年 8 月份。
安装 generator-jhipster 前提条件安装 Java 和 NodeJs，然后通过 npm 或者 yarn 安装 generator-jhipster。以下是通过 npm 安装：
npm install -g generator-jhipster 查看版本：
$ npx jhipster --version 8.0.0-rc.1 另外，可以在 docker 里面安装：
docker image pull jhipster/jhipster docker container run --name jhipster -v ~/jhipster:/home/jhipster/app -v ~/....</p></div><footer class=entry-footer><span title='2023-11-02 00:00:00 +0000 UTC'>2023-11-02</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1089 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to JHipster安装和介绍" href=https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/categories/java/page/5/>«&nbsp;Prev&nbsp;5/13
</a><a class=next href=https://blog.chensoul.cc/categories/java/page/7/>Next&nbsp;7/13&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>