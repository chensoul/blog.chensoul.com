<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | ChenSoul</title>
<meta name=keywords content><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/categories/java/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/categories/java/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/categories/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Java"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/categories/java/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Java
<a href=/categories/java/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Circuit Breaker</h2></header><div class=entry-content><p>本文主要介绍 Circuit Breaker 断路器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。
在一个分布式系统中，不可避免地会出现许多外部依赖，如数据库、网络服务等。这些外部依赖可能会发生故障、延迟或不可用的情况。如果没有适当的措施，这些故障可能会导致整个系统的性能下降，甚至系统崩溃。
断路器模式通过在应用程序和外部依赖之间引入一个断路器接口来解决这个问题。断路器接口充当一个中间层，监视对外部依赖的调用。当外部依赖发生故障时，断路器可以迅速地中断对外部依赖的调用，避免资源的浪费和故障的传递。
除了断路器接口之外，断路器模式还涉及以下几个重要的知识点：
故障阈值（Failure Threshold）：断路器模式通过设置故障阈值来判断服务的健康状态。当服务的失败次数达到或超过故障阈值时，断路器会打开，阻止对服务的进一步调用。 回退响应（Fallback Response）：当断路器打开时，可以为调用方提供回退响应。回退响应是一个预定义的响应，用于代替无法正常调用的服务的响应。回退响应可以是事先定义好的静态响应，或者是通过调用备用服务来获取的响应。 断路器状态（Circuit Breaker State）：断路器可以处于不同的状态，如关闭（Closed）、打开（Open）和半开（Half-Open）。初始状态通常是关闭状态，表示服务正常可用。当服务的失败次数达到故障阈值时，断路器会打开，阻止对服务的进一步调用。在一定时间后，断路器会进入半开状态，允许发起一次测试调用。如果测试调用成功，断路器将重新关闭；如果测试调用仍然失败，断路器将重新打开。 断路器的自动恢复（Automatic Recovery）：断路器模式通常具有自动恢复功能。在断路器打开的状态下，一段时间过去后，断路器会尝试重新关闭，以允许对服务的正常调用。自动恢复可以防止长时间的服务中断，提供给服务一个机会来恢复正常运行。 健康检查（Health Check）：断路器模式可以通过定期的健康检查来监控服务的状态。健康检查可以是定期发送心跳请求或执行一些特定的健康检查操作。通过健康检查，可以及时发现服务的故障或不可用状态，并相应地打开断路器。 示例 首先，您需要创建一个监控服务类，它将使用断路器来包装远程服务的调用。以下是一个示例监控服务类的代码：
public class MonitoringService { private final CircuitBreaker delayedService; private final CircuitBreaker quickService; public MonitoringService(CircuitBreaker delayedService, CircuitBreaker quickService) { this.delayedService = delayedService; this.quickService = quickService; } public String localResourceResponse() { return "Local Service is working"; } public String delayedServiceResponse() { try { return this.delayedService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } public String quickServiceResponse() { try { return this.quickService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } } 在上述代码中，MonitoringService 类接受两个断路器对象作为参数，分别用于包装延迟服务和快速服务的远程调用。它还包含一个用于获取本地资源的方法。...</p></div><footer class=entry-footer><span title='2023-10-26 00:00:00 +0000 UTC'>2023-10-26</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;884 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Circuit Breaker" href=https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Chain</h2></header><div class=entry-content><p>本文主要介绍 Chain 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
目的 通过给多个对象一个处理请求的机会，避免请求的发送者和它的接收者耦合。串联接收对象并在链条中传递请求直到一个对象处理它。
介绍 责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象按照顺序处理请求，直到其中一个对象能够处理该请求为止。该模式将请求发送者和接收者解耦，使多个对象都有机会处理请求，同时避免请求发送者与接收者之间的直接耦合。
在责任链模式中，通常会构建一个处理请求的链条，链条上的每个对象都有一个指向下一个对象的引用。当请求到达链条的起点时，它会依次经过链条上的每个对象，直到找到能够处理请求的对象为止。每个对象都可以决定是否处理请求，或者将请求传递给下一个对象。
以下是责任链模式的几个关键角色：
抽象处理器（Handler）：定义处理请求的接口，并包含一个指向下一个处理器的引用。通常会提供一个处理请求的方法。 具体处理器（ConcreteHandler）：实现抽象处理器的接口，具体处理请求的逻辑。如果自己无法处理请求，则将请求传递给下一个处理器。 客户端（Client）：创建责任链，并将请求发送给链条的起点。 下面是一个示例，说明如何使用责任链模式处理请求：
// 抽象处理器 public abstract class Handler { protected Handler nextHandler; public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } public abstract void handleRequest(Request request); } // 具体处理器 public class ConcreteHandler1 extends Handler { @Override public void handleRequest(Request request) { if (满足处理条件) { // 处理请求的逻辑 } else if (nextHandler != null) { // 将请求传递给下一个处理器 nextHandler.handleRequest(request); } } } // 具体处理器2和具体处理器3的定义与具体处理器1类似 // 客户端 public class Client { public static void main(String[] args) { Handler handler1 = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); Handler handler3 = new ConcreteHandler3(); // 构建责任链 handler1....</p></div><footer class=entry-footer><span title='2023-10-16 00:00:00 +0000 UTC'>2023-10-16</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;324 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Chain" href=https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Boot3和Spring6中的新特性</h2></header><div class=entry-content><p>Spring Boot 3.0 于 2022 年 11 月正式发布，包含一些新功能和改进。这是继大约 4.5 年前发布 Spring Boot 2.0 后 Spring Boot 的第一个主要版本。它也是第一个支持 Spring Framework 6.0 的 Spring Boot GA 版本。作为开发人员，我们需要了解这些更新，才能顺利使用 Spring Boot。毫无疑问，新版本中最大的转变之一是放弃了对旧版本 Java 的支持。
在本文中，我们将讨论“Spring Boot 3 和 Spring 6 中的新功能”。
Spring 3.0 版本有哪些主要亮点？ Spring 3.0 版本的亮点包括：
Java 17 基线 支持 Jakarta EE 10 和 EE 9 基线 支持使用 GraalVM 生成本机映像，取代实验性 Spring Native 项目 通过测微计和测微计追踪提高了可观测性 谁可以真正使用 Spring Boot 3？ 如前所述，Spring Boot 3.0 最大的转变是忽略了对旧版本 Java 的支持。是的，我们至少需要 Java 17 才能使用 Spring Boot 3.0。因此，在使用 Spring Boot 3.0 之前必须具备 JDK 17 环境。
Spring Boot 3 和 Spring 6 有哪些新功能？ 这里需要注意的重要一点是 Spring Boot 3.0 构建于 Spring Framework 6 之上并需要 Spring Framework 6。因此，如果您的 pom....</p></div><footer class=entry-footer><span title='2023-10-13 00:00:00 +0000 UTC'>2023-10-13</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;703 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Boot3和Spring6中的新特性" href=https://blog.chensoul.cc/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Callback</h2></header><div class=entry-content><p>本文主要介绍 Callback 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 回调（Callback）是一种设计模式，在这种模式中，一个可执行的代码被作为参数传递给其他代码，接收方的代码可以在适当的时候调用它。
在真实世界的例子中，当我们需要在任务完成时被通知时，我们可以将一个回调方法传递给调用者，并等待它调用以通知我们。简单地说，回调是一个传递给调用者的方法，在定义的时刻被调用。
维基百科说
在计算机编程中，回调又被称为“稍后调用”函数，可以是任何可执行的代码用来作为参数传递给其他代码；其它代码被期望在给定时间内调用回调方法。
代码 回调是一个只有一个方法的简单接口。
public interface Callback { void call(); } 下面我们定义一个任务它将在任务执行完成后执行回调。
public abstract class Task { final void executeWith(Callback callback) { execute(); Optional.ofNullable(callback).ifPresent(Callback::call); } public abstract void execute(); } public final class SimpleTask extends Task { private static final Logger LOGGER = getLogger(SimpleTask.class); @Override public void execute() { LOGGER.info("Perform some important activity and after call the callback method."); } } 最后这里是我们如何执行一个任务然后接收一个回调当它完成时。
var task = new SimpleTask(); task.executeWith(() -> LOGGER.info("I'm done now.")); 类图 适用场景 回调模式适用于以下场景：
异步操作：当需要在异步操作完成后执行某些操作时，可以使用回调模式。例如，在网络请求中，可以传递一个回调函数，在请求完成后调用该函数处理响应数据。 事件处理：当需要对事件进行响应和处理时，可以使用回调模式。例如，在图形界面开发中，可以注册某个控件的回调函数，以便在用户触发事件时执行相应的操作。 插件扩展：当需要为应用程序提供扩展性，允许第三方插件在特定事件发生时进行自定义操作时，可以使用回调模式。例如，游戏引擎中的事件系统允许开发者注册回调函数以响应游戏中的特定事件。 回调链：当需要按特定顺序执行多个回调函数，并将前一个回调函数的结果传递给下一个回调函数时，可以使用回调模式。这种情况下，回调函数形成了一个回调链。 模板方法模式：回调模式常与模板方法模式结合使用。模板方法模式定义了一个算法的骨架，而具体的步骤由子类实现。可以使用回调模式将子类中的具体步骤作为回调函数传递给模板方法。 总的来说，回调模式适用于需要在特定事件发生后执行某些操作的情况，以及需要实现解耦和灵活性的场景。它提供了一种在代码间通信的方式，使得代码可以更加模块化和可复用。
Java 例子 CyclicBarrier 构造函数可以接受回调，该回调将在每次障碍被触发时触发。 FAQ 回调模式如何实现解耦和灵活性？ 回调模式通过将一个可执行的代码块（回调函数）作为参数传递给其他代码，实现了解耦和灵活性。
解耦性：回调模式可以将调用方与被调用方解耦，使它们之间的关系更加松散。调用方只需要知道回调函数的接口，而不需要了解具体的实现细节。被调用方在特定的时机调用回调函数，而不需要知道调用方的具体实现。这种解耦性使得系统中的不同部分可以独立地进行修改和扩展，而不会对彼此产生过多的依赖。
灵活性：回调模式提供了一种灵活的扩展机制。通过传递不同的回调函数，可以改变程序的行为或逻辑，而不需要修改原有的代码。这种灵活性使得系统可以适应不同的需求和变化，而不需要进行大规模的修改或重构。同时，回调模式也允许在运行时动态地修改回调函数，从而实现更高级的动态行为。...</p></div><footer class=entry-footer><span title='2023-10-13 00:00:00 +0000 UTC'>2023-10-13</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;300 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Callback" href=https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security 面试问题</h2></header><div class=entry-content><p>本面试准备指南将讨论一些常见的 Spring Security 面试问题。无论您是准备面试还是只是想增强对 Spring Security 的了解，这些问题都将帮助您理解关键概念并指导您设计常见安全问题的解决方案。
1. Spring Security 的核心特性是什么？ Spring Security 提供的两个最突出的功能是身份验证和授权。这些功能在确保应用程序的安全性方面发挥着至关重要的作用。然而，Spring Security 超越了身份验证和授权，还提供了额外的功能来防止漏洞利用并与其他框架集成。
1.1.验证 身份验证是验证尝试访问应用程序的用户身份的过程。 Spring Security 提供多种身份验证方法（基于表单的身份验证、HTTP 基本身份验证、OAuth2、Siteminder、OpenID Connect、LDAP、JDBC 等），允许应用程序使用各种方法对用户进行身份验证。
它还支持自定义，当默认选项不满足要求时，可以实现自定义的身份验证机制。
1.2.授权 授权是向经过身份验证的用户或实体授予许可或权利的过程。用户或实体成功通过身份验证后，授权将决定他们可以在应用程序中访问哪些操作或资源。 Spring Security 为开发人员提供了多种方法来实现授权并控制用户对应用程序不同部分的访问。以下是一些常见的方法：
基于 Web URL 的授权：可以根据特定的 URL 或 URL 模式实施访问控制，规范哪些用户可以访问某些资源。 方法级授权：如果需要，甚至可以对 Java Bean 中的方法进行访问控制，从而在方法级提供细粒度的授权。 域实例级授权：Spring Security 提供了控制对特定域实例的访问的能力，允许基于某些实体的所有权或关联进行授权。 1.3.防止漏洞利用 Spring Security 提供了多种功能来防范常见的 Web 应用程序安全漏洞。一些显着的功能包括：
跨站请求伪造 (CSRF) 保护：Spring Security 会自动将 CSRF 令牌添加到表单和 AJAX 请求中，从而防止 CSRF 攻击。 跨站脚本 (XSS) 保护：Spring Security 支持输出编码，并提供实用程序通过清理用户输入来防止 XSS 攻击。 点击劫持保护：Spring Security 包括 X-Frame-Options 支持，以防止点击劫持攻击。 1.4.集成 Spring Security 与其他框架和库无缝集成，以增强应用程序的安全性。一些关键的集成是：
Spring MVC：Spring Security 与 Spring MVC 集成，为 Web 应用程序提供无缝的安全功能。它可以安全地处理请求、身份验证、授权并防止常见的 Web 漏洞。 Spring Data：Spring Security 与 Spring Data 集成，以便在查询中引用当前用户。这种集成确保可以根据身份验证和授权规则轻松访问和过滤用户特定的数据。 Jackson：Jackson 的支持可以实现 Spring Security 相关类的高效序列化和反序列化，特别是在使用分布式会话或 Spring Session 等框架时，从而提高效率和可扩展性。 密码学：Spring Security 与各种密码库和算法集成，以提供敏感信息的安全存储和传输。这种集成包括密码散列、加密和安全通信协议等功能，以保护数据的机密性和完整性。 有关 Spring Security 功能的更详细信息，请参阅官方文档。...</p></div><footer class=entry-footer><span title='2023-10-12 00:00:00 +0000 UTC'>2023-10-12</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1336 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security 面试问题" href=https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Caching</h2></header><div class=entry-content><p>本文主要介绍 Caching 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 缓存模式（Caching Pattern）是一种设计模式，旨在通过在资源使用后将其保留在某个快速访问的存储中，并在需要时重新使用资源，以避免昂贵的资源重新获取。
缓存模式的目的是减少重复获取、初始化和释放同一资源所带来的不必要性能开销。通过将资源保留在缓存中，可以避免再次获取资源，从而提高系统的响应速度和性能。
在缓存模式中，当需要访问资源时，首先检查缓存中是否存在该资源的副本。如果缓存中存在资源，则直接从缓存中获取并返回给调用方。如果缓存中不存在资源，则需要从原始数据源或其他途径获取资源，并将其存储在缓存中，以供后续使用。
缓存模式适用于那些需要频繁访问、计算成本较高的资源的情况，例如数据库查询、网络请求、文件读写等。通过使用缓存模式，可以显著提升系统的性能和响应速度，减少对原始数据源的访问次数，从而降低系统的负载。
关于缓存模式的更多信息和实现方式，您可以参考以下资源：
Write-Through, Write-Around, Write-Back: Cache Explained：对缓存模式进行了详细解释和说明，提供了不同的缓存策略和实现方式。 Read-Through, Write-Through, Write-Behind, and Refresh-Ahead Caching：介绍了不同类型的缓存操作和策略，包括读取、写入、刷新等。 Cache-Aside Pattern：介绍了缓存模式中的一种常见实现方式，即"Cache-Aside"模式，包括其工作原理和使用方法。 实现策略 缓存模式有多种常见的实现策略，以下是其中一些常见的实现策略：
写入穿透（Write-Through）：当从数据源获取数据时，将数据同时写入缓存。这样，在下一次需要相同数据时，可以从缓存中获取，避免再次访问数据源。写入穿透策略确保缓存中始终保持最新的数据。 写入回写（Write-Back）：在数据发生变化时，首先将数据写入缓存，然后再定期将缓存中的数据批量写回到数据源。写入回写策略可以减少对数据源的频繁写入操作，提高性能。 写入旁路（Write-Around）：将写操作直接发送到数据源，而不是通过缓存。这样可以避免将不经常访问的数据写入缓存，从而节省缓存空间。只有当数据被读取时，才会将其放入缓存。 刷新预取（Refresh-Ahead）：在缓存中存储数据的同时，预先获取和更新与当前数据相关的其他数据。这样，当需要访问相关数据时，可以直接从缓存中获取，减少等待时间。 最近最少使用（Least Recently Used, LRU）：根据数据的访问频率和时间进行缓存淘汰。当缓存空间不足时，优先淘汰最近最少被访问的数据，以保留最常用的数据。 固定时间过期（Time-To-Live, TTL）：为缓存中的每个数据项设置一个固定的过期时间。一旦数据项超过过期时间，将被视为过期并从缓存中移除。 异步刷新（Asynchronous Refresh）：在数据过期或无效时，通过异步方式从数据源获取新数据并更新缓存。这样可以避免阻塞调用方，提高系统的响应速度。 缓存框架 当涉及到缓存框架或工具时，有几个常见且广泛使用的选项可以考虑。以下是其中一些常见的缓存框架或工具：
Ehcache: Ehcache 是一个流行的开源 Java 缓存框架，提供了各种缓存策略和功能，包括内存缓存、磁盘缓存、分布式缓存等。它易于使用且性能优秀，可以轻松集成到 Java 应用程序中。 Redis: Redis 是一个开源的高性能内存数据结构存储系统，也可以用作缓存。它支持多种数据结构和丰富的缓存功能，如数据过期、持久化、分布式缓存等。Redis 可以作为独立的缓存服务器，也可以与应用程序集成使用。 Memcached: Memcached 是一个简单而高效的分布式内存对象缓存系统。它以键值对的形式存储数据，并提供了分布式缓存的支持。Memcached 适用于高并发环境下的缓存需求，可以减轻后端数据库的压力。 Caffeine: Caffeine 是一个基于 Java 的高性能缓存库，专注于提供快速的缓存访问和高效的内存管理。它支持各种缓存策略和功能，并提供了线程安全和异步加载等特性。 Hazelcast: Hazelcast 是一个开源的分布式数据存储和计算平台，其中包括了分布式缓存的功能。它提供了高可用性和可扩展性，并支持多种缓存策略和分布式缓存模式。 Guava Cache: Guava Cache 是 Google 的 Guava 库中提供的一个本地缓存实现。它提供了简单易用的 API，支持各种缓存策略和功能，如过期时间、最大缓存大小、缓存统计等。 Apache Ignite: Apache Ignite 是一个内存计算平台，提供了分布式缓存和计算能力。它可以作为一个分布式缓存存储数据，并支持 SQL 查询、分布式计算、流处理等功能。 Couchbase: Couchbase 是一个面向企业应用的 NoSQL 数据库和缓存平台。它提供了可扩展的内存缓存功能，并支持数据持久化和分布式缓存集群。 Aerospike: Aerospike 是一个高性能的 NoSQL 数据库和缓存平台，专注于提供低延迟和高吞吐量的数据访问。它支持内存和闪存存储，并具有分布式缓存的功能。 Oracle Coherence: Oracle Coherence 是一个企业级的分布式缓存和数据网格解决方案。它提供了高可用性、可扩展性和事务支持，并支持多种缓存策略和数据复制模式。</p></div><footer class=entry-footer><span title='2023-09-25 00:00:00 +0000 UTC'>2023-09-25</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;98 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Caching" href=https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Bytecode</h2></header><div class=entry-content><p>本文主要介绍 Bytecode 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 字节码设计模式是一种软件设计模式，它允许以数据驱动的方式定义和执行行为。在字节码设计模式中，行为被表示为一系列虚拟机指令，这些指令被编码为字节码，并在运行时执行。
字节码设计模式的目的是将行为与代码分离，使得行为可以在不修改源代码的情况下进行动态调整和扩展。通过将行为以数据的形式表示，并使用字节码指令进行执行，可以实现更灵活和可配置的行为逻辑。
下面是字节码设计模式的一些关键要点：
指令集：字节码设计模式通过定义一组指令集来表示不同的行为。每个指令都有自己的语义和操作方式，用于执行特定的行为逻辑。 虚拟机：字节码设计模式需要一个虚拟机来执行指令集。虚拟机负责解释和执行字节码指令，并根据指令的要求进行相应的操作。 数据驱动的行为：字节码设计模式的核心思想是将行为表示为数据而不是代码。行为逻辑由字节码指令和相关数据组成，这些数据可以在运行时进行修改和配置，从而改变程序的行为。 动态性和灵活性：由于行为以数据形式存在，并且可以在运行时进行调整，字节码设计模式具有很高的动态性和灵活性。这使得开发人员可以根据需要动态地配置和修改行为，而无需修改源代码。 可重用性和扩展性：字节码设计模式提供了一种可重用和可扩展的方式来定义行为。通过定义不同的指令和指令集，可以构建具有不同行为的模块，并在不同的上下文中重复使用这些模块。 字节码设计模式在游戏开发、模拟器、脚本引擎等领域中具有广泛的应用。它使得开发人员能够以更灵活和动态的方式定义和管理程序的行为，从而提供了更高的可配置性和可扩展性。
举例 一个常见的例子是在游戏开发中使用字节码设计模式来定义角色的行为。假设我们有一个角色类（Character），它具有各种行为，例如攻击、防御、移动等。而这些行为的具体逻辑可能会根据游戏的需求而变化。
使用字节码设计模式，我们可以将角色的行为表示为一系列字节码指令，并通过虚拟机来执行这些指令，以实现角色的行为逻辑。
下面是一个简化的示例：
定义指令集： 我们定义一组指令来表示角色的行为，例如： ATTACK：进行攻击操作 DEFEND：进行防御操作 MOVE：进行移动操作 创建虚拟机： 我们创建一个虚拟机（VirtualMachine）类，它接收字节码作为输入，并执行相应的指令。虚拟机可以解释字节码指令，并根据指令的要求执行相应的行为逻辑。
定义角色行为： 我们创建一个角色（Character）类，它包含一个字节码数组，用于表示角色的行为。例如：
byte[] bytecode = {ATTACK, MOVE, ATTACK, DEFEND}; 执行角色行为： 我们将角色的字节码传递给虚拟机，并执行角色的行为逻辑：
VirtualMachine vm = new VirtualMachine(); vm.execute(bytecode); 虚拟机会解释字节码指令，并根据指令执行相应的行为。例如，当遇到 ATTACK 指令时，虚拟机会执行攻击操作；当遇到 MOVE 指令时，虚拟机会执行移动操作，依此类推。
除了游戏开发之外，字节码设计模式还在其他领域中有一些应用。以下是一些常见的应用领域：
脚本引擎：字节码设计模式可用于实现脚本引擎，其中脚本语言的行为逻辑被表示为字节码指令。这种设计使得脚本的执行可以更高效和灵活，同时还可以提供动态性和扩展性。 模拟器：在模拟器开发中，字节码设计模式可以用于定义和执行模拟器的指令集。模拟器可以通过解释和执行字节码指令来模拟不同的操作和行为，从而实现对特定系统或环境的模拟。 动态编程语言：一些动态编程语言（如 Python、Ruby 等）使用字节码设计模式来实现动态性和灵活性。这些语言将代码编译为字节码，并使用虚拟机来执行字节码指令，从而提供动态类型、动态绑定和运行时修改代码等特性。 JIT 编译器：即时编译器（Just-in-Time Compiler）可以使用字节码设计模式来实现代码的即时编译和优化。在运行时，即时编译器将字节码转换为本地机器码，并对代码进行优化，以提高执行效率。 领域特定语言（DSL）：字节码设计模式可以用于开发领域特定语言，其中 DSL 的行为逻辑被表示为字节码指令。这种设计使得 DSL 的执行更高效，并提供了更大的灵活性和可配置性。 需要注意的是，字节码设计模式的应用不仅限于以上领域，它可以在需要动态性、灵活性和可配置性的任何领域中发挥作用。由于字节码设计模式提供了一种将行为表示为数据的方式，使得行为可以在运行时进行调整和修改，因此在许多软件开发和系统设计的场景中都具有潜在的应用价值。
适用场景 字节码设计模式适用于以下场景：
动态行为需求：当系统需要在运行时动态地定义、配置或修改行为时，字节码设计模式可以提供一种灵活的方式。它允许将行为表示为字节码指令，以便在需要时进行调整和修改，而无需修改源代码。 可配置性和可扩展性要求：如果系统需要具有高度可配置和可扩展的行为逻辑，字节码设计模式可以提供一种解决方案。通过将行为表示为字节码指令和相关数据，开发人员可以轻松地定义和管理不同的行为模块，并在不同的上下文中重复使用这些模块。 脚本引擎和动态语言实现：字节码设计模式可以用于实现脚本引擎或支持动态语言的运行时环境。它可以将脚本行为表示为字节码指令，从而提供动态性、灵活性和执行效率。 模拟和仿真系统：在模拟和仿真系统中，字节码设计模式可以用于定义和执行模拟器的行为。通过使用字节码指令来表示各种操作和行为，可以实现对特定系统或环境的准确模拟。 编译器和优化器开发：字节码设计模式可用于开发编译器、优化器和即时编译器。它提供了一种将源代码转换为字节码指令，并在运行时进行优化和执行的方式，以提高程序的性能和效率。 总的来说，字节码设计模式在需要动态性、灵活性、可配置性和可扩展性的场景中都有应用价值。它可以用于开发各种类型的系统，包括游戏引擎、脚本引擎、模拟器、编译器、优化器等。</p></div><footer class=entry-footer><span title='2023-09-22 00:00:00 +0000 UTC'>2023-09-22</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;73 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Bytecode" href=https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]SPRING BOOT JWT - 如何使用 SPRING SECURITY 和 JSON WEB 令牌保护您的 REST API</h2></header><div class=entry-content><p>如果您快速搜索如何使用 JSON Web Tokens 在 Spring Boot 中保护 REST API，您会发现很多相同的结果。这些结果包含一种方法，该方法涉及编写自定义过滤器链并引入第三方库来编码和解码 JWT。
在看完这些令人费解且令人困惑的教程后，我说必须有一种更简单的方法来做到这一点。我做了任何直接接触 Spring Security 团队的人都会做的事情，我向他们寻求帮助。他们告诉我，Spring Security 确实使用 oAuth2 资源服务器内置了对 JWT 的支持。
在本教程中，您将学习如何使用 JSON Web Tokens (JWT) 和 Spring Security 来保护您的 API。我并不是说这种方法无论如何都很容易，但对我来说，它比其他选择更有意义。
Github 存储库
应用架构 在我们开始编写一些代码之前，我想确保我们对于我们正在构建的内容都达成共识。在下面的示例中，您有一个客户端应用程序，它可以是一个简单的命令行应用程序、一个用 Angular 或 Vue 等编写的完整前端应用程序，或者系统中的其他一些服务。
该客户端应用程序将调用使用 Spring Boot 编写的服务器应用程序，该应用程序通过 REST API 公开数据。在下面的示例中，它是一个整体，但如果您有分布式架构，则同样适用。当前有 3 个 REST 控制器公开资源产品、订单和客户。
您要做的是保护所有资源，以便当客户端调用 REST API 时，客户端将收到 401（未经授权），这意味着客户端请求尚未完成，因为它缺少所请求资源的有效身份验证凭据。
JSON 网络令牌 (JWT) JSON Web 令牌是一种开放方法，用于在两方之间安全地表示声明。 JWT 是一组声明（JSON 属性-值对），它们共同构成一个 JSON 对象。它由三部分组成：
Header: 由两个属性组成：{ “alg”: “HS256”, “typ”: “JWT” }。 alg 是用于加密 JWT 的算法。 Payload: 这是存储要发送的数据的地方；该数据存储为 JSON 属性-值对。 Signature: 这是通过加密创建的，使用标头中指定的算法：（i）base64Url 编码的标头，（ii）base64Url 编码的有效负载，以及（iii）秘密（或私钥）： HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret|privateKey) 最终的 JWT 由三部分组成。每个都是 base64Url 编码的，并且与下一个之间用点分隔。有关更多详细信息，请参阅 openid.net 和 jwt.io 网站。...</p></div><footer class=entry-footer><span title='2023-09-19 00:00:00 +0000 UTC'>2023-09-19</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;907 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]SPRING BOOT JWT - 如何使用 SPRING SECURITY 和 JSON WEB 令牌保护您的 REST API" href=https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security 与 JWT for REST API</h2></header><div class=entry-content><p>免责声明：Spring Security 5+ 已发布 OAuth JWT 支持。建议使用最新版本的 OAuth 来支持 JWT，而不是使用自定义安全性或过滤器。
Spring 被认为是 Java 生态系统中值得信赖的框架，并且被广泛使用。将 Spring 称为框架不再有效，因为它更多的是涵盖各种框架的总括术语。其中一个框架是 Spring Security，它是一个功能强大且可定制的身份验证和授权框架。它被认为是保护基于 Spring 的应用程序的事实标准，因此，如果您希望实现 Spring JWT 令牌解决方案，那么将其基于 Spring Security 是有意义的。
尽管它很受欢迎，但我必须承认，当涉及到单页应用程序时，Spring 的配置并不简单和直接。我怀疑原因是它更多地是作为一个面向应用程序的 MVC 框架开始的，其中网页渲染发生在服务器端，并且通信是基于会话的。
如果后端基于 Java 和 Spring，那么使用 Spring Security 和 JWT 进行身份验证/授权并将其配置为无状态通信是有意义的。虽然有很多文章解释了这是如何完成的，但对我来说，第一次设置它仍然令人沮丧，我必须阅读并总结来自多个来源的信息。这就是我决定编写这个 Spring Security 教程的原因，我将在其中尝试总结并涵盖您在配置过程中可能遇到的所有必需的微妙细节和缺陷。
术语定义 在深入探讨技术细节之前，我想明确定义 Spring Security 上下文中使用的术语，以确保我们都使用相同的语言。 这些是我们需要解决的术语：
Authentication 验证是指根据提供的凭据验证用户身份的过程。一个常见的示例是在登录网站时输入用户名和密码。您可以将其视为对“您是谁？”这个问题的答案。 Authorization 授权是指假设用户已成功通过身份验证，则确定用户是否具有执行特定操作或读取特定数据的适当权限的过程。您可以将其视为“用户可以执行/阅读此操作吗？”问题的答案。 Principle 原则是指当前经过身份验证的用户。 Granted authority 授予权限是指经过认证的用户的权限。 Role 角色是指经过身份验证的用户的一组权限。 创建基本的 Spring 应用程序 在开始配置 Spring Security 框架之前，让我们创建一个基本的 Spring Web 应用程序。为此，我们可以使用 Spring Initializr 并生成一个模板项目。对于一个简单的 Web 应用程序，只需要 Spring Web 框架依赖就足够了：
&lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;/dependencies> 创建项目后，我们可以向其中添加一个简单的 REST 控制器，如下所示：
@RestController @RequestMapping("hello") public class HelloRestController { @GetMapping("user") public String helloUser() { return "Hello User"; } @GetMapping("admin") public String helloAdmin() { return "Hello Admin"; } } 之后，如果我们构建并运行该项目，我们可以在 Web 浏览器中访问以下 URL：...</p></div><footer class=entry-footer><span title='2023-09-19 00:00:00 +0000 UTC'>2023-09-19</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1507 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security 与 JWT for REST API" href=https://blog.chensoul.cc/posts/2023/09/19/spring-security-tutorial/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Builder</h2></header><div class=entry-content><p>本文主要介绍 Builder 构造器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 构造器模式（Builder Pattern）是一种创建型设计模式，用于将复杂对象的构建过程与其表示分离，从而可以使用相同的构建过程创建不同的表示。
在构造器模式中，通常有两个主要角色：产品（Product）和建造者（Builder）。产品是最终构建的对象，而建造者负责构建产品。
以下是构造器模式的类图示例：
+-------------------+ +----------------------+ | Director | | Builder | +-------------------+ +----------------------+ | construct() | | buildPartA() | | | | buildPartB() | +-------------------+ | getResult() | +----------+-----------+ | v +----------+-----------+ | Product | +----------------------+ | partA | | partB | +----------------------+ 在上述类图中，Director（指导者）负责定义构建产品的顺序和方式，而Builder（建造者）负责实际构建产品的具体步骤。Product（产品）是最终构建的对象。
以下是一个简单的示例，演示如何使用构造器模式创建一个角色生成器的例子：
// 产品类 public class Character { private String profession; private String name; private String hairColor; private String weapon; // 构造器私有化，只能通过建造者创建对象 private Character() {} // Getters public String getProfession() { return profession; } public String getName() { return name; } public String getHairColor() { return hairColor; } public String getWeapon() { return weapon; } // 建造者类 public static class CharacterBuilder { private Character character; public CharacterBuilder() { character = new Character(); } public CharacterBuilder withProfession(String profession) { character....</p></div><footer class=entry-footer><span title='2023-09-05 00:00:00 +0000 UTC'>2023-09-05</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;545 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Builder" href=https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/categories/java/page/6/>«&nbsp;Prev&nbsp;6/13
</a><a class=next href=https://blog.chensoul.cc/categories/java/page/8/>Next&nbsp;8/13&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>