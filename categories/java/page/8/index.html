<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | ChenSoul</title>
<meta name=keywords content><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/categories/java/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/categories/java/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/categories/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Java"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/categories/java/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Java
<a href=/categories/java/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Business Delegate</h2></header><div class=entry-content><p>本文主要介绍 Business Delegate 业务委托模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 业务委托模式（Business Delegate Pattern）在表示层和业务层之间引入了一个抽象层，旨在实现这两个层之间的松散耦合，并封装了有关如何定位、连接和交互业务对象的逻辑。
在该模式中，业务委托（Business Delegate）充当一个中间人角色，负责将表示层的调用委托给业务对象。它隐藏了具体业务对象的实现细节，包括底层服务的查找和可访问性，以提供简化的接口供表示层使用。
业务委托模式用于解耦表示层和业务层。它基本上用于减少表示层代码中业务层代码的通信或远程查找功能。在业务层，我们有以下实体。
Client - 表示层代码可以是 JSP、Servlet 或 UI java 代码。 Business Delegate -业务委托 - 客户端实体提供对业务服务方法的访问的单个入口点类。 LookUp Service - 查找服务对象负责获取相关业务实现并提供对业务委托对象的业务对象访问。 Business Service - 业务服务接口。具体类实现该业务服务以提供实际的业务实现逻辑。 以下是一个示例的程序代码，演示了业务委托模式的实现：
public interface VideoStreamingService { void doProcessing(); } @Slf4j public class NetflixService implements VideoStreamingService { @Override public void doProcessing() { LOGGER.info("NetflixService is now processing"); } } @Slf4j public class YouTubeService implements VideoStreamingService { @Override public void doProcessing() { LOGGER.info("YouTubeService is now processing"); } } @Setter public class BusinessLookup { private NetflixService netflixService; private YouTubeService youTubeService; public VideoStreamingService getBusinessService(String movie) { if (movie.toLowerCase(Locale.ROOT).contains("die hard")) { return netflixService; } else { return youTubeService; } } } @Setter public class BusinessDelegate { private BusinessLookup lookupService; public void playbackMovie(String movie) { VideoStreamingService videoStreamingService = lookupService....</p></div><footer class=entry-footer><span title='2023-09-05 09:00:00 +0800 +0800'>2023-09-05</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;205 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Business Delegate" href=https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Bridge</h2></header><div class=entry-content><p>本文主要介绍 Bridge 桥接模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 桥接模式（Bridge Pattern）是一种结构型设计模式，用于将抽象与其实现分离，使它们可以独立地变化。桥接模式通过创建两个独立的层次结构，一个是抽象部分，一个是实现部分，来实现这种分离。
在桥接模式中，抽象部分包含抽象类或接口，定义了高层逻辑和功能。实现部分包含具体实现类，负责实现抽象部分定义的接口或方法。通过桥接模式，可以在两个层次结构中独立地扩展和变化类，而不会相互影响。同时，抽象部分和实现部分之间的耦合度降低，使系统更加灵活和可维护。
举例 考虑一下你拥有一种具有不同附魔的武器，并且应该允许将具有不同附魔的不同武器混合使用。 你会怎么做？ 为每个附魔创建每种武器的多个副本，还是只是创建单独的附魔并根据需要为武器设置它？ 桥接模式使您可以进行第二次操作。
翻译一下上面的武器示例。下面我们有武器的类层级：
public interface Weapon { void wield(); void swing(); void unwield(); Enchantment getEnchantment(); } public class Sword implements Weapon { private final Enchantment enchantment; public Sword(Enchantment enchantment) { this.enchantment = enchantment; } @Override public void wield() { LOGGER.info("The sword is wielded."); enchantment.onActivate(); } @Override public void swing() { LOGGER.info("The sword is swinged."); enchantment.apply(); } @Override public void unwield() { LOGGER.info("The sword is unwielded."); enchantment.onDeactivate(); } @Override public Enchantment getEnchantment() { return enchantment; } } public class Hammer implements Weapon { private final Enchantment enchantment; public Hammer(Enchantment enchantment) { this....</p></div><footer class=entry-footer><span title='2023-08-28 09:00:00 +0800 +0800'>2023-08-28</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;811 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Bridge" href=https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Balking</h2></header><div class=entry-content><p>本文主要介绍 Balking 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 止步模式（Balking）是一种在对象处于特定状态时才执行操作的设计模式。它用于防止对象在不完整或不合适的状态下执行某些代码，从而确保代码的正确性和一致性。
该模式的核心思想是，在执行操作之前，检查对象的状态，并只在特定的状态下才执行操作。如果对象不处于预期状态，操作将被忽略或推迟执行，从而避免了不必要的操作或不一致的状态转换。
以下是止步模式的要点和示例：
对象状态检查：在执行操作之前，对象会检查自身的状态。这可以通过使用条件语句或状态标志来实现。 特定状态执行：只有当对象处于特定状态时，操作才会被执行。如果对象不满足执行条件，操作将被忽略或推迟执行。 线程安全考虑：由于止步模式通常涉及多线程环境，需要确保对共享资源的访问是线程安全的。可以使用同步机制（如 synchronized 关键字）来保护共享资源。 解释 真实世界例子
洗衣机中有一个开始按钮，用于启动衣物洗涤。当洗衣机处于非活动状态时，按钮将按预期工作，但是如果已经在洗涤，则按钮将不起任何作用。
通俗地说
使用止步模式，仅当对象处于特定状态时才执行特定代码。
维基百科说
禁止模式是一种软件设计模式，仅当对象处于特定状态时才对对象执行操作。例如，一个对象读取 zip 压缩文件并在压缩文件没打开的时候调用 get 方法，对象将在请求的时候”止步“。
程序示例
在此示例中， WashingMachine是一个具有两个状态的对象，可以处于两种状态：ENABLED 和WASHING。 如果机器已启用，则使用线程安全方法将状态更改为 WASHING。 另一方面，如果已经进行了清洗并且任何其他线程执行 wash（），则它将不执行该操作，而是不执行任何操作而返回。
这里是 WashingMachine 类相关的部分。
@Slf4j public class WashingMachine { private final DelayProvider delayProvider; private WashingMachineState washingMachineState; public WashingMachine(DelayProvider delayProvider) { this.delayProvider = delayProvider; this.washingMachineState = WashingMachineState.ENABLED; } public WashingMachineState getWashingMachineState() { return washingMachineState; } public void wash() { synchronized (this) { var machineState = getWashingMachineState(); LOGGER.info("{}: Actual machine state: {}", Thread.currentThread().getName(), machineState); if (this.washingMachineState == WashingMachineState.WASHING) { LOGGER.error("Cannot wash if the machine has been already washing!"); return; } this....</p></div><footer class=entry-footer><span title='2023-08-25 08:50:00 +0800 +0800'>2023-08-25</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1207 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Balking" href=https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]REST API 的自定义错误消息处理</h2></header><div class=entry-content><p>1. 概述 在本教程中，我们将讨论如何为 Spring REST API 实现全局错误处理程序。
我们将使用每个异常的语义为客户端构建有意义的错误消息，其明确的目标是为客户端提供所有信息以轻松诊断问题。
2. 自定义错误消息 让我们首先实现一个用于通过线路发送错误的简单结构 — ApiError：
public class ApiError { private HttpStatus status; private String message; private List&lt;String> errors; public ApiError(HttpStatus status, String message, List&lt;String> errors) { super(); this.status = status; this.message = message; this.errors = errors; } public ApiError(HttpStatus status, String message, String error) { super(); this.status = status; this.message = message; errors = Arrays.asList(error); } } 这里的信息应该很简单：
status – HTTP 状态代码 message – 与异常相关的错误消息 error – 构建的错误消息列表 当然，对于 Spring 中的实际异常处理逻辑，我们将使用 @ControllerAdvice 注解：
@ControllerAdvice public class CustomRestExceptionHandler extends ResponseEntityExceptionHandler { ... } 3. 处理错误请求异常 3.1.处理异常 现在让我们看看如何处理最常见的客户端错误 - 基本上是客户端向 API 发送无效请求的情况：
BindException – 发生致命绑定错误时抛出此异常。 MethodArgumentNotValidException – 当使用 @Valid 注解的参数验证失败时抛出此异常： @Override protected ResponseEntity&lt;Object> handleMethodArgumentNotValid( MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { List&lt;String> errors = new ArrayList&lt;String>(); for (FieldError error : ex....</p></div><footer class=entry-footer><span title='2023-08-25 08:20:00 +0800 +0800'>2023-08-25</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;787 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]REST API 的自定义错误消息处理" href=https://blog.chensoul.cc/posts/2023/08/25/global-error-handler-in-a-spring-rest-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]使用Spring进行REST的错误处理</h2></header><div class=entry-content><p>1. 概述 本教程将说明如何使用 Spring 为 REST API 实现异常处理。我们还将获得一些历史概述，并了解不同版本引入了哪些新选项。
在 Spring 3.2 之前，Spring MVC 应用程序中处理异常的两种主要方法是 HandlerExceptionResolver 或 @ExceptionHandler 注解。两者都有一些明显的缺点。
从 3.2 开始，我们使用了 @ControllerAdvice 注释来解决前两个解决方案的局限性，并促进整个应用程序的统一异常处理。
现在 Spring 5 引入了 ResponseStatusException 类，一种在 REST API 中进行基本错误处理的快速方法。
所有这些都有一个共同点：它们很好地处理了关注点分离。应用程序可以正常抛出异常来指示某种失败，然后将单独处理。
最后，我们将了解 Spring Boot 带来的功能以及如何配置它以满足我们的需求。
2.方案一：控制器级@ExceptionHandler 第一个解决方案在 @Controller 级别工作。我们将定义一个处理异常的方法并使用@ExceptionHandler 进行注释：
public class FooController{ //... @ExceptionHandler({ CustomException1.class, CustomException2.class }) public void handleException() { // } } 这种方法有一个主要缺点：· 注解的方法仅对特定的控制器有效，而不是对整个应用程序全局有效。当然，将其添加到每个控制器使其不太适合通用异常处理机制。
我们可以通过让所有控制器扩展基本控制器类来解决此限制。
然而，对于无论出于何种原因这是不可能的应用程序来说，此解决方案可能是一个问题。例如，控制器可能已经从另一个基类扩展，该基类可能位于另一个 jar 中或不可直接修改，或者本身可能不可直接修改。
接下来，我们将研究另一种解决异常处理问题的方法 - 一种全局的方法，不包括对现有工件（例如控制器）的任何更改。
3.解决方案 2：HandlerExceptionResolver 第二种解决方案是定义一个 HandlerExceptionResolver。这将解决应用程序抛出的任何异常。它还允许我们在 REST API 中实现统一的异常处理机制。
在选择自定义解析器之前，让我们先回顾一下现有的实现。
3.1.异常处理器异常解析器 该解析器是在 Spring 3.1 中引入的，并且在 DispatcherServlet 中默认启用。这实际上是前面介绍的 @ExceptionHandler 机制如何工作的核心组件。
3.2.默认处理程序异常解析器 这个解析器是在 Spring 3.0 中引入的，并且在 DispatcherServlet 中默认启用。
它用于将标准 Spring 异常解析为其相应的 HTTP 状态代码，即客户端错误 4xx 和服务器错误 5xx 状态代码。以下是它处理的 Spring 异常的完整列表以及它们如何映射到状态代码。...</p></div><footer class=entry-footer><span title='2023-08-25 08:05:00 +0800 +0800'>2023-08-25</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;657 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]使用Spring进行REST的错误处理" href=https://blog.chensoul.cc/posts/2023/08/25/exception-handling-for-rest-with-spring/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]使用@Async进行Spring Security上下文传播</h2></header><div class=entry-content><p>1. 简介 在本教程中，我们将重点关注使用 @Async 传播 Spring Security 主体 默认情况下，Spring Security 身份验证绑定到 ThreadLocal - 因此，当执行流在带有 @Async 的新线程中运行时，它不会是经过身份验证的上下文。
这并不理想——让我们解决它。
2.Maven 依赖 为了在 Spring Security 中使用异步集成，我们需要在 pom.xml 的依赖项中包含以下部分：
&lt;dependency> &lt;groupId>org.springframework.security&lt;/groupId> &lt;artifactId>spring-security-config&lt;/artifactId> &lt;version>5.7.3&lt;/version> &lt;/dependency> 可以在此处找到最新版本的 Spring Security 依赖项。
3.使用@Async 进行 Spring Security 传播 我们先写一个简单的例子：
@RequestMapping(method = RequestMethod.GET, value = "/async") @ResponseBody public Object standardProcessing() throws Exception { log.info("Outside the @Async logic - before the async call: " + SecurityContextHolder.getContext().getAuthentication().getPrincipal()); asyncService.asyncCall(); log.info("Inside the @Async logic - after the async call: " + SecurityContextHolder.getContext().getAuthentication().getPrincipal()); return SecurityContextHolder.getContext().getAuthentication().getPrincipal(); } 我们想要检查 Spring SecurityContext 是否传播到新线程。首先，我们在异步调用之前记录上下文，接下来我们运行异步方法，最后再次记录上下文。 asyncCall() 方法具有以下实现：
@Async @Override public void asyncCall() { log.info("Inside the @Async logic: " + SecurityContextHolder.getContext().getAuthentication().getPrincipal()); } 正如我们所看到的，只有一行代码将输出异步方法的新线程内的上下文。...</p></div><footer class=entry-footer><span title='2023-08-25 08:00:00 +0800 +0800'>2023-08-25</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;278 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]使用@Async进行Spring Security上下文传播" href=https://blog.chensoul.cc/posts/2023/08/25/spring-security-async-principal-propagation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Events</h2></header><div class=entry-content><p>1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。
事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。
有一些简单的准则需要遵循：
如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。
2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。
在本例中，事件类保存一条字符串消息：
public class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。
要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：
@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System.out.println("Publishing custom event. "); CustomSpringEvent customSpringEvent = new CustomSpringEvent(this, message); applicationEventPublisher.publishEvent(customSpringEvent); } } 或者，发布者类可以实现 ApplicationEventPublisherAware 接口，这也将在应用程序启动时注入事件发布者。通常，使用 @Autowire 注入发布者会更简单。...</p></div><footer class=entry-footer><span title='2023-08-25 07:00:00 +0800 +0800'>2023-08-25</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;431 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Events" href=https://blog.chensoul.cc/posts/2023/08/25/spring-events/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]如何在Spring中执行@Async</h2></header><div class=entry-content><p>1. 概述 在本教程中，我们将探讨 Spring 中的异步执行支持和 @Async 注解。
简单地说，用 @Async 注解 bean 的方法将使其在单独的线程中执行。换句话说，调用者不会等待被调用方法的完成。
Spring 的一个有趣的方面是，框架中的事件支持还 支持异步处理（如果需要）。
2.启用异步支持 让我们首先通过 Java 注解启用异步处理。
我们将通过将 @EnableAsync 添加到配置类来完成此操作：
@Configuration @EnableAsync public class SpringAsyncConfig { ... } 启用注解就足够了。但也有一些简单的配置选项：
annotation 默认情况下，@EnableAsync 检测 Spring 的 @Async 注解和 EJB 3.1 javax.ejb.Asynchronous。我们也可以使用此选项来检测其他用户定义的注解类型。 mode 指示应使用的建议类型 - 基于 JDK 代理或 AspectJ 编织。 proxyTargetClass 指示应使用的代理类型 — CGLIB 或 JDK。仅当模式设置为 AdviceMode.PROXY 时，此属性才有效。 order 设置应用 AsyncAnnotationBeanPostProcessor 的顺序。默认情况下，它最后运行，以便它可以考虑所有现有代理。 我们还可以使用任务命名空间通过 XML 配置启用异步处理：
&lt;task:executor id="myexecutor" pool-size="5" /> &lt;task:annotation-driven executor="myexecutor"/> 3.@Async 注解 首先，让我们回顾一下规则。 @Async 有两个限制：
它必须仅应用于公共方法。 自调用（从同一个类中调用异步方法）将不起作用。 原因很简单：该方法需要公开，以便可以被代理。并且自调用不起作用，因为它绕过代理并直接调用底层方法。
3.1.返回类型为 void 的方法 这是配置具有 void 返回类型的方法以异步运行的简单方法：
@Async public void asyncMethodWithVoidReturnType() { System.out.println("Execute method asynchronously. " + Thread.currentThread().getName()); } 3.2.具有返回类型的方法 我们还可以通过将实际返回包装在 Future 中来将 @Async 应用于具有返回类型的方法：...</p></div><footer class=entry-footer><span title='2023-08-25 07:00:00 +0800 +0800'>2023-08-25</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;338 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何在Spring中执行@Async" href=https://blog.chensoul.cc/posts/2023/08/25/spring-async/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Boot项目如何实现JWT认证？</h2></header><div class=entry-content><p>没有人可以否认这样一个事实：安全性是生产就绪应用程序的一项重要功能。尽管我们可以使用内存身份验证、JDBC 身份验证或通过 UserDetailsS​​ervice 来保护一个 Web 应用程序的安全。但是，当一个应用程序在内部使用其他应用程序的服务时，使用 Web 服务概念实现安全性就变得很重要。在这种情况下，我们使用具有特定有效期的令牌来保护我们的应用程序。此外，我们将学习“如何在 Spring Boot 项目中实现 JWT 身份验证？”以整体了解 JWT（JSON Web Token）身份验证背后的概念。
由于 JWT 代表“JSON Web Token”，很明显，该令牌仅以 JSON 形式保存数据。
此外，与上述身份验证技术不同，JWT 属于无状态身份验证。简而言之，它没有数据。通常，这种类型的身份验证用于 Web 服务、服务器的水平扩展，甚至在某种程度上用于 OAuth 技术。为了说明该网络服务，让我们可视化从亚马逊预订订单的过程。在这里，用户与 Amazon 应用程序交互，而 Amazon 应用程序在内部通过 Web 服务调用与支付网关应用程序交互。
现在让我们开始讨论我们的主题“如何在 Spring Boot 项目中实现 JWT 身份验证？”以及相关点。
您对整篇文章有何期望？ 读完本文后，您将能够回答：
什么是安全上下文中的无状态和有状态身份验证？ 无状态认证和有状态认证有什么区别？ 那么什么是 Token，什么是 JWT(JSON Web Token)？
使用 JWT 认证有什么好处？
JWT 内部如何运作？
我们在什么情况下使用 JWT 身份验证？
此外，JWT 身份验证和状态身份验证之间有什么区别？
此外，如何生成 JWT 编码令牌以及如何将其解码回来？
如何在 Spring Boot 项目中逐步实现 JWT 认证？
在 Spring Boot 3.0 中，如何在不使用 WebSecurityConfigurerAdapter 的情况下编写安全配置类？
最后，如何测试启用 JWT 安全的应用程序？
什么是无状态和有状态身份验证？ 通常有两种类型的认证技术。两者都发生在客户端服务器概念中，服务器仅在身份验证后才向客户端提供服务。这里的客户端可以是浏览器，也可以是另一个服务器。
状态认证 在这种类型的身份验证中，客户端和服务器之间涉及会话管理。当客户端向服务器请求服务时，它首先登录到服务器。然后服务器创建一个会话并以键值对的形式存储该信息。这个会话是服务器端的一种内存。我们也称其为 HttpSession，因为 Http 协议管理它。
此外，为了响应客户端请求，服务器以 Cookie 的形式向客户端提供带有响应的会话 id。该 cookie 存储在客户端浏览器中。当同一个客户端第二次发出请求时，请求头中也会带有 cookie。因此，服务器会检查请求标头，如果在 cookie 中发现相同的 SID（会话 ID），则假定该请求来自同一客户端。通过这种方式，会话管理就发生了。
当客户端从服务器注销时，会话会相应地被销毁。结果，服务器相应地从内存中删除会话信息（键值）。同样重要的是，对于每个新客户端，服务器都会创建一个新会话（内存）。
无状态身份验证 当客户端向服务器发送服务请求时，它首先登录到服务器。因此，服务器生成一个令牌（编码格式的数据）并将响应发送到客户端。在发出第二个请求时，客户端将相同的令牌与请求一起发送到服务器。现在，服务器从请求中读取令牌并验证令牌。事实上，从第一个请求开始，服务器就检查客户端的有效登录（凭据）。...</p></div><footer class=entry-footer><span title='2023-08-18 12:00:00 +0800 +0800'>2023-08-18</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1974 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Boot项目如何实现JWT认证？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]没有WebSecurityConfigurerAdapter的Spring Security.md</h2></header><div class=entry-content><p>在 Spring Security 模块的上下文中，WebSecurityConfigurerAdapter 是一个抽象类，根据 Spring 官方网站 2022 年 2 月 21 日发布的公告，该类已从 Spring Security 5.7.0-M2 中弃用。它通常用于扩展 configure() 方法由自定义配置子类实现。因此，它鼓励用户转向基于组件的安全配置。为了支持对这种新配置设计的更改，我们将讨论常见用例列表和未来建议的替代方案。因此，我们将讨论没有 WebSecurityConfigurerAdapter 的 Spring Security 用例的实现。
了解这一变化很重要，因为迟早我们将使用最新版本的 Spring Security 来开发安全功能。让我们讨论“没有 WebSecurityConfigurerAdapter 的 Spring Security”主题及其相关概念。
什么是 WebSecurityConfigurerAdapter？ WebSecurityConfigurerAdapter 是 Spring Security 模块提供的一个抽象类。一般来说，我们使用它来重写它的 configure()方法来定义我们的安全配置类。通常，我们在应用程序中实现 Spring Security 时使用两个具有不同参数的 configure() 方法。一种用于声明与身份验证相关的配置，另一种用于声明与授权相关的配置。该代码类似于下面的代码片段。
@Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // configure Authentication ...... } @Override protected void configure(HttpSecurity http) throws Exception { // configure Authorization ...... } } 为什么我们需要学习这个改变？ 如果您使用 Spring Boot 2.7.0 和 maven，它将自动下载 Spring Security 5.7.0 或更高版本。在这种情况下，您会发现 WebSecurityConfigurerAdapter 已被弃用。如果您仍然想使用此类而不弃用，您可以在 pom.xml 中将 Spring Boot 版本更改为较低版本（例如 2.6.6 ），如下所示。它将自动下载低于 5....</p></div><footer class=entry-footer><span title='2023-08-18 11:30:00 +0800 +0800'>2023-08-18</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;882 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]没有WebSecurityConfigurerAdapter的Spring Security.md" href=https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/categories/java/page/7/>«&nbsp;Prev&nbsp;7/13
</a><a class=next href=https://blog.chensoul.cc/categories/java/page/9/>Next&nbsp;9/13&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>