---
title: "[译]微服务设计模式"
date: 2023-06-26T08:00:00+08:00
slug: microservice-design-patterns
categories: ["Notes"]
tags: [java]
---

在 MySQL 中，可以使用多种方式来设计树形结构的区域表，以下是一些常见的方案：

## Adjacency List 模型

Adjacency List 模型是最常见的树形结构模型之一，在该模型中，每个节点都包含一个指向其父节点的外键。在区域表中，可以使用一个 `parent_id` 列来存储每个地区的父节点 ID。该模型的优点是简单易理解，易于实现，但是查询某个节点的子孙节点需要使用递归查询，效率较低。

下面是在 MySQL 中使用 Adjacency List 模型创建区域表 `sys_area`，并实现增删改查操作的示例代码。

首先，创建 `sys_area` 表，包含 `id`、`name` 和 `parent_id` 三个字段：

```sql
CREATE TABLE sys_area (
  id INT(11) NOT NULL AUTO_INCREMENT,
  name VARCHAR(50) NOT NULL,
  parent_id INT(11),
  PRIMARY KEY (id),
  INDEX idx_parent_id (parent_id)
);
```

在该表中，`id` 是地区的唯一标识符，`name` 是地区的名称，`parent_id` 是地区的父节点 ID。

接下来，可以实现增删改查操作的 SQL 语句，例如：

1、插入地区记录：

```sql
INSERT INTO sys_area (name, parent_id) VALUES ('中国', NULL);
INSERT INTO sys_area (name, parent_id) VALUES ('浙江省', 1);
INSERT INTO sys_area (name, parent_id) VALUES ('杭州市', 2);
INSERT INTO sys_area (name, parent_id) VALUES ('西湖区', 3);
INSERT INTO sys_area (name, parent_id) VALUES ('上城区', 3);
```

在这个示例中，首先插入了一个顶级地区 `中国`，然后插入了其下属的地区 `浙江省`、`杭州市` 和 `西湖区`，其中 `parent_id` 分别为 `NULL`、`1`、`2`，表示它们的父节点分别是顶级节点、`中国`、`浙江省`。



2、查询地区记录：

```sql
SELECT * FROM sys_area;
SELECT * FROM sys_area WHERE parent_id = 2;
```

在这个示例中，第一个 SQL 语句查询了所有的地区记录，第二个 SQL 语句查询了父节点为 `2`（即 `杭州市`）的地区记录，即其下属的地区 `西湖区`。



3、查询所有子节点

例如：查询浙江省下的所有区域。以下是一种常见的递归查询方法：

```sql
WITH RECURSIVE cte AS (
  SELECT id, name, parent_id
  FROM sys_area
  WHERE name = '浙江省'
  UNION ALL
  SELECT a.id, a.name, a.parent_id
  FROM sys_area a
  INNER JOIN cte c ON c.id = a.parent_id
)
SELECT * FROM cte;
```

在这个 SQL 语句中，使用了 CTE（Common Table Expression）和递归查询来查询浙江省下的所有区域。首先，从 `sys_area` 表中选取名称为 `浙江省` 的地区作为起始节点，然后通过递归查询找到其所有的子孙节点。最后，查询结果包括所有子孙节点的 ID、名称和父节点 ID。

> Common Table Expression（CTE）是一种非标准的 SQL 语法，它在 MySQL 中的支持情况取决于具体的 MySQL 版本。在 MySQL 5.7 版本中，CTE 确实是不支持的。不过，从 MySQL 8.0 版本开始，MySQL 开始支持 CTE 语法。
>
> 在 MySQL 5.7 版本及以下版本中，可以使用子查询或者临时表等方式来替代 CTE 的功能。



4、查询所有父节点

使用 Adjacency List 模型，查询杭州市的所有父节点需要使用递归查询。以下是一种常见的递归查询方法：

```sql
WITH RECURSIVE cte AS (
  SELECT id, name, parent_id
  FROM sys_area
  WHERE name = '杭州市'
  UNION ALL
  SELECT a.id, a.name, a.parent_id
  FROM sys_area a
  INNER JOIN cte c ON c.parent_id = a.id
)
SELECT * FROM cte;
```

在这个 SQL 语句中，使用了 CTE 和递归查询来查询杭州市的所有父节点。首先，从 `sys_area` 表中选取名称为 `杭州市` 的地区作为起始节点，然后通过递归查询找到其所有的父节点。最后，查询结果包括所有父节点的 ID、名称和父节点 ID。



以下是使用子查询实现查询杭州市的所有父节点的示例代码：

```sql
SELECT t1.*
FROM (
  SELECT * FROM sys_area WHERE name = '杭州市'
) t1
LEFT JOIN sys_area t2 ON t1.parent_id = t2.id
LEFT JOIN sys_area t3 ON t2.parent_id = t3.id
LEFT JOIN sys_area t4 ON t3.parent_id = t4.id;
```

在这个示例中，使用了四个子查询，每个子查询查询一个层级的父节点。通过使用多个子查询和 LEFT JOIN 操作，查询结果包含了杭州市的所有父节点。



如果需要查询的层级较多，使用多个子查询或者临时表等方式可能会导致 SQL 语句复杂度极高，不利于维护和优化。在这种情况下，可以考虑使用其他树形结构模型，例如 Nested Set 模型或者 Closure Table 模型，来优化查询性能。



## Path Enumeration 模型

Path Enumeration 模型是一种基于路径的树形结构模型，在该模型中，每个节点都包含一个表示其路径的字符串，该字符串包含该节点的所有祖先节点的 ID。在区域表中，可以使用一个 `path` 列来存储每个地区的路径。该模型的优点是查询某个节点的所有祖先、后代节点都非常高效，但是需要对路径进行修改、维护较为麻烦。



在 Path Enumeration 模型中，每个节点都有一个唯一的路径，表示节点在树中的位置。路径通常使用字符串或者数组的形式来表示，例如使用斜杠分隔符 `/` 将每个节点的 ID 连接起来作为路径。

以下是一个使用 Path Enumeration 模型的表结构设计示例：

```sql
CREATE TABLE sys_area (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  path VARCHAR(255)
);
```

在这个示例中，`sys_area` 表包含了树形结构中的节点信息，包括节点 ID、名称和路径。其中，节点 ID 是一个自增的整数，用于唯一标识每个节点。节点名称用于描述节点的名称信息。节点路径用于表示节点在树中的位置，例如 `/1/2/3` 表示一个深度为 3 的节点，其祖先节点分别为 ID 为 1、2 和 3 的节点。



插入数据：

```sql
INSERT INTO sys_area (id, name, path) VALUES
(1, '中国', '/'),
(2, '浙江省', '/1/'),
(3, '杭州市', '/1/2/'),
(4, '上城区', '/1/2/3/'),
(5, '下城区', '/1/2/4/'),
(6, '江干区', '/1/2/5/'),
(7, '西湖区', '/1/2/6/'),
(8, '滨江区', '/1/2/7/'),
(9, '萧山区', '/1/2/8/'),
(10, '余杭区', '/1/2/9/'),
(11, '临安市', '/1/2/10/'),
(12, '富阳区', '/1/2/11/'),
(13, '宁波市', '/1/12/'),
(14, '海曙区', '/1/12/13/'),
(15, '江北区', '/1/12/14/'),
(16, '北仑区', '/1/12/15/'),
(17, '镇海区', '/1/12/16/'),
(18, '鄞州区', '/1/12/17/'),
(19, '余姚市', '/1/12/18/'),
(20, '慈溪市', '/1/12/19/'),
(21, '奉化市', '/1/12/20/');
```

在这个示例数据中，使用了 Path Enumeration 模型表示了一个地区树形结构，包括了中国、浙江省、杭州市、上城区、下城区等多个层级。每个节点都有一个唯一的 ID 和一个路径，用于标识节点在树中的位置。



查询每个节点的层级：

```sql
SELECT id, name, LENGTH(path) - LENGTH(REPLACE(path, '/', '')) AS level
FROM sys_area;
```



查询杭州市的所有子节点（包括杭州市）：

```sql
SELECT *
FROM sys_area
WHERE path LIKE '/1/2/%';
```

查询杭州市的所有子节点（不包括杭州市）：

```sql
SELECT *
FROM sys_area
WHERE path LIKE '/1/2/%' and path<>'/1/2/';
```

查询杭州市的所有直接子节点：

```sql
SELECT *
FROM sys_area
WHERE path LIKE '/1/2/%' and LENGTH(path) - LENGTH(REPLACE(path, '/', ''))=4;
```



查询杭州市的所有父节点（包括杭州市）：

```sql
SELECT *
FROM sys_area
WHERE '/1/2/' LIKE CONCAT(path, '%')
ORDER BY LENGTH(path);
```

查询杭州市的所有父节点（不包括杭州市）：

```sql
SELECT *
FROM sys_area
WHERE '/1/2/' LIKE CONCAT(path, '%') and path<>'/1/2/'
ORDER BY LENGTH(path);
```



需要注意的是，使用 Path Enumeration 模型需要在每次插入、删除或移动节点时更新节点的路径，因此在处理频繁的树形结构操作时，可能会影响数据库的性能。同时，Path Enumeration 模型也有一些局限性，例如不支持节点的随意移动和插入。因此，在使用 Path Enumeration 模型时，需要根据具体的需求和场景来选择合适的树形结构模型。



## Materialized Path 模型

Materialized Path 模型是一种基于路径的树形结构模型，在该模型中，每个节点都包含一个表示其路径的字符串，该字符串包含该节点的所有祖先节点的 ID，同时还包括该节点自身的 ID。在区域表中，可以使用一个 `path` 列来存储每个地区的路径。该模型的优点是查询某个节点的所有祖先、后代节点都非常高效，且对路径的修改、维护较为方便。

需要根据具体的需求和场景来选择合适的树形结构模型，不同的模型各有优缺点。例如，如果需要频繁查询某个节点的所有祖先、后代节点，则可以选择 Path Enumeration 模型或 Materialized Path 模型；如果需要频繁插入、删除节点，则可以选择 Nested Set 模型。



下面是一个 Materialized Path 模型的建表语句，并插入一些测试数据：

```sql
CREATE TABLE sys_area (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  path VARCHAR(255) NOT NULL
);

INSERT INTO sys_area (name, path) VALUES
('中国', '/1'),
('浙江省', '/1/2'),
('杭州市', '/1/2/3'),
('西湖区', '/1/2/3/4'),
('上城区', '/1/2/3/5'),
('江干区', '/1/2/3/6'),
('下城区', '/1/2/3/7'),
('拱墅区', '/1/2/3/8'),
('滨江区', '/1/2/3/9'),
('萧山区', '/1/2/3/10'),
('余杭区', '/1/2/3/11');
```

在这个表中，每个节点都有一个自增的 ID，一个名称字段和一个路径字段。路径字段中存储了从根节点到该节点的完整路径，使用 `/` 分隔各级节点的 ID。

例如，中国节点的路径为 `/1`，杭州市节点的路径为 `/1/2/3`。这个表中的数据仅供测试和演示使用，实际应用中可能需要根据具体的业务需求进行调整。



查询每个节点的层级：

```sql
SELECT id, name, LENGTH(path) - LENGTH(REPLACE(path, '/', '')) AS level
FROM sys_area;
```



查询杭州市的所有子节点（不包括杭州市）：

```sql
SELECT *
FROM sys_area
WHERE path LIKE '/1/2/3/%';

SELECT *
FROM sys_area
WHERE SUBSTRING(path, 1, LENGTH('/1/2/3')) = '/1/2/3' and path <> '/1/2/3'
```

需要注意的是，这个 SQL 语句中的 `%` 符号表示匹配任意字符，包括空字符串。如果想要排除空字符串，可以使用 `_` 符号表示匹配单个字符。

```sql
SELECT *
FROM sys_area
WHERE path LIKE '/1/2/3/_';
```



查询浙江省的所有直接子节点：

```sql
-- 浙江省 path=/1/2, 层级=2
SELECT *
FROM sys_area
WHERE path LIKE '/1/2%' and LENGTH(path) - LENGTH(REPLACE(path, '/', ''))=3;
```



查询杭州市的所有父节点

```sql
SELECT *
FROM sys_area
WHERE '/1/2/3' LIKE CONCAT(path, '%') and path<>'/1/2/3'
ORDER BY LENGTH(path);
```



## Nested Set 模型

Nested Set 模型是一种基于嵌套集合的树形结构模型，在该模型中，每个节点都包含一个左右值，该值表示该节点的子孙节点在一个完整的嵌套集合中的位置。在区域表中，可以使用一个 `lft` 和 `rgt` 列来存储每个地区的左右值。该模型的优点是查询某个节点的所有祖先、后代节点非常高效，但是需要对左右值进行修改、维护较为麻烦。
