<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.129.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ChenSoul</title>
<meta name=keywords content="java,python,go"><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/index.xml><link rel=alternate type=application/json href=https://blog.chensoul.cc/index.json><link rel=alternate hreflang=en href=https://blog.chensoul.cc/><meta name=twitter:title content="ChenSoul"><meta name=twitter:description content><meta property="og:title" content="ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/"><meta property="og:site_name" content="ChenSoul"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"ChenSoul","url":"https://blog.chensoul.cc/","description":"","thumbnailUrl":"https://blog.chensoul.cc/favicon.ico","sameAs":[]}</script><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-page kind-home layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>[译]JMS 2.0 的十个好处意味着可以减少代码编写量</h2></header><section class=entry-content><p>原文链接：Ten ways in which JMS 2.0 means writing less code
这里有十个简单的例子，说明 JMS 2.0 比 JMS 1.1 需要更少的代码。
单一 JMSContext 而不是单独的 Connection 和 Session 对象 JMS 2.0 简化 API 引入了一个新对象， JMSContext 它提供了与 JMS 1.1 API 中的分隔 Connection 对象 Session 相同的功能：
JMS 1.1
Connection connection = connectionFactory.createConnection(); Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); JMS 2.0
JMSContext context = connectionFactory.createContext(JMSContext.SESSION_TRANSACTED); 使用 try-with-resources 块意味着不需要调用 close 使用后未能关闭Connection可能会导致您的应用程序耗尽资源。
JMS 1.1
在 JMS 1.1 中，确保使用后关闭连接的最佳方法是调用close()一个finally块：
try { Connection connection = connectionFactory.createConnection(); try { Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); ... etc ... } finally { connection.close(); } } catch (JMSException ex) { ex.printStackTrace(); } 这太冗长了。更糟糕的是，如果您在块主体中遇到异常try，然后在中遇到异常close()，则第一个异常将会丢失，即使第一个异常可能是失败的根本原因。
JMS 2.0
在 JMS 2.0 中，Connection对象实现了java.lang.AutoCloseable接口。这意味着，如果您Connection 在 try-with-resources 块中创建对象，则该close方法将在该块的末尾自动调用。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-24</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 2.0 的十个好处意味着可以减少代码编写量" href=https://blog.chensoul.cc/posts/2024/07/24/jms20-means-less-code/></a></article><article class=post-entry><header class=entry-header><h2>[译]JMS 2.0 中的新增功能</h2></header><section class=entry-content><p>原文链接：What is new in JMS 2.0
在在软件集成领域，从一个软件组件到另一个软件组件进行通信是一项基本要求。虽然已经出现了许多具有这种能力的技术，但 Java 编程语言为我们提供了一个 API，以促进用 Java 编写的组件之间的消息传递。此 API 的实现将由不同的供应商（JMS 提供商）通过代理软件提供。
这个API被称为Java消息服务（JMS）。
JMS 规范的最后一次更新是在 2002 年，当时推出了JMS 1.1。从那时起，多年来，该 API 已在全球许多软件组件中使用，证明了其对开发人员的友好性。JMS 的下一个版本（JMS 2.0）于 2013 年 4 月问世，距离 1.1 版已有数年之久。
JMS 2.0 只能与Java SE 7 及更高版本一起使用。了解 JMS 2.0 中的新功能将会很有趣。
易于使用的语言功能 从语言角度来看，对 API 所做的最重大的更改是减少了开发人员需要编写的代码量。让我们将 JMS 2.0 与 1.1 进行比较，看看它们有什么区别。
连接和会话对象纳入单个 JMSContext 不再需要创建连接和会话对象。您可以创建 JMSContext 并直接使用它来创建消息生产者。
//JMS 1.1 public void sendMessageJMS11(ConnectionFactory connectionFactory, Queue queueString text) { try { Connection connection = connectionFactory.createConnection(); try { Session session =connection.createSession(false,Session.AUTO_ACKNOWLEDGE); MessageProducer messageProducer = session.createProducer(queue); TextMessage textMessage = session.createTextMessage(text); messageProducer.send(textMessage); } finally { connection.close(); } } catch (JMSException ex) { // handle exception (details omitted) } } //JMS 2....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-24</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>3 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 2.0 中的新增功能" href=https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/></a></article><article class=post-entry><header class=entry-header><h2>[译]JMS 2.0 中的新增功能（第一部分）- 易于使用</h2></header><section class=entry-content><p>原文链接：https://www.oracle.com/technical-resources/articles/java/jms20.html
作者：Nigel Deakin 出版日期：2013 年 5 月
了解新的易用性功能如何使您编写更少的代码行。
本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在第二部分中，我们将介绍新的消息传递特性。
JMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。
JMS 2.0 的重点是追赶其他企业 Java 技术的易用性改进。虽然企业 JavaBeans 或 Java 持久性等技术现在比十年前使用起来简单得多，但 JMS 仍然保持着成功但相当冗长的 API。
JMS 2.0 中最大的变化是引入了用于发送和接收消息的新 API，从而减少了开发人员必须编写的代码量。对于在 Java EE 应用服务器中运行的应用程序，新 API 还支持资源注入。这允许应用服务器负责创建和管理 JMS 对象，从而进一步简化应用程序。
JMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序，也可以在 Java SE 环境中独立使用。正如我在下面解释的那样，这里描述的某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。
简化的 API 新 API 称为简化 API。顾名思义，它旨在比现有的 JMS 1.1 API 更简单、更易于使用，而后者现在（相当可预测地）被称为经典 API。
简化的 API 包含三个新接口：JMSContext、JMSProducer和JMSConsumer：
JMSContext用单个对象替换经典 API 中单独的Connection和Session对象。 JMSProducer是经典 API 中对象的轻量级替代品。它允许使用方法链（有时称为构建器模式MessageProducer）配置消息传递选项、标头和属性。 JMSConsumer替代了MessageConsumer经典API中的对象，使用方式类似。 开发人员现在可以选择是使用传统 API（JMS 1....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-24</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>7 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 2.0 中的新增功能（第一部分）- 易于使用" href=https://blog.chensoul.cc/posts/2024/07/24/jms20/></a></article><article class=post-entry><header class=entry-header><h2>[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能</h2></header><section class=entry-content><p>原文链接：https://www.oracle.com/technical-resources/articles/java/jms2messaging.html
作者：Nigel Deakin 出版日期：2013 年 5 月
了解如何利用 JMS 2.0 中的新消息传递功能。
本文是两部分系列文章中的第二部分，介绍了 Java 消息服务 (JMS) 2.0 中引入的一些新消息传递功能。本文假设读者对 JMS 1.1 有基本的了解。
在第一部分中，我们了解了 JMS 2.0 中引入的新的易用特性。在这里，我们来了解一下重要的新消息传递特性。
JMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。
JMS 2.0 的重点是跟上近年来对其他企业 Java 技术所做的易用性改进。同时还借此机会引入了许多新的消息传递功能。
JMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序。它也可以单独用于 Java SE 环境中。正如我下面所解释的那样，某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。
这里我们讨论 JMS 2.0 中的五个重要的新消息传递功能。
允许多个消费者订阅同一主题 在 JMS 1.1 中，一个主题的订阅不允许同时有多个使用者。这意味着，处理主题订阅上的消息的工作不能在多个线程、连接或 Java 虚拟机 (JVM) 之间共享，从而限制了应用程序的可伸缩性。JMS 2.0 中引入了一种称为共享订阅的新主题订阅，从而消除了此限制。
让我们回顾一下主题订阅在 JMS 1.1 中的工作方式。在清单 1 中，方法createConsumeronSession用于创建指定主题的非持久订阅（我们稍后将讨论持久订阅）：
private void createUnsharedConsumer(ConnectionFactory connectionFactory, Topic topic) throws JMSException { Connection connection = connectionFactory....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-24</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能" href=https://blog.chensoul.cc/posts/2024/07/24/jms20/></a></article><article class=post-entry><header class=entry-header><h2>[译]完整的 JMS 2.0 教程</h2></header><section class=entry-content><p>JMS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。消息传递是在各种应用程序或服务之间交换业务数据的过程。这是一个完整的 JMS 2.0 教程， 其中包含大量代码示例。完整的代码示例可在 GitHub 上找到，请下载并运行示例。本教程使用 Glassfish 开源服务器作为 JMS 提供程序的示例。
您可以使用 ActiveMQ 或 ActiveMQ Artemes 作为 JMS 提供程序，JMS API 保持不变，只有使用相应 JMS 提供程序的 maven 依赖项会发生变化。以下是本教程中涵盖的主题。
代码示例
JMS 简介 – Java 消息服务 为 JMS 安装和设置 Glassfish 在 JMS 中发送和接收消息 JMS 消息模型 JMS 确定消息优先级 JMS 点对点消息传递的实际应用 JMS 发布-订阅消息模型 JMS 消息选择器在过滤消息中的应用 使用 JMS 消息确认保证传送 JMS 事务的实际应用 参考 Apache ActiveMQ Artemis 用户手册 管理和排除 Glassfish JMS 故障 JMS 2.0 中的新增功能 原文链接：A Complete JMS 2.0 Tutorial</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]完整的 JMS 2.0 教程" href=https://blog.chensoul.cc/posts/2024/07/23/a-complete-jms-2-0-tutorial/></a></article><article class=post-entry><header class=entry-header><h2>[译]JMS 事务的实际应用</h2></header><section class=entry-content><p>在本文中，您将了解如何选择性地使用 JMS 事务。在 JMS 中，您可以选择控制一个会话的原子操作。每个会话都支持一系列事务。每个事务将一组生成或使用的消息分组为一个原子工作单元。确保您已经理解了JMS 中的消息确认。
交易提交时 – ( jmsContext.commit())
其输入的原子单位被承认。 对于消费者来说，类似地，其相关的输出也被发送（被消费者接收）。 如果事务回滚完成– （jmsContext.rollback()）
其产生的信息被销毁。 其使用的消息被恢复（不会从 JMS 服务器中删除）。 让我们看一下代码示例，以更好地理解其功能。链接到GitHub 代码库。
package lab07.transactons.example; import labxx.common.settings.CommonSettings; import javax.jms.*; public class TransactionExample { public static void main(String[] args) { ConnectionFactory connectionFactory = CommonSettings.getConnectionFactory(); Queue queue = CommonSettings.getDefaultQueue(); Thread messageproducer = new Thread() { public void run() { try (JMSContext jmsContext = connectionFactory.createContext(JMSContext.SESSION_TRANSACTED)) { JMSProducer producer = jmsContext.createProducer(); producer.send(queue, "This is a SESSION_TRANSACTED message"); producer.send(queue, "Sending another message"); //TODO - Comment and see the result, message is not delivered until committed sleep(5000); jmsContext.commit(); //Important //Next message is never delivered as it is rollback() producer.send(queue, "This message will not be delivered"); jmsContext....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 事务的实际应用" href=https://blog.chensoul.cc/posts/2024/07/23/jms-transactions-in-action/></a></article><article class=post-entry><header class=entry-header><h2>[译]使用 JMS 消息确认保证传送</h2></header><section class=entry-content><p>JMS 通过 JMS 消息确认（确认模式）确保消息传递的可靠性。如果会话已进行事务处理，则该commit()方法会自动处理消息确认。否则，该方法将处理恢复rollback()。在本文中，我们将假设会话未进行事务处理。这是一个高级主题，请确保您对 JMS 有基本的了解。如果您是 JMS 新手，可以参考使用 JMS发送和接收消息。
JMS Client会话未进行事务处理时使用消息确认。消息确认是在（JMS 生产者和 JMS 消费者）和之间建立的协议JMS Server。
JMS 提供三种确认选项，并且恢复是手动处理的。
AUTO_ACKNOWLEDGE – JMS 会话自动确认客户端已收到消息。不会发送重复消息。 CLIENT_ACKNOWLEDGE – JMS 客户端必须通过调用消息的acknowledge()方法来确认。 DUPS_OK_ACKNOWLEDGE – JMS 服务器可以放心地向 JMSConsumer 发送重复消息。客户端应用程序应该能够在此模式下处理重复消息。 1. JMS AUTO_ACKNOWLEDGE消息传递的实际操作 这是创建Session或时设置的默认确认模式JMSContext。您可以手动指定AUTO_ACKNOWLEDGE模式，如下所示。
JMSContext jmsContext = connectionFactory.createContext(JMSContext.AUTO_ACKNOWLEDGE); 在此模式下，当客户端成功从接收调用返回或其调用来处理消息的消息侦听器成功返回时，JMS 会话会自动确认客户端已收到消息。以下代码显示了此模式的用法。链接至GitHub 代码库。
package lab06.message.acknowledgement; import labxx.common.settings.CommonSettings; import javax.jms.*; public class AutoAcknowledgeExample { public static void main(String[] args) { ConnectionFactory connectionFactory = CommonSettings.getConnectionFactory(); Queue queue = CommonSettings.getDefaultQueue(); Thread messageproducer = new Thread() { public void run() { try (JMSContext jmsContext = connectionFactory.createContext(JMSContext.AUTO_ACKNOWLEDGE)) { JMSProducer producer = jmsContext.createProducer(); //Send the message Message message = jmsContext.createTextMessage("This is an AUTO_ACKNOWLEDGEMENT message"); producer.send(queue, message); } } }; Thread messageConsumer = new Thread() { public void run() { try (JMSContext jmsContext = connectionFactory....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>3 min</span></span></footer><a class=entry-link aria-label="post link to [译]使用 JMS 消息确认保证传送" href=https://blog.chensoul.cc/posts/2024/07/23/guaranteed-delivery-using-jms-message-acknowledgement/></a></article><article class=post-entry><header class=entry-header><h2>[译]JMS 消息选择器在过滤消息中的应用</h2></header><section class=entry-content><p>发送给接收方的消息通常需要根据某些标准进行过滤。JMS 提供消息选择器，允许 JMS 消费者根据消息头指定其感兴趣的消息。在本文中，您将学习使用 JMS 消息选择器来过滤消息。
这是一篇高级教程，在继续阅读本文之前，请确保您对 JMS 有基本的了解。如果您是 JMS 新手，请查看JMS 点对点消息传递模型文章。
为什么要使用消息选择器？ 当一条消息被广播给许多接收者时，将标准放入订阅中以注册特定的兴趣是很有用的。这样只有感兴趣的消息才会被传递给订阅者。
消息选择器是一种String基于SQL92条件表达式的语法。 仅传递标题和属性与选择器匹配的消息。 消息选择器不能引用消息正文值。 消息选择器从左到右进行评估。 选择器文字和运算符通常以大写字母书写，但它们不区分大小写。 1. 按属性过滤消息 就像我之前提到的，你只能根据属性或标头过滤消息，而不能根据实际消息内容过滤消息。下面的示例显示，只有级别日志被传递给消费者。链接至GitHub 代码库。
package lab04.message.filtering; import labxx.common.settings.CommonSettings; import org.junit.jupiter.api.Test; import javax.jms.*; import java.util.UUID; public class MessageSelectorExample { private static ConnectionFactory connectionFactory = null; private static Queue defaultQueue = null; static { connectionFactory = CommonSettings.getConnectionFactory(); defaultQueue = CommonSettings.getDefaultQueue(); } @Test public void messageFilterOnProperties() throws JMSException, InterruptedException { try (JMSContext jmsContext = connectionFactory.createContext()) { LogEvent event1 = new LogEvent("Sample ERROR Log", UUID.randomUUID().toString(), LogLevel.ERROR); LogEvent event2 = new LogEvent("Sample DEBUG Log", UUID.randomUUID().toString(), LogLevel.DEBUG); LogEvent event3 = new LogEvent("Sample INFO Log", UUID.randomUUID().toString(), LogLevel.INFO); LogEvent event4 = new LogEvent("Sample WARN Log", UUID....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>4 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 消息选择器在过滤消息中的应用" href=https://blog.chensoul.cc/posts/2024/07/23/jms-message-selectors-in-action-to-filter-messages/></a></article><article class=post-entry><header class=entry-header><h2>[译]JMS 发布-订阅消息模型</h2></header><section class=entry-content><p>在本文中，您将了解 JMS 发布-订阅 (publish-subscribe) 消息传递模型。正如您在JMS 简介文章中所读到的，在发布/订阅模型中，客户端通过称为主题的中介将消息发送给多个接收者。发送者通常称为发布者，接收者称为订阅者。
JMS 发布/订阅消息传递示例 下面是一个简单的代码示例，演示了发布/订阅消息模型的工作原理。我创建了 2 个主线程，publisher和subscriber1。将订阅者 1 克隆到subscriber2。所以基本上我有一个消息发布者和 2 个消息订阅者。链接至GitHub 。
package lab03.message.pubsub; import labxx.common.settings.CommonSettings; import javax.jms.*; public class SimplePubSubExample { private static ConnectionFactory connectionFactory = null; private static Topic defaultTopic = null; static { connectionFactory = CommonSettings.getConnectionFactory(); defaultTopic = CommonSettings.getDefautTopic(); } public static void main(String[] args) { Thread publisher = new Thread(){ @Override public void run(){ try(JMSContext jmsContext = connectionFactory.createContext()) { Thread.sleep(1000); JMSProducer producer = jmsContext.createProducer(); TextMessage message = jmsContext.createTextMessage("World needs to worry about the Climate changes"); producer.send(defaultTopic, message); } catch (InterruptedException ex){ ex.printStackTrace(); } } }; Thread subscriber1 = new Thread(){ @Override public void run(){ try(JMSContext jmsContext = connectionFactory....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 发布-订阅消息模型" href=https://blog.chensoul.cc/posts/2024/07/23/jms-pub-sub-messaging-model/></a></article><article class=post-entry><header class=entry-header><h2>[译]JMS 点对点消息传递的实际应用</h2></header><section class=entry-content><p>点对点系统使用队列进行消息传递。客户端将消息发送到特定队列，特定订阅者监听或接收来自该队列的消息。在 JMS 点对点消息传递系统中，队列用于处理单个发送者和单个消费者。确保您已经阅读了有关JMS 消息模型以及如何在 JMS 中发送和接收消息的先前教程。
使用队列进行 PTP 消息传送 您现在知道点对点消息传递完全是利用队列。JMS 提供javax.jms.Queue表示队列对象的功能。我将利用 JMS 2.0 API 来javax.jms.JMSProducer发送javax.jms.JMSConsumer和接收消息。
我已经向您展示了多个使用 JMS 队列的示例。以下代码表示在 JMS 2.0 API 中使用 JMS 队列的步骤，只是为了再次刷新一下概念。
package lab00.simple.helloworld; import javax.jms.*; import javax.naming.InitialContext; import javax.naming.NamingException; public class TestHelloWorld { public static void main(String[] args) { ConnectionFactory connectionFactory = null; Queue queue = null; try { InitialContext initialContext = new InitialContext(); //Step-1 Create ConnectionFactory connectionFactory = (ConnectionFactory) initialContext.lookup("jms/__defaultConnectionFactory"); //Step-2 Get the Destination queue = (Queue) initialContext.lookup("jms/PTPQueue"); } catch (NamingException e) { e.printStackTrace(); } //Step-3 Create J MSContext try (JMSContext jmsContext = connectionFactory.createContext()) { //Step-4a Create a Text Message and send TextMessage textMessage = jmsContext.createTextMessage("Message using JMS 2....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-07-23</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>4 min</span></span></footer><a class=entry-link aria-label="post link to [译]JMS 点对点消息传递的实际应用" href=https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://blog.chensoul.cc/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>