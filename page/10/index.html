<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.121.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ChenSoul</title>
<meta name=keywords content="java,python,go"><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/index.xml><link rel=alternate type=application/json href=https://blog.chensoul.cc/index.json><meta name=twitter:title content="ChenSoul"><meta name=twitter:description content><meta property="og:title" content="ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/"><meta property="og:site_name" content="ChenSoul"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"ChenSoul","url":"https://blog.chensoul.cc","description":"","thumbnailUrl":"https://blog.chensoul.cc/favicon.ico","sameAs":[]}</script><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-page kind-home layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>Java设计模式：Async Method Invocation</h2></header><section class=entry-content><p>本文主要介绍 Async Method Invocation 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 Async Method Invocation（异步方法调用）是一种编程模式，用于处理异步操作和并发执行。它允许在执行某个操作时不阻塞主线程，而是将操作委托给另一个线程或处理程序，并在操作完成后获取结果或执行回调。
异步方法调用的主要目的是提高应用程序的性能和响应能力。通过将耗时的操作（如网络请求、文件读写、数据库查询等）置于后台线程或异步任务中，可以使主线程能够继续执行其他任务，而不会被阻塞。
异步方法调用可以在不同的编程语言和框架中以不同的方式实现，包括以下几种常见的形式：
回调函数（Callback）：通过定义回调函数，将异步操作的结果传递给调用方。当异步操作完成时，回调函数会被调用并处理结果。 Future/Promise（Future/Deferred）：通过 Future 或 Promise 对象表示异步操作的结果，调用方可以在需要时获取结果或添加回调函数来处理结果。 异步/await：异步/await 是一种语法糖，用于简化异步代码的编写和理解。它允许以同步的方式编写异步操作，使代码更具可读性。 观察者模式（Observer）：通过定义观察者对象，异步操作的结果可以被观察者订阅。当结果可用时，观察者会被通知并执行相应的操作。 使用异步方法调用可以提高应用程序的并发性能和用户体验。它可以在后台执行耗时的操作，使主线程保持响应，并允许应用程序同时处理多个并发请求。然而，对于并发操作的正确处理和管理资源的安全性仍然需要仔细考虑和实施。
举例 AsyncResult（用于异步评估值的中间容器），AsyncCallback（可以在任务完成时被执行）和AsyncExecutor（用于管理异步任务的执行）。
public interface AsyncResult&lt;T> { boolean isCompleted(); T getValue() throws ExecutionException; void await() throws InterruptedException; } public interface AsyncCallback&lt;T> { void onComplete(T value, Optional&lt;Exception> ex); } public interface AsyncExecutor { &lt;T> AsyncResult&lt;T> startProcess(Callable&lt;T> task); &lt;T> AsyncResult&lt;T> startProcess(Callable&lt;T> task, AsyncCallback&lt;T> callback); &lt;T> T endProcess(AsyncResult&lt;T> asyncResult) throws ExecutionException, InterruptedException; } ThreadAsyncExecutor是AsyncExecutor的实现。 接下来将突出显示其一些关键部分。
public class ThreadAsyncExecutor implements AsyncExecutor { @Override public &lt;T> AsyncResult&lt;T> startProcess(Callable&lt;T> task) { return startProcess(task, null); } @Override public &lt;T> AsyncResult&lt;T> startProcess(Callable&lt;T> task, AsyncCallback&lt;T> callback) { var result = new CompletableResult&lt;>(callback); new Thread( () -> { try { result....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-08-14</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>3 min</span></span></footer><a class=entry-link aria-label="post link to Java设计模式：Async Method Invocation" href=https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/></a></article><article class=post-entry><header class=entry-header><h2>Java设计模式：API Gateway</h2></header><section class=entry-content><p>本文主要介绍 API Gateway 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
目的 API 网关设计模式旨在将所有对微服务的调用聚合到一起。客户端通过调用 API 网关来实现对多个微服务的访问，而不是直接调用每个微服务。这种模式的目的是解决以下问题：
减少客户端的网络请求：如果客户端直接调用每个微服务，会导致额外的网络请求，增加加载时间。通过使用 API 网关，客户端只需要进行一次调用，而不是多次调用。 解耦客户端和微服务：如果客户端直接与每个微服务进行通信，客户端与微服务之间的耦合度很高。当微服务的实现发生变化或位置发生变化时，需要更新所有客户端。使用 API 网关可以将客户端与具体的微服务解耦，客户端只需要与 API 网关通信。 提供集中化的功能和服务：API 网关可以实现一些通用的功能和服务，例如限流、认证、授权、安全性等。这样可以避免每个微服务都实现这些功能，减少重复代码。 解释 在实际应用中，API 网关通常包括一个转换引擎，用于实时地编排和修改请求和响应。它还可以提供收集分析数据和提供缓存等功能。另外，API 网关还可以支持身份验证、授权、安全性、审计和法规遵从性等功能。
假设你正在开发一个电子商务平台，其中包含多个微服务，如用户服务、产品服务、图片服务、订单服务和支付服务等。每个微服务都有自己的 API 和数据库。
在这种情况下，你可以引入一个 API 网关来处理对这些微服务的访问。API 网关作为一个入口点，接收来自客户端的请求，并将请求转发到适当的微服务。
例如，当一个客户端需要获取某个产品的详细信息时，他们可以发送一个 HTTP 请求到 API 网关的特定端点。API 网关会验证请求并将其转发到产品服务。产品服务将查询数据库获取产品信息，并将响应返回给 API 网关。然后，API 网关将产品信息返回给客户端。
API 网关可以实现以下功能：
认证和授权：API 网关可以验证客户端的身份和权限，确保只有经过授权的用户能够访问特定的微服务。 请求转发和路由：API 网关根据请求的路径和参数将请求转发到适当的微服务。它可以执行负载均衡和路由策略，确保请求被正确地分发到相应的微服务实例。 响应聚合：如果一个请求需要从多个微服务获取数据，API 网关可以将这些请求发送给相应的微服务，并将它们的响应聚合到一个响应中返回给客户端。 缓存和性能优化：API 网关可以缓存常用的请求和响应，以提高性能并减轻后端微服务的负载。 安全性和监控：API 网关可以实施安全策略，例如防止恶意请求和 DDoS 攻击。它还可以监控请求和响应，收集应用程序的指标和日志数据。 程序示例
此实现展示了电子商务站点的 API 网关模式。 ApiGateway分别使用 ImageClientImpl和 PriceClientImpl来调用 Image 和 Price 微服务。 在桌面设备上查看该网站的客户可以看到价格信息和产品图片，因此 ApiGateway会调用这两种微服务并在DesktopProduct模型中汇总数据。 但是，移动用户只能看到价格信息。 他们看不到产品图片。 对于移动用户，ApiGateway仅检索价格信息，并将其用于填充MobileProduct模型。
这个是图像微服务的实现。
public interface ImageClient { String getImagePath(); } public class ImageClientImpl implements ImageClient { @Override public String getImagePath() { var httpClient = HttpClient.newHttpClient(); var httpGet = HttpRequest.newBuilder() ....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-08-13</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to Java设计模式：API Gateway " href=https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/></a></article><article class=post-entry><header class=entry-header><h2>Java设计模式：Arrange/Act/Assert</h2></header><section class=entry-content><p>本文主要介绍 Arrange/Act/Assert 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 Arrange/Act/Assert（安排/执行/断言）又称 Given/When/Then，是一种测试设计模式，用于组织和编写单元测试的结构。它提供了一种清晰的测试布局，使得测试代码易于理解和维护。
该模式的三个阶段如下：
Arrange（安排）：在这个阶段，你准备测试环境和设置测试数据。这包括创建对象、设置输入参数、模拟依赖项等。你的目标是为将要进行的测试创建一个合适的环境。 Act（执行）：在这个阶段，你执行要测试的操作或调用要测试的方法。这是你对被测试代码进行实际调用的地方。 Assert（断言）：在这个阶段，你验证测试的结果是否符合预期。你会检查实际的输出、状态变化或异常情况，并使用断言语句来断言测试的期望结果。 这种测试结构的优势在于它提供了清晰的分离和组织测试代码的方式，并使得测试的目的和预期结果更容易理解。它也有助于减少测试代码中的重复和冗余。
以下是一个使用 Arrange/Act/Assert 模式编写的示例测试方法的伪代码：
public void testCalculateTotalPrice() { // Arrange ShoppingCart cart = new ShoppingCart(); cart.addItem(new Item("Item 1", 10.0)); cart.addItem(new Item("Item 2", 15.0)); // Act double totalPrice = cart.calculateTotalPrice(); // Assert assertEquals(25.0, totalPrice, 0.01); } 在上述示例中，首先在 Arrange 阶段创建了一个购物车对象，并添加了两个商品。然后，在 Act 阶段调用了calculateTotalPrice()方法来计算总价格。最后，在 Assert 阶段使用断言语句来验证计算的结果是否等于预期的总价格。
适用性 Arrange/Act/Assert（安排/执行/断言）设计模式适用于编写单元测试，特别是针对函数、方法或类的单元测试。它在以下情况下特别有用：
单元测试：Arrange/Act/Assert 模式适用于对单个函数或方法进行测试。它帮助你组织测试代码，使其结构清晰，并确保每个测试只关注一个特定的功能或行为。 易于理解和维护：这种模式提供了一种一致的测试结构，使得测试代码易于理解和维护。通过明确的安排、执行和断言阶段，你可以更清楚地了解测试的目的和预期结果。 测试代码可读性：Arrange/Act/Assert 模式可以使测试代码更具可读性。通过按照统一的结构组织测试代码，使得测试逻辑更加清晰可见，易于他人理解和参与。 提高可维护性：使用这种模式可以减少测试代码中的重复和冗余，使得测试代码更易于维护。在 Arrange 阶段设置测试环境和准备数据，可以减少在每个测试中重复的代码。 测试结果验证：Arrange/Act/Assert 模式明确了测试结果的验证过程。在 Assert 阶段使用断言语句来验证实际结果与预期结果的一致性，帮助你确保被测试代码的正确性。 需要注意的是，Arrange/Act/Assert 模式主要适用于单元测试，而对于集成测试或端到端测试等更大范围的测试，可能需要使用其他测试设计模式或框架来进行组织和管理测试代码。
除了 Arrange/Act/Assert 模式，以下是一些适用于集成测试或端到端测试的设计模式或框架：
Page Object 模式：Page Object 模式是一种用于管理用户界面元素和操作的设计模式。它将页面的元素和操作封装到可重用的对象中，使得测试代码更具可读性和可维护性。Page Object 模式特别适用于 Web 应用程序的端到端测试。 数据构建器模式：数据构建器模式用于生成测试数据，以便在集成测试或端到端测试中使用。它提供了一种灵活的方式来创建测试数据，包括复杂的数据结构和关联关系。 数据准备和清理模式：在集成测试或端到端测试中，通常需要准备测试数据和环境，并在测试完成后进行清理。数据准备和清理模式提供了一种结构化的方法来管理这些操作，确保测试的一致性和可重复性。 Mock 对象模式：Mock 对象模式用于模拟或替代外部依赖项，以便进行集成测试或端到端测试。通过使用 Mock 对象，你可以隔离被测试代码与外部系统的交互，使得测试更加可控和独立。 BDD（行为驱动开发）框架：BDD 框架（如 Cucumber、SpecFlow 等）提供了一种以自然语言编写测试用例和规范的方式。它将测试用例描述为可读性强的场景和步骤，帮助开发人员、测试人员和业务利益相关者之间的沟通和理解。 参考 Arrange, Act, Assert: What is AAA Testing?...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-08-13</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>1 min</span></span></footer><a class=entry-link aria-label="post link to Java设计模式：Arrange/Act/Assert" href=https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/></a></article><article class=post-entry><header class=entry-header><h2>周报-28｜技术文档范例</h2></header><section class=entry-content><p>前言 本篇是对 2023-07-10 到 2023-07-16 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。
读书、健身、投资、帮朋友、陪家人。
这是我的第 27 篇周报，由于工作的原因，前两周的周报是一起发布的，所以第 27 篇周报被跳过去了。
技术文档范例 以下是一个使用中文标题的技术文档范例：
一、介绍 1.1 目的 1.2 范围 1.3 受众 1.4 定义、缩略语和术语 二、概述 2.1 系统架构 2.2 主要功能 2.3 系统要求 三、入门指南 3.1 安装 3.2 配置 3.3 第一步操作 四、用户指南 4.1 用户界面 4.2 导航 4.3 功能 五、管理指南 5.1 系统配置 5.2 用户管理 5.3 安全性 六、故障排除 6.1 常见问题 6.2 错误消息 七、附录 7.1 发行说明 7.2 术语表 7.3 参考文献 以下是一个使用数字标题的 Spring Cloud Gateway 教程示例：
1. 介绍 1.1 目的 1.2 范围 1.3 受众 1.4 术语和定义 2. 概述 2.1 什么是 Spring Cloud Gateway 2.2 Spring Cloud Gateway 的优势 3. 快速入门 3.1 环境配置 3.2 创建Spring Cloud Gateway项目 3.3 配置路由规则 3....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-07-27</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/review/>review</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to 周报-28｜技术文档范例" href=https://blog.chensoul.cc/posts/2023/07/27/weekly_review_28/></a></article><article class=post-entry><header class=entry-header><h2>[译]Spring Boot授权服务器 - 使用 Java 的资源服务器和客户端凭证示例</h2></header><section class=entry-content><p>概述 在本文中，我们将创建一个授权服务器，为任何客户端生成 access_token。这称为 OAuth2 的 client_credentials 流程。它主要用于服务间通信。
我们将使用 spring boot oauth2 授权服务器依赖项来创建身份验证服务器。我们还将创建一个资源服务器和客户端来对其进行端到端测试。
Spring 授权服务器 我们首先创建授权服务器。
依赖项： 让我们将以下依赖项添加到我们的项目中。
implementation 'org.springframework.security:spring-security-oauth2-authorization-server:1.0.0' implementation 'org.springframework.boot:spring-boot-starter-security' implementation 'org.springframework.boot:spring-boot-starter-web' testImplementation 'org.springframework.boot:spring-boot-starter-test' testImplementation 'org.springframework.security:spring-security-test' 我们正在使用 spring oauth2 依赖项的最新（当时）稳定版本。
Java 实现： 让我们创建一个名为 AuthorizationServerConfig 的配置类，并向该类添加 @Configuration 注解。现在让我们创建以下 bean 来完成配置：
SecurityFilterChain @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SecurityFilterChain authServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); return http.build(); } 我们将把 bean 的顺序设置为最高，因为我们想首先执行它。
RegisteredClientRepository @Bean public RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId("oauth-client") .clientSecret("{noop}oauth-secret") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .scope(OidcScopes.OPENID) .scope("articles.read") .build(); return new InMemoryRegisteredClientRepository(registeredClient); } 现在让我们使用内存存储库对内容进行硬编码。我们可以根据我们的需要更新这些。
JwtDecoder @Bean public JwtDecoder jwtDecoder(JWKSource&lt;SecurityContext> jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } 我们将使用它来解码令牌以进行验证。
JWKSource @Bean public JWKSource&lt;SecurityContext> jwkSource() throws NoSuchAlgorithmException { RSAKey rsaKey = generateRsa(); JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -> jwkSelector....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-07-26</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/spring/>spring</a><a href=https://blog.chensoul.cc/tags/spring-boot/>spring boot</a><a href=https://blog.chensoul.cc/tags/spring-security/>spring security</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>3 min</span></span></footer><a class=entry-link aria-label="post link to [译]Spring Boot授权服务器 - 使用 Java 的资源服务器和客户端凭证示例" href=https://blog.chensoul.cc/posts/2023/07/26/spring-boot-authorization-server/></a></article><article class=post-entry><header class=entry-header><h2>[译]Spring Boot异常处理完整指南</h2></header><section class=entry-content><p>处理异常是构建健壮应用程序的重要部分。 Spring Boot 提供了不止一种方法。
本文将探讨这些方法，并提供一些关于何时某种给定方法可能优于另一种方法的指导。
示例代码 本文附有 GitHub 上的工作代码示例。
介绍 Spring Boot 为我们提供了处理异常的工具，而不仅仅是简单的“try-catch”块。为了使用这些工具，我们应用了一些注释，使我们能够将异常处理视为横切关注点：
@ResponseStatus @ExceptionHandler @ControllerAdvice 在深入了解这些注释之前，我们将首先了解 Spring 如何处理 Web 控制器抛出的异常——这是捕获异常的最后一道防线。
我们还将查看 Spring Boot 提供的一些配置来修改默认行为。
我们将确定这样做时面临的挑战，然后我们将尝试使用这些注释来克服这些挑战。
Spring Boot 默认的异常处理机制 假设我们有一个名为 ProductController 的控制器，当未找到具有给定 id 的 Product 时，其 getProduct(...) 方法会抛出 NoSuchElementFoundException 运行时异常：
@RestController @RequestMapping("/product") public class ProductController { private final ProductService productService; //constructor omitted for brevity... @GetMapping("/{id}") public Response getProduct(@PathVariable String id){ // this method throws a "NoSuchElementFoundException" exception return productService.getProduct(id); } } 如果我们使用无效的 id 调用 /product API，服务将抛出 NoSuchElementFoundException 运行时异常，我们将得到以下响应：
{ "timestamp": "2020-11-28T13:24:02.239+00:00", "status": 500, "error": "Internal Server Error", "message": "", "path": "/product/1" } 我们可以看到，除了格式良好的错误响应之外，有效负载没有为我们提供任何有用的信息。甚至 message 字段也是空的，我们可能希望包含“未找到 id 1 的项目”之类的内容。
让我们从修复错误消息问题开始。
Spring Boot 提供了一些属性，我们可以使用它们添加异常消息、异常类，甚至堆栈跟踪作为响应负载的一部分：...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-07-26</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/spring-boot/>spring boot</a><a href=https://blog.chensoul.cc/tags/spring/>spring</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>5 min</span></span></footer><a class=entry-link aria-label="post link to [译]Spring Boot异常处理完整指南" href=https://blog.chensoul.cc/posts/2023/07/26/spring-boot-exception-handling/></a></article><article class=post-entry><header class=entry-header><h2>[译]使用 Spring 的 Null-Safety 注解保护您的代码免受 NullPointerExceptions 的影响</h2></header><section class=entry-content><p>NullPointerExceptions （通常缩写为“NPE”）对于每个 Java 程序员来说都是一场噩梦。
我们可以在互联网上找到大量解释如何编写空安全代码的文章。空安全确保我们在代码中添加了适当的检查，以保证对象引用不能为空，或者毕竟在对象为空时采取可能的安全措施。
由于 NullPointerException 是一个运行时异常，因此在代码编译过程中很难找出这种情况。 Java 的类型系统没有办法快速消除危险的空对象引用。
幸运的是，Spring 框架提供了一些注释来解决这个问题。在本文中，我们将学习如何使用这些注释通过 Spring Boot 编写空安全代码。
示例代码 本文附有 GitHub 上的工作代码示例。
Spring 中的空安全注解 在 Spring 核心包 org.springframework.lang 下，有 4 个这样的注解：
@NonNull, @NonNull ， @NonNullFields, @NonNullFields ， @Nullable, @NonNullApi. Eclipse 和 IntelliJ IDEA 等流行的 IDE 可以理解这些注释。它们可以在编译期间警告开发人员潜在的问题。
我们将在本教程中使用 IntelliJ IDEA。让我们通过一些代码示例来了解更多信息。
要创建基础项目，我们可以使用 Spring Initializr。 Spring Boot 启动器就是我们所需要的，不需要添加任何额外的依赖项。
IDE 配置 请注意，并非所有开发工具都可以显示这些编译警告。如果您没有看到相关警告，请检查 IDE 中的编译器设置。
IntelliJ 对于 IntelliJ，我们可以在“Build, Execution, Deployment -> Compiler”下激活注释检查：
Eclipse 对于 Eclipse，我们可以在“Java -> Compiler -> Errors/Warnings”下找到设置：
示例代码 让我们使用一个简单的 Employee 类来理解注释：
package io.reflectoring.nullsafety; // imports class Employee { String id; String name; LocalDate joiningDate; String pastEmployment; // standard constructor, getters, setters } @NonNull 大多数情况下， id 字段（在 Employee 类中）将是一个不可为 null 的值。因此，为了避免任何潜在的 NullPointerException 我们可以将此字段标记为 @NonNull ：...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-07-26</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/spring-boot/>spring boot</a><a href=https://blog.chensoul.cc/tags/spring/>spring</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]使用 Spring 的 Null-Safety 注解保护您的代码免受 NullPointerExceptions 的影响" href=https://blog.chensoul.cc/posts/2023/07/26/spring-boot-null-safety-annotations/></a></article><article class=post-entry><header class=entry-header><h2>[译]使用 Spring Boot 和 Spring Security 配置 CORS</h2></header><section class=entry-content><p>跨源资源共享 (CORS) 是一种基于 HTTP 标头的机制，允许服务器显式将某些源列入白名单，并帮助绕过同源策略。
这是必需的，因为浏览器默认应用同源策略以确保安全。通过在 Web 应用程序中实施 CORS，网页可以请求额外的资源并从其他域加载到浏览器中。
本文将重点介绍在基于 Spring 的应用程序中实现 CORS 的各种方式。要详细了解 CORS 的工作原理，请参阅这篇优秀的介绍性文章。
示例代码 本文附有 GitHub 上的工作代码示例。
CORS 特定 HTTP 响应标头概述 CORS 规范定义了服务器返回的一组响应标头，这将是后续部分的重点。
响应头 描述 Access-Control-Allow-Origin 以逗号分隔的白名单来源列表或“*”。 Access-Control-Allow-Methods Web 服务器允许跨源请求的 HTTP 方法的逗号分隔列表。 Access-Control-Allow-Headers Web 服务器允许跨源请求的 HTTP 标头的逗号分隔列表。 Access-Control-Expose-Headers 客户端脚本认为可以安全显示的以逗号分隔的 HTTP 标头列表。 Access-Control-Allow-Credentials 如果浏览器通过传递凭据（以 cookie 或授权标头的形式）向服务器发出请求，则其值设置为 true 。 Access-Control-Max-Age 指示预检请求的结果可以缓存多长时间。 设置示例客户端应用程序 我们将使用一个简单的角度应用程序来调用 REST 端点，我们可以使用浏览器开发人员工具检查这些端点。您可以在 GitHub 上查看源代码。
ng serve --open 我们应该能够成功启动客户端应用程序。
设置示例服务器应用程序 我们将使用一个基于 Spring 的示例应用程序，其中包含客户端应用程序可以调用的 GET 和 POST 请求。请注意，您会发现两个独立的应用程序：一个使用 Spring MVC (REST)，另一个使用 Spring Reactive 堆栈。
为简单起见，两个应用程序之间的 CORS 配置相同，并且定义了相同的端点。两台服务器都从不同的端口 8091 和 8092 启动。
与应用程序捆绑在一起的 Maven Wrapper 将用于启动服务。您可以查看 Spring REST 源代码和 Spring Reactive 源代码。
mvnw clean verify spring-boot:run (for Windows) ./mvnw clean verify spring-boot:run (for Linux) 一旦 Spring 应用程序成功启动，客户端应用程序应该能够成功从服务器加载数据。...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-07-26</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/spring/>spring</a><a href=https://blog.chensoul.cc/tags/spring-boot/>spring boot</a><a href=https://blog.chensoul.cc/tags/spring-security/>spring security</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>5 min</span></span></footer><a class=entry-link aria-label="post link to [译]使用 Spring Boot 和 Spring Security 配置 CORS" href=https://blog.chensoul.cc/posts/2023/07/26/spring-cors/></a></article><article class=post-entry><header class=entry-header><h2>[译]使用Spring Boot Actuator公开有用的信息端点</h2></header><section class=entry-content><p>在分布式、快节奏的环境中，开发团队通常希望了解他们部署应用程序的时间、部署的应用程序版本、部署的 Git 提交等等。
Spring Boot Actuator 帮助我们监控和管理应用程序。它公开了提供应用程序运行状况、指标和其他相关信息的各种端点。
在本文中，我们将了解如何使用 Spring Boot Actuator 和 Maven/Gradle 构建插件将此类信息添加到我们的项目中。
示例代码 本文附有 GitHub 上的工作代码示例。
启用 Spring Boot 执行器 Spring Boot Actuator 是 Spring Boot 的一个子项目。在本节中，我们将快速了解如何引导示例项目并启用 /info 端点。如果您想了解更多有关 Spring Boot Actuator 的信息，已经有一个很棒的教程了。
让我们使用 Spring Initializr 快速创建一个 Spring Boot 项目。我们将需要以下依赖项：
依赖性 目的 Spring Boot Actuator 公开应用程序管理端点，例如 info 。 Spring Web 启用 Web 应用程序行为。 如果有帮助，这里是 Maven 和 Gradle 中预填充项目的链接。
项目构建后，我们将通过 HTTP 公开内置的 /info 端点。默认情况下， /info Web 端点处于禁用状态。我们可以通过在 application.properties 配置中添加 management.endpoints.web.exposure.include 属性来简单地启用它：
management.endpoints.web.exposure.include=health,info 让我们运行 Spring Boot 应用程序并在浏览器中打开 URL http://localhost:8080/actuator/info 。目前还看不到任何有用的东西，因为我们仍然需要进行一些配置更改。在下一节中，我们将了解如何在此响应中添加信息丰富的构建信息。
保护端点 如果您公开公开端点，请确保适当保护它们。我们不应在不知情的情况下泄露任何敏感信息。
Spring Boot 应用程序信息 Spring 从应用程序上下文中定义的各种 InfoContributor bean 收集有用的应用程序信息。下面是默认 InfoContributor beans 的摘要：
ID Bean Name 用法 build BuildInfoContributor 公开构建信息。 env EnvironmentInfoContributor 公开 Environment 中名称以 info....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-07-26</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/spring/>spring</a><a href=https://blog.chensoul.cc/tags/maven/>maven</a><a href=https://blog.chensoul.cc/tags/gradle/>gradle</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>3 min</span></span></footer><a class=entry-link aria-label="post link to [译]使用Spring Boot Actuator公开有用的信息端点" href=https://blog.chensoul.cc/posts/2023/07/26/spring-boot-info-endpoint/></a></article><article class=post-entry><header class=entry-header><h2>[译]在 Spring 中实现 OAuth2：使用范围（第 2 部分）</h2></header><section class=entry-content><p>我们在上一篇文章中了解了基本的 OAuth2 概念以及如何在 Spring 中实现和执行不同的授权。在这篇文章中，我们将介绍 OAuth2 的另一个重要概念：范围。
OAuth 范围 保护对应用程序的访问通常分两个步骤进行：身份验证和授权。要理解这两个概念，假设您在绝密政府大楼工作。在开始之前，你会得到一张卡片，可以让你进入建筑物。 OAuth 令牌可以看作是允许您访问的卡片。
一旦你进去，你决定去三楼见你的一位同事，在尝试使用你的卡打开三楼的门后，你听到一声嘟嘟声，告诉你你没有被授权。在 OAuth 中，范围是一种定义令牌可以访问哪些资源以及不能访问哪些资源的方法。范围允许访问控制，并且可以被视为相当于传统身份验证中的用户角色。
实现 为了演示范围，我们将使用第 1 部分中的示例。
在资源服务器的控制器中，我们有以下端点：
@RestController("/") public class ResourceController { @GetMapping("/hello") public String hello(){ return "hello"; } @GetMapping("/foo") public String foo(){ return "foo"; } @PostMapping("/bar") public String bar(){ return "bar"; } @DeleteMapping("/test") public String test(){ return "test"; } } 第一步是使用所需的范围配置授权服务器：
clients.inMemory().withClient("my-trusted-client") .authorizedGrantTypes("password", "refresh_token", "implicit", "client_credentials", "authorization_code") .authorities("CLIENT") .scopes("read", "write", "trust") .accessTokenValiditySeconds(60) .redirectUris("http://localhost:8081/test.html") .resourceIds("resource") .secret("mysecret"); 要在资源服务器中启用范围检查，我们有两个选项：使用安全配置或使用方法安全性。
使用安全配置： @Override public void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(HttpMethod.GET,"/hello").access("#oauth2.hasScope('read')") .antMatchers(HttpMethod.GET,"/foo").access("#oauth2.hasScope('read')") .antMatchers(HttpMethod.POST,"/bar").access("#oauth2.hasScope('write')") .antMatchers(HttpMethod.DELETE,"/test").access("#oauth2.hasScope('trust')") .anyRequest().authenticated(). and().csrf().disable(); } 使用方法安全性： @PreAuthorize("#oauth2.hasScope('read')") @GetMapping("/hello") public String hello(){ return "hello"; } @PreAuthorize("#oauth2.hasScope('read')") @GetMapping("/foo") public String foo(){ return "foo"; } @PreAuthorize("#oauth2....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-07-26</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/spring/>spring</a><a href=https://blog.chensoul.cc/tags/spring-boot/>spring boot</a><a href=https://blog.chensoul.cc/tags/spring-security/>spring security</a><a href=https://blog.chensoul.cc/tags/oauth2/>oauth2</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]在 Spring 中实现 OAuth2：使用范围（第 2 部分）" href=https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring-scopes/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/page/9/>« Prev Page</a>
<a class=next href=https://blog.chensoul.cc/page/11/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>