<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.133.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ChenSoul</title>
<meta name=keywords content="java"><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/index.xml><link rel=alternate type=application/json href=https://blog.chensoul.cc/index.json><link rel=alternate hreflang=en href=https://blog.chensoul.cc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="ChenSoul"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="ChenSoul"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"ChenSoul","url":"https://blog.chensoul.cc/","description":"健康，爱情和使命，按照这个顺序，其它的都不重要","thumbnailUrl":"https://blog.chensoul.cc/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>All things about Drone</h2></header><div class=entry-content><p>Drone by Harness ™ 是一个现代化的持续集成平台，使忙碌的团队能够使用强大的云原生管道引擎自动化其构建、测试和发布工作流程。
Drone实践 Docker 容器环境下的持续集成最佳实践：构建基于 Drone + GitFlow + K8s 的云原生语义化 CI 工作流 容器环境持续集成优化，Drone CI 提速 500% 在Kubernetes上执行Drone CI/CD 玩转 Drone CI 基于 gogs/gitlab 和 drone 搭建的 CI/CD 平台 基于drone构建CI/CD系统,对接k8s 使用Drone构建静态博客
Hugo + Gogs + Drone 搭建博客 How to build a Hugo static site automatically using Drone CI and Codeberg.org Static Website Generation on Steriods with Docker A HUGO PLUGIN FOR YOUR DRONE CI PIPELINE drone持续集成-发布github pages 视频教学 一天學會 DevOps 自動化測試及部署</p></div><footer class=entry-footer><span title='2024-05-09 12:00:00 +0800 +0800'>2024-05-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;74 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to All things about Drone" href=https://blog.chensoul.cc/posts/2024/05/09/all-things-about-drone/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>通过k3sup安装k3s</h2></header><div class=entry-content><p>k3sup是一个支持在PC、虚拟机、ARM设备上安装k3s的工具，官方网站：https://k3sup.dev/
安装k3sup 在线安装：
curl -sLS https://get.k3sup.dev | sh sudo install k3sup /usr/local/bin/ 离线安装，下载地址：https://github.com/alexellis/k3sup/releases
wget https://github.com/alexellis/k3sup/releases/download/0.13.5/k3sup mv k3sup /usr/local/bin/ chmod +x /usr/local/bin/k3sup 查看版本：
$ k3sup version _ _____ | | _|___ / ___ _ _ _ __ | |/ / |_ \/ __| | | | '_ \ | &lt; ___) \__ \ |_| | |_) | |_|\_\____/|___/\__,_| .__/ |_| bootstrap K3s over SSH in &lt; 60s 🚀 🚀 Speed up GitHub Actions/GitLab CI + reduce costs: https://actuated.dev Version: 0.13.5 Git Commit: d952d6df22b06147806ca1030b8ba3a4bb9e0c0c 创建k3s集群 创建一个本地集群 k3sup install \ --local \ --context localk3s \ --k3s-channel stable \ --k3s-extra-args '--docker' 查看集群状态：
$ k3sup ready --context localk3s --kubeconfig ....</p></div><footer class=entry-footer><span title='2024-05-09 11:00:00 +0800 +0800'>2024-05-09</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;401 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 通过k3sup安装k3s" href=https://blog.chensoul.cc/posts/2024/05/09/install-k3s-using-k3sup/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>安装k3s</h2></header><div class=entry-content><p>K3s 是轻量级的 Kubernetes。K3s 易于安装，仅需要 Kubernetes 内存的一半，所有组件都在一个小于 100 MB 的二进制文件中。
k3s 文档：https://docs.rancher.cn/docs/k3s/_index
K3s介绍 什么是 K3s？ K3s 是一个完全兼容的 Kubernetes 发行版，具有以下增强功能：
打包为单个二进制文件。 使用基于 sqlite3 作为默认存储机制的轻量级存储后端。同时支持使用 etcd3、MySQL 和 Postgres。 封装在简单的启动程序中，可以处理很多复杂的 TLS 和选项。 默认情况下是安全的，对轻量级环境有合理的默认值。 添加了简单但强大的 batteries-included 功能，例如： 本地存储提供程序 service load balancer Helm controller Traefik ingress controller 所有 Kubernetes control plane 组件的操作都封装在单个二进制文件和进程中。因此，K3s 支持自动化和管理复杂的集群操作（例如证书分发等）。 最大程度减轻了外部依赖性，K3s 仅需要现代内核和 cgroup 挂载。K3s 打包了所需的依赖，包括： containerd Flannel (CNI) CoreDNS Traefik (Ingress) Klipper-lb (Service LB) 嵌入式网络策略控制器 嵌入式 local-path-provisioner 主机实用程序（iptables、socat 等） 为什么叫 K3s? 我们希望安装的 Kubernetes 只占用一半的内存。Kubernetes 是一个 10 个字母的单词，简写为 K8s。Kubernetes 的一半就是一个 5 个字母的单词，因此简写为 K3s。K3s 没有全称，也没有官方的发音。
适用场景 K3s 适用于以下场景：
边缘计算-Edge 物联网-IoT CI Development ARM 嵌入 K8s 由于运行 K3s 所需的资源相对较少，所以 K3s 也适用于开发和测试场景。在这些场景中，如果开发或测试人员需要对某些功能进行验证，或对某些问题进行重现，那么使用 K3s 不仅能够缩短启动集群的时间，还能够减少集群需要消耗的资源。与此同时，Rancher 中国团队推出了一款针对 K3s 的效率提升工具：AutoK3s。只需要输入一行命令，即可快速创建 K3s 集群并添加指定数量的 master 节点和 worker 节点。如需详细了解 AutoK3s，请参考AutoK3s 功能介绍。...</p></div><footer class=entry-footer><span title='2024-05-09 10:00:00 +0800 +0800'>2024-05-09</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;670 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 安装k3s" href=https://blog.chensoul.cc/posts/2024/05/09/install-k3s/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>通过k3d安装k3s</h2></header><div class=entry-content><p>k3d是什么 k3d 是一个轻量级包装器，用于在 docker 中运行k3s（Rancher Lab 的最小 Kubernetes 发行版）。
k3d 使得在 docker 中创建单节点和多节点k3s集群变得非常容易，例如用于 Kubernetes 上的本地开发。
注意： k3d 是一个社区驱动的项目，但它不是官方 Rancher (SUSE) 产品。
k3d安装 通过脚本安装：
wget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash macos 上通过homebrew安装：
brew install k3d 查看帮助文档：
$ k3d -h https://k3d.io/ k3d is a wrapper CLI that helps you to easily create k3s clusters inside docker. Nodes of a k3d cluster are docker containers running a k3s image. All Nodes of a k3d cluster are part of the same docker network. Usage: k3d [flags] k3d [command] Available Commands: cluster Manage cluster(s) completion Generate completion scripts for [bash, zsh, fish, powershell | psh] config Work with config file(s) help Help about any command image Handle container images....</p></div><footer class=entry-footer><span title='2024-05-09 10:00:00 +0800 +0800'>2024-05-09</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;611 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 通过k3d安装k3s" href=https://blog.chensoul.cc/posts/2024/05/09/install-k3s-using-k3d/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>All things about Spring Modulith</h2></header><div class=entry-content><p>VMware 推出了一个实验性的项目Spring Modulith，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。
2022 年 11 月推出的Spring Boot 3会是 Spring Modulith 的基础。所以它的基线是 Spring Framework 6、Java 17 和 Jakarta EE 9。Spring Modulith 是Moduliths（其名字有个“s”后缀）项目的继承者。该项目使用 Spring Boot 2.7，目前已经退役，只接收缺陷修正，直至 2023 年 11 月份。
https://spring.io/blog/2022/10/21/introducing-spring-modulith
https://www.baeldung.com/spring-modulith
https://www.baeldung.com/spring-modulith-event-externalization
https://piotrminkowski.com/2023/10/13/guide-to-modulith-with-spring-boot/
https://springdoc.cn/guide-to-modulith-with-spring-boot/
https://medium.com/andamp/event-sourcing-with-spring-modulith-2b35b0569dbb
https://www.geeksforgeeks.org/what-is-spring-modulith/
https://github.com/xsreality/spring-modulith-with-ddd
https://riteshshergill.medium.com/the-spring-modulith-monolithic-but-manageable-ca1532a1e585
https://www.infoq.com/news/2022/11/spring-modulith-launch/
https://dzone.com/articles/architecture-style-modulith-vs-microservices
https://speakerdeck.com/olivergierke/spring-modulith-a-deep-dive
https://www.jappware.com/proffesional-activity/make-monolithic-apps-great-again-with-spring-modulith-coffeejug/
https://blog.worldline.tech/2024/01/23/modulith.html
https://springdoc.cn/spring-modulith-intro/
https://dimitri.codes/checking-out-spring-modulith/
https://www.lefer.cn/posts/29752/
https://www.jdon.com/63003.html
https://blog.csdn.net/cfy_banq/article/details/132185951
https://www.zhihu.com/question/567053421</p></div><footer class=entry-footer><span title='2024-05-09 08:00:00 +0800 +0800'>2024-05-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;67 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to All things about Spring Modulith" href=https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</h2></header><div class=entry-content><p>原文链接：https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249
来源：https://www.thewebmaster.com/
先决条件：了解 javascript、客户端-服务器架构。
完整的代码可以在github上找到。
第 1 部分：概述（http2 的原因、内容、时间、方式）第 2 部分：使用 node-http2 核心和 hapijs 进行探索
免责声明：本文将使用node@v9+附带的http2模块。这里列出了其他几个 http2 客户端-服务器库实现。
让我们开始创建一个具有单一路由的简单 http1.1 服务器。
mkdir hapijs-http2 && \ cd hapijs-http2 && \ npm init -y && \ npm i hapi@^16.6 -s && \ touch http1Server.js 将下面的代码复制到此处或从此处http1Server.js克隆整个存储库。
const Hapi = require('hapi'); const server = new Hapi.Server(); // define server config server.connection({ port: '8000' }); // define route config server.route([{ method: 'GET', path: '/ping', handler: (request, reply) => { reply('pong'); } }]); // start server server.start(err => { if (err) console.error(err) console.log(`Started ${server.connections.length} connections`) }); 现在，让我们进行健全性检查。
启动服务器，node http1Server.js
⇒ http://127.0.0.1:8000/ping pong 凉爽的！如果我们得到 pong 的 ping，让我们尝试将http2集成到我们的 hapijs 服务器中。...</p></div><footer class=entry-footer><span title='2024-05-08 11:34:00 +0800 +0800'>2024-05-08</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;324 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs" href=https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]探索 http2（第 1 部分）：概述</h2></header><div class=entry-content><p>原文链接：https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f
让我们来谈谈 http2 的内容、原因、时间和方式
完整的代码可以在github上找到。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
什么是http2？ **http2*是自 1999 年以来使用的http1.1***之后的最新更新
http2协议注重性能；具体来说，最终用户感知的延迟、网络和服务器资源的使用情况。 （在此处阅读有关规格的信息*）*
为什么是http2？ 换句话说http1.1有什么问题
加载网页是一项资源密集型工作，因为 HTTP/1.1 只允许每个 TCP 连接有一个未完成的请求。网络需要进行更新，以提高效率、安全性和速度。
http2如何解决性能问题？
http2 带来的改进：
**单一连接：**仅使用一个与服务器的连接来加载网站，并且只要网站打开，该连接就保持打开状态。这减少了建立多个 TCP 连接所需的往返次数。（更多信息在这里） **多路复用：**同一连接上同时允许多个请求。以前，在 HTTP/1.1 中，每个传输都必须等待其他传输完成。（更多信息在这里） **服务器推送：**可以将其他资源发送到客户端以供将来使用。（更多信息在这里） **优先级：**请求被分配依赖级别，服务器可以使用它来更快地交付更高优先级的资源。（更多信息在这里） **二进制：**使 HTTP/2 更易于服务器解析、更紧凑且不易出错。将信息从文本转换为二进制不会浪费额外的时间。（更多信息在这里） 标头压缩： HTTP/2 使用HPACK压缩，从而减少开销。在 HTTP/1.1 中，每个请求中的许多标头都使用相同的值发送。（更多信息在这里） 我们什么时候可以开始使用http2？ 现在！
这是时间线，
来源：https://www.polyglotdeveloper.com/
是的，从 1999 年到今天，我们（大多数）都在使用同样好的旧 http1.1； 15年！
如何开始使用http2？ 以下是各种语言的 http2 库实现列表。
根据Can I Use的统计，大约 83% 的在线浏览器已经支持 http2
查看实际情况，http1.1 与 http2（网络节流：快速 3g）
http1.1（左）与http2（右）；让我们在下一节中构建它
在下一部分中，我们将构建一个支持 http2 的简单服务器；具有http1.1向后兼容性；一步一步使用http2-node core 和hapi js。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
完整的代码可以在github上找到。</p></div><footer class=entry-footer><span title='2024-05-08 11:30:00 +0800 +0800'>2024-05-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;88 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]探索 http2（第 1 部分）：概述" href=https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]比较 Socket.IO 和 HTTP：主要区别和用例</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/socketio-vs-http
在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。
什么是Socket.IO？ Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。
Socket.IO 需要两个库 - 一个在服务器上，一个在客户端上。 Socket.IO 创建者维护以下“官方”：
Socket.IO是 Node.js 服务器组件。 Socket.IO-client是客户端 JavaScript 库。 一些 Socket.IO 客户端和服务器实现可以用其他语言实现。请阅读Socket.IO 是什么来获取列表。
下图总结了典型的 Socket.IO 设置：
Socket.IO 主要特性 Socket.IO 具有以下主要特性：
**向后兼容性：**在现代浏览器中，Socket.IO 使用WebSocket API提供所需的连接并发送消息。 WebSocket 在服务器和浏览器之间提供全双工、低延迟、事件驱动的连接。它也是有状态的。如果需要旧版浏览器支持，或者 WebSocket 连接无法使用（由于防火墙或公司代理），Socket.IO 可以回退到 HTTP 和长轮询。 重连和缓冲： Socket.IO提供自动重连功能。当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送。 多种数据格式： Socket.IO 支持任何可序列化格式的数据传输，包括Buffer或TypedArray等二进制对象。 **致谢：**使用 Socket.IO，一旦成功接收到消息就可以发送响应消息。 命名空间： Socket.IO 使您能够设置具有不同客户端、房间、事件和应用程序逻辑的不同通道。 **广播到不同的客户端组：**从服务器，您可以向所有连接的客户端或子集发送消息。 Socket.IO 的优缺点 Socket.IO 专业人士 连接效率： Socket.IO 使用 HTTP 长轮询发起连接，一旦建立可用性就升级到 WebSocket（有关更多详细信息，请参阅升级机制）。当发生这种情况时，客户端-服务器连接使用单个 WebSocket，而不必启动多个连接，从而减少延迟并改善用户体验。 **客户端和服务器发起的通信：**由于WebSocket提供了全双工、双向的通信通道，因此服务器可以向客户端发送消息，并且两者可以同时发送消息。 事件驱动的通信： WebSocket是一种事件驱动的协议，这意味着您可以在收到消息后立即监听并响应消息，而不是使用轮询机制来检查更新，这样既浪费又低效。 丰富的功能集： Socket.IO 提供了实现实时应用程序所需的一切。当使用原始 HTTP 甚至原始 WebSocket 时，您必须自己实现其中大部分功能。 有状态： Socket.IO 使用 WebSocket，它是有状态的。该状态一直持续到连接关闭为止。 Socket.IO 缺点 **有限的平台支持：**我们之前提到，Socket.IO 在不同的平台和语言上有多种服务器和客户端实现。值得一提的是，其中一些没有得到积极维护，或者功能集有限，因此在考虑使用它们之前请仔细检查它们。此外，Socket.IO 实现与本机 WebSocket 不兼容，因为 Socket.IO 会向其发送的每个数据包添加额外的元数据。 可扩展性： Socket.IO 非常适合有限数量用户的实时通信应用程序。但是，如果您的用户数量和数据量开始变大，您的服务器可能会过载。当您的服务器达到最大负载时，您将需要将连接拆分到多个服务器上，否则可能会丢失重要信息。这种增加的架构复杂性带来了更多问题。阅读Scaling Socket.IO - 实际注意事项以获取更多信息。 **内存泄漏：**已知 Socket.IO 存在一些与内存泄漏相关的问题。内存泄漏不太可能导致任何直接问题，但如果您的应用程序使用了很长一段时间，它们最终可能会导致用户的设备冻结或崩溃。 什么是 HTTP？ HTTP 是一种请求/响应协议，作为 Web 的主要通信机制，构建在 TCP 网络协议之上。有限版本最初由 Tim Berners-Lee 于 1989 年提出，随后经过快速修改以支持更广泛的浏览器和服务器功能。 HTTP 工作组于 1996 年将这些修改记录为 HTTP/1....</p></div><footer class=entry-footer><span title='2024-05-08 11:00:00 +0800 +0800'>2024-05-08</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;326 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]比较 Socket.IO 和 HTTP：主要区别和用例" href=https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是 HTTP？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/http/
HTTP 概述 HTTP，即超文本传输协议，是互联网通信的基础。它在客户端-服务器模型上运行，其中前端客户端（例如网络浏览器）通过向服务器发送HTTP请求消息来发起请求，例如请求网页（例如搜索引擎）。然后，服务器使用包含所请求资源的 HTTP 响应消息进行响应，如果资源不可用，则使用错误消息进行响应。
HTTP 是一种无状态协议，这意味着每个请求都是独立的，与之前或将来的请求无关。这允许客户端和服务器之间进行有效的通信。
HTTP 于 1991 年首次引入，作为 Tim Berners-Lee 创建的万维网项目的一部分，并由互联网工程任务组 (IETF)进行标准化。 IETF 负责开发和维护 HTTP、TCP/IP、DNS 等协议，以及他们在 RFC 或“征求意见”中记录的许多其他协议。
早期，需要一种标准化协议来促进不同计算机和服务器之间的通信。这导致了各种协议的发展，包括 HTTP。
HTTP 0.9，该协议的第一个版本，是一个简单且有限的系统，仅支持超文本文档的检索。它不支持标头，只允许传输纯文本数据。
1996 年，HTTP 1.0 发布，引入了至今仍在使用的几个重要功能。它增加了对多种媒体类型的支持，允许传输图像、视频和其他文件格式。它还引入了使用标头来实现更高级的功能，例如缓存和身份验证。
1999 年发布的 HTTP 1.1 进一步改进了该协议。它引入了持久连接，允许通过单个 TCP 连接发送多个请求和响应。这极大地提高了客户端和服务器之间通信的效率和速度。
近年来，人们致力于增强和优化HTTP协议。这导致了HTTP/2的开发，并于 2015 年发布。HTTP/2 带来了多项改进，包括多路复用、标头压缩和服务器推送，以减少延迟并提高性能。
最后是 HTTP/3。HTTP/3也称为 HTTP over QUIC（快速 UDP Internet 连接），是最新的 HTTP 协议版本，旨在解决以前版本的一些限制并提高性能。
HTTP/3 构建在 QUIC 传输协议之上，该协议使用用户数据报协议 (UDP)而不是 TCP。与 TCP 相比，UDP 具有多种优势，例如减少延迟和改进拥塞控制。 HTTP/3 使用 UDP，旨在提供更快、更可靠、更安全的连接。
HTTP/3 的关键特性之一是它支持多路复用和流多路复用的能力。这允许通过单个连接同时发送多个请求和响应，从而提高效率并减少延迟。此外，HTTP/3 还包含零 RTT 连接建立、改进的拥塞控制以及通过加密提高安全性等功能。
HTTP 和服务器 服务器对于处理 HTTP 请求和提供相应的响应至关重要。以下是HTTP与服务器关系的几个要点：
请求-响应模型：如前所述，HTTP 遵循请求-响应模型。客户端向服务器发送 HTTP 请求，指定所需的操作，例如检索网页或提交表单数据。服务器处理请求并发回 HTTP 响应，其中包括状态代码、标头和请求的内容（如果适用）。 Web 服务器：Web 服务器是处理 HTTP 请求的软件应用程序或程序。它们侦听特定网络端口（通常为 HTTP 的端口 80）上的传入请求，并将它们路由到适当的资源或应用程序。流行的 Web 服务器软件包括 Apache、Nginx和 Microsoft IIS。 路由和资源处理：在 HTTP 服务器中，路由确定传入请求如何映射到特定资源或端点处理程序。例如，当接收到针对特定 URL 或路径的请求时，服务器使用路由规则来确定哪个代码或资源应处理该请求并生成适当的响应。 处理和生成响应：当 HTTP 请求到达服务器时，它会触发与所请求的资源关联的代码或资源处理程序的执行。这些处理程序可以从数据库检索数据、与外部服务交互或生成动态内容。服务器根据请求处理这些数据，并生成带有必要标头和内容的 HTTP 响应。 状态代码：HTTP 响应包括指示请求结果的状态代码。这些状态代码的范围从信息性 (1xx) 到成功 (2xx)、重定向 (3xx)、客户端错误 (4xx) 和服务器错误 (5xx)。常见状态代码包括 200（正常）、404（未找到）和 500（内部服务器错误）。 无状态：HTTP 是一种无状态协议，这意味着每个请求/响应交互都是独立的，并且不保留有关先前请求的信息。为了维护用户会话或跟踪用户交互，服务器通常使用 cookie 或会话管理技术。 HTTP 是如何工作的？ 当客户端想要从服务器检索网页或新资源时，它会发起 HTTP 请求。该请求由几个部分组成：...</p></div><footer class=entry-footer><span title='2024-05-07 14:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;503 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是 HTTP？" href=https://blog.chensoul.cc/posts/2024/05/07/http/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是 OAuth？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/oauth/
什么是 OAuth？ OAuth（开放授权）是一种开放标准授权框架，允许第三方应用程序访问用户数据，而无需用户共享其登录凭据。它为用户提供了一种安全且标准化的方式，将其在一个网站上的资源的访问权限授予另一个网站或应用程序，而无需暴露其密码。
简单来说，OAuth 充当最终用户和他们想要授予访问权限的应用程序之间的中间人。用户不会直接向 Web 应用程序提供用户名和密码，而是会被重定向到授权服务器（例如 Google、Facebook 或 Twitter），在那里他们可以安全地验证自己的身份。经过身份验证后，用户可以授予或拒绝对其想要使用的应用程序上的数据的访问权限。
OAuth 是如何工作的？ OAuth 为用户提供了一种安全且标准化的方式来授权应用程序从各种来源（例如社交媒体平台或在线服务）访问其数据。
OAuth工作流程涉及三个主要方：用户、应用程序和服务提供商（也称为OAuth 服务器）。以下是 OAuth 流程的高级概述：
用户启动该过程：用户想要使用需要访问服务提供商上受保护资源的应用程序。用户首先向应用程序请求访问权限。 应用程序请求授权：应用程序将用户重定向到服务提供商的授权端点，以及必要的参数，例如应用程序的客户端 ID 和请求的访问范围。 用户授予授权：服务提供商在授权端点向用户显示登录屏幕。用户输入其凭据，如果有效，则系统会要求授予或拒绝应用程序访问其资源的请求。 服务提供商发出授权代码：如果用户授予授权，服务提供商会生成授权代码并将用户重定向回应用程序指定的重定向 URI。授权码是一个临时令牌，代表用户的同意。 应用程序用授权代码交换访问令牌：现在拥有授权代码的应用程序向服务提供商发送请求，以用代码交换访问令牌。该请求包括代码、应用程序的客户端 ID 和客户端密钥，它们用于向服务提供商验证应用程序的身份。 服务提供商验证授权代码：服务提供商对其进行验证并检查它是否与之前为用户生成的授权代码相匹配。如果代码有效，服务提供商将向应用程序颁发访问令牌。 应用程序使用访问令牌来访问受保护的资源：通过从服务提供商获得的访问令牌，应用程序现在可以代表用户发出请求以访问其受保护的资源。这些请求通常是向服务提供商的 API 端点发出的。 访问令牌过期和刷新：访问令牌的生命周期有限，过期后就会过期。要继续访问用户的资源，应用程序可以使用刷新令牌（如果提供）来获取新的访问令牌，而无需用户的参与。 使用 OAuth 有什么好处？ 这种广泛采用的协议为构建实时聊天和消息应用程序的开发人员提供了多种好处：
增强的安全性： OAuth 消除了应用程序需要存储用户凭据的情况，从而降低了未经授权访问的风险。通过利用 OAuth，开发人员可以对用户进行身份验证和授权，而无需处理用户的敏感信息（例如密码）。这显着降低了数据泄露的可能性并增强了整体应用程序的安全性。
简化的用户体验： OAuth 使用户能够向第三方应用程序授予权限而无需共享其凭据，从而提供无缝且用户友好的体验。这消除了为每个应用程序创建和管理单独帐户的麻烦，从而提高了便利性和用户采用率。
可扩展性和互操作性： OAuth 使开发人员能够构建集成多个平台和服务的应用程序。通过利用 OAuth，开发人员可以轻松地验证和访问来自不同提供商的资源，从而允许他们的聊天和消息应用程序与其他系统无缝交互。这增强了可扩展性，并使开发人员能够利用不同平台的现有用户群。
细粒度的访问控制： OAuth 允许开发人员为其聊天和消息应用程序实施细粒度的访问控制。可以为每个资源授予权限，确保第三方应用程序只能访问所需的资源。这种对访问的精细控制有助于维护数据隐私和控制，降低未经授权的数据泄露的风险。
开发人员友好： OAuth 提供了一个简单、开发人员友好的框架，用于在聊天和消息传递应用程序中实现身份验证和授权。该协议有详细的文档记录，并受到各种库和 SDK 的支持，使开发人员可以轻松地将 OAuth 集成到他们的应用程序中。此外，OAuth 通过内置的令牌过期和撤销机制简化了访问令牌的管理。这简化了开发流程并降低了处理用户身份验证和授权的复杂性。
使用 OAuth 有哪些缺点？ 虽然 OAuth 对于构建实时聊天和消息应用程序的开发人员来说具有众多优势，但也存在一些缺点。这些缺点包括：
**复杂性：**实施 OAuth 可能很复杂，尤其是对于不熟悉该协议的开发人员而言。该过程涉及多个步骤，包括注册应用程序、获取客户端凭据和处理授权流程。与多个身份提供商集成或处理刷新令牌时，复杂性可能会进一步增加。开发人员需要投入时间和精力来正确理解和实施 OAuth。
对第三方提供商的依赖： OAuth 依赖第三方身份提供商来对用户进行身份验证和授权。这种依赖性引入了潜在的单点故障。如果身份提供商遇到中断或更改其 API，则可能会中断聊天和消息传递应用程序的身份验证和授权过程。开发人员需要考虑所选身份提供商的可靠性和寿命。
用户隐私问题： OAuth 提供了一种安全的身份验证和授权机制，但一些用户可能担心与第三方应用程序共享其个人信息。尽管 OAuth 不会公开密码等敏感信息，但用户仍然需要授予访问其数据的权限。某些用户可能会犹豫是否授予这些权限，尤其是对于鲜为人知或不太受信任的应用程序。
**缺乏标准化：**尽管 OAuth 被广泛采用，但不同提供商和平台的实施可能存在差异。缺乏标准化可能会导致与多个系统集成时出现不一致和兼容性问题。开发人员可能需要额外的努力来处理这些变化并确保不同平台和提供商之间的兼容性。
**安全漏洞：**虽然 OAuth 的设计是安全的，但也存在发现和利用漏洞的情况。这些漏洞可能导致未经授权的用户数据访问或冒充攻击。开发人员必须及时了解最新的安全最佳实践，并定期修补 OAuth 实施中的任何漏洞。
OAuth 与 OpenID OAuth 和OpenID是广泛使用的身份验证和授权协议，但用途不同。
OAuth 主要是一种授权协议，允许应用程序访问另一个系统上的用户资源，而无需共享其凭据。它通常用于委托授权场景，即用户向第三方应用程序授予访问其在特定网站或服务上的数据的权限。例如，当您使用 Google 帐户登录第三方应用程序时，OAuth 通常用于授予该应用程序访问您的 Google 云端硬盘或 Gmail 数据的权限。...</p></div><footer class=entry-footer><span title='2024-05-07 14:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;534 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是 OAuth？" href=https://blog.chensoul.cc/posts/2024/05/07/oauth/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/page/6/>«&nbsp;Prev&nbsp;6/28
</a><a class=next href=https://blog.chensoul.cc/page/8/>Next&nbsp;8/28&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>