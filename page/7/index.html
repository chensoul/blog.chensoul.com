<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.131.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ChenSoul</title>
<meta name=keywords content="java,python,go"><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/index.xml><link rel=alternate type=application/json href=https://blog.chensoul.cc/index.json><link rel=alternate hreflang=en href=https://blog.chensoul.cc/><meta name=twitter:title content="ChenSoul"><meta name=twitter:description content><meta property="og:title" content="ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/"><meta property="og:site_name" content="ChenSoul"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"ChenSoul","url":"https://blog.chensoul.cc/","description":"","thumbnailUrl":"https://blog.chensoul.cc/favicon.ico","sameAs":[]}</script><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-page kind-home layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>安装k3s</h2></header><section class=entry-content><p>K3s 是轻量级的 Kubernetes。K3s 易于安装，仅需要 Kubernetes 内存的一半，所有组件都在一个小于 100 MB 的二进制文件中。
k3s 文档：https://docs.rancher.cn/docs/k3s/_index
K3s介绍 什么是 K3s？ K3s 是一个完全兼容的 Kubernetes 发行版，具有以下增强功能：
打包为单个二进制文件。 使用基于 sqlite3 作为默认存储机制的轻量级存储后端。同时支持使用 etcd3、MySQL 和 Postgres。 封装在简单的启动程序中，可以处理很多复杂的 TLS 和选项。 默认情况下是安全的，对轻量级环境有合理的默认值。 添加了简单但强大的 batteries-included 功能，例如： 本地存储提供程序 service load balancer Helm controller Traefik ingress controller 所有 Kubernetes control plane 组件的操作都封装在单个二进制文件和进程中。因此，K3s 支持自动化和管理复杂的集群操作（例如证书分发等）。 最大程度减轻了外部依赖性，K3s 仅需要现代内核和 cgroup 挂载。K3s 打包了所需的依赖，包括： containerd Flannel (CNI) CoreDNS Traefik (Ingress) Klipper-lb (Service LB) 嵌入式网络策略控制器 嵌入式 local-path-provisioner 主机实用程序（iptables、socat 等） 为什么叫 K3s? 我们希望安装的 Kubernetes 只占用一半的内存。Kubernetes 是一个 10 个字母的单词，简写为 K8s。Kubernetes 的一半就是一个 5 个字母的单词，因此简写为 K3s。K3s 没有全称，也没有官方的发音。
适用场景 K3s 适用于以下场景：
边缘计算-Edge 物联网-IoT CI Development ARM 嵌入 K8s 由于运行 K3s 所需的资源相对较少，所以 K3s 也适用于开发和测试场景。在这些场景中，如果开发或测试人员需要对某些功能进行验证，或对某些问题进行重现，那么使用 K3s 不仅能够缩短启动集群的时间，还能够减少集群需要消耗的资源。与此同时，Rancher 中国团队推出了一款针对 K3s 的效率提升工具：AutoK3s。只需要输入一行命令，即可快速创建 K3s 集群并添加指定数量的 master 节点和 worker 节点。如需详细了解 AutoK3s，请参考AutoK3s 功能介绍。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-09</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/k3s/>K3s</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>4 min</span></span></footer><a class=entry-link aria-label="post link to 安装k3s" href=https://blog.chensoul.cc/posts/2024/05/09/install-k3s/></a></article><article class=post-entry><header class=entry-header><h2>通过k3d安装k3s</h2></header><section class=entry-content><p>k3d是什么 k3d 是一个轻量级包装器，用于在 docker 中运行k3s（Rancher Lab 的最小 Kubernetes 发行版）。
k3d 使得在 docker 中创建单节点和多节点k3s集群变得非常容易，例如用于 Kubernetes 上的本地开发。
注意： k3d 是一个社区驱动的项目，但它不是官方 Rancher (SUSE) 产品。
k3d安装 通过脚本安装：
wget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash macos 上通过homebrew安装：
brew install k3d 查看帮助文档：
$ k3d -h https://k3d.io/ k3d is a wrapper CLI that helps you to easily create k3s clusters inside docker. Nodes of a k3d cluster are docker containers running a k3s image. All Nodes of a k3d cluster are part of the same docker network. Usage: k3d [flags] k3d [command] Available Commands: cluster Manage cluster(s) completion Generate completion scripts for [bash, zsh, fish, powershell | psh] config Work with config file(s) help Help about any command image Handle container images....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-09</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/k3s/>K3s</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>3 min</span></span></footer><a class=entry-link aria-label="post link to 通过k3d安装k3s" href=https://blog.chensoul.cc/posts/2024/05/09/install-k3s-using-k3d/></a></article><article class=post-entry><header class=entry-header><h2>All things about Spring Modulith</h2></header><section class=entry-content><p>VMware 推出了一个实验性的项目Spring Modulith，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。
2022 年 11 月推出的Spring Boot 3会是 Spring Modulith 的基础。所以它的基线是 Spring Framework 6、Java 17 和 Jakarta EE 9。Spring Modulith 是Moduliths（其名字有个“s”后缀）项目的继承者。该项目使用 Spring Boot 2.7，目前已经退役，只接收缺陷修正，直至 2023 年 11 月份。
https://spring.io/blog/2022/10/21/introducing-spring-modulith
https://www.baeldung.com/spring-modulith
https://www.baeldung.com/spring-modulith-event-externalization
https://piotrminkowski.com/2023/10/13/guide-to-modulith-with-spring-boot/
https://springdoc.cn/guide-to-modulith-with-spring-boot/
https://medium.com/andamp/event-sourcing-with-spring-modulith-2b35b0569dbb
https://www.geeksforgeeks.org/what-is-spring-modulith/
https://github.com/xsreality/spring-modulith-with-ddd
https://riteshshergill.medium.com/the-spring-modulith-monolithic-but-manageable-ca1532a1e585
https://www.infoq.com/news/2022/11/spring-modulith-launch/
https://dzone.com/articles/architecture-style-modulith-vs-microservices
https://speakerdeck.com/olivergierke/spring-modulith-a-deep-dive
https://www.jappware.com/proffesional-activity/make-monolithic-apps-great-again-with-spring-modulith-coffeejug/
https://blog.worldline.tech/2024/01/23/modulith.html
https://springdoc.cn/spring-modulith-intro/
https://dimitri.codes/checking-out-spring-modulith/
https://www.lefer.cn/posts/29752/
https://www.jdon.com/63003.html
https://blog.csdn.net/cfy_banq/article/details/132185951
https://www.zhihu.com/question/567053421</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-09</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/spring/>Spring</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to All things about Spring Modulith" href=https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/></a></article><article class=post-entry><header class=entry-header><h2>[译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</h2></header><section class=entry-content><p>原文链接：https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249
来源：https://www.thewebmaster.com/
先决条件：了解 javascript、客户端-服务器架构。
完整的代码可以在github上找到。
第 1 部分：概述（http2 的原因、内容、时间、方式）第 2 部分：使用 node-http2 核心和 hapijs 进行探索
免责声明：本文将使用node@v9+附带的http2模块。这里列出了其他几个 http2 客户端-服务器库实现。
让我们开始创建一个具有单一路由的简单 http1.1 服务器。
mkdir hapijs-http2 && \ cd hapijs-http2 && \ npm init -y && \ npm i hapi@^16.6 -s && \ touch http1Server.js 将下面的代码复制到此处或从此处http1Server.js克隆整个存储库。
const Hapi = require('hapi'); const server = new Hapi.Server(); // define server config server.connection({ port: '8000' }); // define route config server.route([{ method: 'GET', path: '/ping', handler: (request, reply) => { reply('pong'); } }]); // start server server.start(err => { if (err) console.error(err) console.log(`Started ${server.connections.length} connections`) }); 现在，让我们进行健全性检查。
启动服务器，node http1Server.js
⇒ http://127.0.0.1:8000/ping pong 凉爽的！如果我们得到 pong 的 ping，让我们尝试将http2集成到我们的 hapijs 服务器中。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-08</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/http/>Http</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs" href=https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/></a></article><article class=post-entry><header class=entry-header><h2>[译]探索 http2（第 1 部分）：概述</h2></header><section class=entry-content><p>原文链接：https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f
让我们来谈谈 http2 的内容、原因、时间和方式
完整的代码可以在github上找到。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
什么是http2？ **http2*是自 1999 年以来使用的http1.1***之后的最新更新
http2协议注重性能；具体来说，最终用户感知的延迟、网络和服务器资源的使用情况。 （在此处阅读有关规格的信息*）*
为什么是http2？ 换句话说http1.1有什么问题
加载网页是一项资源密集型工作，因为 HTTP/1.1 只允许每个 TCP 连接有一个未完成的请求。网络需要进行更新，以提高效率、安全性和速度。
http2如何解决性能问题？
http2 带来的改进：
**单一连接：**仅使用一个与服务器的连接来加载网站，并且只要网站打开，该连接就保持打开状态。这减少了建立多个 TCP 连接所需的往返次数。（更多信息在这里） **多路复用：**同一连接上同时允许多个请求。以前，在 HTTP/1.1 中，每个传输都必须等待其他传输完成。（更多信息在这里） **服务器推送：**可以将其他资源发送到客户端以供将来使用。（更多信息在这里） **优先级：**请求被分配依赖级别，服务器可以使用它来更快地交付更高优先级的资源。（更多信息在这里） **二进制：**使 HTTP/2 更易于服务器解析、更紧凑且不易出错。将信息从文本转换为二进制不会浪费额外的时间。（更多信息在这里） 标头压缩： HTTP/2 使用HPACK压缩，从而减少开销。在 HTTP/1.1 中，每个请求中的许多标头都使用相同的值发送。（更多信息在这里） 我们什么时候可以开始使用http2？ 现在！
这是时间线，
来源：https://www.polyglotdeveloper.com/
是的，从 1999 年到今天，我们（大多数）都在使用同样好的旧 http1.1； 15年！
如何开始使用http2？ 以下是各种语言的 http2 库实现列表。
根据Can I Use的统计，大约 83% 的在线浏览器已经支持 http2
查看实际情况，http1.1 与 http2（网络节流：快速 3g）
http1.1（左）与http2（右）；让我们在下一节中构建它
在下一部分中，我们将构建一个支持 http2 的简单服务器；具有http1.1向后兼容性；一步一步使用http2-node core 和hapi js。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
完整的代码可以在github上找到。</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-08</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/http/>Http</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]探索 http2（第 1 部分）：概述" href=https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/></a></article><article class=post-entry><header class=entry-header><h2>[译]比较 Socket.IO 和 HTTP：主要区别和用例</h2></header><section class=entry-content><p>原文链接：https://ably.com/topic/socketio-vs-http
在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。
什么是Socket.IO？ Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。
Socket.IO 需要两个库 - 一个在服务器上，一个在客户端上。 Socket.IO 创建者维护以下“官方”：
Socket.IO是 Node.js 服务器组件。 Socket.IO-client是客户端 JavaScript 库。 一些 Socket.IO 客户端和服务器实现可以用其他语言实现。请阅读Socket.IO 是什么来获取列表。
下图总结了典型的 Socket.IO 设置：
Socket.IO 主要特性 Socket.IO 具有以下主要特性：
**向后兼容性：**在现代浏览器中，Socket.IO 使用WebSocket API提供所需的连接并发送消息。 WebSocket 在服务器和浏览器之间提供全双工、低延迟、事件驱动的连接。它也是有状态的。如果需要旧版浏览器支持，或者 WebSocket 连接无法使用（由于防火墙或公司代理），Socket.IO 可以回退到 HTTP 和长轮询。 重连和缓冲： Socket.IO提供自动重连功能。当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送。 多种数据格式： Socket.IO 支持任何可序列化格式的数据传输，包括Buffer或TypedArray等二进制对象。 **致谢：**使用 Socket.IO，一旦成功接收到消息就可以发送响应消息。 命名空间： Socket.IO 使您能够设置具有不同客户端、房间、事件和应用程序逻辑的不同通道。 **广播到不同的客户端组：**从服务器，您可以向所有连接的客户端或子集发送消息。 Socket.IO 的优缺点 Socket.IO 专业人士 连接效率： Socket.IO 使用 HTTP 长轮询发起连接，一旦建立可用性就升级到 WebSocket（有关更多详细信息，请参阅升级机制）。当发生这种情况时，客户端-服务器连接使用单个 WebSocket，而不必启动多个连接，从而减少延迟并改善用户体验。 **客户端和服务器发起的通信：**由于WebSocket提供了全双工、双向的通信通道，因此服务器可以向客户端发送消息，并且两者可以同时发送消息。 事件驱动的通信： WebSocket是一种事件驱动的协议，这意味着您可以在收到消息后立即监听并响应消息，而不是使用轮询机制来检查更新，这样既浪费又低效。 丰富的功能集： Socket.IO 提供了实现实时应用程序所需的一切。当使用原始 HTTP 甚至原始 WebSocket 时，您必须自己实现其中大部分功能。 有状态： Socket.IO 使用 WebSocket，它是有状态的。该状态一直持续到连接关闭为止。 Socket.IO 缺点 **有限的平台支持：**我们之前提到，Socket.IO 在不同的平台和语言上有多种服务器和客户端实现。值得一提的是，其中一些没有得到积极维护，或者功能集有限，因此在考虑使用它们之前请仔细检查它们。此外，Socket.IO 实现与本机 WebSocket 不兼容，因为 Socket.IO 会向其发送的每个数据包添加额外的元数据。 可扩展性： Socket.IO 非常适合有限数量用户的实时通信应用程序。但是，如果您的用户数量和数据量开始变大，您的服务器可能会过载。当您的服务器达到最大负载时，您将需要将连接拆分到多个服务器上，否则可能会丢失重要信息。这种增加的架构复杂性带来了更多问题。阅读Scaling Socket.IO - 实际注意事项以获取更多信息。 **内存泄漏：**已知 Socket.IO 存在一些与内存泄漏相关的问题。内存泄漏不太可能导致任何直接问题，但如果您的应用程序使用了很长一段时间，它们最终可能会导致用户的设备冻结或崩溃。 什么是 HTTP？ HTTP 是一种请求/响应协议，作为 Web 的主要通信机制，构建在 TCP 网络协议之上。有限版本最初由 Tim Berners-Lee 于 1989 年提出，随后经过快速修改以支持更广泛的浏览器和服务器功能。 HTTP 工作组于 1996 年将这些修改记录为 HTTP/1....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-08</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/socketio/>Socketio</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]比较 Socket.IO 和 HTTP：主要区别和用例" href=https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/></a></article><article class=post-entry><header class=entry-header><h2>[译]什么是 HTTP？</h2></header><section class=entry-content><p>原文链接：https://www.pubnub.com/guides/http/
HTTP 概述 HTTP，即超文本传输协议，是互联网通信的基础。它在客户端-服务器模型上运行，其中前端客户端（例如网络浏览器）通过向服务器发送HTTP请求消息来发起请求，例如请求网页（例如搜索引擎）。然后，服务器使用包含所请求资源的 HTTP 响应消息进行响应，如果资源不可用，则使用错误消息进行响应。
HTTP 是一种无状态协议，这意味着每个请求都是独立的，与之前或将来的请求无关。这允许客户端和服务器之间进行有效的通信。
HTTP 于 1991 年首次引入，作为 Tim Berners-Lee 创建的万维网项目的一部分，并由互联网工程任务组 (IETF)进行标准化。 IETF 负责开发和维护 HTTP、TCP/IP、DNS 等协议，以及他们在 RFC 或“征求意见”中记录的许多其他协议。
早期，需要一种标准化协议来促进不同计算机和服务器之间的通信。这导致了各种协议的发展，包括 HTTP。
HTTP 0.9，该协议的第一个版本，是一个简单且有限的系统，仅支持超文本文档的检索。它不支持标头，只允许传输纯文本数据。
1996 年，HTTP 1.0 发布，引入了至今仍在使用的几个重要功能。它增加了对多种媒体类型的支持，允许传输图像、视频和其他文件格式。它还引入了使用标头来实现更高级的功能，例如缓存和身份验证。
1999 年发布的 HTTP 1.1 进一步改进了该协议。它引入了持久连接，允许通过单个 TCP 连接发送多个请求和响应。这极大地提高了客户端和服务器之间通信的效率和速度。
近年来，人们致力于增强和优化HTTP协议。这导致了HTTP/2的开发，并于 2015 年发布。HTTP/2 带来了多项改进，包括多路复用、标头压缩和服务器推送，以减少延迟并提高性能。
最后是 HTTP/3。HTTP/3也称为 HTTP over QUIC（快速 UDP Internet 连接），是最新的 HTTP 协议版本，旨在解决以前版本的一些限制并提高性能。
HTTP/3 构建在 QUIC 传输协议之上，该协议使用用户数据报协议 (UDP)而不是 TCP。与 TCP 相比，UDP 具有多种优势，例如减少延迟和改进拥塞控制。 HTTP/3 使用 UDP，旨在提供更快、更可靠、更安全的连接。
HTTP/3 的关键特性之一是它支持多路复用和流多路复用的能力。这允许通过单个连接同时发送多个请求和响应，从而提高效率并减少延迟。此外，HTTP/3 还包含零 RTT 连接建立、改进的拥塞控制以及通过加密提高安全性等功能。
HTTP 和服务器 服务器对于处理 HTTP 请求和提供相应的响应至关重要。以下是HTTP与服务器关系的几个要点：
请求-响应模型：如前所述，HTTP 遵循请求-响应模型。客户端向服务器发送 HTTP 请求，指定所需的操作，例如检索网页或提交表单数据。服务器处理请求并发回 HTTP 响应，其中包括状态代码、标头和请求的内容（如果适用）。 Web 服务器：Web 服务器是处理 HTTP 请求的软件应用程序或程序。它们侦听特定网络端口（通常为 HTTP 的端口 80）上的传入请求，并将它们路由到适当的资源或应用程序。流行的 Web 服务器软件包括 Apache、Nginx和 Microsoft IIS。 路由和资源处理：在 HTTP 服务器中，路由确定传入请求如何映射到特定资源或端点处理程序。例如，当接收到针对特定 URL 或路径的请求时，服务器使用路由规则来确定哪个代码或资源应处理该请求并生成适当的响应。 处理和生成响应：当 HTTP 请求到达服务器时，它会触发与所请求的资源关联的代码或资源处理程序的执行。这些处理程序可以从数据库检索数据、与外部服务交互或生成动态内容。服务器根据请求处理这些数据，并生成带有必要标头和内容的 HTTP 响应。 状态代码：HTTP 响应包括指示请求结果的状态代码。这些状态代码的范围从信息性 (1xx) 到成功 (2xx)、重定向 (3xx)、客户端错误 (4xx) 和服务器错误 (5xx)。常见状态代码包括 200（正常）、404（未找到）和 500（内部服务器错误）。 无状态：HTTP 是一种无状态协议，这意味着每个请求/响应交互都是独立的，并且不保留有关先前请求的信息。为了维护用户会话或跟踪用户交互，服务器通常使用 cookie 或会话管理技术。 HTTP 是如何工作的？ 当客户端想要从服务器检索网页或新资源时，它会发起 HTTP 请求。该请求由几个部分组成：...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-07</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/http/>Http</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>3 min</span></span></footer><a class=entry-link aria-label="post link to [译]什么是 HTTP？" href=https://blog.chensoul.cc/posts/2024/05/07/http/></a></article><article class=post-entry><header class=entry-header><h2>[译]什么是 OAuth？</h2></header><section class=entry-content><p>原文链接：https://www.pubnub.com/guides/oauth/
什么是 OAuth？ OAuth（开放授权）是一种开放标准授权框架，允许第三方应用程序访问用户数据，而无需用户共享其登录凭据。它为用户提供了一种安全且标准化的方式，将其在一个网站上的资源的访问权限授予另一个网站或应用程序，而无需暴露其密码。
简单来说，OAuth 充当最终用户和他们想要授予访问权限的应用程序之间的中间人。用户不会直接向 Web 应用程序提供用户名和密码，而是会被重定向到授权服务器（例如 Google、Facebook 或 Twitter），在那里他们可以安全地验证自己的身份。经过身份验证后，用户可以授予或拒绝对其想要使用的应用程序上的数据的访问权限。
OAuth 是如何工作的？ OAuth 为用户提供了一种安全且标准化的方式来授权应用程序从各种来源（例如社交媒体平台或在线服务）访问其数据。
OAuth工作流程涉及三个主要方：用户、应用程序和服务提供商（也称为OAuth 服务器）。以下是 OAuth 流程的高级概述：
用户启动该过程：用户想要使用需要访问服务提供商上受保护资源的应用程序。用户首先向应用程序请求访问权限。 应用程序请求授权：应用程序将用户重定向到服务提供商的授权端点，以及必要的参数，例如应用程序的客户端 ID 和请求的访问范围。 用户授予授权：服务提供商在授权端点向用户显示登录屏幕。用户输入其凭据，如果有效，则系统会要求授予或拒绝应用程序访问其资源的请求。 服务提供商发出授权代码：如果用户授予授权，服务提供商会生成授权代码并将用户重定向回应用程序指定的重定向 URI。授权码是一个临时令牌，代表用户的同意。 应用程序用授权代码交换访问令牌：现在拥有授权代码的应用程序向服务提供商发送请求，以用代码交换访问令牌。该请求包括代码、应用程序的客户端 ID 和客户端密钥，它们用于向服务提供商验证应用程序的身份。 服务提供商验证授权代码：服务提供商对其进行验证并检查它是否与之前为用户生成的授权代码相匹配。如果代码有效，服务提供商将向应用程序颁发访问令牌。 应用程序使用访问令牌来访问受保护的资源：通过从服务提供商获得的访问令牌，应用程序现在可以代表用户发出请求以访问其受保护的资源。这些请求通常是向服务提供商的 API 端点发出的。 访问令牌过期和刷新：访问令牌的生命周期有限，过期后就会过期。要继续访问用户的资源，应用程序可以使用刷新令牌（如果提供）来获取新的访问令牌，而无需用户的参与。 使用 OAuth 有什么好处？ 这种广泛采用的协议为构建实时聊天和消息应用程序的开发人员提供了多种好处：
增强的安全性： OAuth 消除了应用程序需要存储用户凭据的情况，从而降低了未经授权访问的风险。通过利用 OAuth，开发人员可以对用户进行身份验证和授权，而无需处理用户的敏感信息（例如密码）。这显着降低了数据泄露的可能性并增强了整体应用程序的安全性。
简化的用户体验： OAuth 使用户能够向第三方应用程序授予权限而无需共享其凭据，从而提供无缝且用户友好的体验。这消除了为每个应用程序创建和管理单独帐户的麻烦，从而提高了便利性和用户采用率。
可扩展性和互操作性： OAuth 使开发人员能够构建集成多个平台和服务的应用程序。通过利用 OAuth，开发人员可以轻松地验证和访问来自不同提供商的资源，从而允许他们的聊天和消息应用程序与其他系统无缝交互。这增强了可扩展性，并使开发人员能够利用不同平台的现有用户群。
细粒度的访问控制： OAuth 允许开发人员为其聊天和消息应用程序实施细粒度的访问控制。可以为每个资源授予权限，确保第三方应用程序只能访问所需的资源。这种对访问的精细控制有助于维护数据隐私和控制，降低未经授权的数据泄露的风险。
开发人员友好： OAuth 提供了一个简单、开发人员友好的框架，用于在聊天和消息传递应用程序中实现身份验证和授权。该协议有详细的文档记录，并受到各种库和 SDK 的支持，使开发人员可以轻松地将 OAuth 集成到他们的应用程序中。此外，OAuth 通过内置的令牌过期和撤销机制简化了访问令牌的管理。这简化了开发流程并降低了处理用户身份验证和授权的复杂性。
使用 OAuth 有哪些缺点？ 虽然 OAuth 对于构建实时聊天和消息应用程序的开发人员来说具有众多优势，但也存在一些缺点。这些缺点包括：
**复杂性：**实施 OAuth 可能很复杂，尤其是对于不熟悉该协议的开发人员而言。该过程涉及多个步骤，包括注册应用程序、获取客户端凭据和处理授权流程。与多个身份提供商集成或处理刷新令牌时，复杂性可能会进一步增加。开发人员需要投入时间和精力来正确理解和实施 OAuth。
对第三方提供商的依赖： OAuth 依赖第三方身份提供商来对用户进行身份验证和授权。这种依赖性引入了潜在的单点故障。如果身份提供商遇到中断或更改其 API，则可能会中断聊天和消息传递应用程序的身份验证和授权过程。开发人员需要考虑所选身份提供商的可靠性和寿命。
用户隐私问题： OAuth 提供了一种安全的身份验证和授权机制，但一些用户可能担心与第三方应用程序共享其个人信息。尽管 OAuth 不会公开密码等敏感信息，但用户仍然需要授予访问其数据的权限。某些用户可能会犹豫是否授予这些权限，尤其是对于鲜为人知或不太受信任的应用程序。
**缺乏标准化：**尽管 OAuth 被广泛采用，但不同提供商和平台的实施可能存在差异。缺乏标准化可能会导致与多个系统集成时出现不一致和兼容性问题。开发人员可能需要额外的努力来处理这些变化并确保不同平台和提供商之间的兼容性。
**安全漏洞：**虽然 OAuth 的设计是安全的，但也存在发现和利用漏洞的情况。这些漏洞可能导致未经授权的用户数据访问或冒充攻击。开发人员必须及时了解最新的安全最佳实践，并定期修补 OAuth 实施中的任何漏洞。
OAuth 与 OpenID OAuth 和OpenID是广泛使用的身份验证和授权协议，但用途不同。
OAuth 主要是一种授权协议，允许应用程序访问另一个系统上的用户资源，而无需共享其凭据。它通常用于委托授权场景，即用户向第三方应用程序授予访问其在特定网站或服务上的数据的权限。例如，当您使用 Google 帐户登录第三方应用程序时，OAuth 通常用于授予该应用程序访问您的 Google 云端硬盘或 Gmail 数据的权限。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-07</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/oauth2/>Oauth2</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>3 min</span></span></footer><a class=entry-link aria-label="post link to [译]什么是 OAuth？" href=https://blog.chensoul.cc/posts/2024/05/07/oauth/></a></article><article class=post-entry><header class=entry-header><h2>[译]什么是HTTP/3？</h2></header><section class=entry-content><p>原文链接：https://www.pubnub.com/guides/http-3/
什么是 HTTP/3？ HTTP/3（或 HTTP-over-QUIC）是超文本传输协议 ( HTTP ) 的第三个主要版本。它是用于 Web 浏览器和服务器之间通信的应用层协议。 HTTP/3 旨在提高 Web 通信的性能和安全性。
HTTP/3的主要功能之一是它构建在用户数据报协议 (UDP)之上，而不是建立在 HTTP 早期版本中使用的传输控制协议(TCP) 之上。 UDP 是一种无连接协议，可为实时应用程序提供更低的延迟和更好的性能。
HTTP/3 还引入了一种新的传输协议，称为QUIC（快速 UDP 互联网连接）。与 TCP 相比，QUIC 具有多种优势，包括减少延迟、提高可靠性和更好的拥塞控制。它还包括内置加密，增强网页和通信安全性。
HTTP/3 的另一个重要特性是它对多路复用的支持。这意味着可以通过单个连接同时发送和接收多个请求和响应，从而提高数据传输效率。
HTTP/3 还包括其他优化以提高性能，例如标头压缩和流优先级。这些优化有助于减少开销并提高 Web 通信的整体速度。
总体而言，HTTP/3 在性能和安全性方面比其前身 HTTP/2 显着改进了功能。它对于构建实时聊天和消息传递应用程序的开发人员特别有利，因为它提供更低的延迟和更高的可靠性，使其成为需要快速交付实时数据的用例的理想选择。
让我们退一步看看这一切从第一个 HTTP 版本开始。
HTTP 简史 HTTP（超文本传输协议）协议有着长达数十年的丰富历史。它于 20 世纪 90 年代初首次推出，作为万维网上客户端和服务器之间的通信方式。
HTTP 最初是由Tim Berners-Lee和他在CERN（欧洲核研究组织）的团队开发的，旨在促进超文本文档的交换。第一个版本 HTTP/0.9 是一个简单的协议，仅支持用于检索 HTML 文档的 GET 请求。
1996 年，HTTP/1.0 协议由互联网工程任务组(IETF)标准化。该版本引入了几个重要的功能，包括对 POST 请求、响应状态代码和标头的支持。 HTTP/1.0 还允许传输不同的媒体类型，例如图像和视频以及 HTML 文档。
然而，随着网络变得更加复杂和交互，HTTP/1.0 的局限性变得明显。它是围绕请求-响应模型设计的，其中每个请求都需要与服务器的单独连接。这导致了高延迟和网络资源的低效使用。
HTTP/1.1 协议解决了这些问题。
HTTP/1.1 HTTP/1.1 是超文本传输协议 (HTTP) 的第二个主要版本，于 1999 年推出，如今在互联网上广泛使用。
HTTP/1.1 的关键功能之一是支持持久连接，也称为保持活动连接。在以前版本的 HTTP 中，必须为每个请求和响应建立一个新的 TCP 连接，这导致延迟和开销增加。使用 HTTP/1.1，可以通过单个连接发送多个请求和响应，从而减少建立新连接的需要并提高性能。
HTTP/1.1 的另一个重要特性是它对管道的支持。流水线允许发送多个请求而无需等待相应的响应，这有助于减少延迟并提高数据传输效率。
HTTP/1.1还引入了缓存的概念。缓存允许 Web 浏览器存储和重用以前访问的资源，例如图像和样式表，这可以显着缩短页面加载时间并减少带宽使用。
然而，尽管有这些改进，HTTP/1.1 仍然存在一些局限性。同时处理多个请求和响应可能效率低下，因为它需要严格的消息排序。这可能会导致性能问题，特别是对于需要低延迟和高并发的实时应用程序。
此外，HTTP/1.1 不支持标头压缩，这可能会导致开销增加和数据传输速度变慢。
HTTP/2 HTTP/2 是超文本传输协议 (HTTP)的最新主要版本，于 2015 年推出，作为对之前 HTTP/1....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-07</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/http/>Http</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]什么是HTTP/3？" href=https://blog.chensoul.cc/posts/2024/05/07/http3/></a></article><article class=post-entry><header class=entry-header><h2>[译]什么是HTTP流式传输？</h2></header><section class=entry-content><p>原文链接：https://www.pubnub.com/guides/http-streaming/
什么是 HTTP 流式传输？ HTTP 流，也称为基于 HTTP 的流或 HTTP 实时流，是一种用于通过 Internet 传送实时多媒体内容（例如音频或视频）的技术。该协议允许从服务器到客户端设备的连续数据传输，使用户能够消费媒体内容而无需完整的文件下载。
与传统的文件下载方法不同，在开始播放之前需要下载整个文件，HTTP 流允许立即播放媒体内容。它的工作原理是将媒体文件分成更小的片段或块，然后将其连续传送到客户端设备。
HTTP 流利用超文本传输协议 (HTTP)作为其通信协议。它利用现有的 Web 基础设施并使用 HTTP 服务器的可扩展性、缓存和负载平衡功能。这使其成为向许多用户提供实时内容的高效且灵活的解决方案。
HTTP 流如何工作？ 从较高层面来看，HTTP 流式传输的工作原理是将媒体文件分成小块并通过 HTTP 连接将其传输到客户端。客户端（通常是网络浏览器或媒体播放器）不断请求和接收这些块，从而实现媒体的无缝播放。
HTTP 流式传输有两种主要方法：渐进式下载和自适应流式传输。
1.渐进式下载：
渐进式下载缺乏自适应流媒体提供的适应性。在客户端开始播放之前，会通过渐进式下载来下载整个媒体文件。这意味着，如果在下载过程中出现任何 Wi-Fi 网络中断或带宽波动，用户可能会遇到播放缓冲或延迟的情况。这可能会让用户感到沮丧，并可能导致糟糕的用户体验。
2.[自适应流媒体](https://www.cloudflare.com/learning/video/what-is-adaptive-bitrate-streaming/#:~:text=Adaptive bitrate streaming adjusts video,%2C location%2C or Internet speed.)：
自适应流媒体对于开发人员构建实时聊天和消息传递应用程序（提供视频或音频等媒体文件）来说是一项至关重要的技术。它确保无论用户的网络条件如何，媒体内容都可以流畅、高效地传输。这在当今的数字环境中尤其重要，用户期望高质量、不间断的媒体播放，但有时具有不同的互联网速度。
自适应流式传输通常涉及以下步骤：
内容编码：媒体文件被编码为具有不同比特率和质量级别的多种变体。这些变化存储在服务器上。 清单文件：创建一个清单文件，其中包含有关可用变体及其相应 URL 的信息。 初始请求：客户端向服务器请求清单文件，该文件提供有关媒体文件的可用变体的信息。 变体选择：客户端根据网络条件和设备功能选择所需的变体。然后它从服务器请求相应的媒体块。 块传送：服务器通过 HTTP 连接将分块媒体传送到客户端。客户端不断请求并接收这些块，并在必要时调整播放质量。 比特率适应：在播放期间，客户端监视网络状况并根据可用带宽动态调整所选变体。如果网络变得拥塞，它可能会切换到较低的比特率变体，或者如果网络状况改善，它可能会切换到较高的比特率变体。 无缝播放：通过连续接收和播放媒体块，自适应流媒体提供无缝播放体验，使用户能够在没有中断或缓冲的情况下享受内容。 HTTP 流有什么好处？ HTTP 流式传输为构建实时聊天和消息传递应用程序的开发人员提供了多种好处：
实时数据传送：HTTP流可以实现数据的实时传送，允许用户即时发送和接收消息。这确保用户可以进行实时对话，而不会出现任何明显的延迟。 可扩展性：HTTP 流具有高度可扩展性，能够处理许多并发连接并向多个用户实时传送消息。这对于支持不断增长的用户群和处理大量消息的应用程序至关重要。 减少网络开销：使用 HTTP 流式传输，当有新信息可用时，仅通过网络发送必要的数据，从而减少网络开销。这与轮询等其他方法形成鲜明对比，即使不存在新数据，也会不断发出请求。 高效的资源利用：HTTP 流可以有效地利用服务器资源，因为它消除了频繁的轮询请求。这可以减少服务器负载并提高性能，特别是在具有许多活跃用户的应用程序中。 更好的用户体验：HTTP 流通过提供实时更新和即时消息传递，增强了聊天和消息传递应用程序的用户体验。用户可以进行更具互动性和吸引力的对话，而不会因延迟或错过消息而感到沮丧。 安全性：HTTP 流可以利用 HTTPS 等现有安全措施提供安全的通信通道。这可确保敏感的用户数据和对话免受未经授权的访问和窃听。 使用 HTTP 流有哪些缺点？ 使用 HTTP 流进行实时聊天和消息传递应用程序有几个缺点：
延迟： HTTP 流媒体依赖于客户端和服务器之间的持续连接。这可能会引入延迟，因为服务器需要维持开放连接并以块的形式发送数据。因此，向用户发送实时消息可能会出现延迟，从而影响用户体验。
可扩展性： HTTP 流对于客户端和服务器来说可能是资源密集型的。维护大量打开的连接会给服务器带来压力并限制其可扩展性。此外，客户端需要处理传入的数据流，这也可能对其资源提出要求。
**兼容性：**所有设备或网络可能不支持 HTTP 流。某些防火墙或代理可能会阻止或干扰流连接，从而导致通信问题。这可能会将聊天应用程序的可用性限制为部分用户。
**可靠性：**由于 HTTP 流媒体依赖于长期连接，因此中断或网络故障可能会破坏流媒体过程。如果连接丢失，客户端可能需要重新建立连接，这可能会导致消息丢失或重复。
安全性： HTTP 流本身并不为数据传输提供加密或安全措施。如果没有额外的安全层，通过聊天应用程序交换的敏感信息可能容易遭到窃听或未经授权的访问。
**电池消耗：**连续连接和数据流会快速耗尽移动设备的电池。这可能是实时聊天应用程序的用户所关心的问题，尤其是在长时间使用这些应用程序时。
开发人员在选择实时聊天和消息应用程序技术时需要考虑这些缺点。虽然 HTTP 流提供了一些好处，例如利用现有的安全措施，但开发人员应该权衡这些优点与潜在的缺点，并评估它们是否符合其特定的用例和要求。
HTTP 流式传输有哪些替代方案？ HTTP 流的一些替代方案包括：...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-07</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/http/>Http</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to [译]什么是HTTP流式传输？" href=https://blog.chensoul.cc/posts/2024/05/07/http-streaming/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/page/6/>« Prev Page</a>
<a class=next href=https://blog.chensoul.cc/page/8/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>