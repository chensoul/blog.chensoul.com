<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.133.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ChenSoul</title>
<meta name=keywords content="java"><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/index.xml><link rel=alternate type=application/json href=https://blog.chensoul.cc/index.json><link rel=alternate hreflang=en href=https://blog.chensoul.cc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="ChenSoul"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="ChenSoul"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"ChenSoul","url":"https://blog.chensoul.cc/","description":"健康，爱情和使命，按照这个顺序，其它的都不重要","thumbnailUrl":"https://blog.chensoul.cc/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]HTTP 的演变 – HTTP2 深入探讨</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/http2
可以毫不夸张地说，超文本传输协议 (HTTP) 造就了我们所熟知的互联网。 HTTP 最初是由万维网的发明者蒂姆·伯纳斯·李 (Tim Berners-Lee) 于 1989 年提出的应用程序协议。第一个记录版本 HTTP/0.9 被称为单行协议。鉴于它催生了万维网，它现在可以被描述为有史以来最伟大的俏皮话。
随着我们对互联网的需求不断增长，HTTP 作为网络协议也必须不断发展才能提供可接受的性能。 HTTP/2 标志着一次重大改革，是自 1997 年 HTTP/1.1 ( RFC 2068 ) 提供以来第一个新的标准化。本文介绍了 HTTP/2 如何设计来克服 HTTP/1.1 的限制、新协议的实现、HTTP/2 的工作原理以及其自身的限制。
通过单个 TCP 连接的 HTTP/2 客户端-服务器。
出身卑微——HTTP 简史 HTTP/0.9 的“单行协议”由请求组成：方法GET后跟文档地址、可选端口地址，并以回车符和换行符结束。由一串 ASCII 字符组成的请求。只能传输 HTML 文件。没有 HTTP 标头、状态代码或错误代码。
进化的第一阶段必须很快到来。
HTTP/1.0 – 突破限制 为了克服 HTTP/0.9 的严重限制，浏览器和服务器独立修改了协议。一些关键的协议更改：
请求允许包含多个由换行符分隔的标头字段。 服务器发送了包含单个状态行的响应。 响应中添加了一个标头字段。响应标头对象由由换行符分隔的标头字段组成。 服务器可以使用 HTML 以外的文件进行响应。 这些修改没有以有序或商定的方式完成，导致 HTTP/0.9 的不同风格，进而导致互操作性问题。为了解决这些问题，HTTP 工作组成立，并于 1996 年发布了 HTTP/1.0（RFC 1945）。它是一个信息性 RFC，仅记录当时的所有用法。因此，HTTP/1.0 不被视为正式规范或互联网标准。
HTTP/1.0 请求/响应的代码示例 来自客户端的使用 GET 方法的请求
GET /contact HTTP/1.0 Host: www.ably.io User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0) Accept: text/*, text/html, text/html;level=1, */*Accept-Language: en-us 客户端通过 POST 方法发出请求
POST /contact HTTP/1.0 Host: www.ably.io User-Agent: Mozilla/4....</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1012 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]HTTP 的演变 – HTTP2 深入探讨" href=https://blog.chensoul.cc/posts/2024/05/07/http2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]Java和WebSockets：构建可靠的实时应用程序</h2></header><div class=entry-content><p>原文：https://ably.com/topic/websockets-java
在全球范围内，人们对实时传输数据的需求不断增长，WebSocket可能是此类用例中最流行的传输协议。在 WebSocket 出现之前，“实时”网络已经存在，但它很难实现，通常速度较慢，并且是通过破解现有的网络技术来实现的，而这些技术并不是为实时应用程序设计的。 WebSocket 协议为真正的实时网络铺平了道路。
Java是一种流行的编程语言和计算语言。它是 Android 智能手机应用程序的核心编程语言之一，是构建实时系统的可靠选择。 WebSockets 成为 Java 标准版 SDK 的一部分已经有一段时间了。WebSocket 协议最初是在 2013 年作为JSR 356的一部分提出的，目前已作为javax.websocket包的一部分包含在 Java SDK 中。
由于对实时数据的需求正在稳步增长，并且 Java 已成为一种成熟且广泛使用的语言/平台，因此我认为值得考虑为Java 客户端应用程序实现可靠的 WebSocket 解决方案所面临的众多挑战。
现状——简要概述 基本或原始的 WebSocket 实现很少能够满足为未知（但可能非常多）数量的用户提供服务的实时应用程序的需求。大多数时候，您需要考虑扩展 Java 客户端 WebSocket 实现的功能。
为此，您可以使用nv-websocket-client等开源库，其中包含一些附加功能，例如代理支持。这是使用 nv-websocket-client 创建 WebSocket 实例的方法：
// Create a WebSocket. The scheme part can be one of the following: // 'ws', 'wss', 'http' and 'https' (case-insensitive). The user info // part, if any, is interpreted as expected. If a raw socket failed // to be created, an IOException is thrown. WebSocket ws = new WebSocketFactory().createSocket("ws://localhost/endpoint"); 创建 WebSocket 实例后，下一步是注册侦听器以接收 WebSocket 事件：
// Register a listener to receive WebSocket events....</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;535 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Java和WebSockets：构建可靠的实时应用程序" href=https://blog.chensoul.cc/posts/2024/05/07/websockets-java/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]WebSocket API和协议说明</h2></header><div class=entry-content><p>原文地址：https://ably.com/topic/websockets
WebSocket 标志着 Web 开发的转折点。 WebSocket 技术旨在以事件为驱动，并针对低延迟进行了优化，已成为许多寻求构建交互式实时数字体验以提供令人愉悦的用户体验的组织和开发人员的首选。本文探讨了与 WebSocket 相关的关键主题：
WebSocket 协议和 API 解释
WebSockets 是如何工作的？
WebSockets的优缺点是什么？
WebSockets 是否可扩展？
WebSocket 的用途是什么？
WebSockets 的最佳替代品是什么？
如何开始使用 WebSockets 构建实时体验
WebSocket 常见问题解答
WebSocket：协议和 API 解释 WebSocket 是一种实时技术，可通过持久的单套接字连接在客户端和服务器之间实现双向全双工通信。只要需要，WebSocket 连接就会保持活动状态（理论上，它可以永远持续下去），允许服务器和客户端随意发送数据，开销最小。
WebSocket 技术由两个核心构建块组成：
WebSocket 协议。 WebSocket API。 WebSocket的历史是什么？ 第一个实时 Web 应用程序开始出现在 2000 年代，试图提供响应迅速、动态和交互式的最终用户体验。然而，在那个时候，实时网络很难实现，而且比我们现在习惯的要慢;它是通过入侵现有的基于HTTP的技术（AJAX和Comet）来实现的，这些技术不是为实时应用程序设计和优化的。很明显，需要一个更好的替代方案。
在 2008 年，开发人员 Michael Carter 和 Ian Hickson 特别敏锐地感受到了在实现任何类似实时的东西时使用 AJAX 和 Comet 的痛苦和局限性。通过在 IRC 和 W3C 邮件列表上的合作，他们提出了一个计划，为网络上的现代、真正的实时通信引入一个新标准。因此，“WebSocket”这个名字被创造出来。
什么是 WebSocket 协议？ WebSocket 协议支持 Web 客户端和 Web 服务器之间通过基础 TCP 连接进行持续的全双工双向通信。该协议旨在允许客户端和服务器实时通信，从而在 Web 应用程序中实现高效且响应迅速的数据传输。
2011 年 12 月，互联网工程任务组 （IETF） 通过 RFC 6455 对 WebSocket 协议进行了标准化。互联网号码分配机构 （IANA） 与 IETF 协调维护 WebSocket 协议注册管理机构，该注册管理机构定义了协议使用的许多代码和参数标识符。
什么是 WebSocket API？ WebSocket API 包含在 HTML Living Standard 中，是一个编程接口，用于创建 WebSocket 连接并管理 Web 应用程序中客户端和服务器之间的数据交换。它为开发人员提供了一种简单且标准化的方法，可以在其应用程序中使用 WebSocket 协议。...</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1016 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]WebSocket API和协议说明" href=https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/websockets-vs-http
当谈到 WebSocket 与 HTTP 时，决定使用哪一种并不总是那么明确。哪一个更好？您的应用程序应该使用哪一款？
但问题的答案不一定是其中之一 - 开发人员经常根据场景在同一个应用程序中同时使用 WebSocket 和 HTTP。更重要的问题是 - 我如何确定 WebSockets 还是 HTTP 是特定类型通信的正确通信协议？
这是您需要了解的一切。
WebSocket 与 HTTP 概览 在此页面上，我们将探讨这些技术的工作原理、它们在实现实时通信方面的表现如何，并就在哪些场景中使用哪些技术提供具体指导。
如果您正在寻找高级比较，以下是主要差异一目了然：
请继续阅读以详细了解这两种流行协议的比较。
HTTP协议 什么是 HTTP？ 从根本上讲，HTTP 是一种通信协议，使客户端（例如 Web 浏览器）和服务器能够共享信息。
例如，HTML 文档、图像、应用程序数据 (JSON) 等。
很难想出比您现在正在阅读的此页面更好的 HTTP 实际示例。
当您加载此页面时，您的浏览器会发出 HTTP 请求，服务器会使用您当前正在阅读的 HTML 文档来响应该请求。
HTTP 是如何工作的？ HTTP 遵循请求-响应消息传递模式，其中客户端发出请求，Web 服务器发送响应，该响应不仅包括请求的内容，还包括有关请求的相关信息。
在底层，每个请求都会打开一个与服务器的短暂连接，然后关闭。
HTTP 示例
网页浏览。 下载图像、视频或二进制文件，例如桌面应用程序。 使用 JavaScript 中的 fetch 函数向 API 发出异步请求。 由于每个 HTTP 请求都包含处理它所需的所有信息，因此服务器无需跟踪连接和请求。
这种无状态设计是有利的，因为它使得可以部署额外的服务器来处理请求，而不需要在服务器之间同步状态逻辑。
此外，由于每个请求都是独立的，因此通过代理路由消息以执行缓存、加密和压缩等增值功能变得非常简单。
这种无状态方法的缺点是客户端打开一个临时连接并为每个请求发送元数据，从而产生少量开销。
当加载网页或下载文件时，这种开销可以忽略不计。但是，如果您发送负载较小的高频请求，它可能会对应用程序的性能产生显着影响。
通过 HTTP 进行实时更新 这种模式（客户端发出请求，服务器发出响应）非常适合网页、文件或应用程序数据等静态资源。
但是，请考虑这样一种情况：客户不知道新信息何时可用。
例如，假设您正在为 BBC 实施突发新闻功能。
在这种情况下，客户不知道故事的下一次更新何时会发生。
现在，您可以对客户端进行编码，以频繁地发出 HTTP 请求，以防万一发生某些情况，并且对于少数客户端来说，这可能工作得足够好。
但是假设您有成百上千个客户端（在 BBC 的情况下有数十万个）向服务器发送请求，而这些请求在更新之间没有产生任何新内容。
这不仅浪费带宽和服务器资源，而且在最近的请求完成后不久更新就会中断 - 可能需要几秒钟才能发送下一个请求并且用户获得更新。一般来说，这种方法称为HTTP 轮询，它既不高效也不实时！
相反，如果服务器能够在新信息可用时将数据推送到客户端，那就更好了，但这从根本上违背了请求-响应模式的原则。
或者确实如此？
HTTP 流式传输 尽管 HTTP 从根本上遵循请求-响应模式，但有一种解决方法可用于实现实时更新。
服务器不是发出完整的响应，而是发出部分 HTTP 响应并保持底层连接打开。
基于上一节的突发新闻示例，通过 HTTP 流，服务器可以在每次新闻更新中断时将部分响应（如果您愿意，可以是块）附加到响应流 - 连接无限期保持打开状态，使服务器能够推送当新信息可用时，以最短的延迟向客户端提供新信息。...</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;452 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]WebSocket与HTTP：2024年为您的项目选择哪一个" href=https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]WebSocket与REST</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/websocket-vs-rest
无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。
好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。
在本文中，我们将阐明 REST 与 WebSocket，涵盖：
回顾一下 REST 和 WebSocket 是什么 他们的技术权衡，包括 WebSocket 与 REST 性能 何时应该使用 REST 以及何时 WebSocket 是更好的选择 如果您使用任一协议，则需要填补一些空白。 但如果您正在寻找快速摘要，那么您需要了解以下内容：
当您需要轻松扩展的基础架构来进行无状态 CRUD 操作并且您希望坚持使用标准 Web 工具时，REST 是理想的选择。例如，如果您正在构建一个 API 来将更新发布到社交网络 当您需要客户端和服务器之间进行实时、双向、低延迟通信时，WebSocket 是正确的选择。例如，如果您正在构建聊天应用程序。 什么是REST？ 表述性状态传输 (REST) 是一组原则，定义了通过 HTTP 构建 API 的一种方法。这很容易被忽视，但 REST 不是一种协议，这意味着您可以非常灵活地根据您的需求来塑造它。它的流行很大程度上是由于它的简单性以及它重用了已经用于网络的方法和技术。这在很大程度上定义了它表现良好的用例以及您需要寻找替代方案的用例。
让我们快速了解一下 REST 与其他方法的区别。
REST 的主要特征 **无状态：**对 REST API 发出的每个请求都是独立且自包含的。这使得扩展变得更加简单。当流量增加时，您可以在负载均衡器后面添加更多服务器，因为特定客户端不需要每次都连接到同一台服务器。尽管 HTTP 和 REST 是无状态的，但您可以通过使用客户端 cookie 来跟踪会话和登录状态来维护长时间运行的会话。 **CRUD：**每个 REST 请求都使用标准 HTTP 动词（GET、POST、PUT、PATCH 和 DELETE），与创建、读取、更新、删除操作对齐。 有效负载格式： REST 通常使用 JSON 或 XML 等标准化消息格式进行数据交换。但是您可以使用任何您喜欢的数据格式，只要您设置正确的Content-Type标头即可。 **可缓存：**您可以选择允许客户端和中间基础设施缓存响应。这有助于扩展和响应时间。 同步： REST 所依赖的 HTTP 请求-响应周期最适合短暂、简单的事务，其中客户端在继续下一个任务之前等待响应。 什么是 WebSocket？ REST 适用于短暂、无状态的通信，而 WebSocket 则提供持续、低延迟的双向通信通道。这意味着您与 WebSocket 交互的方式是不同的。因此，您无需使用特定端点构建“WebSocket API”，而是打开一个连接，双方可以在需要时交换消息。这使其成为实时应用程序的理想选择，例如聊天、体育或金融数据的实时流媒体，以及 Figma、Miro 和 Google Docs 等交互式实时协作环境。...</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;352 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]WebSocket与REST" href=https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是 HTTP？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/http/
HTTP 概述 HTTP，即超文本传输协议，是互联网通信的基础。它在客户端-服务器模型上运行，其中前端客户端（例如网络浏览器）通过向服务器发送HTTP请求消息来发起请求，例如请求网页（例如搜索引擎）。然后，服务器使用包含所请求资源的 HTTP 响应消息进行响应，如果资源不可用，则使用错误消息进行响应。
HTTP 是一种无状态协议，这意味着每个请求都是独立的，与之前或将来的请求无关。这允许客户端和服务器之间进行有效的通信。
HTTP 于 1991 年首次引入，作为 Tim Berners-Lee 创建的万维网项目的一部分，并由互联网工程任务组 (IETF)进行标准化。 IETF 负责开发和维护 HTTP、TCP/IP、DNS 等协议，以及他们在 RFC 或“征求意见”中记录的许多其他协议。
早期，需要一种标准化协议来促进不同计算机和服务器之间的通信。这导致了各种协议的发展，包括 HTTP。
HTTP 0.9，该协议的第一个版本，是一个简单且有限的系统，仅支持超文本文档的检索。它不支持标头，只允许传输纯文本数据。
1996 年，HTTP 1.0 发布，引入了至今仍在使用的几个重要功能。它增加了对多种媒体类型的支持，允许传输图像、视频和其他文件格式。它还引入了使用标头来实现更高级的功能，例如缓存和身份验证。
1999 年发布的 HTTP 1.1 进一步改进了该协议。它引入了持久连接，允许通过单个 TCP 连接发送多个请求和响应。这极大地提高了客户端和服务器之间通信的效率和速度。
近年来，人们致力于增强和优化HTTP协议。这导致了HTTP/2的开发，并于 2015 年发布。HTTP/2 带来了多项改进，包括多路复用、标头压缩和服务器推送，以减少延迟并提高性能。
最后是 HTTP/3。HTTP/3也称为 HTTP over QUIC（快速 UDP Internet 连接），是最新的 HTTP 协议版本，旨在解决以前版本的一些限制并提高性能。
HTTP/3 构建在 QUIC 传输协议之上，该协议使用用户数据报协议 (UDP)而不是 TCP。与 TCP 相比，UDP 具有多种优势，例如减少延迟和改进拥塞控制。 HTTP/3 使用 UDP，旨在提供更快、更可靠、更安全的连接。
HTTP/3 的关键特性之一是它支持多路复用和流多路复用的能力。这允许通过单个连接同时发送多个请求和响应，从而提高效率并减少延迟。此外，HTTP/3 还包含零 RTT 连接建立、改进的拥塞控制以及通过加密提高安全性等功能。
HTTP 和服务器 服务器对于处理 HTTP 请求和提供相应的响应至关重要。以下是HTTP与服务器关系的几个要点：
请求-响应模型：如前所述，HTTP 遵循请求-响应模型。客户端向服务器发送 HTTP 请求，指定所需的操作，例如检索网页或提交表单数据。服务器处理请求并发回 HTTP 响应，其中包括状态代码、标头和请求的内容（如果适用）。 Web 服务器：Web 服务器是处理 HTTP 请求的软件应用程序或程序。它们侦听特定网络端口（通常为 HTTP 的端口 80）上的传入请求，并将它们路由到适当的资源或应用程序。流行的 Web 服务器软件包括 Apache、Nginx和 Microsoft IIS。 路由和资源处理：在 HTTP 服务器中，路由确定传入请求如何映射到特定资源或端点处理程序。例如，当接收到针对特定 URL 或路径的请求时，服务器使用路由规则来确定哪个代码或资源应处理该请求并生成适当的响应。 处理和生成响应：当 HTTP 请求到达服务器时，它会触发与所请求的资源关联的代码或资源处理程序的执行。这些处理程序可以从数据库检索数据、与外部服务交互或生成动态内容。服务器根据请求处理这些数据，并生成带有必要标头和内容的 HTTP 响应。 状态代码：HTTP 响应包括指示请求结果的状态代码。这些状态代码的范围从信息性 (1xx) 到成功 (2xx)、重定向 (3xx)、客户端错误 (4xx) 和服务器错误 (5xx)。常见状态代码包括 200（正常）、404（未找到）和 500（内部服务器错误）。 无状态：HTTP 是一种无状态协议，这意味着每个请求/响应交互都是独立的，并且不保留有关先前请求的信息。为了维护用户会话或跟踪用户交互，服务器通常使用 cookie 或会话管理技术。 HTTP 是如何工作的？ 当客户端想要从服务器检索网页或新资源时，它会发起 HTTP 请求。该请求由几个部分组成：...</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;503 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是 HTTP？" href=https://blog.chensoul.cc/posts/2024/05/07/http/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是 OAuth？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/oauth/
什么是 OAuth？ OAuth（开放授权）是一种开放标准授权框架，允许第三方应用程序访问用户数据，而无需用户共享其登录凭据。它为用户提供了一种安全且标准化的方式，将其在一个网站上的资源的访问权限授予另一个网站或应用程序，而无需暴露其密码。
简单来说，OAuth 充当最终用户和他们想要授予访问权限的应用程序之间的中间人。用户不会直接向 Web 应用程序提供用户名和密码，而是会被重定向到授权服务器（例如 Google、Facebook 或 Twitter），在那里他们可以安全地验证自己的身份。经过身份验证后，用户可以授予或拒绝对其想要使用的应用程序上的数据的访问权限。
OAuth 是如何工作的？ OAuth 为用户提供了一种安全且标准化的方式来授权应用程序从各种来源（例如社交媒体平台或在线服务）访问其数据。
OAuth工作流程涉及三个主要方：用户、应用程序和服务提供商（也称为OAuth 服务器）。以下是 OAuth 流程的高级概述：
用户启动该过程：用户想要使用需要访问服务提供商上受保护资源的应用程序。用户首先向应用程序请求访问权限。 应用程序请求授权：应用程序将用户重定向到服务提供商的授权端点，以及必要的参数，例如应用程序的客户端 ID 和请求的访问范围。 用户授予授权：服务提供商在授权端点向用户显示登录屏幕。用户输入其凭据，如果有效，则系统会要求授予或拒绝应用程序访问其资源的请求。 服务提供商发出授权代码：如果用户授予授权，服务提供商会生成授权代码并将用户重定向回应用程序指定的重定向 URI。授权码是一个临时令牌，代表用户的同意。 应用程序用授权代码交换访问令牌：现在拥有授权代码的应用程序向服务提供商发送请求，以用代码交换访问令牌。该请求包括代码、应用程序的客户端 ID 和客户端密钥，它们用于向服务提供商验证应用程序的身份。 服务提供商验证授权代码：服务提供商对其进行验证并检查它是否与之前为用户生成的授权代码相匹配。如果代码有效，服务提供商将向应用程序颁发访问令牌。 应用程序使用访问令牌来访问受保护的资源：通过从服务提供商获得的访问令牌，应用程序现在可以代表用户发出请求以访问其受保护的资源。这些请求通常是向服务提供商的 API 端点发出的。 访问令牌过期和刷新：访问令牌的生命周期有限，过期后就会过期。要继续访问用户的资源，应用程序可以使用刷新令牌（如果提供）来获取新的访问令牌，而无需用户的参与。 使用 OAuth 有什么好处？ 这种广泛采用的协议为构建实时聊天和消息应用程序的开发人员提供了多种好处：
增强的安全性： OAuth 消除了应用程序需要存储用户凭据的情况，从而降低了未经授权访问的风险。通过利用 OAuth，开发人员可以对用户进行身份验证和授权，而无需处理用户的敏感信息（例如密码）。这显着降低了数据泄露的可能性并增强了整体应用程序的安全性。
简化的用户体验： OAuth 使用户能够向第三方应用程序授予权限而无需共享其凭据，从而提供无缝且用户友好的体验。这消除了为每个应用程序创建和管理单独帐户的麻烦，从而提高了便利性和用户采用率。
可扩展性和互操作性： OAuth 使开发人员能够构建集成多个平台和服务的应用程序。通过利用 OAuth，开发人员可以轻松地验证和访问来自不同提供商的资源，从而允许他们的聊天和消息应用程序与其他系统无缝交互。这增强了可扩展性，并使开发人员能够利用不同平台的现有用户群。
细粒度的访问控制： OAuth 允许开发人员为其聊天和消息应用程序实施细粒度的访问控制。可以为每个资源授予权限，确保第三方应用程序只能访问所需的资源。这种对访问的精细控制有助于维护数据隐私和控制，降低未经授权的数据泄露的风险。
开发人员友好： OAuth 提供了一个简单、开发人员友好的框架，用于在聊天和消息传递应用程序中实现身份验证和授权。该协议有详细的文档记录，并受到各种库和 SDK 的支持，使开发人员可以轻松地将 OAuth 集成到他们的应用程序中。此外，OAuth 通过内置的令牌过期和撤销机制简化了访问令牌的管理。这简化了开发流程并降低了处理用户身份验证和授权的复杂性。
使用 OAuth 有哪些缺点？ 虽然 OAuth 对于构建实时聊天和消息应用程序的开发人员来说具有众多优势，但也存在一些缺点。这些缺点包括：
**复杂性：**实施 OAuth 可能很复杂，尤其是对于不熟悉该协议的开发人员而言。该过程涉及多个步骤，包括注册应用程序、获取客户端凭据和处理授权流程。与多个身份提供商集成或处理刷新令牌时，复杂性可能会进一步增加。开发人员需要投入时间和精力来正确理解和实施 OAuth。
对第三方提供商的依赖： OAuth 依赖第三方身份提供商来对用户进行身份验证和授权。这种依赖性引入了潜在的单点故障。如果身份提供商遇到中断或更改其 API，则可能会中断聊天和消息传递应用程序的身份验证和授权过程。开发人员需要考虑所选身份提供商的可靠性和寿命。
用户隐私问题： OAuth 提供了一种安全的身份验证和授权机制，但一些用户可能担心与第三方应用程序共享其个人信息。尽管 OAuth 不会公开密码等敏感信息，但用户仍然需要授予访问其数据的权限。某些用户可能会犹豫是否授予这些权限，尤其是对于鲜为人知或不太受信任的应用程序。
**缺乏标准化：**尽管 OAuth 被广泛采用，但不同提供商和平台的实施可能存在差异。缺乏标准化可能会导致与多个系统集成时出现不一致和兼容性问题。开发人员可能需要额外的努力来处理这些变化并确保不同平台和提供商之间的兼容性。
**安全漏洞：**虽然 OAuth 的设计是安全的，但也存在发现和利用漏洞的情况。这些漏洞可能导致未经授权的用户数据访问或冒充攻击。开发人员必须及时了解最新的安全最佳实践，并定期修补 OAuth 实施中的任何漏洞。
OAuth 与 OpenID OAuth 和OpenID是广泛使用的身份验证和授权协议，但用途不同。
OAuth 主要是一种授权协议，允许应用程序访问另一个系统上的用户资源，而无需共享其凭据。它通常用于委托授权场景，即用户向第三方应用程序授予访问其在特定网站或服务上的数据的权限。例如，当您使用 Google 帐户登录第三方应用程序时，OAuth 通常用于授予该应用程序访问您的 Google 云端硬盘或 Gmail 数据的权限。...</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;534 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是 OAuth？" href=https://blog.chensoul.cc/posts/2024/05/07/oauth/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是HTTP/3？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/http-3/
什么是 HTTP/3？ HTTP/3（或 HTTP-over-QUIC）是超文本传输协议 ( HTTP ) 的第三个主要版本。它是用于 Web 浏览器和服务器之间通信的应用层协议。 HTTP/3 旨在提高 Web 通信的性能和安全性。
HTTP/3的主要功能之一是它构建在用户数据报协议 (UDP)之上，而不是建立在 HTTP 早期版本中使用的传输控制协议(TCP) 之上。 UDP 是一种无连接协议，可为实时应用程序提供更低的延迟和更好的性能。
HTTP/3 还引入了一种新的传输协议，称为QUIC（快速 UDP 互联网连接）。与 TCP 相比，QUIC 具有多种优势，包括减少延迟、提高可靠性和更好的拥塞控制。它还包括内置加密，增强网页和通信安全性。
HTTP/3 的另一个重要特性是它对多路复用的支持。这意味着可以通过单个连接同时发送和接收多个请求和响应，从而提高数据传输效率。
HTTP/3 还包括其他优化以提高性能，例如标头压缩和流优先级。这些优化有助于减少开销并提高 Web 通信的整体速度。
总体而言，HTTP/3 在性能和安全性方面比其前身 HTTP/2 显着改进了功能。它对于构建实时聊天和消息传递应用程序的开发人员特别有利，因为它提供更低的延迟和更高的可靠性，使其成为需要快速交付实时数据的用例的理想选择。
让我们退一步看看这一切从第一个 HTTP 版本开始。
HTTP 简史 HTTP（超文本传输协议）协议有着长达数十年的丰富历史。它于 20 世纪 90 年代初首次推出，作为万维网上客户端和服务器之间的通信方式。
HTTP 最初是由Tim Berners-Lee和他在CERN（欧洲核研究组织）的团队开发的，旨在促进超文本文档的交换。第一个版本 HTTP/0.9 是一个简单的协议，仅支持用于检索 HTML 文档的 GET 请求。
1996 年，HTTP/1.0 协议由互联网工程任务组(IETF)标准化。该版本引入了几个重要的功能，包括对 POST 请求、响应状态代码和标头的支持。 HTTP/1.0 还允许传输不同的媒体类型，例如图像和视频以及 HTML 文档。
然而，随着网络变得更加复杂和交互，HTTP/1.0 的局限性变得明显。它是围绕请求-响应模型设计的，其中每个请求都需要与服务器的单独连接。这导致了高延迟和网络资源的低效使用。
HTTP/1.1 协议解决了这些问题。
HTTP/1.1 HTTP/1.1 是超文本传输协议 (HTTP) 的第二个主要版本，于 1999 年推出，如今在互联网上广泛使用。
HTTP/1.1 的关键功能之一是支持持久连接，也称为保持活动连接。在以前版本的 HTTP 中，必须为每个请求和响应建立一个新的 TCP 连接，这导致延迟和开销增加。使用 HTTP/1.1，可以通过单个连接发送多个请求和响应，从而减少建立新连接的需要并提高性能。
HTTP/1.1 的另一个重要特性是它对管道的支持。流水线允许发送多个请求而无需等待相应的响应，这有助于减少延迟并提高数据传输效率。
HTTP/1.1还引入了缓存的概念。缓存允许 Web 浏览器存储和重用以前访问的资源，例如图像和样式表，这可以显着缩短页面加载时间并减少带宽使用。
然而，尽管有这些改进，HTTP/1.1 仍然存在一些局限性。同时处理多个请求和响应可能效率低下，因为它需要严格的消息排序。这可能会导致性能问题，特别是对于需要低延迟和高并发的实时应用程序。
此外，HTTP/1.1 不支持标头压缩，这可能会导致开销增加和数据传输速度变慢。
HTTP/2 HTTP/2 是超文本传输协议 (HTTP)的最新主要版本，于 2015 年推出，作为对之前 HTTP/1....</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;415 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是HTTP/3？" href=https://blog.chensoul.cc/posts/2024/05/07/http3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是HTTP流式传输？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/http-streaming/
什么是 HTTP 流式传输？ HTTP 流，也称为基于 HTTP 的流或 HTTP 实时流，是一种用于通过 Internet 传送实时多媒体内容（例如音频或视频）的技术。该协议允许从服务器到客户端设备的连续数据传输，使用户能够消费媒体内容而无需完整的文件下载。
与传统的文件下载方法不同，在开始播放之前需要下载整个文件，HTTP 流允许立即播放媒体内容。它的工作原理是将媒体文件分成更小的片段或块，然后将其连续传送到客户端设备。
HTTP 流利用超文本传输协议 (HTTP)作为其通信协议。它利用现有的 Web 基础设施并使用 HTTP 服务器的可扩展性、缓存和负载平衡功能。这使其成为向许多用户提供实时内容的高效且灵活的解决方案。
HTTP 流如何工作？ 从较高层面来看，HTTP 流式传输的工作原理是将媒体文件分成小块并通过 HTTP 连接将其传输到客户端。客户端（通常是网络浏览器或媒体播放器）不断请求和接收这些块，从而实现媒体的无缝播放。
HTTP 流式传输有两种主要方法：渐进式下载和自适应流式传输。
1.渐进式下载：
渐进式下载缺乏自适应流媒体提供的适应性。在客户端开始播放之前，会通过渐进式下载来下载整个媒体文件。这意味着，如果在下载过程中出现任何 Wi-Fi 网络中断或带宽波动，用户可能会遇到播放缓冲或延迟的情况。这可能会让用户感到沮丧，并可能导致糟糕的用户体验。
2.[自适应流媒体](https://www.cloudflare.com/learning/video/what-is-adaptive-bitrate-streaming/#:~:text=Adaptive bitrate streaming adjusts video,%2C location%2C or Internet speed.)：
自适应流媒体对于开发人员构建实时聊天和消息传递应用程序（提供视频或音频等媒体文件）来说是一项至关重要的技术。它确保无论用户的网络条件如何，媒体内容都可以流畅、高效地传输。这在当今的数字环境中尤其重要，用户期望高质量、不间断的媒体播放，但有时具有不同的互联网速度。
自适应流式传输通常涉及以下步骤：
内容编码：媒体文件被编码为具有不同比特率和质量级别的多种变体。这些变化存储在服务器上。 清单文件：创建一个清单文件，其中包含有关可用变体及其相应 URL 的信息。 初始请求：客户端向服务器请求清单文件，该文件提供有关媒体文件的可用变体的信息。 变体选择：客户端根据网络条件和设备功能选择所需的变体。然后它从服务器请求相应的媒体块。 块传送：服务器通过 HTTP 连接将分块媒体传送到客户端。客户端不断请求并接收这些块，并在必要时调整播放质量。 比特率适应：在播放期间，客户端监视网络状况并根据可用带宽动态调整所选变体。如果网络变得拥塞，它可能会切换到较低的比特率变体，或者如果网络状况改善，它可能会切换到较高的比特率变体。 无缝播放：通过连续接收和播放媒体块，自适应流媒体提供无缝播放体验，使用户能够在没有中断或缓冲的情况下享受内容。 HTTP 流有什么好处？ HTTP 流式传输为构建实时聊天和消息传递应用程序的开发人员提供了多种好处：
实时数据传送：HTTP流可以实现数据的实时传送，允许用户即时发送和接收消息。这确保用户可以进行实时对话，而不会出现任何明显的延迟。 可扩展性：HTTP 流具有高度可扩展性，能够处理许多并发连接并向多个用户实时传送消息。这对于支持不断增长的用户群和处理大量消息的应用程序至关重要。 减少网络开销：使用 HTTP 流式传输，当有新信息可用时，仅通过网络发送必要的数据，从而减少网络开销。这与轮询等其他方法形成鲜明对比，即使不存在新数据，也会不断发出请求。 高效的资源利用：HTTP 流可以有效地利用服务器资源，因为它消除了频繁的轮询请求。这可以减少服务器负载并提高性能，特别是在具有许多活跃用户的应用程序中。 更好的用户体验：HTTP 流通过提供实时更新和即时消息传递，增强了聊天和消息传递应用程序的用户体验。用户可以进行更具互动性和吸引力的对话，而不会因延迟或错过消息而感到沮丧。 安全性：HTTP 流可以利用 HTTPS 等现有安全措施提供安全的通信通道。这可确保敏感的用户数据和对话免受未经授权的访问和窃听。 使用 HTTP 流有哪些缺点？ 使用 HTTP 流进行实时聊天和消息传递应用程序有几个缺点：
延迟： HTTP 流媒体依赖于客户端和服务器之间的持续连接。这可能会引入延迟，因为服务器需要维持开放连接并以块的形式发送数据。因此，向用户发送实时消息可能会出现延迟，从而影响用户体验。
可扩展性： HTTP 流对于客户端和服务器来说可能是资源密集型的。维护大量打开的连接会给服务器带来压力并限制其可扩展性。此外，客户端需要处理传入的数据流，这也可能对其资源提出要求。
**兼容性：**所有设备或网络可能不支持 HTTP 流。某些防火墙或代理可能会阻止或干扰流连接，从而导致通信问题。这可能会将聊天应用程序的可用性限制为部分用户。
**可靠性：**由于 HTTP 流媒体依赖于长期连接，因此中断或网络故障可能会破坏流媒体过程。如果连接丢失，客户端可能需要重新建立连接，这可能会导致消息丢失或重复。
安全性： HTTP 流本身并不为数据传输提供加密或安全措施。如果没有额外的安全层，通过聊天应用程序交换的敏感信息可能容易遭到窃听或未经授权的访问。
**电池消耗：**连续连接和数据流会快速耗尽移动设备的电池。这可能是实时聊天应用程序的用户所关心的问题，尤其是在长时间使用这些应用程序时。
开发人员在选择实时聊天和消息应用程序技术时需要考虑这些缺点。虽然 HTTP 流提供了一些好处，例如利用现有的安全措施，但开发人员应该权衡这些优点与潜在的缺点，并评估它们是否符合其特定的用例和要求。
HTTP 流式传输有哪些替代方案？ HTTP 流的一些替代方案包括：...</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;902 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是HTTP流式传输？" href=https://blog.chensoul.cc/posts/2024/05/07/http-streaming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是Socket.IO？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/socket-io/
什么是Socket.IO？ Socket.IO是一个开源的跨平台库，它提供客户端和服务器之间基于事件的全双工双向通信。它基于 WebSocket 协议构建，提供附加功能，例如自动重新连接以及在无法使用 WebSocket时回退到HTTP 长轮询。
Socket.IO 客户端由客户端和服务器端库组成。虽然最初在服务器上支持NodeJS ，在客户端支持JavaScript，但现在它支持各种服务器和客户端技术，包括Java、Python、Swift和Kotlin，它们都是官方代码库的一部分，由活跃社区贡献。
Socket.io 有何用途？ Socket.IO 允许您实现依赖于消息交换的各种应用程序，例如即时消息传递、多用户协作、实时分析、文件共享和通知。
Socket.io 适合实时应用程序吗？ 是的，Socket.IO 是构建实时 Web 应用程序的不错选择，因为它提供了许多对开发人员有用的开箱即用功能，包括：
房间和命名空间支持允许您将客户端分组到可以接收广播或多播消息的房间中。 自动重连意味着您无需担心客户端上线或离线。 二进制数据支持，使您不仅可以交换聊天消息，还可以交换图像或其他媒体。 Socket.io 是 API 吗？ Socket.IO不是传统意义上的API。它是一个库或框架，抽象了底层传输机制，并提供了一组用于在客户端和服务器之间构建实时双向通信的工具和实用程序。
Socket.IO 包含客户端和服务器组件，每个组件都公开其 API。
Socket.io是TCP还是UDP，有什么区别？ Socket.IO可以使用TCP和UDP作为底层传输协议，但它主要使用TCP。
TCP（传输控制协议）是一种可靠的、面向连接的协议，可确保数据按顺序且无错误地传送。
另一方面，UDP（用户数据报协议）是一种无连接、不可靠的协议，它发送数据时不检查数据是否已成功接收。
UDP 比 TCP 更轻量级，因为只有后者在客户端和服务器之间建立连接，但它只能由能够抵御丢失消息的应用程序使用。
Socket.io 与 Web Sockets 虽然 Socket.IO 明确不是WebSocket实现，但有一些相似之处。两者都是基于事件的，这意味着您可以“侦听”连接、断开连接或 new_message 等事件，并且都允许您发送JSON 对象等结构化数据。
您可以将 Socket.IO 视为底层传输协议之上的抽象层。除了底层通信层之外，该库还实现了其他功能，例如自动重新连接、数据包缓冲和消息确认，以及在 WebSocket 不可用时回退到 HTTP 长轮询，从而增加了鲁棒性。
Socket.io 示例：客户端/服务器 JavaScript 中 Socket.IO 的 Hello World 客户端/服务器实现将编写如下，摘自4.x Socket.IO 文档：
Socket.io 服务器示例：
Socket.io 客户端示例：
Socket.IO 是如何工作的？ 该库支持两种传输方法：HTTP 长轮询和 WebSockets。首先建立 HTTP 长轮询连接，然后在可能的情况下升级为 WebSocket 连接。 WebSocket 不能在任何地方运行，例如，它们被许多公司代理和防火墙阻止，因此首先发起 HTTP 长轮询，因为它更有可能成功。 HTTP 长轮询连接建立后，会在对最终用户完全透明的过程中“升级”为 WebSocket 连接。
Socket.IO的架构是怎样的？ Socket.IO 由两个不同的层组成，分别存在于客户端和服务器上：
底层管道由一个名为Engine.IO的单独库提供 Socket.IO 提供的高级 API 作为开发人员或用户，您通常不会直接与 Engine.IO 交互，但它在幕后运行以建立连接、协商传输机制并检测任何断开连接。将 Engine.IO 与 WebSocket 进行比较时，两者在功能上非常相似，只是 Engine....</p></div><footer class=entry-footer><span title='2024-05-07 00:00:00 +0000 UTC'>2024-05-07</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;128 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是Socket.IO？" href=https://blog.chensoul.cc/posts/2024/05/07/socket-io/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/page/7/>«&nbsp;Prev&nbsp;7/28
</a><a class=next href=https://blog.chensoul.cc/page/9/>Next&nbsp;9/28&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>