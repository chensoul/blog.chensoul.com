<!doctype html><html lang=zh itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.111.3"><meta charset=utf-8><title>《Effective Java 3》笔记：静态工厂方法代替构造函数 · ChenSoul</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。 介绍 静态工厂方法是指在类中定义一个静态方法，用"><meta name=keywords content="devops,programming"><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><link rel=canonical href=https://blog.chensoul.com/posts/2023/04/03/static-factory-methods-instead-of-constructors/><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link rel=stylesheet href=https://blog.chensoul.com/css/den.css><link rel=stylesheet href=https://blog.chensoul.com/css/custom.min.css><link rel=preload as=font type=font/woff2 href=/css/font/open-sans.css><link rel=stylesheet type=text/css href=/css/font/open-sans.css media=print onload='this.media="all"'><meta property="og:title" content="《Effective Java 3》笔记：静态工厂方法代替构造函数"><meta property="og:description" content="本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。 介绍 静态工厂方法是指在类中定义一个静态方法，用"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.com/posts/2023/04/03/static-factory-methods-instead-of-constructors/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-03T12:00:00+08:00"><meta property="article:modified_time" content="2023-04-03T12:00:00+08:00"><meta itemprop=name content="《Effective Java 3》笔记：静态工厂方法代替构造函数"><meta itemprop=description content="本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。 介绍 静态工厂方法是指在类中定义一个静态方法，用"><meta itemprop=datePublished content="2023-04-03T12:00:00+08:00"><meta itemprop=dateModified content="2023-04-03T12:00:00+08:00"><meta itemprop=wordCount content="3266"><meta itemprop=keywords content="java,"><meta name=twitter:card content="summary"><meta name=twitter:title content="《Effective Java 3》笔记：静态工厂方法代替构造函数"><meta name=twitter:description content="本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。 介绍 静态工厂方法是指在类中定义一个静态方法，用"></head><body id=top><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://blog.chensoul.com/images/background.webp);background-position:50%;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://blog.chensoul.com/><img class="mr20 header-logo-image" src=https://blog.chensoul.com/images/fly.png alt=logo>
ChenSoul</a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://blog.chensoul.com/categories/ideas/>思考</a></li><li class=nav-item><a class=nav-link href=https://blog.chensoul.com/categories/notes/>编程</a></li><li class=nav-item><a class=nav-link href=https://blog.chensoul.com/search/>搜索</a></li><li class=nav-item><a class=nav-link href=https://blog.chensoul.com/memos/>嘀咕</a></li><li class=nav-item><a class=nav-link href=https://blog.chensoul.com/links/>友链</a></li><li class=nav-item><a class=nav-link href=https://blog.chensoul.com/about/>关于</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>《Effective Java 3》笔记：静态工厂方法代替构造函数</h1><p class=header-date>作者:
chensoul
| <span>3266 字, 7 分钟</span>
| 2023-04-03
| 分类:
<a href=https://blog.chensoul.com/categories/notes/>Notes</a></p><div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://blog.chensoul.com/tags/java/>java</a></p></div></div></div></div></div><main><div class="container content"><article><p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。</p><h2 id=介绍>介绍</h2><p>静态工厂方法是指在类中定义一个静态方法，用于创建该类的实例。示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=n>Boolean</span> <span class=nf>valueOf</span><span class=o>(</span><span class=kt>boolean</span> <span class=n>b</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>b</span> <span class=o>?</span> <span class=n>Boolean</span><span class=o>.</span><span class=na>TRUE</span> <span class=o>:</span> <span class=n>Boolean</span><span class=o>.</span><span class=na>FALSE</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>与构造函数不同的是，静态工厂方法可以有自己的名称，并且可以根据参数的不同返回不同的对象实例。</p><h2 id=优点>优点</h2><p>这本书中提到了一些静态工厂方法的优点，包括：</p><ol><li><p>静态工厂方法可以有意义的名称：与构造函数不同，静态工厂方法可以有自己的名称，这使得代码更具有可读性和可维护性。</p><blockquote><p>例如，BigInteger 类提供了一个返回素数的静态工厂方法 <code>BigInteger.probablePrime</code> 。</p></blockquote></li><li><p>静态工厂方法可以隐藏实现细节：静态工厂方法可以隐藏对象的创建和初始化过程，使客户端代码更加简洁和易于维护。</p><blockquote><p>这是服务提供者框架的基础。</p><p>服务提供者框架中有三个基本组件：服务接口，代表要实现的服务；提供者注册 API，提供者使用它来注册实现，以及服务访问 API，客户端使用它来获取服务的实例。服务访问 API 允许客户端指定选择实现的标准。在没有这些条件的情况下，API 返回一个默认实现的实例，或者允许客户端循环使用所有可用的实现。服务访问 API 是灵活的静态工厂，它构成了服务提供者框架的基础。</p><p>服务提供者框架的第四个可选组件是服务提供者接口，它描述了产生服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须以反射的方式实例化实现。</p><p>在 JDBC 中，<code>Connection</code> 扮演服务接口的角色。<code>DriverManager.registerDriver</code> 是提供者注册的 API，<code>DriverManager.getConnection</code> 是服务访问 API，<code>Driver</code> 是服务提供者接口。</p><p>服务提供者框架模式有许多变体。例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口，这是桥接模式。依赖注入框架可以看作是强大的服务提供者。由于是 Java 6，该平台包括一个通用服务提供者框架 <code>Java.util.ServiceLoader</code>，所以你不需要，通常也不应该自己写。JDBC 不使用 ServiceLoader，因为前者比后者要早。</p></blockquote></li><li><p>静态工厂方法可以返回缓存的对象：静态工厂方法可以返回缓存的对象，这避免了创建新对象的开销，提高了性能。</p><blockquote><p>这种技术类似于享元模式。如果经常请求相同的对象，特别是在创建对象的代价很高时，它可以极大地提高性能。</p></blockquote><p><strong>举例 1：使用 ConcurrentHashMap</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadSafeCache</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ThreadSafeCache</span><span class=o>&gt;</span> <span class=n>instances</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ConcurrentHashMap</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>ThreadSafeCache</span><span class=o>()</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>ThreadSafeCache</span> <span class=nf>getInstance</span><span class=o>(</span><span class=n>String</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>instances</span><span class=o>.</span><span class=na>computeIfAbsent</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>k</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>ThreadSafeCache</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>computeIfAbsent</code> 方法用于计算缓存对象。如果 <code>key</code> 在 <code>instances</code> 中不存在，则使用 lambda 表达式 <code>k -> new ThreadSafeCache()</code> 创建一个新的 <code>ThreadSafeCache</code> 对象，并将该对象与 <code>key</code> 关联。如果 <code>key</code> 已经存在，则直接返回与之关联的 <code>ThreadSafeCache</code> 对象。</p><p>使用 <code>computeIfAbsent</code> 方法可以更简洁地实现线程安全的缓存类，并且可以确保在多线程环境下的线程安全性。</p><p><strong>举例 2：使用 synchronized 关键字</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadSafeCache</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ThreadSafeCache</span><span class=o>&gt;</span> <span class=n>instances</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>ThreadSafeCache</span><span class=o>()</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>synchronized</span> <span class=n>ThreadSafeCache</span> <span class=nf>getInstance</span><span class=o>(</span><span class=n>String</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(!</span><span class=n>instances</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>key</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>instances</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=k>new</span> <span class=n>ThreadSafeCache</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>instances</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div></li><li><p>静态工厂方法可以返回子类对象：静态工厂方法可以返回实现了某个接口或继承了某个类的子类对象，这提高了代码的灵活性和可扩展性。</p><blockquote><p>例如，Java 的 Collections 框架有 45 个接口实用工具实现，提供了不可修改的集合、同步集合等。几乎所有这些实现都是通过一个非实例化类（<code>java.util.Collections</code>）中的静态工厂方法导出的。返回对象的类都是私有的子类。</p></blockquote><p><strong>举例：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Shape</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>draw</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Circle</span> <span class=kd>implements</span> <span class=n>Shape</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>draw</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Drawing Circle&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Square</span> <span class=kd>implements</span> <span class=n>Shape</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>draw</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Drawing Square&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ShapeFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Shape</span> <span class=nf>getShape</span><span class=o>(</span><span class=n>String</span> <span class=n>shapeType</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>shapeType</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>shapeType</span><span class=o>.</span><span class=na>equalsIgnoreCase</span><span class=o>(</span><span class=s>&#34;CIRCLE&#34;</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=n>Circle</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>shapeType</span><span class=o>.</span><span class=na>equalsIgnoreCase</span><span class=o>(</span><span class=s>&#34;SQUARE&#34;</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=n>Square</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>ShapeFactory</code> 类使用静态工厂方法 <code>getShape</code> 来创建 <code>Shape</code> 对象。如果 <code>shapeType</code> 参数为 <code>CIRCLE</code>，则创建 <code>Circle</code> 对象并返回，如果参数为 <code>SQUARE</code>，则创建 <code>Square</code> 对象并返回。</p></li><li><p>静态工厂方法可以返回不可变对象：静态工厂方法可以返回不可变对象，这确保了对象的安全性和线程安全性。</p><p><strong>举例</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>ThreadSafeImmutableClass</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>name</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>ThreadSafeImmutableClass</span><span class=o>(</span><span class=kt>int</span> <span class=n>id</span><span class=o>,</span> <span class=n>String</span> <span class=n>name</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>name</span> <span class=o>=</span> <span class=n>name</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>ThreadSafeImmutableClass</span> <span class=nf>getInstance</span><span class=o>(</span><span class=kt>int</span> <span class=n>id</span><span class=o>,</span> <span class=n>String</span> <span class=n>name</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>ThreadSafeImmutableClass</span><span class=o>(</span><span class=n>id</span><span class=o>,</span> <span class=n>name</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getId</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>getName</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>name</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>ThreadSafeImmutableClass</code> 类使用静态工厂方法 <code>getInstance</code> 来创建不可变对象。由于该类的属性都是 <code>final</code> 的，因此该对象是不可变的。由于没有任何状态可以修改，因此该对象是线程安全的。</p></li></ol><h2 id=缺点>缺点</h2><p>使用静态工厂方法也有一些缺点，例如：</p><ol><li>静态工厂方法可能会导致代码的可测试性变差，因为它们往往是静态的，难以进行模拟和替换。</li><li>静态工厂方法可能会使代码的扩展性变差，因为它们通常是静态的，难以扩展和修改。</li><li>静态工厂方法可能会使代码的可读性变差，因为它们往往是自定义的，难以理解和维护。</li></ol><p>仅提供静态工厂方法也存在一些局限：</p><ol><li>不可继承：静态工厂方法是通过类名直接调用的，因此无法通过继承来创建对象的变体或子类对象。</li><li>可能难以扩展：如果在实现静态工厂方法时没有考虑到所有可能的用例，那么在需要添加新功能或对象类型时可能会很难扩展。</li><li>可能难以测试：如果静态工厂方法中包含复杂的逻辑或依赖外部资源，那么在测试时可能会很难模拟或替换这些依赖项。</li><li>可能会引起混淆：如果在同一个类中定义多个静态工厂方法，它们可能具有相似的名称或参数类型，从而可能会导致混淆或误用。</li><li>对象创建可能较慢：如果创建对象需要进行复杂的计算或依赖大量的外部资源，那么静态工厂方法可能会导致对象创建的性能问题。</li></ol><p>所以，在选择不同的静态工厂方法时，需要考虑以下几个因素：</p><ol><li>目的：考虑每个工厂方法的目的，以及它是否符合您的需求。不同的工厂方法可能有不同的目的，例如创建新对象、返回共享实例或从一种类型转换为另一种类型。</li><li>灵活性：考虑每个工厂方法的灵活性。某些工厂方法可能比其他工厂方法更灵活，允许更多的自定义或配置选项。</li><li>可读性：考虑工厂方法的可读性。好的工厂方法应该易于阅读和理解，具有清晰的名称和明确的参数。</li><li>性能：考虑每个工厂方法的性能影响。根据具体的用例，某些工厂方法可能比其他工厂方法更高效或更快。</li><li>兼容性：考虑工厂方法是否与您现有的代码库和第三方库兼容。根据具体的技术和框架，某些工厂方法可能比其他工厂方法更兼容。</li><li>维护：考虑每个工厂方法的维护影响。根据实现的复杂性以及文档和支持的可用性，某些工厂方法可能比其他工厂方法更易于维护。</li></ol><h2 id=使用>使用</h2><p>以下是一些常见静态工厂方法的名称：</p><ul><li><p><code>from</code>，用于从其他类型的对象或数据源中创建一个对象，例如 <code>Date.from</code> 和 <code>Duration.from</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Date</span> <span class=n>d</span> <span class=o>=</span> <span class=n>Date</span><span class=o>.</span><span class=na>from</span><span class=o>(</span><span class=n>instant</span><span class=o>);</span>
</span></span></code></pre></div></li><li><p><code>of</code>，一个聚合方法，它接受多个参数并返回一个包含这些参数的实例，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Set</span><span class=o>&lt;</span><span class=n>Rank</span><span class=o>&gt;</span> <span class=n>faceCards</span> <span class=o>=</span> <span class=n>EnumSet</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>JACK</span><span class=o>,</span> <span class=n>QUEEN</span><span class=o>,</span> <span class=n>KING</span><span class=o>);</span>
</span></span></code></pre></div></li><li><p><code>valueOf</code>，一种替代 <code>from</code> 和 <code>of</code> 但更冗长的方法，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>BigInteger</span> <span class=n>prime</span> <span class=o>=</span> <span class=n>BigInteger</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span><span class=o>);</span>
</span></span></code></pre></div></li><li><p><code>instance</code> 或 <code>getInstance</code>，返回一个实例，该实例由其参数（如果有的话）描述，但不具有相同的值，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>StackWalker</span> <span class=n>luke</span> <span class=o>=</span> <span class=n>StackWalker</span><span class=o>.</span><span class=na>getInstance</span><span class=o>(</span><span class=n>options</span><span class=o>);</span>
</span></span></code></pre></div></li><li><p><code>create</code> 或 <code>newInstance</code>，与 <code>instance</code> 或 <code>getInstance</code> 类似，只是该方法保证每个调用都返回一个新实例，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Object</span> <span class=n>newArray</span> <span class=o>=</span> <span class=n>Array</span><span class=o>.</span><span class=na>newInstance</span><span class=o>(</span><span class=n>classObject</span><span class=o>,</span> <span class=n>arrayLen</span><span class=o>);</span>
</span></span></code></pre></div></li><li><p><code>getType</code>，类似于 <code>getInstance</code>，但如果工厂方法位于不同的类中，则使用此方法。其类型是工厂方法返回的对象类型，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>FileStore</span> <span class=n>fs</span> <span class=o>=</span> <span class=n>Files</span><span class=o>.</span><span class=na>getFileStore</span><span class=o>(</span><span class=n>path</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Runtime</span> <span class=n>runtime</span> <span class=o>=</span> <span class=n>Runtime</span><span class=o>.</span><span class=na>getRuntime</span><span class=o>();</span>
</span></span></code></pre></div></li><li><p><code>newType</code>，与 <code>newInstance</code> 类似，但是如果工厂方法在不同的类中使用。类型是工厂方法返回的对象类型，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>BufferedReader</span> <span class=n>br</span> <span class=o>=</span> <span class=n>Files</span><span class=o>.</span><span class=na>newBufferedReader</span><span class=o>(</span><span class=n>path</span><span class=o>);</span>
</span></span></code></pre></div></li><li><p><code>type</code>，一个用来替代 <code>getType</code> 和 <code>newType</code> 的比较简单的方式，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>Complaint</span><span class=o>&gt;</span> <span class=n>litany</span> <span class=o>=</span> <span class=n>Collections</span><span class=o>.</span><span class=na>list</span><span class=o>(</span><span class=n>legacyLitany</span><span class=o>);</span>
</span></span></code></pre></div></li><li><p><code>parse</code>：用于从字符串或其他格式中解析出一个对象，例如 <code>LocalDate.parse</code> 和 <code>NumberFormat.parse</code>。</p></li><li><p><code>build</code>：用于构建一个对象，例如 <code>RequestBuilder.build</code> 和 <code>ResponseBuilder.build</code>。</p></li></ul><p>还有一些常用的静态工厂方法名称：</p><ol><li><code>asXxx</code>：用于将该类的对象转换为其他类型的对象，例如 <code>ByteBuffer.asCharBuffer</code> 和 <code>FileChannel.asIntBuffer</code>。</li><li><code>toXxx</code>：用于将该类的对象转换为其他类型的对象，例如 <code>BigInteger.toByteArray</code> 和 <code>String.toCharArray</code>。</li><li><code>getXXX</code>：用于获取某个对象，例如 <code>TimeZone.getDefault</code>。</li><li><code>newXxx</code>：用于创建一个新的对象，例如 <code>File.newFile</code> 和 <code>Thread.newThread</code>。</li><li><code>withXxx</code>：用于创建一个修改了指定属性的对象的副本，例如 <code>LocalDate.withYear</code> 和 <code>HttpHeaders.withAccept</code>。</li><li><code>forXxx</code>：用于创建一个与指定参数相关的对象，例如 <code>Charset.forName</code> 和 <code>ThreadLocalRandom.forWeb</code>。</li></ol></article><h2>相关文章</h2><dl class=row><dt class=col-md-3>2023-04-13</dt><dd class=col-md-9><a href=/posts/2023/04/13/weekly_review_14/>周报-14｜如何学习一门编程语言</a></dd><dt class=col-md-3>2023-04-11</dt><dd class=col-md-9><a href=/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/>《Effective Java 3》笔记：使用私有构造函数或枚举类型创建单例</a></dd><dt class=col-md-3>2023-04-03</dt><dd class=col-md-9><a href=/posts/2023/04/03/builder-instead-of-constructors/>《Effective Java 3》笔记：使用构造器代替构造方法</a></dd><dt class=col-md-3>2023-03-28</dt><dd class=col-md-9><a href=/posts/2023/03/28/weekly_review_12/>周报-12｜车辆被堵、开车总结、Effective Java3笔记</a></dd><dt class=col-md-3>2023-02-27</dt><dd class=col-md-9><a href=/posts/2023/02/27/weekly_review_8/>周报-8｜内存泄漏、公司裁员、练车</a></dd><dt class=col-md-3>2023-02-13</dt><dd class=col-md-9><a href=/posts/2023/02/13/weekly_review_6/>周报-6｜买车和选号、粉色理论</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=author-image><a href=https://blog.chensoul.com><img src=/images/author.webp alt=chensoul></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>chensoul</p><p class=author-desc>Java 开发工程师，喜欢探索新技术。 可以在 <a href=https://github.com/chensoul>GitHub</a> 了解更多关于我的信息，也欢迎加入我的 <a href=https://t.me/chensoul_share>Telegram</a> 频道。</p></div></div></div><div align=center><div class=comment-underline></div></div><br><div id=cusdis_thread data-host=https://cusdis.chensoul.com data-app-id=3fce9b16-7416-4c74-9786-757bf28c1b8b data-page-id=c7610ac580630c99b7b1959621820d71 data-page-url=https://blog.chensoul.com/posts/2023/04/03/static-factory-methods-instead-of-constructors/ data-page-title="《Effective Java 3》笔记：静态工厂方法代替构造函数"></div><script async defer src=https://cusdis.chensoul.com/js/cusdis.es.js></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://blog.chensoul.com/tags/>标签</a></li><li><a href=https://blog.chensoul.com/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://blog.chensoul.com/index.xml></i>RSS</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社交</div><ul class=list-unstyled><li><a href=https://t.me/chensoul_share rel=noopener target=_blank>Telegram</a></li><li><a href=https://twitter.com/chensoul_eth rel=noopener target=_blank>Twitter</a></li><li><a href=https://github.com/chensoul rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>关于</div><ul class=list-unstyled><li><a href=https://blog.chensoul.com/memos rel=noopener target=_blank>嘀咕</a></li><li><a href=https://blog.chensoul.com/links rel=noopener target=_blank>友链</a></li><li><a href=https://blog.chensoul.com/about rel=noopener target=_blank>关于</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Blog <a href=https://umami.chensoul.com/share/zWO2pDuP/chenshou rel=noopener target=_blank>analytics</a></em></small><br><small><em>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
chensoul
2020 -
2023</small></p></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g style=visibility:visible;opacity:1><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></div></div></div><script async defer data-website-id=f110cfa0-b737-4690-a032-2b9073a57fc3 src=https://umami.chensoul.com/umami.js></script></body></html>