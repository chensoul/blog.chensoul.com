<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。"><title>《Effective Java 3》笔记5：依赖注入优于硬编码资源 | ChenSoul</title>
<link rel=canonical href=https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/images/favicon.webp"><meta name=twitter:title content="《Effective Java 3》笔记5：依赖注入优于硬编码资源"><meta name=twitter:description content="本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。"><meta name=twitter:creator content="@ichensoul"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="《Effective Java 3》笔记5：依赖注入优于硬编码资源"><meta property="og:description" content="本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-17T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-17T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="og:image" content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=name content="《Effective Java 3》笔记5：依赖注入优于硬编码资源"><meta itemprop=description content="本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。"><meta itemprop=datePublished content="2023-04-17T00:00:00+00:00"><meta itemprop=dateModified content="2023-04-17T00:00:00+00:00"><meta itemprop=wordCount content="703"><meta itemprop=image content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=keywords content="Java"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"《Effective Java 3》笔记5：依赖注入优于硬编码资源","headline":"《Effective Java 3》笔记5：依赖注入优于硬编码资源","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/","description":"\u003cp\u003e本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。\u003c/p\u003e","wordCount":"703","keywords":["java"],"datePublished":"2023-04-17T00:00:00Z","dateModified":"2023-04-17T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://x.com/ichensoul","https://github.com/chensoul","https://www.linkedin.com/in/","https://www.youtube.com/@chensoul","https://t.me/chensouls"]}]}</script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/ rel=bookmark title="《Effective Java 3》笔记5：依赖注入优于硬编码资源">《Effective Java 3》笔记5：依赖注入优于硬编码资源</a></h2><hr><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2023-04-17T00:00:00>2023-04-17
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/java/ title=java>java</a></span></div></header><div style=background-color:#f1f3f5;margin-top:20px><aside style=margin:5px><span style=font-size:20px;font-weight:700>Table of Contents</span><div style=padding-left:30px><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#举例>举例</a><ul><li><a href=#构造函数>构造函数</a></li><li><a href=#静态工厂>静态工厂</a></li><li><a href=#构建器>构建器</a></li><li><a href=#函数式接口>函数式接口</a></li></ul></li><li><a href=#优点>优点</a></li><li><a href=#运用>运用</a><ul><li><a href=#spring-依赖注入>Spring 依赖注入</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></aside></div><div class=entry-content><p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。</p><h2 id=介绍>介绍</h2><p>依赖注入是软件工程中使用的一种设计模式，用于将组件和依赖项相互解耦。而不是在组件内部创建和管理依赖项，我们从外部传递它们。这种方法可以帮助创建更模块化和灵活的代码。</p><p>相比之下，硬编码资源涉及在组件内部直接创建和管理依赖项。这种方法可能会使代码不太灵活，难以维护。</p><h2 id=举例>举例</h2><p>许多类依赖于一个或多个底层资源。例如，拼写检查程序依赖于字典。常见做法是，将这种类实现为静态实用工具类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Inappropriate use of static utility - inflexible &amp; untestable!</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SpellChecker</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Lexicon dictionary <span style=color:#f92672>=</span> ...;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>SpellChecker</span>() {} <span style=color:#75715e>// Noninstantiable</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isValid</span>(String word) { ... }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>suggestions</span>(String typo) { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>类似地，我们也经常看到它们的单例实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Inappropriate use of singleton - inflexible &amp; untestable!</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SpellChecker</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> INSTANCE <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SpellChecker(...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lexicon dictionary <span style=color:#f92672>=</span> ...;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>SpellChecker</span>(...) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isValid</span>(String word) { ... }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>suggestions</span>(String typo) { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这两种方法都不令人满意，因为它们假设只使用一个字典。在实际应用中，每种语言都有自己的字典，特殊的字典用于特殊的词汇表。另外，最好使用一个特殊的字典进行测试。</p><p>你可以尝试让 SpellChecker 支持多个字典：首先取消 dictionary 字段的 final 修饰，并在现有的拼写检查器中添加更改 dictionary 的方法。但是在并发环境中这种做法是笨拙的、容易出错的和不可行的。<strong>静态实用工具类和单例不适用于由底层资源参数化的类。</strong></p><p>所需要的是支持类的多个实例的能力（在我们的示例中是 SpellChecker），每个实例都使用客户端需要的资源（在我们的示例中是 dictionary）。满足此要求的一个简单模式是在<strong>创建新实例时将资源传递给构造函数。</strong> 这是依赖注入的一种形式：字典是拼写检查器的依赖项，在创建它时被注入到拼写检查器中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Dependency injection provides flexibility and testability</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SpellChecker</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lexicon dictionary;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SpellChecker</span>(Lexicon dictionary) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dictionary</span> <span style=color:#f92672>=</span> Objects.<span style=color:#a6e22e>requireNonNull</span>(dictionary);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isValid</span>(String word) { ... }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>suggestions</span>(String typo) { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>依赖注入模式非常简单，许多程序员在不知道其名称的情况下使用了多年。虽然拼写检查器示例只有一个资源（字典），但是依赖注入可以处理任意数量的资源和任意依赖路径。它保持了不可变性，因此多个客户端可以共享依赖对象（假设客户端需要相同的底层资源）。<strong>依赖注入同样适用于构造函数、静态工厂和构建器</strong>。</p><p>以下是这些情况的示例：</p><h3 id=构造函数>构造函数</h3><p>在构造函数中使用依赖注入是最常见的方式。例如，假设我们有一个名为<code>UserService</code>的类，它需要一个能够验证用户的<code>UserValidator</code>接口作为依赖项。我们可以像这样在构造函数中注入<code>UserValidator</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> UserValidator userValidator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>UserService</span>(UserValidator userValidator) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userValidator</span> <span style=color:#f92672>=</span> userValidator;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=静态工厂>静态工厂</h3><p>静态工厂是一种创建对象的方式，它将创建对象的逻辑封装在一个静态方法中。例如，假设我们有一个名为<code>UserServiceFactory</code>的类，它负责创建<code>UserService</code>实例。我们可以像这样在静态工厂方法中注入<code>UserValidator</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceFactory</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> UserService <span style=color:#a6e22e>createUserService</span>(UserValidator userValidator) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> UserService(userValidator);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=构建器>构建器</h3><p>构建器是一种创建对象的方式，它将创建对象的逻辑封装在一个构建器类中。例如，假设我们有一个名为<code>UserServiceBuilder</code>的类，它负责创建<code>UserService</code>实例。我们可以像这样在构建器类中注入<code>UserValidator</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceBuilder</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> UserValidator userValidator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> UserServiceBuilder <span style=color:#a6e22e>withUserValidator</span>(UserValidator userValidator) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userValidator</span> <span style=color:#f92672>=</span> userValidator;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> UserService <span style=color:#a6e22e>build</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> UserService(userValidator);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，我们可以使用构建器来创建<code>UserService</code>实例，并在构建器中注入<code>UserValidator</code>。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>UserValidator userValidator <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CustomUserValidator();
</span></span><span style=display:flex><span>UserService userService <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UserServiceBuilder().<span style=color:#a6e22e>withUserValidator</span>(userValidator).<span style=color:#a6e22e>build</span>();
</span></span></code></pre></div><p>这种模式的一个有用变体是将资源工厂传递给构造函数。资源工厂是一种创建和提供对象的方式，它可以在需要时动态地创建和返回资源。在将资源工厂传递给构造函数时，我们可以将对象的创建和配置逻辑从类中移除，从而实现更好的可测试性和可维护性。</p><p>以下是一个使用资源工厂传递给构造函数的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> UserValidator userValidator;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> DataSource dataSource;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>UserService</span>(ResourceFactory resourceFactory) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userValidator</span> <span style=color:#f92672>=</span> resourceFactory.<span style=color:#a6e22e>createUserValidator</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dataSource</span> <span style=color:#f92672>=</span> resourceFactory.<span style=color:#a6e22e>createDataSource</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>authenticate</span>(String username, String password) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// perform authentication using userValidator and dataSource</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面的示例中，<code>UserService</code>类需要一个能够验证用户的<code>UserValidator</code>实例和一个<code>DataSource</code>实例。这两个依赖项都是通过资源工厂来创建的。通过将资源工厂传递给构造函数，我们可以将对象的创建和配置逻辑从类中移除，并使其更加灵活和可维护。</p><p>例如，假设我们有一个名为<code>MySqlResourceFactory</code>的类，它实现了<code>ResourceFactory</code>接口，并用于创建<code>UserValidator</code>和<code>DataSource</code>实例。我们可以像这样使用它来创建<code>UserService</code>实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ResourceFactory resourceFactory <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MySqlResourceFactory();
</span></span><span style=display:flex><span>UserService userService <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UserService(resourceFactory);
</span></span></code></pre></div><p>使用这种方法，我们将<code>UserService</code>类与具体的资源实现解耦，并使其更加灵活和可维护。同时，我们可以轻松地模拟和测试<code>UserService</code>类，因为我们可以在测试中传递不同的资源工厂实现，而不需要依赖于外部资源。</p><h3 id=函数式接口>函数式接口</h3><p>在 Java 8 中，<code>Supplier&lt;T></code>是一个函数式接口，用于表示一个无参数函数，该函数返回类型为<code>T</code>。由于其函数式特性，<code>Supplier&lt;T></code>非常适合表示工厂，因为它可以提供一种通用的方式来创建对象。</p><p>以下是一个使用<code>Supplier&lt;T></code>表示工厂的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> UserValidator userValidator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>UserService</span>(Supplier<span style=color:#f92672>&lt;</span>UserValidator<span style=color:#f92672>&gt;</span> userValidatorFactory) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userValidator</span> <span style=color:#f92672>=</span> userValidatorFactory.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>authenticate</span>(String username, String password) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// perform authentication using userValidator</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面的示例中，<code>UserService</code>类的构造函数接受一个<code>Supplier&lt;UserValidator></code>作为参数。这个<code>Supplier</code>可以在需要时动态地创建<code>UserValidator</code>实例。在<code>UserService</code>类中，我们可以通过调用<code>userValidatorFactory.get()</code>来获取<code>UserValidator</code>实例。</p><p>例如，假设我们有一个名为<code>CustomUserValidator</code>的类，它实现了<code>UserValidator</code>接口，并用于验证用户。我们可以像这样使用<code>UserService</code>类和<code>Supplier&lt;T></code>来创建<code>UserService</code>实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Supplier<span style=color:#f92672>&lt;</span>UserValidator<span style=color:#f92672>&gt;</span> userValidatorFactory <span style=color:#f92672>=</span> CustomUserValidator::<span style=color:#66d9ef>new</span>;
</span></span><span style=display:flex><span>UserService userService <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UserService(userValidatorFactory);
</span></span></code></pre></div><p>在上面的示例中，<code>userValidatorFactory</code>是一个<code>Supplier&lt;UserValidator></code>实例，它使用<code>CustomUserValidator::new</code>构造函数引用来创建<code>UserValidator</code>实例。通过将这个<code>Supplier</code>传递给<code>UserService</code>类的构造函数，我们可以创建<code>UserService</code>实例，而无需显式地创建<code>UserValidator</code>实例。</p><p>使用<code>Supplier&lt;T></code>表示工厂可以使我们的代码更加简洁和灵活。它可以使对象的创建更加通用，并允许我们在需要时动态地创建对象。同时，由于<code>Supplier&lt;T></code>是一个函数式接口，我们可以使用 lambda 表达式和方法引用来创建工厂，使代码更加简洁和易于理解。</p><h2 id=优点>优点</h2><p>以下是使用依赖注入比硬编码资源的优点：</p><ol><li>可测试性：使用依赖注入，很容易创建和注入模拟对象进行测试。这样，我们可以将正在测试的组件隔离开来，并专注于测试其行为，而不必担心其依赖项的行为。</li><li>灵活性：使用依赖注入，我们可以轻松地用不同实现替换依赖项。这在需要更改组件的行为而不更改其代码时非常有用。</li><li>解耦：依赖注入有助于将组件与其依赖项解耦，使代码更加模块化并易于维护。</li><li>关注点分离：依赖注入将依赖项的创建和管理与组件本身分离，允许更清晰地分离关注点。</li></ol><h2 id=运用>运用</h2><p>依赖注入是一种常见的设计模式，被广泛应用于许多开源框架中。以下是一些常见的开源框架和库，它们使用依赖注入来管理对象之间的依赖关系：</p><ol><li>Spring Framework：Spring 是一个非常流行的 Java 框架，它使用依赖注入来管理应用程序中的对象之间的依赖关系。Spring 通过<code>@Autowired</code>注解和 XML 配置文件来实现依赖注入。</li><li>Google Guice：Guice 是一个轻量级的依赖注入框架，它使用 Java 注解来实现依赖注入。Guice 提供了一个<code>Binder</code>接口，使用户可以配置注入规则。</li><li>Dagger：Dagger 是一个基于 Java 和 Android 平台的依赖注入框架，它使用 Java 注解和代码生成技术来实现依赖注入。Dagger 提供了一个<code>Component</code>接口，用于表示应用程序对象之间的依赖关系。</li><li>CDI：CDI 是 Java EE 6 中引入的一种依赖注入框架，它使用 Java 注解和 XML 配置文件来实现依赖注入。CDI 提供了一个<code>BeanManager</code>接口，使用户可以配置和管理应用程序对象之间的依赖关系。</li><li>Micronaut：Micronaut 是一个轻量级的依赖注入框架，它使用 Java 注解和字节码生成技术来实现依赖注入。Micronaut 提供了一个<code>@Inject</code>注解，用于标记需要注入的依赖项。</li><li>Weld：Weld 是一个 Java SE 和 Java EE 的依赖注入框架，它使用 Java 注解和 XML 配置文件来实现依赖注入。Weld 提供了一个<code>BeanManager</code>接口，用于配置和管理应用程序对象之间的依赖关系。</li><li>PicoContainer：PicoContainer 是一个轻量级的依赖注入框架，它使用 Java 注解和代码生成技术来实现依赖注入。PicoContainer 提供了一个<code>Container</code>接口，用于表示应用程序对象之间的依赖关系。</li><li>HK2：HK2 是 Java EE 8 和 Jakarta EE 9 的依赖注入框架，它使用 Java 注解和 XML 配置文件来实现依赖注入。HK2 提供了一个<code>ServiceLocator</code>接口，用于配置和管理应用程序对象之间的依赖关系。</li><li>Micrometer：Micrometer 是一个用于度量应用程序性能的库，它使用依赖注入来管理度量记录器之间的依赖关系。Micrometer 支持多种依赖注入框架，包括 Spring 和 Guice。</li><li>Google Dagger Hilt：Dagger Hilt 是一个基于 Dagger 2 的依赖注入库，它使用注解来管理对象之间的依赖关系。它提供了一些附加功能，例如使用<code>@ViewModelInject</code>注解来注入 ViewModel 依赖项。</li><li>Quarkus：Quarkus 是一个用于构建可扩展的 Java 应用程序的框架，它使用依赖注入来管理应用程序对象之间的依赖关系。它支持多种依赖注入框架，包括 CDI、Spring 和 Guice。</li><li>Micronaut Data：Micronaut Data 是一个用于管理数据库访问的库，它使用依赖注入来管理数据访问对象之间的依赖关系。它支持多种 ORM 框架，包括 Hibernate 和 JDBC。</li><li>Akka：Akka 是一个用于构建事件驱动应用程序的库，它使用依赖注入来管理 Actor 之间的依赖关系。它提供了一个<code>@Inject</code>注解，用于标记需要注入的依赖项。</li><li>JHipster：JHipster 是一个用于生成现代 Web 应用程序的框架，它使用依赖注入来管理应用程序对象之间的依赖关系。它支持多种依赖注入框架，包括 Spring 和 Guice。</li><li>Vert.x：Vert.x 是一个基于事件驱动的应用程序框架，它使用依赖注入来管理应用程序对象之间的依赖关系。它支持多种依赖注入框架，包括 CDI 和 Guice。</li><li>Quarkus Reactive：Quarkus Reactive 是一个用于构建反应式应用程序的框架，它使用依赖注入来管理应用程序对象之间的依赖关系。它支持多种依赖注入框架，包括 CDI 和 Spring。</li><li>Micronaut Security：Micronaut Security 是一个用于管理 Web 应用程序安全的库，它使用依赖注入来管理安全服务之间的依赖关系。它支持多种安全框架，包括 Spring Security 和 Apache Shiro。</li><li>Eclipse MicroProfile：Eclipse MicroProfile 是一个用于构建微服务的框架，它使用依赖注入来管理微服务之间的依赖关系。它支持多种依赖注入框架，包括 CDI 和 Guice。</li><li>Kotlin Koin：Koin 是一个用于 Kotlin 应用程序的依赖注入库，它使用 DSL 语法来管理应用程序对象之间的依赖关系。它支持单例、工厂和懒加载等不同的注入模式。</li><li>Spring Cloud：Spring Cloud 是一个用于构建分布式系统的框架，它使用依赖注入来管理分布式系统之间的依赖关系。它支持多种依赖注入框架，包括 Spring 和 Guice。</li><li>Micronaut HTTP Client：Micronaut HTTP Client 是一个用于管理 HTTP 客户端的库，它使用依赖注入来管理 HTTP 客户端之间的依赖关系。它支持多种 HTTP 客户端实现，包括 Apache HttpClient 和 Netty。</li><li>Quarkus Security：Quarkus Security 是一个用于管理 Web 应用程序安全的库，它使用依赖注入来管理安全服务之间的依赖关系。它支持多种安全框架，包括 Spring Security 和 Apache Shiro。</li></ol><p>这些框架和库都使用依赖注入来管理对象之间的依赖关系，使代码更加灵活、可维护和可测试。它们提供了一些不同的注入技术和 API，以适应不同的应用场景和需求。</p><h3 id=spring-依赖注入>Spring 依赖注入</h3><p>在 Spring 框架中，依赖注入是核心特性之一。Spring 使用依赖注入来管理应用程序对象之间的依赖关系，以实现松耦合、可测试和可扩展的代码。以下是 Spring 中使用依赖注入的方法：</p><ol><li>注解：Spring 使用注解将依赖项注入到对象中。常用的注解包括<code>@Autowired</code>、<code>@Qualifier</code>和<code>@Value</code>。其中，<code>@Autowired</code>注解用于自动装配依赖项，<code>@Qualifier</code>注解用于指定依赖项的名称或限定符，<code>@Value</code>注解用于从属性文件或环境变量中注入值。</li><li>XML 配置文件：Spring 也支持使用 XML 配置文件来定义对象之间的依赖关系。在 XML 配置文件中，可以使用<code>&lt;bean></code>元素定义对象，并使用<code>&lt;property></code>元素设置对象的属性和依赖项。</li><li>Java 配置类：Spring 还支持使用 Java 配置类来定义对象之间的依赖关系。在 Java 配置类中，可以使用<code>@Configuration</code>注解定义配置类，并使用<code>@Bean</code>注解定义对象，并使用<code>@Autowired</code>注解注入依赖项。</li></ol><p>以下是一些在 Spring 中使用依赖注入的例子：</p><p><strong>1、自动装配示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyService</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> MyRepository myRepository;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyService</span>(MyRepository myRepository) {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>myRepository</span> <span style=color:#f92672>=</span> myRepository;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>MyService</code>类通过构造函数注入了<code>MyRepository</code>依赖。在<code>MyService</code>对象创建时，Spring 框架自动装配并注入了<code>MyRepository</code>对象。</p><p><strong>2、XML 配置示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;myService&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;com.example.MyService&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;constructor-arg</span> <span style=color:#a6e22e>ref=</span><span style=color:#e6db74>&#34;myRepository&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/bean&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;myRepository&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;com.example.MyRepository&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>在这个例子中，<code>MyService</code>类和<code>MyRepository</code>类被定义为 Spring 的 bean，并在 XML 配置文件中指定它们之间的依赖关系。在<code>MyService</code>对象创建时，Spring 框架自动创建并注入了<code>MyRepository</code>对象。</p><p><strong>3、Java 配置示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppConfig</span> {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> MyService <span style=color:#a6e22e>myService</span>(MyRepository myRepository) {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> MyService(myRepository);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> MyRepository <span style=color:#a6e22e>myRepository</span>() {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> MyRepository();
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>AppConfig</code>类通过<code>@Bean</code>注解定义了<code>MyService</code>对象和<code>MyRepository</code>对象，并通过方法参数的方式注入了<code>MyRepository</code>依赖。在应用程序启动时，Spring 框架会自动创建并注入这些对象。</p><h4 id=spring-依赖注入意事项>Spring 依赖注入意事项</h4><p>在使用 Spring 中的依赖注入时，有一些注意事项需要注意，以确保代码的正确性和可维护性。</p><ol><li>依赖项注入的顺序：如果一个类依赖于多个其他类，那么这些依赖项的注入顺序可能会影响到代码的正确性。为了避免这种情况，可以使用<code>@DependsOn</code>注解指定依赖项之间的顺序。</li><li>循环依赖：如果两个或多个类之间出现循环依赖，那么会导致对象无法正确创建。为了避免这种情况，可以使用构造函数注入或 setter 注入来解决循环依赖问题。</li><li>作用域：Spring 提供了多种作用域，包括单例、原型和请求作用域等。在使用依赖注入时，需要了解每种作用域的区别和适用场景，并选择合适的作用域。</li><li>配置文件管理：在使用 XML 配置文件或 Java 配置类时，需要注意配置文件或类的管理和维护。可以使用 Spring 的 Profile 功能来管理不同的配置文件或类，并根据不同的环境或需求来选择合适的配置。</li><li>依赖注入类型选择：Spring 支持多种依赖注入类型，包括构造函数注入、setter 注入和字段注入等。需要根据情况选择合适的依赖注入类型，并考虑到代码的可测试性和可维护性。</li></ol><h4 id=如何避免循环依赖问题>如何避免循环依赖问题</h4><p>循环依赖是指两个或多个类之间相互依赖而导致无法正确创建对象的情况。在 Spring 中，可以通过以下几种方式来避免循环依赖问题：</p><ol><li>使用构造函数注入：构造函数注入是指依赖项通过构造函数的方式进行注入。这种方式可以避免循环依赖问题，因为对象的创建顺序是确定的，每个对象都必须先创建其依赖项，然后才能创建自身。</li><li>使用 setter 注入：setter 注入是指依赖项通过 setter 方法进行注入。这种方式可以避免循环依赖问题，因为对象的创建顺序是不确定的，每个对象都可以先创建自身，然后再通过 setter 方法注入其依赖项。</li><li>使用<code>@Lazy</code>注解：<code>@Lazy</code>注解可以延迟依赖项的注入，直到对象第一次使用该依赖项时才进行注入。这种方式可以避免循环依赖问题，因为对象的创建顺序是不确定的，每个对象都可以先创建自身，然后再等待其依赖项被注入。</li><li>优化依赖关系：如果出现循环依赖问题，可以通过优化依赖关系来解决。例如，将依赖项抽象成接口或抽象类，然后通过不同的实现类来解决循环依赖问题。</li></ol><h4 id=spring-多种依赖注入类的优缺点>Spring 多种依赖注入类的优缺点</h4><p>Spring 支持多种依赖注入类型，包括构造函数注入、setter 注入和字段注入等。各种依赖注入类型的优缺点如下：</p><p><strong>1、构造函数注入</strong></p><p>优点：</p><ul><li>对象创建时依赖项已经确定，可以保证依赖项的完整性和正确性。</li><li>依赖项是只读的，可以保证对象的不变性。</li></ul><p>缺点：</p><ul><li>构造函数注入比较繁琐，需要在每个类中添加构造函数和依赖项参数。</li></ul><p><strong>2、setter 注入</strong></p><p>优点：</p><ul><li>setter 注入比较灵活，可以随时注入或更改依赖项。</li><li>可以使用默认构造函数创建对象，简化代码。</li></ul><p>缺点：</p><ul><li>对象创建时依赖项可能还未注入，需要进行 null 检查。</li><li>setter 方法是公共的，可能会影响对象的不变性。</li></ul><p><strong>3、字段注入</strong></p><p>优点：</p><ul><li>简单方便，不需要手动编写构造函数或 setter 方法。</li><li>可以使用默认构造函数创建对象，简化代码。</li></ul><p>缺点：</p><ul><li>依赖项是公共的，可能会影响对象的不变性。</li><li>对象创建时依赖项可能还未注入，需要进行 null 检查。</li></ul><p>总的来说，**构造函数注入是最推荐的依赖注入方式，因为它可以保证对象的完整性和正确性。**setter 注入和字段注入则比较灵活，但需要注意依赖项的注入时机和可能对对象不变性的影响。根据具体的情况和需求，可以选择合适的依赖注入方式。</p><h2 id=总结>总结</h2><p>总之，不要使用单例或静态实用工具类来实现依赖于一个或多个底层资源的类，这些资源的行为会影响类的行为，也不要让类直接创建这些资源。相反，将创建它们的资源或工厂传递给构造函数（或静态工厂或构建器）。这种操作称为依赖注入，它将大大增强类的灵活性、可复用性和可测试性。</p></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b05%ef%bc%9a%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e4%bc%98%e4%ba%8e%e7%a1%ac%e7%bc%96%e7%a0%81%e8%b5%84%e6%ba%90 https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f04%2f17%2fprefer-dependency-injection-to-hardwiring-resources%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f04%2f17%2fprefer-dependency-injection-to-hardwiring-resources%2f&title=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b05%ef%bc%9a%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e4%bc%98%e4%ba%8e%e7%a1%ac%e7%bc%96%e7%a0%81%e8%b5%84%e6%ba%90" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b05%ef%bc%9a%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e4%bc%98%e4%ba%8e%e7%a1%ac%e7%bc%96%e7%a0%81%e8%b5%84%e6%ba%90&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f04%2f17%2fprefer-dependency-injection-to-hardwiring-resources%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f04%2f17%2fprefer-dependency-injection-to-hardwiring-resources%2f&title=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b05%ef%bc%9a%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e4%bc%98%e4%ba%8e%e7%a1%ac%e7%bc%96%e7%a0%81%e8%b5%84%e6%ba%90" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f04%2f17%2fprefer-dependency-injection-to-hardwiring-resources%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b05%ef%bc%9a%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e4%bc%98%e4%ba%8e%e7%a1%ac%e7%bc%96%e7%a0%81%e8%b5%84%e6%ba%90%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f04%2f17%2fprefer-dependency-injection-to-hardwiring-resources%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2023/04/18/weekly_review_15/ rel=next><span class=post-title>周报-15｜Umami升级到2.0、汉街蜡像馆、使用Strava跑步</span></a></div><div class=nav-next><a href=/posts/2023/04/13/weekly_review_14/ rel=prev><span class=post-title>周报-14｜如何学习一门编程语言</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2023/12/14/all-things-about-microprofile/>All things about MicroProfile</a></li><li><a href=/posts/2023/11/02/jhipster-intro/>JHipster安装和介绍</a></li><li><a href=/posts/2023/10/26/java-design-patterns-circuit-breaker/>Java设计模式：Circuit Breaker</a></li><li><a href=/posts/2023/10/16/java-design-patterns-chain/>Java设计模式：Chain</a></li><li><a href=/posts/2023/10/13/java-design-patterns-callback/>Java设计模式：Callback</a></li><li><a href=/posts/2023/09/25/java-design-patterns-cahcing/>Java设计模式：Caching</a></li><li><a href=/posts/2023/09/22/java-design-patterns-bytecode/>Java设计模式：Bytecode</a></li><li><a href=/posts/2023/09/05/java-design-patterns-builder/>Java设计模式：Builder</a></li><li><a href=/posts/2023/09/05/java-design-patterns-business-delegate/>Java设计模式：Business Delegate</a></li><li><a href=/posts/2023/08/28/java-design-patterns-bridge/>Java设计模式：Bridge</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link><a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a>
Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a>
<a style=margin-left:20px href=/privacy_policy/ target=_blank rel="noopener noreferrer">Privacy Policy</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>