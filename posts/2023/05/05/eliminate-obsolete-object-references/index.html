<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。
介绍
&ldquo;Eliminate obsolete object references&rdquo; 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。"><title>《Effective Java 3》笔记7：排除过时的对象引用 | ChenSoul</title>
<link rel=canonical href=https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/images/favicon.webp"><meta name=twitter:title content="《Effective Java 3》笔记7：排除过时的对象引用"><meta name=twitter:description content="本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。
介绍 “Eliminate obsolete object references” 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="《Effective Java 3》笔记7：排除过时的对象引用"><meta property="og:description" content="本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。
介绍 “Eliminate obsolete object references” 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-05T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="og:image" content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=name content="《Effective Java 3》笔记7：排除过时的对象引用"><meta itemprop=description content="本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。
介绍 “Eliminate obsolete object references” 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。"><meta itemprop=datePublished content="2023-05-05T00:00:00+00:00"><meta itemprop=dateModified content="2023-05-05T00:00:00+00:00"><meta itemprop=wordCount content="715"><meta itemprop=image content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=keywords content="Java"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"《Effective Java 3》笔记7：排除过时的对象引用","headline":"《Effective Java 3》笔记7：排除过时的对象引用","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/","description":"\u003cp\u003e本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。\u003c/p\u003e\n\u003ch2 id=\"介绍\"\u003e介绍\u003c/h2\u003e\n\u003cp\u003e\u0026ldquo;Eliminate obsolete object references\u0026rdquo; 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。\u003c/p\u003e","wordCount":"715","keywords":["java"],"datePublished":"2023-05-05T00:00:00Z","dateModified":"2023-05-05T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://twitter.com/","https://github.com/chensoul","https://www.linkedin.com/in/"]}]}</script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/ rel=bookmark title="《Effective Java 3》笔记7：排除过时的对象引用">《Effective Java 3》笔记7：排除过时的对象引用</a></h2><hr><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2023-05-05T00:00:00>2023-05-05
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/java/ title=java>java</a></span></div></header><div style=background-color:#f1f3f5;margin-top:20px><aside style=margin:5px><span style=font-size:20px;font-weight:700>Table of Contents</span><div style=padding-left:30px><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a><ul><li><a href=#如何排除过时对象引用>如何排除过时对象引用</a></li></ul></li><li><a href=#扩展>扩展</a><ul><li><a href=#弱引用软引用和虚引用区别>弱引用、软引用和虚引用区别</a></li><li><a href=#弱引用是否会影响程序的性能>弱引用是否会影响程序的性能？</a></li><li><a href=#如何检查弱引用对象是否被回收>如何检查弱引用对象是否被回收？</a></li></ul></li></ul></nav></div></aside></div><div class=entry-content><p>本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。</p><h2 id=介绍>介绍</h2><p>&ldquo;Eliminate obsolete object references&rdquo; 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。</p><p>考虑以下简单的堆栈实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Arrays;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.EmptyStackException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Can you spot the &#34;memory leak&#34;?</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stack</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Object<span style=color:#f92672>[]</span> elements;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> DEFAULT_INITIAL_CAPACITY <span style=color:#f92672>=</span> 16;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Stack</span>() {
</span></span><span style=display:flex><span>        elements <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>DEFAULT_INITIAL_CAPACITY<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push</span>(Object e) {
</span></span><span style=display:flex><span>        ensureCapacity();
</span></span><span style=display:flex><span>        elements<span style=color:#f92672>[</span>size<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>pop</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> EmptyStackException();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> elements<span style=color:#f92672>[--</span>size<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Ensure space for at least one more element, roughly
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * doubling the capacity each time the array needs to grow.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ensureCapacity</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (elements.<span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> size)
</span></span><span style=display:flex><span>            elements <span style=color:#f92672>=</span> Arrays.<span style=color:#a6e22e>copyOf</span>(elements, 2 <span style=color:#f92672>*</span> size <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个程序没有明显的错误。你可以对它进行详尽的测试，它会以优异的成绩通过所有的测试，但是有一个潜在的问题。简单地说，该程序有一个「内存泄漏」问题，由于垃圾收集器活动的增加或内存占用的增加，它可以悄无声息地表现为性能的降低。在极端情况下，这种内存泄漏可能导致磁盘分页，甚至出现 OutOfMemoryError 程序故障，但这种故障相对少见。</p><p>那么内存泄漏在哪里呢？如果堆栈增长，然后收缩，那么从堆栈中弹出的对象将不会被垃圾收集，即使使用堆栈的程序不再引用它们。这是因为栈保留了这些对象的旧引用。一个过时的引用，是指永远不会被取消的引用。在本例中，元素数组的「活动部分」之外的任何引用都已过时。活动部分由索引小于大小的元素组成。</p><p>垃圾收集语言中的内存泄漏（更确切地说是无意的对象保留）是暗藏的风险。如果无意中保留了对象引用，那么对象不仅被排除在垃圾收集之外，该对象引用的任何对象也被排除在外，依此类推。即使只是无意中保留了一些对象引用，许多许多的对象也可能被阻止被垃圾收集，从而对性能产生潜在的巨大影响。</p><p>解决这类问题的方法很简单：一旦引用过时，就将置空。在我们的 Stack 类中，对某个项的引用一旦从堆栈中弹出就会过时。pop 方法的正确版本如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>pop</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> EmptyStackException();
</span></span><span style=display:flex><span>    Object result <span style=color:#f92672>=</span> elements<span style=color:#f92672>[--</span>size<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    elements<span style=color:#f92672>[</span>size<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// Eliminate obsolete reference</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>用 null 处理过时引用的另一个好处是，如果它们随后被错误地关联引用，程序将立即失败，出现 NullPointerException，而不是悄悄地做错误的事情。尽可能快地检测编程错误总是有益的。</p><p>那么，什么时候应该取消引用呢？Stack 类的哪些方面容易导致内存泄漏？简单地说，它管理自己的内存。存储池包含元素数组的元素（对象引用单元，而不是对象本身）数组的活动部分（如前面所定义的）中的元素被分配，而数组其余部分中的元素是空闲的。垃圾收集器没有办法知道这一点；对于垃圾收集器，元素数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。只要数组元素成为非活动部分的一部分，程序员就可以通过手动清空数组元素，有效地将这个事实传递给垃圾收集器。</p><p>一般来说，一个类管理它自己的内存时，程序员应该警惕内存泄漏。当释放一个元素时，该元素中包含的任何对象引用都应该被置为 null。</p><p><strong>另一个常见的内存泄漏源是缓存。</strong> 一旦将对象引用放入缓存中，就很容易忘记它就在那里，并且在它变得无关紧要之后很久仍将它留在缓存中。有几个解决这个问题的办法。如果你非常幸运地实现了一个缓存，只要缓存外有对其键的引用，那么就将缓存表示为 WeakHashMap；当条目过时后，条目将被自动删除。记住，WeakHashMap 只有在缓存条目的预期生存期由键的外部引用（而不是值）决定时才有用。</p><p>更常见的情况是，缓存条目的有效生存期定义不太好，随着时间的推移，条目的价值会越来越低。在这种情况下，缓存偶尔应该清理那些已经停用的条目。这可以通过后台线程（可能是 <code>ScheduledThreadPoolExecutor</code>）或向缓存添加新条目时顺便完成。LinkedHashMap 类通过其 <code>removeEldestEntry</code> 方法简化了后一种方法。对于更复杂的缓存，你可能需要直接使用 <code>java.lang.ref</code>。</p><p><strong>内存泄漏的第三个常见来源是侦听器和其他回调。</strong> 如果你实现了一个 API，其中客户端注册回调，但不显式取消它们，除非你采取一些行动，否则它们将累积。确保回调被及时地垃圾收集的一种方法是仅存储对它们的弱引用，例如，将它们作为键存储在 WeakHashMap 中。</p><h3 id=如何排除过时对象引用>如何排除过时对象引用</h3><p>以下是一些示例，展示了如何使用 Java 语言中的一些技术来排除过时的对象引用。</p><ol><li>在循环中使用局部变量</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> list.<span style=color:#a6e22e>size</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    String str <span style=color:#f92672>=</span> list.<span style=color:#a6e22e>get</span>(i);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do something with str</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个示例中，我们使用局部变量<code>str</code>来引用列表中的元素，而不是重复地使用<code>list.get(i)</code>。这样，当循环结束时，<code>str</code>的引用将被自动清除，避免了过时的对象引用。</p><ol start=2><li>在使用完对象后及时清除引用</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SomeObject obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SomeObject();
</span></span><span style=display:flex><span><span style=color:#75715e>// do something with obj</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// clear the reference to obj</span>
</span></span></code></pre></div><p>在这个示例中，我们在使用完对象后立即将其引用设置为 null，以便 JVM 可以及时回收它所占用的内存。如果不清除引用，对象将一直存在于内存中，直到 JVM 进行垃圾回收。</p><ol start=3><li>使用弱引用</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>WeakReference<span style=color:#f92672>&lt;</span>SomeObject<span style=color:#f92672>&gt;</span> ref <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WeakReference<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#66d9ef>new</span> SomeObject());
</span></span><span style=display:flex><span>SomeObject obj <span style=color:#f92672>=</span> ref.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// do something with obj</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// clear the reference to obj</span>
</span></span></code></pre></div><p>在这个示例中，我们使用了一个弱引用来引用对象，以便在对象不再被强引用时可以被及时回收。当我们需要使用对象时，可以通过弱引用获取对象的引用，使用完后及时将其引用设置为 null。</p><ol start=4><li>使用 try-with-resources 语句</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>try</span> (InputStream in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileInputStream(<span style=color:#e6db74>&#34;file.txt&#34;</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do something with in</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个示例中，我们使用了 try-with-resources 语句来打开一个文件流，并在使用完后自动关闭它。这样可以确保在不再需要文件流时，它的引用将被清除，避免了过时的对象引用。</p><ol start=5><li>使用软引用</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SoftReference<span style=color:#f92672>&lt;</span>SomeObject<span style=color:#f92672>&gt;</span> ref <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SoftReference<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#66d9ef>new</span> SomeObject());
</span></span><span style=display:flex><span>SomeObject obj <span style=color:#f92672>=</span> ref.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// do something with obj</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// clear the reference to obj</span>
</span></span></code></pre></div><p>在这个示例中，我们使用了一个软引用来引用对象，以便在 JVM 需要回收内存时可以回收对象。软引用在内存不足时通常会被回收，但在内存充足时可以保留对象，避免了过时的对象引用。</p><ol start=6><li>使用虚引用</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ReferenceQueue<span style=color:#f92672>&lt;</span>SomeObject<span style=color:#f92672>&gt;</span> queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReferenceQueue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>PhantomReference<span style=color:#f92672>&lt;</span>SomeObject<span style=color:#f92672>&gt;</span> ref <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PhantomReference<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#66d9ef>new</span> SomeObject(), queue);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// do something</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ref.<span style=color:#a6e22e>clear</span>(); <span style=color:#75715e>// clear the reference to obj</span>
</span></span></code></pre></div><p>在这个示例中，我们使用了一个虚引用来引用对象，以便在 JVM 回收对象之前可以进行一些必要的清理工作。虚引用在 JVM 回收对象时会被添加到一个引用队列中，因此我们可以在对象被回收之前执行必要的清理工作。</p><ol start=7><li>使用对象池</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectPool</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Set<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> objects <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> T <span style=color:#a6e22e>getObject</span>() {
</span></span><span style=display:flex><span>        T obj;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (objects.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            obj <span style=color:#f92672>=</span> createObject();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            obj <span style=color:#f92672>=</span> objects.<span style=color:#a6e22e>iterator</span>().<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>            objects.<span style=color:#a6e22e>remove</span>(obj);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> obj;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>returnObject</span>(T obj) {
</span></span><span style=display:flex><span>        objects.<span style=color:#a6e22e>add</span>(obj);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> T <span style=color:#a6e22e>createObject</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// create a new object</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个示例中，我们使用了一个对象池来管理对象的生命周期。当需要一个对象时，我们从对象池中获取一个对象，而不是每次都创建一个新的对象。当不再需要对象时，我们将其返回到对象池中，以便其他对象可以重复使用。对象池可以避免过时的对象引用，并提高代码的性能和可伸缩性。</p><ol start=8><li>使用弱散列映射</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>SomeObject, Object<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WeakHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SomeObject key <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SomeObject();
</span></span><span style=display:flex><span>Object value <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>map.<span style=color:#a6e22e>put</span>(key, value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// do something</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>key <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// clear the reference to key</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// do something</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// the entry in the map may be removed if key is not strongly referenced elsewhere</span>
</span></span></code></pre></div><p>在这个示例中，我们使用了一个弱散列映射来存储对象引用和相应的值。当对象不再被强引用时，它的引用可能被从映射中删除，从而避免了过时的对象引用。弱散列映射通常用于缓存和事件处理等场景。</p><ol start=9><li>使用缓存</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SomeObjectCache</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> MAX_SIZE <span style=color:#f92672>=</span> 100;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Map<span style=color:#f92672>&lt;</span>String, SomeObject<span style=color:#f92672>&gt;</span> cache <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;</span>String, SomeObject<span style=color:#f92672>&gt;</span>(MAX_SIZE, 0.<span style=color:#a6e22e>75f</span>, <span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>removeEldestEntry</span>(Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>String, SomeObject<span style=color:#f92672>&gt;</span> eldest) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> size() <span style=color:#f92672>&gt;</span> MAX_SIZE;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>static</span> SomeObject <span style=color:#a6e22e>get</span>(String key) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cache.<span style=color:#a6e22e>get</span>(key);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put</span>(String key, SomeObject value) {
</span></span><span style=display:flex><span>        cache.<span style=color:#a6e22e>put</span>(key, value);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个示例中，我们使用了一个缓存来存储对象引用和相应的值。当缓存达到最大大小时，最旧的条目将被自动删除，从而避免了过时的对象引用。缓存通常用于频繁访问的数据和计算结果，可以提高代码的性能和可伸缩性。</p><ol start=10><li>使用对象池框架</li></ol><p>对象池框架是一种用于管理对象生命周期的通用框架，可以避免过时的对象引用和提高代码的性能和可伸缩性。一些流行的对象池框架包括 Apache Commons Pool 和 Google Guava Cache。</p><h2 id=扩展>扩展</h2><h3 id=弱引用软引用和虚引用区别>弱引用、软引用和虚引用区别</h3><p>弱引用、软引用和虚引用是 Java 中三种不同类型的引用，它们之间的区别如下：</p><h4 id=弱引用weakreference>弱引用（WeakReference）</h4><p>弱引用是一种较弱的引用类型，当一个对象只被弱引用所引用时，它在下一次垃圾回收时会被回收。</p><p>弱引用通常用于需要缓存大量对象的应用场景，例如缓存和高速缓存等。在这些场景中，使用弱引用可以避免占用过多的内存，同时又可以快速访问缓存中的对象。</p><p>应该使用弱引用的情况包括：</p><ol><li><p>需要缓存大量对象：使用弱引用可以避免占用过多的内存空间，从而可以缓存更多的对象。</p></li><li><p>不需要快速访问缓存中的对象：由于弱引用只有在下一次垃圾回收时才会被回收，因此可能会导致较长的访问延迟。如果应用程序可以容忍这种情况，可以考虑使用弱引用。</p></li><li><p>需要频繁的垃圾回收：由于弱引用只有在下一次垃圾回收时才会被回收，因此可能会导致频繁的垃圾回收。如果应用程序可以容忍这种情况，可以考虑使用弱引用。</p></li></ol><p>例如，我们可以使用弱引用来实现一个缓存，当内存不足时，JVM 会自动回收弱引用所引用的对象，从而避免内存泄漏和 OOM 错误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>String, WeakReference<span style=color:#f92672>&lt;</span>SomeObject<span style=color:#f92672>&gt;&gt;</span> cache <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> SomeObject <span style=color:#a6e22e>getObject</span>(String key) {
</span></span><span style=display:flex><span>    SomeObject obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    WeakReference<span style=color:#f92672>&lt;</span>SomeObject<span style=color:#f92672>&gt;</span> reference <span style=color:#f92672>=</span> cache.<span style=color:#a6e22e>get</span>(key);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (reference <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        obj <span style=color:#f92672>=</span> reference.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (obj <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        obj <span style=color:#f92672>=</span> createObject();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (obj <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            cache.<span style=color:#a6e22e>put</span>(key, <span style=color:#66d9ef>new</span> WeakReference<span style=color:#f92672>&lt;&gt;</span>(obj));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> obj;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个示例中，我们使用弱引用来缓存对象，当内存不足时，JVM 会自动回收弱引用所引用的对象。这样可以避免占用过多的内存，同时又可以快速访问缓存中的对象。</p><h4 id=软引用softreference>软引用（SoftReference）</h4><p>软引用是一种较强的引用类型，当一个对象只被软引用所引用时，只有在内存不足时才会被回收。</p><p>软引用通常用于需要缓存大量对象的应用场景，例如图片缓存、数据缓存等。在这些场景中，使用软引用可以避免占用过多的内存，同时又可以快速访问缓存中的对象。</p><p>应该使用软引用的情况包括：</p><ol><li><p>需要缓存大量对象：使用软引用可以避免占用过多的内存空间，从而可以缓存更多的对象。</p></li><li><p>需要快速访问缓存中的对象：使用软引用可以快速访问缓存中的对象，避免频繁地加载和计算。</p></li><li><p>可以容忍偶尔的垃圾回收：由于软引用只有在内存不足时才会被回收，因此可能会导致偶尔的垃圾回收。如果应用程序可以容忍这种情况，可以考虑使用软引用。</p></li></ol><p>例如，我们可以使用软引用来实现一个图片缓存，当内存不足时，JVM 会自动回收软引用所引用的对象，从而避免内存泄漏和 OOM 错误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>String, SoftReference<span style=color:#f92672>&lt;</span>Bitmap<span style=color:#f92672>&gt;&gt;</span> imageCache <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Bitmap <span style=color:#a6e22e>loadImage</span>(String url) {
</span></span><span style=display:flex><span>    Bitmap bitmap <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SoftReference<span style=color:#f92672>&lt;</span>Bitmap<span style=color:#f92672>&gt;</span> reference <span style=color:#f92672>=</span> imageCache.<span style=color:#a6e22e>get</span>(url);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (reference <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        bitmap <span style=color:#f92672>=</span> reference.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (bitmap <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        bitmap <span style=color:#f92672>=</span> downloadImage(url);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (bitmap <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            imageCache.<span style=color:#a6e22e>put</span>(url, <span style=color:#66d9ef>new</span> SoftReference<span style=color:#f92672>&lt;&gt;</span>(bitmap));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bitmap;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个示例中，我们使用软引用来缓存图片，当内存不足时，JVM 会自动回收软引用所引用的对象。这样可以避免占用过多的内存，同时又可以快速访问缓存中的图片。</p><h4 id=虚引用phantomreference>虚引用（PhantomReference）</h4><p>虚引用是 Java 中四种引用类型中最弱的一种，它主要用于跟踪对象被垃圾回收的状态。虚引用本身并不会对对象的生命周期产生影响，但可以在对象被垃圾回收时收到一个通知，从而进行一些清理或其他操作。</p><p>虚引用的使用场景比较少，一般用于以下几个方面：</p><ol><li><strong>对象的 finalize()方法：</strong> 虚引用可以用于实现对象的 finalize()方法，当对象被垃圾回收时，虚引用会收到一个通知，从而触发对象的 finalize()方法。</li><li><strong>NIO DirectByteBuffer 对象的释放：</strong> 在使用 NIO 编程时，可能会创建大量的 DirectByteBuffer 对象，这些对象可能会占用大量的内存空间。当这些对象不再使用时，需要手动调用 System.gc()方法触发一次垃圾回收，才能释放这些对象的内存。使用虚引用可以避免手动调用 System.gc()方法，当这些对象被垃圾回收时，虚引用会收到一个通知，从而释放这些对象的内存。</li><li><strong>对象池的管理：</strong> 在一些需要频繁创建和销毁对象的应用场景中，可以使用对象池来提高性能。当对象不再使用时，可以将对象放入虚引用中，当对象被垃圾回收时，虚引用会收到一个通知，从而将对象从对象池中移除。</li></ol><p>需要注意的是，虚引用不适用于缓存或其他需要快速访问对象的应用场景，因为虚引用本身并不保证对象的可用性和可访问性。</p><blockquote><p>因此，软引用和弱引用的主要区别在于它们的强度和垃圾回收的时机。软引用比弱引用更强，只有在内存不足时才会被回收，而弱引用则更弱，只有在下一次垃圾回收时才会被回收。同时，使用软引用可能会导致更少的垃圾回收，但可能会占用更多的内存空间，而使用弱引用可能会导致更频繁的垃圾回收，但可以更快地释放内存空间。</p></blockquote><h3 id=弱引用是否会影响程序的性能>弱引用是否会影响程序的性能？</h3><p><code>弱引用可能会影响程序的性能，因为它们可能会导致频繁的垃圾回收。</code>由于弱引用<code>只有在下一次垃圾回收时才会被回收</code>，因此当使用大量的弱引用时，可能会导致更频繁的垃圾回收，从而降低程序的性能。</p><p>当一个对象只被弱引用所引用时，在下一次垃圾回收时它会被回收。如果应用程序中存在大量的弱引用对象，每次垃圾回收都需要扫描这些对象，从而增加了垃圾回收的时间和开销。</p><p>因此，在使用弱引用时需要注意以下几点：</p><ol><li>不要过度使用弱引用：如果应用程序中存在大量的弱引用对象，可能会导致频繁的垃圾回收，从而影响程序的性能。因此，应该避免过度使用弱引用，尽可能减少弱引用对象的数量。</li><li>注意垃圾回收的时机：弱引用只在下一次垃圾回收时才会被回收，因此可能会导致较长的访问延迟。在使用弱引用时需要注意垃圾回收的时机，如果应用程序需要快速访问缓存中的对象，可能需要使用其他类型的引用。</li><li>检查弱引用是否被回收：当一个对象只被弱引用所引用时，它在下一次垃圾回收时会被回收。在使用弱引用时需要注意检查弱引用对象是否被回收，避免引用无效的对象。</li></ol><h3 id=如何检查弱引用对象是否被回收>如何检查弱引用对象是否被回收？</h3><p>在 Java 中，可以通过获取弱引用对象的 get()方法返回的对象来检查引用对象是否被回收。当一个弱引用所引用的对象被回收后，get()方法返回的对象将为 null。</p><p>例如，以下示例代码演示了如何使用弱引用检查对象是否被回收：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>WeakReference<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> weakRef <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WeakReference<span style=color:#f92672>&lt;&gt;</span>(obj);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 检查对象是否被回收</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (weakRef.<span style=color:#a6e22e>get</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对象未被回收</span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Object is alive&#34;</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对象已被回收</span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Object has been collected&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个示例中，我们创建了一个对象，并使用弱引用来引用它。然后，我们通过检查弱引用对象的 get()方法返回的对象来判断对象是否被回收。</p><p>当对象未被回收时，get()方法返回的对象不为 null，表示对象仍然存活。当对象被回收时，get()方法返回的对象为 null，表示对象已经被回收。</p><p>需要注意的是，由于弱引用只在下一次垃圾回收时才会被回收，因此在使用弱引用检查对象是否被回收时，需要注意垃圾回收的时机。如果应用程序需要立即检查对象是否被回收，可以手动触发一次垃圾回收，例如通过<code>System.gc()</code>方法来触发。</p></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b07%ef%bc%9a%e6%8e%92%e9%99%a4%e8%bf%87%e6%97%b6%e7%9a%84%e5%af%b9%e8%b1%a1%e5%bc%95%e7%94%a8 https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f05%2feliminate-obsolete-object-references%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f05%2feliminate-obsolete-object-references%2f&title=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b07%ef%bc%9a%e6%8e%92%e9%99%a4%e8%bf%87%e6%97%b6%e7%9a%84%e5%af%b9%e8%b1%a1%e5%bc%95%e7%94%a8" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b07%ef%bc%9a%e6%8e%92%e9%99%a4%e8%bf%87%e6%97%b6%e7%9a%84%e5%af%b9%e8%b1%a1%e5%bc%95%e7%94%a8&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f05%2feliminate-obsolete-object-references%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f05%2feliminate-obsolete-object-references%2f&title=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b07%ef%bc%9a%e6%8e%92%e9%99%a4%e8%bf%87%e6%97%b6%e7%9a%84%e5%af%b9%e8%b1%a1%e5%bc%95%e7%94%a8" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f05%2feliminate-obsolete-object-references%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b07%ef%bc%9a%e6%8e%92%e9%99%a4%e8%bf%87%e6%97%b6%e7%9a%84%e5%af%b9%e8%b1%a1%e5%bc%95%e7%94%a8%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f05%2feliminate-obsolete-object-references%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/ rel=next><span class=post-title>《Effective Java 3》笔记4：用私有构造函数使类不可实例化</span></a></div><div class=nav-next><a href=/posts/2023/04/25/weekly_review_16/ rel=prev><span class=post-title>周报-16｜《灌篮高手》电影、《春山如笑》话剧</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2023/12/14/all-things-about-microprofile/>All things about MicroProfile</a></li><li><a href=/posts/2023/11/02/jhipster-intro/>JHipster安装和介绍</a></li><li><a href=/posts/2023/10/26/java-design-patterns-circuit-breaker/>Java设计模式：Circuit Breaker</a></li><li><a href=/posts/2023/10/16/java-design-patterns-chain/>Java设计模式：Chain</a></li><li><a href=/posts/2023/10/13/java-design-patterns-callback/>Java设计模式：Callback</a></li><li><a href=/posts/2023/09/25/java-design-patterns-cahcing/>Java设计模式：Caching</a></li><li><a href=/posts/2023/09/22/java-design-patterns-bytecode/>Java设计模式：Bytecode</a></li><li><a href=/posts/2023/09/05/java-design-patterns-builder/>Java设计模式：Builder</a></li><li><a href=/posts/2023/09/05/java-design-patterns-business-delegate/>Java设计模式：Business Delegate</a></li><li><a href=/posts/2023/08/28/java-design-patterns-bridge/>Java设计模式：Bridge</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link><a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a>
Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a>
<a style=margin-left:20px href=/privacy_policy/ target=_blank rel="noopener noreferrer">Privacy Policy</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>