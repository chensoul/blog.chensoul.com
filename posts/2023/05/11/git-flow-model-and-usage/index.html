<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git Flow分支模型和使用 | ChenSoul</title><meta name=keywords content="git"><meta name=description content="介绍 Git Flow 是由Vincent Driessen在2010年提出的一种Git工作流。在这之前，Git没有一个明确的标准工作流，导致团队在使用Git"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.com/posts/2023/05/11/git-flow-model-and-usage/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.chensoul.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=msvalidate.01 content="8E787EFCDB0CE747FE1A4DA0ABEC66E4"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Git Flow分支模型和使用"><meta property="og:description" content="介绍 Git Flow 是由Vincent Driessen在2010年提出的一种Git工作流。在这之前，Git没有一个明确的标准工作流，导致团队在使用Git"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.com/posts/2023/05/11/git-flow-model-and-usage/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-11T14:00:00+08:00"><meta property="article:modified_time" content="2023-05-11T14:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git Flow分支模型和使用"><meta name=twitter:description content="介绍 Git Flow 是由Vincent Driessen在2010年提出的一种Git工作流。在这之前，Git没有一个明确的标准工作流，导致团队在使用Git"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.com/posts/"},{"@type":"ListItem","position":2,"name":"Git Flow分支模型和使用","item":"https://blog.chensoul.com/posts/2023/05/11/git-flow-model-and-usage/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git Flow分支模型和使用","name":"Git Flow分支模型和使用","description":"介绍 Git Flow 是由Vincent Driessen在2010年提出的一种Git工作流。在这之前，Git没有一个明确的标准工作流，导致团队在使用Git","keywords":["git"],"articleBody":"介绍 Git Flow 是由Vincent Driessen在2010年提出的一种Git工作流。在这之前，Git没有一个明确的标准工作流，导致团队在使用Git时往往会遇到一些问题，如分支管理、版本控制等。为了解决这些问题，Vincent Driessen提出了Git Flow分支模型，成为了Git在实际应用中的一种标准工作流。\n随着时间的推移，Git Flow也在不断发展和完善。在2011年，Atlassian发布了SourceTree，这是一款图形化的Git客户端，支持Git Flow分支模型。在2013年，Git Flow的一些开发者发布了Git Flow AVH Edition，这是Git Flow的一个增强版本，提供了更多的功能和选项。此外，Git Flow还得到了其他开源工具和平台的支持，如GitHub、GitLab等。\nGit Flow 分支模型 Git Flow分支模型定义了一种标准的Git分支模型，它将代码分为两个长期分支（master和develop）和三个短期分支（feature、release和hotfix），使得团队可以更好地管理代码的版本和发布。\n以下是Git Flow分支模型的详细介绍：\nmaster分支 master分支是代码库的主分支，它包含了所有已发布的代码和版本。所有代码都应该在该分支上进行测试和验证，以确保代码的质量和稳定性。master分支只能通过合并release或hotfix分支来更新。 develop分支 develop分支是代码库的开发分支，它包含了所有开发中的代码和功能。所有新的代码都应该在该分支上进行开发和测试，以确保代码的可靠性和稳定性。develop分支只能通过合并feature分支来更新。 feature分支 feature分支是为开发新的功能或修复bug而创建的临时分支。每个feature分支都是从develop分支分离出来的，开发完成后会合并回develop分支。feature分支的命名应该清晰明确，以反映该分支所涉及的功能或问题。 release分支 release分支是为发布新版本而创建的临时分支。每个release分支都是从develop分支分离出来的，发布完成后会合并回develop分支和master分支。在release分支上可以进行一些小的修复和调整，以确保发布的代码的质量和稳定性。 hotfix分支 hotfix分支是为快速修复生产环境中的问题而创建的临时分支。每个hotfix分支都是从master分支分离出来的，修复完成后会合并回develop分支和master分支。hotfix分支的优先级比其他分支更高，因为它们需要尽快修复生产环境中的问题。 根据上面的理论，我们来实际操作一遍。首先，是 develop 分支创建一个 feature 分支。\n$ git checkout -b feature-test develop Switched to a new branch \"feature-test\" 将 feature 分支的修改合并到 develop 分支，然后删除 feature 分支：\n$ git checkout develop Switched to branch 'develop' $ git merge --no-ff feature-test Updating ea1b82a..05e9557 (Summary of changes) $ git branch -d feature-test Deleted branch feature-test (was 05e9557). $ git push origin develop 合并分支时，添加--no-ff 参数和不添加的区别：\n从 develop 分支创建一个 release 分支，并将版本号改为 1.2 ：\n$ git checkout -b release-1.2 develop Switched to a new branch \"release-1.2\" $ ./bump-version.sh 1.2 Files modified successfully, version bumped to 1.2. $ git commit -a -m \"Bumped version number to 1.2\" [release-1.2 74d9424] Bumped version number to 1.2 1 files changed, 1 insertions(+), 1 deletions(-) release 分支完成开发之后，将 release 分支合并到 master 分支，并创建一个标签：\n$ git checkout master Switched to branch 'master' $ git merge --no-ff release-1.2 Merge made by recursive. (Summary of changes) $ git tag -a 1.2 将 release 分支合并到 develop 分支：\n$ git checkout develop Switched to branch 'develop' $ git merge --no-ff release-1.2 Merge made by recursive. (Summary of changes) 最后删除 release 分支：\n$ git branch -d release-1.2 Deleted branch release-1.2 (was ff452fe). 对于 hoftfix 分支，操作步骤和 release 分支类似，故不在赘述。\ngit-flow 工具 git-flow 工具可以简化上面的操作步骤，关于 git-flow的介绍可以参考文章：Using git-flow to automate your git branching workflow。\nmacos 上安装 git-flow：\nbrew install git-flow git-flow 首先需要初始化，如果不存在 develop 分支，则会新建一个 develop 分支：\ngit flow init No branches exist yet. Base branches must be created now. Branch name for production releases: [master] Branch name for \"next release\" development: [develop] How to name your supporting branch prefixes? Feature branches? [feature-] Release branches? [release-] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] feature 分支 开发一个新功能，创建一个新分支 foo\n$ git flow feature start foo 等价于\n#切换到develop分支,确保新的 feature 分支是基于最新的 develop 分支创建的。 $ git checkout -b feature-foo develop 取消正在进行中的功能分支，并且会将分支删除\n$ git flow feature delete foo 等价于\n$ git branch -D feature-foo foo 功能自测通过后，合并到 develop\n$ git flow feature finish foo 等价于\n//切换到 develop 分支 $ git checkout develop //将 feature-foo 分支中的更改合并到 develop 分支。 --no-ff 参数将保留 foo 分支的commit记录。 $ git merge --no-ff feature-foo //删除已完成的分支 $ git branch -d feature-foo release 分支 当所有新的功能和必要的修复已经被彻底的测试过了，那就开始生成一个新的 release , 在此之后不能添加新功能，只有错误修复、文档生成和其他面向发布的任务应该在该分支中进行。\n# 1.0.0 是版本号 $ git flow release start 1.0.0 等价于\n# 从 develop 分支 创建release分支 $ git checkout -b release-1.0.0 develop 取消正在进行中的发布分支，并且会将分支删除。\n$ git flow release delete 1.0.0 等价于\ngit branch -D release-1.0.0 添加完发布文档之后，完成 release\n$ git flow release finish 1.0.0 等价于\n#切换到 develop 分支。 $ git checkout develop #将 release-1.0.0 分支合并到 develop 分支，--no-ff 选项以保留 feature 分支的 commit 记录 $ git merge --no-ff release-1.0.0 #创建一个名为 1.0.0 的标签 $ git tag -a 1.0.0 -m \"Release 1.0.0\" #切换到 master 分支。 $ git checkout master #将 release-1.0.0 分支合并到 master 分支，--no-ff 选项以保留 feature 分支的 commit 记录 $ git merge --no-ff release-1.0.0 #删除 release-1.0.0 分支。 $ git branch -d release-1.0.0 Hotfixes 分支 线上发生问题的时候，先回滚到之前的稳定版本，稳定局势 然后创建热修复分支开始改 BUG\n$ git flow hotfix start 1.0.1 等价于\n#从master分支 创建一个hotfix/1.0.1分支 $ git checkout -b hotfix/1.0.1 foo master 紧急修复完毕\n$ git flow hotfix finish 1.0.1 等价于\n#切换 master 分支 $ git checkout master #合并热修复分支到master,--no-ff 选项以保留 feature 分支的 commit 记录 $ git merge --no-ff hotfix/ohno #创建一个名为 1.0.1 的标签 $ git tag 1.0.1 #切换到 develop 分支 $ git checkout develop #合并热修复分支到 develop ,--no-ff 选项以保留 feature 分支的 commit 记录 $ git merge --no-ff hotfix/1.0.1 #删除热修复分支 $ git branch -d hotfix/1.0.1 git-flow (AVH Edition) Git-flow (AVH Edition)是Git Flow的一个增强版本，由一些Git Flow的开发者开发和维护。Git-flow (AVH Edition)在保留Git Flow基本思想的前提下，增加了一些新的功能和选项，使得Git Flow更加灵活和适用于不同的团队和项目。\nGit-flow (AVH Edition)的主要增强功能包括：\n支持git-flow init命令，可以在一个新的Git仓库中快速初始化Git Flow。 支持git flow feature pull命令，可以拉取其他团队成员的feature分支。 支持git flow feature publish命令，可以将feature分支发布到远程仓库。 支持git flow hotfix finish命令，可以在修复生产环境问题时自动合并到develop分支和master分支并发布新版本。 支持git flow support分支，可以为旧版本提供长期支持。 允许使用Hooks and Filters来扩展和自定义Git Flow的行为。 除了以上功能之外，Git-flow (AVH Edition)还提供了更多的选项和配置，使得团队可以根据不同的需求和情况来自定义Git Flow的分支模型和工作流程。\n初始化 使用下面命令初始化 git fow，-d 是可选参数，表示使用默认参数：\ngit flow init [-d] 创建 feature/release/hotfix/support 分支 查看、开始、完成、删除 feature 分支：\ngit flow feature # 参数必须是分支名称，缺失时，默认为 develop 分支 git flow feature start [] git flow feature finish git flow feature delete 发布或者跟踪 feature 分支：\n#如果当前在 feature/name 分支，则可以省略 参数 git flow feature publish git flow feature track 当 feature 分支发布之后，其他人可以拉取该分支：\ngit pull git checkout feature/ 类似地，查看、开始、完成、删除 release 分支：\ngit flow release git flow release start [] git flow release finish git flow release delete 类似地，查看、开始、完成、删除 hotfix 分支：\ngit flow hotfix git flow hotfix start [] git flow hotfix finish git flow hotfix delete 查看、开始 support 分支：\ngit flow support git flow support start Hooks 和 Filters Git-flow (AVH Edition)允许使用Hooks and Filters来扩展和自定义Git Flow的行为。Hooks和Filters是Git Flow中的两个关键概念，它们可以在Git Flow的不同阶段执行自定义脚本或命令，从而实现Git Flow的高度定制化。\nHooks是一些脚本或命令，它们会在Git Flow的不同阶段被调用。Git Flow (AVH Edition)支持以下Hooks：\ngit-flow-init: 该Hook会在git-flow init命令执行时被调用。 git-flow-feature-start: 该Hook会在创建新的feature分支时被调用。 git-flow-feature-finish: 该Hook会在完成feature分支时被调用。 git-flow-release-start: 该Hook会在创建新的release分支时被调用。 git-flow-release-finish: 该Hook会在完成release分支时被调用。 git-flow-hotfix-start: 该Hook会在创建新的hotfix分支时被调用。 git-flow-hotfix-finish: 该Hook会在完成hotfix分支时被调用。 Filters是一些命令或参数，它们会在Git Flow的不同阶段被过滤或修改。Git Flow (AVH Edition)支持以下Filters：\ngit-flow-feature-start-message: 可以用于修改feature分支创建时的提交信息。 git-flow-feature-finish-message: 可以用于修改feature分支完成时的提交信息。 git-flow-release-start-message: 可以用于修改release分支创建时的提交信息。 git-flow-release-finish-message: 可以用于修改release分支完成时的提交信息。 git-flow-hotfix-start-message: 可以用于修改hotfix分支创建时的提交信息。 git-flow-hotfix-finish-message: 可以用于修改hotfix分支完成时的提交信息。 下面是一些使用Hooks和Filters的例子：\n使用git-flow-init Hook 如果需要在执行git-flow init命令时执行一些自定义脚本，可以使用git-flow-init Hook。假设我们想在git-flow init命令执行时输出一些信息，可以在.git/hooks/git-flow-init文件中添加以下内容：\n#!/bin/bash echo \"Executing git-flow-init Hook\" 使用git-flow-feature-start Hook 如果需要在创建新的feature分支时执行一些自定义脚本，可以使用git-flow-feature-start Hook。假设我们想在创建新的feature分支时自动为该分支设置一些默认值，可以在.git/hooks/git-flow-feature-start文件中添加以下内容：\n#!/bin/bash # Set default values for feature branch git config branch.$GIT_BRANCH_NAME.some_config_value \"default_value\" 使用git-flow-feature-finish-message Filter 如果需要修改feature分支完成时的提交信息，可以使用git-flow-feature-finish-message Filter。假设我们想在feature分支完成时强制要求填写提交信息，可以在.git/config文件中添加以下内容：\n[gitflow \"feature\"] finishmessage = Please provide a meaningful commit message for the feature branch 使用 git-flow-hotfix-start Hook 如果需要在创建新的hotfix分支时执行一些自定义脚本，可以使用git-flow-hotfix-start Hook。假设我们想在创建新的hotfix分支时自动为该分支设置一些默认值，可以在.git/hooks/git-flow-hotfix-start文件中添加以下内容：\n#!/bin/bash # Set default values for hotfix branch git config branch.$GIT_BRANCH_NAME.some_config_value \"default_value\" 使用 git-flow-hotfix-finish Hook 在.git/hooks/git-flow-hotfix-finish文件中添加以下内容：\n#!/bin/bash # Update version number in package.json VERSION=$(cat package.json | jq -r '.version') NEW_VERSION=$(echo $VERSION | awk -F. '{$NF++;print}' | sed 's/ /./g') sed -i '' \"s/\\\"version\\\": \\\"$VERSION\\\"/\\\"version\\\": \\\"$NEW_VERSION\\\"/g\" package.json 该脚本用于修改前端项目中的版本号。\nGitHub Flow 模型 GitHub Flow是一种基于GitHub的分支模型和代码开发工作流程，它是一个简单而灵活的模型，在敏捷开发和持续交付方面具有很高的效率。相比于Git Flow，GitHub Flow更加适合团队和开发者进行快速迭代和快速上线。\nGitHub Flow的分支模型非常简单：只有一个主分支（通常是master分支）和多个特性分支。主分支始终处于稳定状态并用于生产环境。每个特性分支用于开发新功能或修复bug，并在开发人员完成相应的开发和测试工作后合并到主分支中。\nGitHub Flow 遵循以下 6 条原则：\nmaster 分支永远是随时可部署发布的 需求新增基于 master 分支，并创建一个语义化分支 定期推送本地分支到远端 合并到 master 需要提 PR PR 一旦经过 code review 无误后即可合并到 master master 一旦接收到合并请求，即可立即部署发布 GitHub Flow的代码开发工作流程如下：\n创建特性分支：从主分支中创建一个新的特性分支，用于开发新功能或修复bug。 开发和测试：在特性分支上进行开发和测试，确保代码符合质量标准，并通过自动化测试。 发起合并请求：将特性分支合并到主分支中，发起一个合并请求（pull request），并邀请其他开发者进行代码审查和讨论。 代码审查：其他开发者对代码进行审查和讨论，提出意见和建议，并确保代码符合质量标准和最佳实践。 合并代码：在经过审查和讨论后，将特性分支合并到主分支中，并将代码部署到生产环境。 部署代码：在合并到主分支后，使用自动化部署工具将代码部署到生产环境。 Gitlab flow 模型 GitLab Flow是一个基于GitLab的分支模型和开发工作流程，旨在支持敏捷开发和持续交付。\nGitLab 在 2014 年提出 11 条最佳实践，更多请点击这里，其相对 GitHub 增加了环境分支，且代码必须由上游（master）向下游（staging）发展，并且针对持续发布和版本发布都提出了相应的准则，下面是其大致流程图：\nGitLab Flow的主要特点包括：\n简单的分支模型：GitLab Flow使用一个简单的分支模型，包括一个主分支（通常命名为“master”或“production”）和一个开发分支（通常命名为“develop”或“staging”）。特性分支从开发分支创建，并在特性或错误修复完成并通过测试后合并回开发分支中。 持续集成和交付：GitLab Flow强调持续集成和交付（CI/CD），这意味着每次对代码的更改都会自动构建、测试和部署到测试环境或生产环境（如果测试通过）。 代码审查：GitLab Flow鼓励进行代码审查，这意味着每次对代码的更改都会由至少一个其他开发人员进行审查，以确保其符合质量标准并不会引入任何安全漏洞。 合并请求：GitLab Flow使用合并请求来管理将代码更改合并到主分支的过程。合并请求允许开发人员在将更改合并到主分支之前对其进行审查和讨论。 环境管理：GitLab Flow提供高级的环境管理功能，允许团队创建和管理不同的开发、测试、暂存和生产环境。 GitLab Flow提供了高级的环境管理功能，可以帮助团队更好地管理不同的开发、测试、暂存和生产环境。以下是使用GitLab Flow进行环境管理的一些方法：\n创建不同的环境分支：在GitLab Flow中，可以为不同的环境创建分支。例如，可以创建一个名为“develop”的开发分支，一个名为“staging”的暂存分支，和一个名为“production”的生产分支。这些分支可以帮助团队更好地管理不同环境的代码，确保每个环境都有自己的代码版本。 配置环境变量：在GitLab中，可以为每个环境设置不同的环境变量。这些环境变量可以用于配置不同环境中的应用程序和服务，例如数据库连接字符串、API密钥等。通过设置正确的环境变量，可以确保应用程序在不同环境中正确运行。 自动化部署和测试：GitLab Flow支持自动化部署和测试，可以帮助团队更快地部署代码到不同环境中。可以使用GitLab的CI/CD管道来自动化测试和部署过程，并将代码推送到正确的环境分支中。 环境监控和报告：GitLab Flow还支持环境监控和报告功能，可以帮助团队更好地了解不同环境的运行状况和性能。可以使用GitLab的监控和报告工具来监视不同环境的性能指标、错误率等，并及时发现和解决问题。 GitLab Flow的分支模型如下：\n主分支：主分支始终处于稳定状态，并用于生产环境。在GitLab Flow中，主分支通常是master分支或production分支。 特性分支：特性分支用于开发新功能或修复bug，并从主分支中创建。在GitLab Flow中，特性分支通常以feature/或fix/为前缀。 集成分支：集成分支用于将特性分支集成到主分支中，并进行测试和部署。在GitLab Flow中，集成分支通常是develop分支或staging分支。 发布分支：发布分支用于将特性分支和集成分支的代码发布到生产环境中。在GitLab Flow中，发布分支通常是release/为前缀的分支。 GitLab Flow的开发工作流程如下：\n创建特性分支：从主分支中创建一个新的特性分支，用于开发新功能或修复bug。 开发和测试：在特性分支上进行开发和测试，确保代码符合质量标准，并通过自动化测试。 合并到集成分支：将特性分支合并到集成分支中，并进行集成测试和自动化部署。 发布到生产环境：将集成分支的代码发布到生产环境中，并进行最终测试和部署。 合并到主分支：在发布到生产环境后，将集成分支合并到主分支中，并将代码部署到生产环境。 GitLab Flow强调CI/CD集成和测试自动化，以确保代码质量和快速迭代。它还支持自动化部署和环境管理，以帮助开发人员更轻松地管理不同环境和部署代码。GitLab Flow是一个灵活和强大的开发工作流程，适用于各种类型的项目和团队。\nGitLab Flow、Git Flow和GitHub Flow GitLab Flow、Git Flow和GitHub Flow都是三种常见的基于Git的工作流程。下面是GitLab Flow与其他工作流程的主要区别：\nGitLab Flow与Git Flow的比较： GitLab Flow比Git Flow更简单和更灵活。Git Flow有一个更复杂的分支模型，包含多个长期存在的分支，而GitLab Flow只使用几个主要分支和特性分支。\nGitLab Flow强调持续集成和持续部署（CI/CD），鼓励频繁合并到主要分支。Git Flow更注重版本控制和发布管理。\nGitLab Flow与GitLab内置的CI/CD管道更紧密地集成在一起，更容易自动化开发工作流程。\nGitLab Flow与GitHub Flow的比较： GitLab Flow和GitHub Flow有许多相似之处，例如它们都以GitHub或GitLab作为中央仓库，使用特性分支进行开发。 GitLab Flow强调CI/CD集成和测试自动化，而GitHub Flow更注重代码审查和协作。 GitLab Flow还提供更高级的环境管理、部署和监控功能，更适合于大型、复杂的项目。 总体而言，GitLab Flow比Git Flow更简单和更灵活，强调CI/CD集成和自动化。与GitHub Flow相比，GitLab Flow提供更高级的环境管理和部署功能，更适合于大型、复杂的项目。选择哪种工作流程最终取决于项目和开发团队的具体需求和要求。\n其他 flow TrunkBased OneFlow AoneFlow 总结 目前公司代码部署在自建的 gitlab 上面，对于公司的项目，个人倾向于使用 git-flow 分支模型，并且使用 git-flow (AVH Edition) 来简化操作。\n目前，我参与的大多数项目都是 java 项目并且使用 maven 进行构建。\n在Maven项目中，可以使用Maven版本控制器来区分release版本和snapshot版本。\nRelease版本\n对于Git Flow中的release分支，通常用于为生产环境准备代码。\n在Maven项目中，可以使用Maven Release插件来自动化创建和发布release版本。\nmvn release:prepare mvn release:perform 使用这些命令，Maven Release插件会自动更新项目版本号、创建tag、构建release版本，并发布到Maven仓库中。发布的版本号不包含 -SNAPSHOT 后缀。\n或者，使用 mvn versions：\nmvn versions:set -DnewVersion=1.0.0-SNAPSHOT mvn versions:commit Snapshot版本\n对于Git Flow中的feature和develop分支，通常用于开发和测试新功能或bug修复，这些分支使用snapshot版本。在Maven中，snapshot版本的版本号包含 -SNAPSHOT 后缀，表示当前版本是正在开发的版本。\n对于这些项目，git-flow 操作步骤如下：\n1、初始化\ngit flow init -d 2、开始 feature 分支\ngit flow feature start test 设置maven项目中版本为 snapshot版本。\nmvn versions:set -DnewVersion=1.0.0-SNAPSHOT mvn versions:commit 对于maven多模块项目，如果使用 revision 来统一定义版本号，则使用下面命令：\nmvn versions:set-property -Dproperty=revision -DnewVersion=1.0.0-SNAPSHOT 3、本地在 feature 分支上完成一些开发之后，完成 feature 分支\ngit flow feature finish test 4、开始 release 分支\ngit flow release start 1.0.0 5、本地在 release 分支上完成一些开发之后，完成 feature 分支\n设置maven项目中版本为 release 版本。\nmvn versions:set -DnewVersion=1.0.0 mvn versions:commit 对于maven多模块项目，如果使用 revision 来统一定义版本号，则使用下面命令：\nmvn versions:set-property -Dproperty=revision -DnewVersion=1.0.0 另外，对于多模块项目，需要在每个模块执行下面命令将 jar 推送到 maven 中央仓库：\nmvn install -DskipTests 然后完成分支：\ngit flow release finish 1.0.0 以上。\n","wordCount":"7902","inLanguage":"en","datePublished":"2023-05-11T14:00:00+08:00","dateModified":"2023-05-11T14:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.com/posts/2023/05/11/git-flow-model-and-usage/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.com/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.com/categories/ideas title=周报><span>周报</span></a></li><li><a href=https://blog.chensoul.com/categories/notes title=编程><span>编程</span></a></li><li><a href=https://blog.chensoul.com/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.com/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Git Flow分支模型和使用</h1><div class=post-meta><span title='2023-05-11 14:00:00 +0800 +0800'>2023-05-11</span>&nbsp;·&nbsp;chensoul</div></header><div class=post-content><h2 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h2><p><a href=https://nvie.com/posts/a-successful-git-branching-model/>Git Flow</a> 是由Vincent Driessen在2010年提出的一种Git工作流。在这之前，Git没有一个明确的标准工作流，导致团队在使用Git时往往会遇到一些问题，如分支管理、版本控制等。为了解决这些问题，Vincent Driessen提出了Git Flow分支模型，成为了Git在实际应用中的一种标准工作流。</p><p>随着时间的推移，Git Flow也在不断发展和完善。在2011年，Atlassian发布了SourceTree，这是一款图形化的Git客户端，支持Git Flow分支模型。在2013年，Git Flow的一些开发者发布了Git Flow AVH Edition，这是Git Flow的一个增强版本，提供了更多的功能和选项。此外，Git Flow还得到了其他开源工具和平台的支持，如GitHub、GitLab等。</p><h2 id=git-flow-分支模型>Git Flow 分支模型<a hidden class=anchor aria-hidden=true href=#git-flow-分支模型>#</a></h2><p>Git Flow分支模型定义了一种标准的Git分支模型，它将代码分为两个长期分支（master和develop）和三个短期分支（feature、release和hotfix），使得团队可以更好地管理代码的版本和发布。</p><p>以下是Git Flow分支模型的详细介绍：</p><ol><li>master分支
master分支是代码库的主分支，它包含了所有已发布的代码和版本。所有代码都应该在该分支上进行测试和验证，以确保代码的质量和稳定性。<code>master分支只能通过合并release或hotfix分支来更新</code>。</li><li>develop分支
develop分支是代码库的开发分支，它包含了所有开发中的代码和功能。所有新的代码都应该在该分支上进行开发和测试，以确保代码的可靠性和稳定性。<code>develop分支只能通过合并feature分支来更新</code>。</li><li>feature分支
feature分支是为开发新的功能或修复bug而创建的临时分支。<code>每个feature分支都是从develop分支分离出来的，开发完成后会合并回develop分支</code>。feature分支的命名应该清晰明确，以反映该分支所涉及的功能或问题。</li><li>release分支
release分支是为发布新版本而创建的临时分支。<code>每个release分支都是从develop分支分离出来的，发布完成后会合并回develop分支和master分支</code>。在release分支上可以进行一些小的修复和调整，以确保发布的代码的质量和稳定性。</li><li>hotfix分支
hotfix分支是为快速修复生产环境中的问题而创建的临时分支。每个hotfix分支都是从master分支分离出来的，修复完成后会合并回develop分支和master分支。<code>hotfix分支的优先级比其他分支更高，因为它们需要尽快修复生产环境中的问题。</code></li></ol><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/git-model@2x.png alt=img></p><p>根据上面的理论，我们来实际操作一遍。首先，是 develop 分支创建一个 feature 分支。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout -b feature-test develop
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s2>&#34;feature-test&#34;</span>
</span></span></code></pre></div><p>将 feature 分支的修改合并到 develop 分支，然后删除 feature 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;develop&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git merge --no-ff feature-test
</span></span><span class=line><span class=cl>Updating ea1b82a..05e9557
</span></span><span class=line><span class=cl><span class=o>(</span>Summary of changes<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git branch -d feature-test
</span></span><span class=line><span class=cl>Deleted branch feature-test <span class=o>(</span>was 05e9557<span class=o>)</span>.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git push origin develop
</span></span></code></pre></div><p>合并分支时，添加<code>--no-ff</code> 参数和不添加的区别：</p><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/merge-without-ff@2x.png alt=img></p><p>从 develop 分支创建一个 release 分支，并将版本号改为 1.2 ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout -b release-1.2 develop
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s2>&#34;release-1.2&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./bump-version.sh 1.2
</span></span><span class=line><span class=cl>Files modified successfully, version bumped to 1.2.
</span></span><span class=line><span class=cl>$ git commit -a -m <span class=s2>&#34;Bumped version number to 1.2&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>release-1.2 74d9424<span class=o>]</span> Bumped version number to 1.2
</span></span><span class=line><span class=cl><span class=m>1</span> files changed, <span class=m>1</span> insertions<span class=o>(</span>+<span class=o>)</span>, <span class=m>1</span> deletions<span class=o>(</span>-<span class=o>)</span>
</span></span></code></pre></div><p>release 分支完成开发之后，将 release 分支合并到 master 分支，并创建一个标签：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;master&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git merge --no-ff release-1.2
</span></span><span class=line><span class=cl>Merge made by recursive.
</span></span><span class=line><span class=cl><span class=o>(</span>Summary of changes<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git tag -a 1.2
</span></span></code></pre></div><p>将 release 分支合并到 develop 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;develop&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git merge --no-ff release-1.2
</span></span><span class=line><span class=cl>Merge made by recursive.
</span></span><span class=line><span class=cl><span class=o>(</span>Summary of changes<span class=o>)</span>
</span></span></code></pre></div><p>最后删除 release 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch -d release-1.2
</span></span><span class=line><span class=cl>Deleted branch release-1.2 <span class=o>(</span>was ff452fe<span class=o>)</span>.
</span></span></code></pre></div><p>对于 hoftfix 分支，操作步骤和 release 分支类似，故不在赘述。</p><h2 id=git-flow-工具>git-flow 工具<a hidden class=anchor aria-hidden=true href=#git-flow-工具>#</a></h2><p>git-flow 工具可以简化上面的操作步骤，关于 git-flow的介绍可以参考文章：<a href=https://jeffkreeftmeijer.com/git-flow/>Using git-flow to automate your git branching workflow</a>。</p><p>macos 上安装 git-flow：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>brew install git-flow
</span></span></code></pre></div><p>git-flow 首先需要初始化，如果不存在 develop 分支，则会新建一个 develop 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow init
</span></span><span class=line><span class=cl>No branches exist yet. Base branches must be created now.
</span></span><span class=line><span class=cl>Branch name <span class=k>for</span> production releases: <span class=o>[</span>master<span class=o>]</span>
</span></span><span class=line><span class=cl>Branch name <span class=k>for</span> <span class=s2>&#34;next release&#34;</span> development: <span class=o>[</span>develop<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>How to name your supporting branch prefixes?
</span></span><span class=line><span class=cl>Feature branches? <span class=o>[</span>feature-<span class=o>]</span>
</span></span><span class=line><span class=cl>Release branches? <span class=o>[</span>release-<span class=o>]</span>
</span></span><span class=line><span class=cl>Hotfix branches? <span class=o>[</span>hotfix/<span class=o>]</span>
</span></span><span class=line><span class=cl>Support branches? <span class=o>[</span>support/<span class=o>]</span>
</span></span><span class=line><span class=cl>Version tag prefix? <span class=o>[]</span>
</span></span></code></pre></div><h3 id=feature-分支>feature 分支<a hidden class=anchor aria-hidden=true href=#feature-分支>#</a></h3><p>开发一个新功能，创建一个新分支 foo</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=err>$</span> <span class=nx>git</span> <span class=nx>flow</span> <span class=nx>feature</span> <span class=nx>start</span> <span class=nx>foo</span>
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#切换到develop分支,确保新的 feature 分支是基于最新的 develop 分支创建的。</span>
</span></span><span class=line><span class=cl>$ git checkout -b feature-foo develop
</span></span></code></pre></div><p>取消正在进行中的功能分支，并且会将分支删除</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow feature delete foo
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch -D feature-foo
</span></span></code></pre></div><p>foo 功能自测通过后，合并到 develop</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow feature finish foo
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>//切换到 develop 分支
</span></span><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl>//将 feature-foo 分支中的更改合并到 develop 分支。 --no-ff 参数将保留 foo 分支的commit记录。
</span></span><span class=line><span class=cl>$ git merge --no-ff feature-foo
</span></span><span class=line><span class=cl>//删除已完成的分支
</span></span><span class=line><span class=cl>$ git branch -d feature-foo
</span></span></code></pre></div><h3 id=release-分支>release 分支<a hidden class=anchor aria-hidden=true href=#release-分支>#</a></h3><p>当所有新的功能和必要的修复已经被彻底的测试过了，那就开始生成一个新的 release , 在此之后不能添加新功能，只有错误修复、文档生成和其他面向发布的任务应该在该分支中进行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 1.0.0 是版本号</span>
</span></span><span class=line><span class=cl>$ git flow release start 1.0.0
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 从 develop 分支 创建release分支</span>
</span></span><span class=line><span class=cl>$ git checkout -b release-1.0.0 develop
</span></span></code></pre></div><p>取消正在进行中的发布分支，并且会将分支删除。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow release delete 1.0.0
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git branch -D release-1.0.0
</span></span></code></pre></div><p>添加完发布文档之后，完成 release</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow release finish 1.0.0
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#切换到 develop 分支。</span>
</span></span><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl><span class=c1>#将 release-1.0.0 分支合并到 develop 分支，--no-ff 选项以保留 feature 分支的 commit 记录</span>
</span></span><span class=line><span class=cl>$ git merge --no-ff release-1.0.0
</span></span><span class=line><span class=cl><span class=c1>#创建一个名为 1.0.0 的标签</span>
</span></span><span class=line><span class=cl>$ git tag -a 1.0.0 -m <span class=s2>&#34;Release 1.0.0&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#切换到 master 分支。</span>
</span></span><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl><span class=c1>#将 release-1.0.0 分支合并到 master 分支，--no-ff 选项以保留 feature 分支的 commit 记录</span>
</span></span><span class=line><span class=cl>$ git merge --no-ff release-1.0.0
</span></span><span class=line><span class=cl><span class=c1>#删除 release-1.0.0 分支。</span>
</span></span><span class=line><span class=cl>$ git branch -d release-1.0.0
</span></span></code></pre></div><h3 id=hotfixes-分支>Hotfixes 分支<a hidden class=anchor aria-hidden=true href=#hotfixes-分支>#</a></h3><p>线上发生问题的时候，先回滚到之前的稳定版本，稳定局势
然后创建热修复分支开始改 BUG</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow hotfix start 1.0.1
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#从master分支 创建一个hotfix/1.0.1分支</span>
</span></span><span class=line><span class=cl>$ git checkout -b hotfix/1.0.1 foo master
</span></span></code></pre></div><p>紧急修复完毕</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow hotfix finish 1.0.1
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#切换 master 分支</span>
</span></span><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl><span class=c1>#合并热修复分支到master,--no-ff 选项以保留 feature 分支的 commit 记录</span>
</span></span><span class=line><span class=cl>$ git merge --no-ff hotfix/ohno
</span></span><span class=line><span class=cl><span class=c1>#创建一个名为 1.0.1 的标签</span>
</span></span><span class=line><span class=cl>$ git tag 1.0.1
</span></span><span class=line><span class=cl><span class=c1>#切换到 develop 分支</span>
</span></span><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl><span class=c1>#合并热修复分支到 develop ,--no-ff 选项以保留 feature 分支的 commit 记录</span>
</span></span><span class=line><span class=cl>$ git merge --no-ff hotfix/1.0.1
</span></span><span class=line><span class=cl><span class=c1>#删除热修复分支</span>
</span></span><span class=line><span class=cl>$ git branch -d hotfix/1.0.1
</span></span></code></pre></div><h2 id=git-flow-avh-edition>git-flow (AVH Edition)<a hidden class=anchor aria-hidden=true href=#git-flow-avh-edition>#</a></h2><p>Git-flow (AVH Edition)是Git Flow的一个增强版本，由一些Git Flow的开发者开发和维护。Git-flow (AVH Edition)在保留Git Flow基本思想的前提下，增加了一些新的功能和选项，使得Git Flow更加灵活和适用于不同的团队和项目。</p><p>Git-flow (AVH Edition)的主要增强功能包括：</p><ol><li>支持git-flow init命令，可以在一个新的Git仓库中快速初始化Git Flow。</li><li>支持git flow feature pull命令，可以拉取其他团队成员的feature分支。</li><li>支持git flow feature publish命令，可以将feature分支发布到远程仓库。</li><li>支持git flow hotfix finish命令，可以在修复生产环境问题时自动合并到develop分支和master分支并发布新版本。</li><li>支持git flow support分支，可以为旧版本提供长期支持。</li><li>允许使用Hooks and Filters来扩展和自定义Git Flow的行为。</li></ol><p>除了以上功能之外，Git-flow (AVH Edition)还提供了更多的选项和配置，使得团队可以根据不同的需求和情况来自定义Git Flow的分支模型和工作流程。</p><h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3><p>使用下面命令初始化 git fow，<code>-d</code> 是可选参数，表示使用默认参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow init <span class=o>[</span>-d<span class=o>]</span>
</span></span></code></pre></div><h3 id=创建-featurereleasehotfixsupport--分支>创建 feature/release/hotfix/support 分支<a hidden class=anchor aria-hidden=true href=#创建-featurereleasehotfixsupport--分支>#</a></h3><p>查看、开始、完成、删除 feature 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow feature
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># &lt;base&gt; 参数必须是分支名称，缺失时，默认为 develop 分支</span>
</span></span><span class=line><span class=cl>git flow feature start &lt;name&gt; <span class=o>[</span>&lt;base&gt;<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git flow feature finish &lt;name&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git flow feature delete &lt;name&gt;
</span></span></code></pre></div><p>发布或者跟踪 feature 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#如果当前在 feature/name 分支，则可以省略 &lt;name&gt; 参数</span>
</span></span><span class=line><span class=cl>git flow feature publish &lt;name&gt;
</span></span><span class=line><span class=cl>git flow feature track &lt;name&gt;
</span></span></code></pre></div><p>当 feature 分支发布之后，其他人可以拉取该分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git pull
</span></span><span class=line><span class=cl>git checkout feature/&lt;name&gt;
</span></span></code></pre></div><p>类似地，查看、开始、完成、删除 release 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow release
</span></span><span class=line><span class=cl>git flow release start &lt;name&gt; <span class=o>[</span>&lt;base&gt;<span class=o>]</span>
</span></span><span class=line><span class=cl>git flow release finish &lt;name&gt;
</span></span><span class=line><span class=cl>git flow release delete &lt;name&gt;
</span></span></code></pre></div><p>类似地，查看、开始、完成、删除 hotfix 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git flow hotfix
</span></span><span class=line><span class=cl>git flow hotfix start &lt;name&gt; [&lt;base&gt;]
</span></span><span class=line><span class=cl>git flow hotfix finish &lt;name&gt;
</span></span><span class=line><span class=cl>git flow hotfix delete &lt;name&gt;
</span></span></code></pre></div><p>查看、开始 support 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow support
</span></span><span class=line><span class=cl>git flow support start &lt;name&gt; &lt;base&gt;
</span></span></code></pre></div><h3 id=hooks-和-filters>Hooks 和 Filters<a hidden class=anchor aria-hidden=true href=#hooks-和-filters>#</a></h3><p>Git-flow (AVH Edition)允许使用Hooks and Filters来扩展和自定义Git Flow的行为。Hooks和Filters是Git Flow中的两个关键概念，它们可以在Git Flow的不同阶段执行自定义脚本或命令，从而实现Git Flow的高度定制化。</p><p>Hooks是一些脚本或命令，它们会在Git Flow的不同阶段被调用。Git Flow (AVH Edition)支持以下Hooks：</p><ol><li>git-flow-init: 该Hook会在git-flow init命令执行时被调用。</li><li>git-flow-feature-start: 该Hook会在创建新的feature分支时被调用。</li><li>git-flow-feature-finish: 该Hook会在完成feature分支时被调用。</li><li>git-flow-release-start: 该Hook会在创建新的release分支时被调用。</li><li>git-flow-release-finish: 该Hook会在完成release分支时被调用。</li><li>git-flow-hotfix-start: 该Hook会在创建新的hotfix分支时被调用。</li><li>git-flow-hotfix-finish: 该Hook会在完成hotfix分支时被调用。</li></ol><p>Filters是一些命令或参数，它们会在Git Flow的不同阶段被过滤或修改。Git Flow (AVH Edition)支持以下Filters：</p><ol><li>git-flow-feature-start-message: 可以用于修改feature分支创建时的提交信息。</li><li>git-flow-feature-finish-message: 可以用于修改feature分支完成时的提交信息。</li><li>git-flow-release-start-message: 可以用于修改release分支创建时的提交信息。</li><li>git-flow-release-finish-message: 可以用于修改release分支完成时的提交信息。</li><li>git-flow-hotfix-start-message: 可以用于修改hotfix分支创建时的提交信息。</li><li>git-flow-hotfix-finish-message: 可以用于修改hotfix分支完成时的提交信息。</li></ol><p>下面是一些使用Hooks和Filters的例子：</p><ol><li>使用git-flow-init Hook</li></ol><p>如果需要在执行git-flow init命令时执行一些自定义脚本，可以使用git-flow-init Hook。假设我们想在git-flow init命令执行时输出一些信息，可以在<code>.git/hooks/git-flow-init</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;Executing git-flow-init Hook&#34;</span>
</span></span></code></pre></div><ol start=2><li>使用git-flow-feature-start Hook</li></ol><p>如果需要在创建新的feature分支时执行一些自定义脚本，可以使用git-flow-feature-start Hook。假设我们想在创建新的feature分支时自动为该分支设置一些默认值，可以在<code>.git/hooks/git-flow-feature-start</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># Set default values for feature branch</span>
</span></span><span class=line><span class=cl>git config branch.<span class=nv>$GIT_BRANCH_NAME</span>.some_config_value <span class=s2>&#34;default_value&#34;</span>
</span></span></code></pre></div><ol start=3><li>使用git-flow-feature-finish-message Filter</li></ol><p>如果需要修改feature分支完成时的提交信息，可以使用git-flow-feature-finish-message Filter。假设我们想在feature分支完成时强制要求填写提交信息，可以在<code>.git/config</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=p>[</span><span class=nx>gitflow</span> <span class=s2>&#34;feature&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>finishmessage</span> <span class=p>=</span> <span class=nx>Please</span> <span class=nx>provide</span> <span class=nx>a</span> <span class=nx>meaningful</span> <span class=nx>commit</span> <span class=nx>message</span> <span class=nx>for</span> <span class=nx>the</span> <span class=nx>feature</span> <span class=nx>branch</span>
</span></span></code></pre></div><ol start=4><li>使用 git-flow-hotfix-start Hook</li></ol><p>如果需要在创建新的hotfix分支时执行一些自定义脚本，可以使用git-flow-hotfix-start Hook。假设我们想在创建新的hotfix分支时自动为该分支设置一些默认值，可以在<code>.git/hooks/git-flow-hotfix-start</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># Set default values for hotfix branch</span>
</span></span><span class=line><span class=cl>git config branch.<span class=nv>$GIT_BRANCH_NAME</span>.some_config_value <span class=s2>&#34;default_value&#34;</span>
</span></span></code></pre></div><ol start=5><li>使用 git-flow-hotfix-finish Hook</li></ol><p>在<code>.git/hooks/git-flow-hotfix-finish</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># Update version number in package.json</span>
</span></span><span class=line><span class=cl><span class=nv>VERSION</span><span class=o>=</span><span class=k>$(</span>cat package.json <span class=p>|</span> jq -r <span class=s1>&#39;.version&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>NEW_VERSION</span><span class=o>=</span><span class=k>$(</span><span class=nb>echo</span> <span class=nv>$VERSION</span> <span class=p>|</span> awk -F. <span class=s1>&#39;{$NF++;print}&#39;</span> <span class=p>|</span> sed <span class=s1>&#39;s/ /./g&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>sed -i <span class=s1>&#39;&#39;</span> <span class=s2>&#34;s/\&#34;version\&#34;: \&#34;</span><span class=nv>$VERSION</span><span class=s2>\&#34;/\&#34;version\&#34;: \&#34;</span><span class=nv>$NEW_VERSION</span><span class=s2>\&#34;/g&#34;</span> package.json
</span></span></code></pre></div><blockquote><p>该脚本用于修改前端项目中的版本号。</p></blockquote><h2 id=github-flow-模型>GitHub Flow 模型<a hidden class=anchor aria-hidden=true href=#github-flow-模型>#</a></h2><p>GitHub Flow是一种基于GitHub的分支模型和代码开发工作流程，它是一个简单而灵活的模型，在敏捷开发和持续交付方面具有很高的效率。相比于Git Flow，GitHub Flow更加适合团队和开发者进行快速迭代和快速上线。</p><p>GitHub Flow的分支模型非常简单：只有一个主分支（通常是master分支）和多个特性分支。主分支始终处于稳定状态并用于生产环境。每个特性分支用于开发新功能或修复bug，并在开发人员完成相应的开发和测试工作后合并到主分支中。</p><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/github-flow.png alt="github flow"></p><p>GitHub Flow 遵循以下 6 条原则：</p><ol><li><code>master</code> 分支永远是随时可部署发布的</li><li>需求新增基于 <code>master</code> 分支，并创建一个语义化分支</li><li>定期推送本地分支到远端</li><li>合并到 <code>master</code> 需要提 <code>PR</code></li><li><code>PR</code> 一旦经过 <code>code review</code> 无误后即可合并到 <code>master</code></li><li><code>master</code> 一旦接收到合并请求，即可立即部署发布</li></ol><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/github-flow-whole.png alt=github-flow-whole></p><p>GitHub Flow的代码开发工作流程如下：</p><ol><li>创建特性分支：从主分支中创建一个新的特性分支，用于开发新功能或修复bug。</li><li>开发和测试：在特性分支上进行开发和测试，确保代码符合质量标准，并通过自动化测试。</li><li>发起合并请求：将特性分支合并到主分支中，发起一个合并请求（pull request），并邀请其他开发者进行代码审查和讨论。</li><li>代码审查：其他开发者对代码进行审查和讨论，提出意见和建议，并确保代码符合质量标准和最佳实践。</li><li>合并代码：在经过审查和讨论后，将特性分支合并到主分支中，并将代码部署到生产环境。</li><li>部署代码：在合并到主分支后，使用自动化部署工具将代码部署到生产环境。</li></ol><h2 id=gitlab-flow-模型>Gitlab flow 模型<a hidden class=anchor aria-hidden=true href=#gitlab-flow-模型>#</a></h2><p>GitLab Flow是一个基于GitLab的分支模型和开发工作流程，旨在支持敏捷开发和持续交付。</p><p><code>GitLab</code> 在 2014 年提出 <code>11</code> 条最佳实践，更多请点击<a href=https://about.gitlab.com/topics/version-control/what-are-gitlab-flow-best-practices/>这里</a>，其相对 <code>GitHub</code> 增加了环境分支，且代码必须由<code>上游</code>（<code>master</code>）向<code>下游</code>（<code>staging</code>）发展，并且针对持续发布和版本发布都提出了相应的准则，下面是其大致流程图：</p><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/gilab-flow-cidi.png alt=img></p><p>GitLab Flow的主要特点包括：</p><ol><li>简单的分支模型：GitLab Flow使用一个简单的分支模型，包括一个主分支（通常命名为“master”或“production”）和一个开发分支（通常命名为“develop”或“staging”）。特性分支从开发分支创建，并在特性或错误修复完成并通过测试后合并回开发分支中。</li><li>持续集成和交付：GitLab Flow强调持续集成和交付（CI/CD），这意味着每次对代码的更改都会自动构建、测试和部署到测试环境或生产环境（如果测试通过）。</li><li>代码审查：GitLab Flow鼓励进行代码审查，这意味着每次对代码的更改都会由至少一个其他开发人员进行审查，以确保其符合质量标准并不会引入任何安全漏洞。</li><li>合并请求：GitLab Flow使用合并请求来管理将代码更改合并到主分支的过程。合并请求允许开发人员在将更改合并到主分支之前对其进行审查和讨论。</li><li>环境管理：GitLab Flow提供高级的环境管理功能，允许团队创建和管理不同的开发、测试、暂存和生产环境。</li></ol><blockquote><p>GitLab Flow提供了高级的环境管理功能，可以帮助团队更好地管理不同的开发、测试、暂存和生产环境。以下是使用GitLab Flow进行环境管理的一些方法：</p><ol><li>创建不同的环境分支：在GitLab Flow中，可以为不同的环境创建分支。例如，可以创建一个名为“develop”的开发分支，一个名为“staging”的暂存分支，和一个名为“production”的生产分支。这些分支可以帮助团队更好地管理不同环境的代码，确保每个环境都有自己的代码版本。</li><li>配置环境变量：在GitLab中，可以为每个环境设置不同的环境变量。这些环境变量可以用于配置不同环境中的应用程序和服务，例如数据库连接字符串、API密钥等。通过设置正确的环境变量，可以确保应用程序在不同环境中正确运行。</li><li>自动化部署和测试：GitLab Flow支持自动化部署和测试，可以帮助团队更快地部署代码到不同环境中。可以使用GitLab的CI/CD管道来自动化测试和部署过程，并将代码推送到正确的环境分支中。</li><li>环境监控和报告：GitLab Flow还支持环境监控和报告功能，可以帮助团队更好地了解不同环境的运行状况和性能。可以使用GitLab的监控和报告工具来监视不同环境的性能指标、错误率等，并及时发现和解决问题。</li></ol></blockquote><p>GitLab Flow的分支模型如下：</p><ol><li>主分支：主分支始终处于稳定状态，并用于生产环境。在GitLab Flow中，主分支通常是master分支或production分支。</li><li>特性分支：特性分支用于开发新功能或修复bug，并从主分支中创建。在GitLab Flow中，特性分支通常以feature/或fix/为前缀。</li><li>集成分支：集成分支用于将特性分支集成到主分支中，并进行测试和部署。在GitLab Flow中，集成分支通常是develop分支或staging分支。</li><li>发布分支：发布分支用于将特性分支和集成分支的代码发布到生产环境中。在GitLab Flow中，发布分支通常是release/为前缀的分支。</li></ol><p>GitLab Flow的开发工作流程如下：</p><ol><li>创建特性分支：从主分支中创建一个新的特性分支，用于开发新功能或修复bug。</li><li>开发和测试：在特性分支上进行开发和测试，确保代码符合质量标准，并通过自动化测试。</li><li>合并到集成分支：将特性分支合并到集成分支中，并进行集成测试和自动化部署。</li><li>发布到生产环境：将集成分支的代码发布到生产环境中，并进行最终测试和部署。</li><li>合并到主分支：在发布到生产环境后，将集成分支合并到主分支中，并将代码部署到生产环境。</li></ol><p>GitLab Flow强调CI/CD集成和测试自动化，以确保代码质量和快速迭代。它还支持自动化部署和环境管理，以帮助开发人员更轻松地管理不同环境和部署代码。GitLab Flow是一个灵活和强大的开发工作流程，适用于各种类型的项目和团队。</p><h2 id=gitlab-flowgit-flow和github-flow>GitLab Flow、Git Flow和GitHub Flow<a hidden class=anchor aria-hidden=true href=#gitlab-flowgit-flow和github-flow>#</a></h2><p>GitLab Flow、Git Flow和GitHub Flow都是三种常见的基于Git的工作流程。下面是GitLab Flow与其他工作流程的主要区别：</p><ol><li>GitLab Flow与Git Flow的比较：</li></ol><ul><li><p>GitLab Flow比Git Flow更简单和更灵活。Git Flow有一个更复杂的分支模型，包含多个长期存在的分支，而GitLab Flow只使用几个主要分支和特性分支。</p></li><li><p>GitLab Flow强调持续集成和持续部署（CI/CD），鼓励频繁合并到主要分支。Git Flow更注重版本控制和发布管理。</p></li><li><p>GitLab Flow与GitLab内置的CI/CD管道更紧密地集成在一起，更容易自动化开发工作流程。</p></li></ul><ol start=2><li>GitLab Flow与GitHub Flow的比较：</li></ol><ul><li>GitLab Flow和GitHub Flow有许多相似之处，例如它们都以GitHub或GitLab作为中央仓库，使用特性分支进行开发。</li><li>GitLab Flow强调CI/CD集成和测试自动化，而GitHub Flow更注重代码审查和协作。</li><li>GitLab Flow还提供更高级的环境管理、部署和监控功能，更适合于大型、复杂的项目。</li></ul><p>总体而言，GitLab Flow比Git Flow更简单和更灵活，强调CI/CD集成和自动化。与GitHub Flow相比，GitLab Flow提供更高级的环境管理和部署功能，更适合于大型、复杂的项目。选择哪种工作流程最终取决于项目和开发团队的具体需求和要求。</p><h2 id=其他-flow>其他 flow<a hidden class=anchor aria-hidden=true href=#其他-flow>#</a></h2><ul><li>TrunkBased</li><li>OneFlow</li><li>AoneFlow</li></ul><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>目前公司代码部署在自建的 gitlab 上面，对于公司的项目，个人倾向于使用 git-flow 分支模型，并且使用 git-flow (AVH Edition) 来简化操作。</p><p>目前，我参与的大多数项目都是 java 项目并且使用 maven 进行构建。</p><p>在Maven项目中，可以使用Maven版本控制器来区分release版本和snapshot版本。</p><ul><li><p><strong>Release版本</strong></p><p>对于Git Flow中的release分支，通常用于为生产环境准备代码。</p><p>在Maven项目中，可以使用Maven Release插件来自动化创建和发布release版本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn release:prepare
</span></span><span class=line><span class=cl>mvn release:perform
</span></span></code></pre></div><p>使用这些命令，Maven Release插件会自动更新项目版本号、创建tag、构建release版本，并发布到Maven仓库中。发布的版本号不包含 <code>-SNAPSHOT</code> 后缀。</p><p>或者，使用 <code>mvn versions</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set -DnewVersion<span class=o>=</span>1.0.0-SNAPSHOT
</span></span><span class=line><span class=cl>mvn versions:commit
</span></span></code></pre></div></li><li><p><strong>Snapshot版本</strong></p><p>对于Git Flow中的feature和develop分支，通常用于开发和测试新功能或bug修复，这些分支使用snapshot版本。在Maven中，snapshot版本的版本号包含 <code>-SNAPSHOT</code> 后缀，表示当前版本是正在开发的版本。</p></li></ul><p>对于这些项目，git-flow 操作步骤如下：</p><p>1、初始化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow init -d
</span></span></code></pre></div><p>2、开始 feature 分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow feature start <span class=nb>test</span>
</span></span></code></pre></div><p>设置maven项目中版本为 snapshot版本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set -DnewVersion<span class=o>=</span>1.0.0-SNAPSHOT
</span></span><span class=line><span class=cl>mvn versions:commit
</span></span></code></pre></div><p>对于maven多模块项目，如果使用 revision 来统一定义版本号，则使用下面命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set-property -Dproperty<span class=o>=</span>revision -DnewVersion<span class=o>=</span>1.0.0-SNAPSHOT
</span></span></code></pre></div><p>3、本地在 feature 分支上完成一些开发之后，完成 feature 分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow feature finish <span class=nb>test</span>
</span></span></code></pre></div><p>4、开始 release 分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow release start 1.0.0
</span></span></code></pre></div><p>5、本地在 release 分支上完成一些开发之后，完成 feature 分支</p><p>设置maven项目中版本为 release 版本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set -DnewVersion<span class=o>=</span>1.0.0
</span></span><span class=line><span class=cl>mvn versions:commit
</span></span></code></pre></div><p>对于maven多模块项目，如果使用 revision 来统一定义版本号，则使用下面命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set-property -Dproperty<span class=o>=</span>revision -DnewVersion<span class=o>=</span>1.0.0
</span></span></code></pre></div><p>另外，对于多模块项目，需要在每个模块执行下面命令将 jar 推送到 maven 中央仓库：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn install -DskipTests
</span></span></code></pre></div><p>然后完成分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow release finish 1.0.0
</span></span></code></pre></div><p>以上。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.com/tags/git/>git</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.chensoul.com/>ChenSoul</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script async src=https://umami.chensoul.com/script.js data-website-id=f110cfa0-b737-4690-a032-2b9073a57fc3></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>