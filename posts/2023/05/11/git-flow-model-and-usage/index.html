<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git Flow分支模型和使用 | ChenSoul</title>
<meta name=keywords content="git"><meta name=description content="介绍 Git Flow 是由 Vincent Driessen 在 2010 年提出的一种 Git 工作流。在这之前，Git 没有一个明确的标准工作流，导致团队在使用 Git 时往往会遇到一些问题，如分支管理、版本控制等。为了解决这些问题，Vincent Driessen 提出了 Git Flow 分支模型，成为了 Git 在实际应用中的一种标准工作流。
随着时间的推移，Git Flow 也在不断发展和完善。在 2011 年，Atlassian 发布了 SourceTree，这是一款图形化的 Git 客户端，支持 Git Flow 分支模型。在 2013 年，Git Flow 的一些开发者发布了 Git Flow AVH Edition，这是 Git Flow 的一个增强版本，提供了更多的功能和选项。此外，Git Flow 还得到了其他开源工具和平台的支持，如 GitHub、GitLab 等。
Git Flow 分支模型 Git Flow 分支模型定义了一种标准的 Git 分支模型，它将代码分为两个长期分支（master 和 develop）和三个短期分支（feature、release 和 hotfix），使得团队可以更好地管理代码的版本和发布。
以下是 Git Flow 分支模型的详细介绍：
master 分支 master 分支是代码库的主分支，它包含了所有已发布的代码和版本。所有代码都应该在该分支上进行测试和验证，以确保代码的质量和稳定性。master分支只能通过合并release或hotfix分支来更新。 develop 分支 develop 分支是代码库的开发分支，它包含了所有开发中的代码和功能。所有新的代码都应该在该分支上进行开发和测试，以确保代码的可靠性和稳定性。develop分支只能通过合并feature分支来更新。 feature 分支 feature 分支是为开发新的功能或修复 bug 而创建的临时分支。每个feature分支都是从develop分支分离出来的，开发完成后会合并回develop分支。feature 分支的命名应该清晰明确，以反映该分支所涉及的功能或问题。 release 分支 release 分支是为发布新版本而创建的临时分支。每个release分支都是从develop分支分离出来的，发布完成后会合并回develop分支和master分支。在 release 分支上可以进行一些小的修复和调整，以确保发布的代码的质量和稳定性。 hotfix 分支 hotfix 分支是为快速修复生产环境中的问题而创建的临时分支。每个 hotfix 分支都是从 master 分支分离出来的，修复完成后会合并回 develop 分支和 master 分支。hotfix分支的优先级比其他分支更高，因为它们需要尽快修复生产环境中的问题。 根据上面的理论，我们来实际操作一遍。首先，是 develop 分支创建一个 feature 分支。"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/05/11/git-flow-model-and-usage/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/05/11/git-flow-model-and-usage/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Git Flow分支模型和使用"><meta property="og:description" content="介绍 Git Flow 是由 Vincent Driessen 在 2010 年提出的一种 Git 工作流。在这之前，Git 没有一个明确的标准工作流，导致团队在使用 Git 时往往会遇到一些问题，如分支管理、版本控制等。为了解决这些问题，Vincent Driessen 提出了 Git Flow 分支模型，成为了 Git 在实际应用中的一种标准工作流。
随着时间的推移，Git Flow 也在不断发展和完善。在 2011 年，Atlassian 发布了 SourceTree，这是一款图形化的 Git 客户端，支持 Git Flow 分支模型。在 2013 年，Git Flow 的一些开发者发布了 Git Flow AVH Edition，这是 Git Flow 的一个增强版本，提供了更多的功能和选项。此外，Git Flow 还得到了其他开源工具和平台的支持，如 GitHub、GitLab 等。
Git Flow 分支模型 Git Flow 分支模型定义了一种标准的 Git 分支模型，它将代码分为两个长期分支（master 和 develop）和三个短期分支（feature、release 和 hotfix），使得团队可以更好地管理代码的版本和发布。
以下是 Git Flow 分支模型的详细介绍：
master 分支 master 分支是代码库的主分支，它包含了所有已发布的代码和版本。所有代码都应该在该分支上进行测试和验证，以确保代码的质量和稳定性。master分支只能通过合并release或hotfix分支来更新。 develop 分支 develop 分支是代码库的开发分支，它包含了所有开发中的代码和功能。所有新的代码都应该在该分支上进行开发和测试，以确保代码的可靠性和稳定性。develop分支只能通过合并feature分支来更新。 feature 分支 feature 分支是为开发新的功能或修复 bug 而创建的临时分支。每个feature分支都是从develop分支分离出来的，开发完成后会合并回develop分支。feature 分支的命名应该清晰明确，以反映该分支所涉及的功能或问题。 release 分支 release 分支是为发布新版本而创建的临时分支。每个release分支都是从develop分支分离出来的，发布完成后会合并回develop分支和master分支。在 release 分支上可以进行一些小的修复和调整，以确保发布的代码的质量和稳定性。 hotfix 分支 hotfix 分支是为快速修复生产环境中的问题而创建的临时分支。每个 hotfix 分支都是从 master 分支分离出来的，修复完成后会合并回 develop 分支和 master 分支。hotfix分支的优先级比其他分支更高，因为它们需要尽快修复生产环境中的问题。 根据上面的理论，我们来实际操作一遍。首先，是 develop 分支创建一个 feature 分支。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/05/11/git-flow-model-and-usage/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-11T14:00:00+08:00"><meta property="article:modified_time" content="2023-05-11T14:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git Flow分支模型和使用"><meta name=twitter:description content="介绍 Git Flow 是由 Vincent Driessen 在 2010 年提出的一种 Git 工作流。在这之前，Git 没有一个明确的标准工作流，导致团队在使用 Git 时往往会遇到一些问题，如分支管理、版本控制等。为了解决这些问题，Vincent Driessen 提出了 Git Flow 分支模型，成为了 Git 在实际应用中的一种标准工作流。
随着时间的推移，Git Flow 也在不断发展和完善。在 2011 年，Atlassian 发布了 SourceTree，这是一款图形化的 Git 客户端，支持 Git Flow 分支模型。在 2013 年，Git Flow 的一些开发者发布了 Git Flow AVH Edition，这是 Git Flow 的一个增强版本，提供了更多的功能和选项。此外，Git Flow 还得到了其他开源工具和平台的支持，如 GitHub、GitLab 等。
Git Flow 分支模型 Git Flow 分支模型定义了一种标准的 Git 分支模型，它将代码分为两个长期分支（master 和 develop）和三个短期分支（feature、release 和 hotfix），使得团队可以更好地管理代码的版本和发布。
以下是 Git Flow 分支模型的详细介绍：
master 分支 master 分支是代码库的主分支，它包含了所有已发布的代码和版本。所有代码都应该在该分支上进行测试和验证，以确保代码的质量和稳定性。master分支只能通过合并release或hotfix分支来更新。 develop 分支 develop 分支是代码库的开发分支，它包含了所有开发中的代码和功能。所有新的代码都应该在该分支上进行开发和测试，以确保代码的可靠性和稳定性。develop分支只能通过合并feature分支来更新。 feature 分支 feature 分支是为开发新的功能或修复 bug 而创建的临时分支。每个feature分支都是从develop分支分离出来的，开发完成后会合并回develop分支。feature 分支的命名应该清晰明确，以反映该分支所涉及的功能或问题。 release 分支 release 分支是为发布新版本而创建的临时分支。每个release分支都是从develop分支分离出来的，发布完成后会合并回develop分支和master分支。在 release 分支上可以进行一些小的修复和调整，以确保发布的代码的质量和稳定性。 hotfix 分支 hotfix 分支是为快速修复生产环境中的问题而创建的临时分支。每个 hotfix 分支都是从 master 分支分离出来的，修复完成后会合并回 develop 分支和 master 分支。hotfix分支的优先级比其他分支更高，因为它们需要尽快修复生产环境中的问题。 根据上面的理论，我们来实际操作一遍。首先，是 develop 分支创建一个 feature 分支。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"Git Flow分支模型和使用","item":"https://blog.chensoul.cc/posts/2023/05/11/git-flow-model-and-usage/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git Flow分支模型和使用","name":"Git Flow分支模型和使用","description":"介绍 Git Flow 是由 Vincent Driessen 在 2010 年提出的一种 Git 工作流。在这之前，Git 没有一个明确的标准工作流，导致团队在使用 Git 时往往会遇到一些问题，如分支管理、版本控制等。为了解决这些问题，Vincent Driessen 提出了 Git Flow 分支模型，成为了 Git 在实际应用中的一种标准工作流。\n随着时间的推移，Git Flow 也在不断发展和完善。在 2011 年，Atlassian 发布了 SourceTree，这是一款图形化的 Git 客户端，支持 Git Flow 分支模型。在 2013 年，Git Flow 的一些开发者发布了 Git Flow AVH Edition，这是 Git Flow 的一个增强版本，提供了更多的功能和选项。此外，Git Flow 还得到了其他开源工具和平台的支持，如 GitHub、GitLab 等。\nGit Flow 分支模型 Git Flow 分支模型定义了一种标准的 Git 分支模型，它将代码分为两个长期分支（master 和 develop）和三个短期分支（feature、release 和 hotfix），使得团队可以更好地管理代码的版本和发布。\n以下是 Git Flow 分支模型的详细介绍：\nmaster 分支 master 分支是代码库的主分支，它包含了所有已发布的代码和版本。所有代码都应该在该分支上进行测试和验证，以确保代码的质量和稳定性。master分支只能通过合并release或hotfix分支来更新。 develop 分支 develop 分支是代码库的开发分支，它包含了所有开发中的代码和功能。所有新的代码都应该在该分支上进行开发和测试，以确保代码的可靠性和稳定性。develop分支只能通过合并feature分支来更新。 feature 分支 feature 分支是为开发新的功能或修复 bug 而创建的临时分支。每个feature分支都是从develop分支分离出来的，开发完成后会合并回develop分支。feature 分支的命名应该清晰明确，以反映该分支所涉及的功能或问题。 release 分支 release 分支是为发布新版本而创建的临时分支。每个release分支都是从develop分支分离出来的，发布完成后会合并回develop分支和master分支。在 release 分支上可以进行一些小的修复和调整，以确保发布的代码的质量和稳定性。 hotfix 分支 hotfix 分支是为快速修复生产环境中的问题而创建的临时分支。每个 hotfix 分支都是从 master 分支分离出来的，修复完成后会合并回 develop 分支和 master 分支。hotfix分支的优先级比其他分支更高，因为它们需要尽快修复生产环境中的问题。 根据上面的理论，我们来实际操作一遍。首先，是 develop 分支创建一个 feature 分支。","keywords":["git"],"articleBody":"介绍 Git Flow 是由 Vincent Driessen 在 2010 年提出的一种 Git 工作流。在这之前，Git 没有一个明确的标准工作流，导致团队在使用 Git 时往往会遇到一些问题，如分支管理、版本控制等。为了解决这些问题，Vincent Driessen 提出了 Git Flow 分支模型，成为了 Git 在实际应用中的一种标准工作流。\n随着时间的推移，Git Flow 也在不断发展和完善。在 2011 年，Atlassian 发布了 SourceTree，这是一款图形化的 Git 客户端，支持 Git Flow 分支模型。在 2013 年，Git Flow 的一些开发者发布了 Git Flow AVH Edition，这是 Git Flow 的一个增强版本，提供了更多的功能和选项。此外，Git Flow 还得到了其他开源工具和平台的支持，如 GitHub、GitLab 等。\nGit Flow 分支模型 Git Flow 分支模型定义了一种标准的 Git 分支模型，它将代码分为两个长期分支（master 和 develop）和三个短期分支（feature、release 和 hotfix），使得团队可以更好地管理代码的版本和发布。\n以下是 Git Flow 分支模型的详细介绍：\nmaster 分支 master 分支是代码库的主分支，它包含了所有已发布的代码和版本。所有代码都应该在该分支上进行测试和验证，以确保代码的质量和稳定性。master分支只能通过合并release或hotfix分支来更新。 develop 分支 develop 分支是代码库的开发分支，它包含了所有开发中的代码和功能。所有新的代码都应该在该分支上进行开发和测试，以确保代码的可靠性和稳定性。develop分支只能通过合并feature分支来更新。 feature 分支 feature 分支是为开发新的功能或修复 bug 而创建的临时分支。每个feature分支都是从develop分支分离出来的，开发完成后会合并回develop分支。feature 分支的命名应该清晰明确，以反映该分支所涉及的功能或问题。 release 分支 release 分支是为发布新版本而创建的临时分支。每个release分支都是从develop分支分离出来的，发布完成后会合并回develop分支和master分支。在 release 分支上可以进行一些小的修复和调整，以确保发布的代码的质量和稳定性。 hotfix 分支 hotfix 分支是为快速修复生产环境中的问题而创建的临时分支。每个 hotfix 分支都是从 master 分支分离出来的，修复完成后会合并回 develop 分支和 master 分支。hotfix分支的优先级比其他分支更高，因为它们需要尽快修复生产环境中的问题。 根据上面的理论，我们来实际操作一遍。首先，是 develop 分支创建一个 feature 分支。\n$ git checkout -b feature-test develop Switched to a new branch \"feature-test\" 将 feature 分支的修改合并到 develop 分支，然后删除 feature 分支：\n$ git checkout develop Switched to branch 'develop' $ git merge --no-ff feature-test Updating ea1b82a..05e9557 (Summary of changes) $ git branch -d feature-test Deleted branch feature-test (was 05e9557). $ git push origin develop 合并分支时，添加--no-ff 参数和不添加的区别：\n从 develop 分支创建一个 release 分支，并将版本号改为 1.2 ：\n$ git checkout -b release-1.2 develop Switched to a new branch \"release-1.2\" $ ./bump-version.sh 1.2 Files modified successfully, version bumped to 1.2. $ git commit -a -m \"Bumped version number to 1.2\" [release-1.2 74d9424] Bumped version number to 1.2 1 files changed, 1 insertions(+), 1 deletions(-) release 分支完成开发之后，将 release 分支合并到 master 分支，并创建一个标签：\n$ git checkout master Switched to branch 'master' $ git merge --no-ff release-1.2 Merge made by recursive. (Summary of changes) $ git tag -a 1.2 将 release 分支合并到 develop 分支：\n$ git checkout develop Switched to branch 'develop' $ git merge --no-ff release-1.2 Merge made by recursive. (Summary of changes) 最后删除 release 分支：\n$ git branch -d release-1.2 Deleted branch release-1.2 (was ff452fe). 对于 hoftfix 分支，操作步骤和 release 分支类似，故不在赘述。\ngit-flow 工具 git-flow 工具可以简化上面的操作步骤，关于 git-flow 的介绍可以参考文章：Using git-flow to automate your git branching workflow。\nmacos 上安装 git-flow：\nbrew install git-flow git-flow 首先需要初始化，如果不存在 develop 分支，则会新建一个 develop 分支：\ngit flow init No branches exist yet. Base branches must be created now. Branch name for production releases: [master] Branch name for \"next release\" development: [develop] How to name your supporting branch prefixes? Feature branches? [feature-] Release branches? [release-] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] feature 分支 开发一个新功能，创建一个新分支 foo\n$ git flow feature start foo 等价于\n#切换到develop分支,确保新的 feature 分支是基于最新的 develop 分支创建的。 $ git checkout -b feature-foo develop 取消正在进行中的功能分支，并且会将分支删除\n$ git flow feature delete foo 等价于\n$ git branch -D feature-foo foo 功能自测通过后，合并到 develop\n$ git flow feature finish foo 等价于\n//切换到 develop 分支 $ git checkout develop //将 feature-foo 分支中的更改合并到 develop 分支。 --no-ff 参数将保留 foo 分支的commit记录。 $ git merge --no-ff feature-foo //删除已完成的分支 $ git branch -d feature-foo release 分支 当所有新的功能和必要的修复已经被彻底的测试过了，那就开始生成一个新的 release , 在此之后不能添加新功能，只有错误修复、文档生成和其他面向发布的任务应该在该分支中进行。\n# 1.0.0 是版本号 $ git flow release start 1.0.0 等价于\n# 从 develop 分支 创建release分支 $ git checkout -b release-1.0.0 develop 取消正在进行中的发布分支，并且会将分支删除。\n$ git flow release delete 1.0.0 等价于\ngit branch -D release-1.0.0 添加完发布文档之后，完成 release\n$ git flow release finish 1.0.0 等价于\n#切换到 develop 分支。 $ git checkout develop #将 release-1.0.0 分支合并到 develop 分支，--no-ff 选项以保留 feature 分支的 commit 记录 $ git merge --no-ff release-1.0.0 #创建一个名为 1.0.0 的标签 $ git tag -a 1.0.0 -m \"Release 1.0.0\" #切换到 master 分支。 $ git checkout master #将 release-1.0.0 分支合并到 master 分支，--no-ff 选项以保留 feature 分支的 commit 记录 $ git merge --no-ff release-1.0.0 #删除 release-1.0.0 分支。 $ git branch -d release-1.0.0 Hotfixes 分支 线上发生问题的时候，先回滚到之前的稳定版本，稳定局势 然后创建热修复分支开始改 BUG\n$ git flow hotfix start 1.0.1 等价于\n#从master分支 创建一个hotfix/1.0.1分支 $ git checkout -b hotfix/1.0.1 foo master 紧急修复完毕\n$ git flow hotfix finish 1.0.1 等价于\n#切换 master 分支 $ git checkout master #合并热修复分支到master,--no-ff 选项以保留 feature 分支的 commit 记录 $ git merge --no-ff hotfix/ohno #创建一个名为 1.0.1 的标签 $ git tag 1.0.1 #切换到 develop 分支 $ git checkout develop #合并热修复分支到 develop ,--no-ff 选项以保留 feature 分支的 commit 记录 $ git merge --no-ff hotfix/1.0.1 #删除热修复分支 $ git branch -d hotfix/1.0.1 git-flow (AVH Edition) Git-flow (AVH Edition)是 Git Flow 的一个增强版本，由一些 Git Flow 的开发者开发和维护。Git-flow (AVH Edition)在保留 Git Flow 基本思想的前提下，增加了一些新的功能和选项，使得 Git Flow 更加灵活和适用于不同的团队和项目。\nGit-flow (AVH Edition)的主要增强功能包括：\n支持 git-flow init 命令，可以在一个新的 Git 仓库中快速初始化 Git Flow。 支持 git flow feature pull 命令，可以拉取其他团队成员的 feature 分支。 支持 git flow feature publish 命令，可以将 feature 分支发布到远程仓库。 支持 git flow hotfix finish 命令，可以在修复生产环境问题时自动合并到 develop 分支和 master 分支并发布新版本。 支持 git flow support 分支，可以为旧版本提供长期支持。 允许使用 Hooks and Filters 来扩展和自定义 Git Flow 的行为。 除了以上功能之外，Git-flow (AVH Edition)还提供了更多的选项和配置，使得团队可以根据不同的需求和情况来自定义 Git Flow 的分支模型和工作流程。\n初始化 使用下面命令初始化 git fow，-d 是可选参数，表示使用默认参数：\ngit flow init [-d] 创建 feature/release/hotfix/support 分支 查看、开始、完成、删除 feature 分支：\ngit flow feature # 参数必须是分支名称，缺失时，默认为 develop 分支 git flow feature start [] git flow feature finish git flow feature delete 发布或者跟踪 feature 分支：\n#如果当前在 feature/name 分支，则可以省略 参数 git flow feature publish git flow feature track 当 feature 分支发布之后，其他人可以拉取该分支：\ngit pull git checkout feature/ 类似地，查看、开始、完成、删除 release 分支：\ngit flow release git flow release start [] git flow release finish git flow release delete 类似地，查看、开始、完成、删除 hotfix 分支：\ngit flow hotfix git flow hotfix start [] git flow hotfix finish git flow hotfix delete 查看、开始 support 分支：\ngit flow support git flow support start Hooks 和 Filters Git-flow (AVH Edition)允许使用 Hooks and Filters 来扩展和自定义 Git Flow 的行为。Hooks 和 Filters 是 Git Flow 中的两个关键概念，它们可以在 Git Flow 的不同阶段执行自定义脚本或命令，从而实现 Git Flow 的高度定制化。\nHooks 是一些脚本或命令，它们会在 Git Flow 的不同阶段被调用。Git Flow (AVH Edition)支持以下 Hooks：\ngit-flow-init: 该 Hook 会在 git-flow init 命令执行时被调用。 git-flow-feature-start: 该 Hook 会在创建新的 feature 分支时被调用。 git-flow-feature-finish: 该 Hook 会在完成 feature 分支时被调用。 git-flow-release-start: 该 Hook 会在创建新的 release 分支时被调用。 git-flow-release-finish: 该 Hook 会在完成 release 分支时被调用。 git-flow-hotfix-start: 该 Hook 会在创建新的 hotfix 分支时被调用。 git-flow-hotfix-finish: 该 Hook 会在完成 hotfix 分支时被调用。 Filters 是一些命令或参数，它们会在 Git Flow 的不同阶段被过滤或修改。Git Flow (AVH Edition)支持以下 Filters：\ngit-flow-feature-start-message: 可以用于修改 feature 分支创建时的提交信息。 git-flow-feature-finish-message: 可以用于修改 feature 分支完成时的提交信息。 git-flow-release-start-message: 可以用于修改 release 分支创建时的提交信息。 git-flow-release-finish-message: 可以用于修改 release 分支完成时的提交信息。 git-flow-hotfix-start-message: 可以用于修改 hotfix 分支创建时的提交信息。 git-flow-hotfix-finish-message: 可以用于修改 hotfix 分支完成时的提交信息。 下面是一些使用 Hooks 和 Filters 的例子：\n使用 git-flow-init Hook 如果需要在执行 git-flow init 命令时执行一些自定义脚本，可以使用 git-flow-init Hook。假设我们想在 git-flow init 命令执行时输出一些信息，可以在.git/hooks/git-flow-init文件中添加以下内容：\n#!/bin/bash echo \"Executing git-flow-init Hook\" 使用 git-flow-feature-start Hook 如果需要在创建新的 feature 分支时执行一些自定义脚本，可以使用 git-flow-feature-start Hook。假设我们想在创建新的 feature 分支时自动为该分支设置一些默认值，可以在.git/hooks/git-flow-feature-start文件中添加以下内容：\n#!/bin/bash # Set default values for feature branch git config branch.$GIT_BRANCH_NAME.some_config_value \"default_value\" 使用 git-flow-feature-finish-message Filter 如果需要修改 feature 分支完成时的提交信息，可以使用 git-flow-feature-finish-message Filter。假设我们想在 feature 分支完成时强制要求填写提交信息，可以在.git/config文件中添加以下内容：\n[gitflow \"feature\"] finishmessage = Please provide a meaningful commit message for the feature branch 使用 git-flow-hotfix-start Hook 如果需要在创建新的 hotfix 分支时执行一些自定义脚本，可以使用 git-flow-hotfix-start Hook。假设我们想在创建新的 hotfix 分支时自动为该分支设置一些默认值，可以在.git/hooks/git-flow-hotfix-start文件中添加以下内容：\n#!/bin/bash # Set default values for hotfix branch git config branch.$GIT_BRANCH_NAME.some_config_value \"default_value\" 使用 git-flow-hotfix-finish Hook 在.git/hooks/git-flow-hotfix-finish文件中添加以下内容：\n#!/bin/bash # Update version number in package.json VERSION=$(cat package.json | jq -r '.version') NEW_VERSION=$(echo $VERSION | awk -F. '{$NF++;print}' | sed 's/ /./g') sed -i '' \"s/\\\"version\\\": \\\"$VERSION\\\"/\\\"version\\\": \\\"$NEW_VERSION\\\"/g\" package.json 该脚本用于修改前端项目中的版本号。\nGitHub Flow 模型 GitHub Flow 是一种基于 GitHub 的分支模型和代码开发工作流程，它是一个简单而灵活的模型，在敏捷开发和持续交付方面具有很高的效率。相比于 Git Flow，GitHub Flow 更加适合团队和开发者进行快速迭代和快速上线。\nGitHub Flow 的分支模型非常简单：只有一个主分支（通常是 master 分支）和多个特性分支。主分支始终处于稳定状态并用于生产环境。每个特性分支用于开发新功能或修复 bug，并在开发人员完成相应的开发和测试工作后合并到主分支中。\nGitHub Flow 遵循以下 6 条原则：\nmaster 分支永远是随时可部署发布的 需求新增基于 master 分支，并创建一个语义化分支 定期推送本地分支到远端 合并到 master 需要提 PR PR 一旦经过 code review 无误后即可合并到 master master 一旦接收到合并请求，即可立即部署发布 GitHub Flow 的代码开发工作流程如下：\n创建特性分支：从主分支中创建一个新的特性分支，用于开发新功能或修复 bug。 开发和测试：在特性分支上进行开发和测试，确保代码符合质量标准，并通过自动化测试。 发起合并请求：将特性分支合并到主分支中，发起一个合并请求（pull request），并邀请其他开发者进行代码审查和讨论。 代码审查：其他开发者对代码进行审查和讨论，提出意见和建议，并确保代码符合质量标准和最佳实践。 合并代码：在经过审查和讨论后，将特性分支合并到主分支中，并将代码部署到生产环境。 部署代码：在合并到主分支后，使用自动化部署工具将代码部署到生产环境。 Gitlab flow 模型 GitLab Flow 是一个基于 GitLab 的分支模型和开发工作流程，旨在支持敏捷开发和持续交付。\nGitLab 在 2014 年提出 11 条最佳实践，更多请点击这里，其相对 GitHub 增加了环境分支，且代码必须由上游（master）向下游（staging）发展，并且针对持续发布和版本发布都提出了相应的准则，下面是其大致流程图：\nGitLab Flow 的主要特点包括：\n简单的分支模型：GitLab Flow 使用一个简单的分支模型，包括一个主分支（通常命名为“master”或“production”）和一个开发分支（通常命名为“develop”或“staging”）。特性分支从开发分支创建，并在特性或错误修复完成并通过测试后合并回开发分支中。 持续集成和交付：GitLab Flow 强调持续集成和交付（CI/CD），这意味着每次对代码的更改都会自动构建、测试和部署到测试环境或生产环境（如果测试通过）。 代码审查：GitLab Flow 鼓励进行代码审查，这意味着每次对代码的更改都会由至少一个其他开发人员进行审查，以确保其符合质量标准并不会引入任何安全漏洞。 合并请求：GitLab Flow 使用合并请求来管理将代码更改合并到主分支的过程。合并请求允许开发人员在将更改合并到主分支之前对其进行审查和讨论。 环境管理：GitLab Flow 提供高级的环境管理功能，允许团队创建和管理不同的开发、测试、暂存和生产环境。 GitLab Flow 提供了高级的环境管理功能，可以帮助团队更好地管理不同的开发、测试、暂存和生产环境。以下是使用 GitLab Flow 进行环境管理的一些方法：\n创建不同的环境分支：在 GitLab Flow 中，可以为不同的环境创建分支。例如，可以创建一个名为“develop”的开发分支，一个名为“staging”的暂存分支，和一个名为“production”的生产分支。这些分支可以帮助团队更好地管理不同环境的代码，确保每个环境都有自己的代码版本。 配置环境变量：在 GitLab 中，可以为每个环境设置不同的环境变量。这些环境变量可以用于配置不同环境中的应用程序和服务，例如数据库连接字符串、API 密钥等。通过设置正确的环境变量，可以确保应用程序在不同环境中正确运行。 自动化部署和测试：GitLab Flow 支持自动化部署和测试，可以帮助团队更快地部署代码到不同环境中。可以使用 GitLab 的 CI/CD 管道来自动化测试和部署过程，并将代码推送到正确的环境分支中。 环境监控和报告：GitLab Flow 还支持环境监控和报告功能，可以帮助团队更好地了解不同环境的运行状况和性能。可以使用 GitLab 的监控和报告工具来监视不同环境的性能指标、错误率等，并及时发现和解决问题。 GitLab Flow 的分支模型如下：\n主分支：主分支始终处于稳定状态，并用于生产环境。在 GitLab Flow 中，主分支通常是 master 分支或 production 分支。 特性分支：特性分支用于开发新功能或修复 bug，并从主分支中创建。在 GitLab Flow 中，特性分支通常以 feature/或 fix/为前缀。 集成分支：集成分支用于将特性分支集成到主分支中，并进行测试和部署。在 GitLab Flow 中，集成分支通常是 develop 分支或 staging 分支。 发布分支：发布分支用于将特性分支和集成分支的代码发布到生产环境中。在 GitLab Flow 中，发布分支通常是 release/为前缀的分支。 GitLab Flow 的开发工作流程如下：\n创建特性分支：从主分支中创建一个新的特性分支，用于开发新功能或修复 bug。 开发和测试：在特性分支上进行开发和测试，确保代码符合质量标准，并通过自动化测试。 合并到集成分支：将特性分支合并到集成分支中，并进行集成测试和自动化部署。 发布到生产环境：将集成分支的代码发布到生产环境中，并进行最终测试和部署。 合并到主分支：在发布到生产环境后，将集成分支合并到主分支中，并将代码部署到生产环境。 GitLab Flow 强调 CI/CD 集成和测试自动化，以确保代码质量和快速迭代。它还支持自动化部署和环境管理，以帮助开发人员更轻松地管理不同环境和部署代码。GitLab Flow 是一个灵活和强大的开发工作流程，适用于各种类型的项目和团队。\nGitLab Flow、Git Flow 和 GitHub Flow GitLab Flow、Git Flow 和 GitHub Flow 都是三种常见的基于 Git 的工作流程。下面是 GitLab Flow 与其他工作流程的主要区别：\nGitLab Flow 与 Git Flow 的比较： GitLab Flow 比 Git Flow 更简单和更灵活。Git Flow 有一个更复杂的分支模型，包含多个长期存在的分支，而 GitLab Flow 只使用几个主要分支和特性分支。\nGitLab Flow 强调持续集成和持续部署（CI/CD），鼓励频繁合并到主要分支。Git Flow 更注重版本控制和发布管理。\nGitLab Flow 与 GitLab 内置的 CI/CD 管道更紧密地集成在一起，更容易自动化开发工作流程。\nGitLab Flow 与 GitHub Flow 的比较： GitLab Flow 和 GitHub Flow 有许多相似之处，例如它们都以 GitHub 或 GitLab 作为中央仓库，使用特性分支进行开发。 GitLab Flow 强调 CI/CD 集成和测试自动化，而 GitHub Flow 更注重代码审查和协作。 GitLab Flow 还提供更高级的环境管理、部署和监控功能，更适合于大型、复杂的项目。 总体而言，GitLab Flow 比 Git Flow 更简单和更灵活，强调 CI/CD 集成和自动化。与 GitHub Flow 相比，GitLab Flow 提供更高级的环境管理和部署功能，更适合于大型、复杂的项目。选择哪种工作流程最终取决于项目和开发团队的具体需求和要求。\n其他 flow TrunkBased OneFlow AoneFlow 总结 目前公司代码部署在自建的 gitlab 上面，对于公司的项目，个人倾向于使用 git-flow 分支模型，并且使用 git-flow (AVH Edition) 来简化操作。\n目前，我参与的大多数项目都是 java 项目并且使用 maven 进行构建。\n在 Maven 项目中，可以使用 Maven 版本控制器来区分 release 版本和 snapshot 版本。\nRelease 版本\n对于 Git Flow 中的 release 分支，通常用于为生产环境准备代码。\n在 Maven 项目中，可以使用 Maven Release 插件来自动化创建和发布 release 版本。\nmvn release:prepare mvn release:perform 使用这些命令，Maven Release 插件会自动更新项目版本号、创建 tag、构建 release 版本，并发布到 Maven 仓库中。发布的版本号不包含 -SNAPSHOT 后缀。\n或者，使用 mvn versions：\nmvn versions:set -DnewVersion=1.0.0-SNAPSHOT mvn versions:commit Snapshot 版本\n对于 Git Flow 中的 feature 和 develop 分支，通常用于开发和测试新功能或 bug 修复，这些分支使用 snapshot 版本。在 Maven 中，snapshot 版本的版本号包含 -SNAPSHOT 后缀，表示当前版本是正在开发的版本。\n对于这些项目，git-flow 操作步骤如下：\n1、初始化\ngit flow init -d 2、开始 feature 分支\ngit flow feature start test 设置 maven 项目中版本为 snapshot 版本。\nmvn versions:set -DnewVersion=1.0.0-SNAPSHOT mvn versions:commit 对于 maven 多模块项目，如果使用 revision 来统一定义版本号，则使用下面命令：\nmvn versions:set-property -Dproperty=revision -DnewVersion=1.0.0-SNAPSHOT mvn versions:commit 3、本地在 feature 分支上完成一些开发之后，完成 feature 分支\ngit flow feature finish test 4、开始 release 分支\ngit flow release start 1.0.0 5、本地在 release 分支上完成一些开发之后，完成 feature 分支\n设置 maven 项目中版本为 release 版本。\nmvn versions:set -DnewVersion=1.0.0 mvn versions:commit 对于 maven 多模块项目，如果使用 revision 来统一定义版本号，则使用下面命令：\nmvn versions:set-property -Dproperty=revision -DnewVersion=1.0.0 mvn versions:commit 另外，对于多模块项目，需要在每个模块执行下面命令将 jar 推送到 maven 中央仓库：\nmvn deploy -DskipTests 然后完成分支：\ngit flow release finish 1.0.0 6、推送主分支和开发分支\ngit push origin develop git checkout main git push origin main 以上。\n","wordCount":"1491","inLanguage":"en","datePublished":"2023-05-11T14:00:00+08:00","dateModified":"2023-05-11T14:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/05/11/git-flow-model-and-usage/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Git Flow分支模型和使用</h1><div class=post-meta><span title='2023-05-11 14:00:00 +0800 +0800'>2023-05-11</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1491 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a></li><li><a href=#git-flow-%e5%88%86%e6%94%af%e6%a8%a1%e5%9e%8b aria-label="Git Flow 分支模型">Git Flow 分支模型</a></li><li><a href=#git-flow-%e5%b7%a5%e5%85%b7 aria-label="git-flow 工具">git-flow 工具</a><ul><li><a href=#feature-%e5%88%86%e6%94%af aria-label="feature 分支">feature 分支</a></li><li><a href=#release-%e5%88%86%e6%94%af aria-label="release 分支">release 分支</a></li><li><a href=#hotfixes-%e5%88%86%e6%94%af aria-label="Hotfixes 分支">Hotfixes 分支</a></li></ul></li><li><a href=#git-flow-avh-edition aria-label="git-flow (AVH Edition)">git-flow (AVH Edition)</a><ul><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=初始化>初始化</a></li><li><a href=#%e5%88%9b%e5%bb%ba-featurereleasehotfixsupport-%e5%88%86%e6%94%af aria-label="创建 feature/release/hotfix/support 分支">创建 feature/release/hotfix/support 分支</a></li><li><a href=#hooks-%e5%92%8c-filters aria-label="Hooks 和 Filters">Hooks 和 Filters</a></li></ul></li><li><a href=#github-flow-%e6%a8%a1%e5%9e%8b aria-label="GitHub Flow 模型">GitHub Flow 模型</a></li><li><a href=#gitlab-flow-%e6%a8%a1%e5%9e%8b aria-label="Gitlab flow 模型">Gitlab flow 模型</a></li><li><a href=#gitlab-flowgit-flow-%e5%92%8c-github-flow aria-label="GitLab Flow、Git Flow 和 GitHub Flow">GitLab Flow、Git Flow 和 GitHub Flow</a></li><li><a href=#%e5%85%b6%e4%bb%96-flow aria-label="其他 flow">其他 flow</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h2 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h2><p><a href=https://nvie.com/posts/a-successful-git-branching-model/>Git Flow</a> 是由 Vincent Driessen 在 2010 年提出的一种 Git 工作流。在这之前，Git 没有一个明确的标准工作流，导致团队在使用 Git 时往往会遇到一些问题，如分支管理、版本控制等。为了解决这些问题，Vincent Driessen 提出了 Git Flow 分支模型，成为了 Git 在实际应用中的一种标准工作流。</p><p>随着时间的推移，Git Flow 也在不断发展和完善。在 2011 年，Atlassian 发布了 SourceTree，这是一款图形化的 Git 客户端，支持 Git Flow 分支模型。在 2013 年，Git Flow 的一些开发者发布了 Git Flow AVH Edition，这是 Git Flow 的一个增强版本，提供了更多的功能和选项。此外，Git Flow 还得到了其他开源工具和平台的支持，如 GitHub、GitLab 等。</p><h2 id=git-flow-分支模型>Git Flow 分支模型<a hidden class=anchor aria-hidden=true href=#git-flow-分支模型>#</a></h2><p>Git Flow 分支模型定义了一种标准的 Git 分支模型，它将代码分为两个长期分支（master 和 develop）和三个短期分支（feature、release 和 hotfix），使得团队可以更好地管理代码的版本和发布。</p><p>以下是 Git Flow 分支模型的详细介绍：</p><ol><li>master 分支
master 分支是代码库的主分支，它包含了所有已发布的代码和版本。所有代码都应该在该分支上进行测试和验证，以确保代码的质量和稳定性。<code>master分支只能通过合并release或hotfix分支来更新</code>。</li><li>develop 分支
develop 分支是代码库的开发分支，它包含了所有开发中的代码和功能。所有新的代码都应该在该分支上进行开发和测试，以确保代码的可靠性和稳定性。<code>develop分支只能通过合并feature分支来更新</code>。</li><li>feature 分支
feature 分支是为开发新的功能或修复 bug 而创建的临时分支。<code>每个feature分支都是从develop分支分离出来的，开发完成后会合并回develop分支</code>。feature 分支的命名应该清晰明确，以反映该分支所涉及的功能或问题。</li><li>release 分支
release 分支是为发布新版本而创建的临时分支。<code>每个release分支都是从develop分支分离出来的，发布完成后会合并回develop分支和master分支</code>。在 release 分支上可以进行一些小的修复和调整，以确保发布的代码的质量和稳定性。</li><li>hotfix 分支
hotfix 分支是为快速修复生产环境中的问题而创建的临时分支。每个 hotfix 分支都是从 master 分支分离出来的，修复完成后会合并回 develop 分支和 master 分支。<code>hotfix分支的优先级比其他分支更高，因为它们需要尽快修复生产环境中的问题。</code></li></ol><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/git-model@2x.png alt=img></p><p>根据上面的理论，我们来实际操作一遍。首先，是 develop 分支创建一个 feature 分支。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout -b feature-test develop
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s2>&#34;feature-test&#34;</span>
</span></span></code></pre></div><p>将 feature 分支的修改合并到 develop 分支，然后删除 feature 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;develop&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git merge --no-ff feature-test
</span></span><span class=line><span class=cl>Updating ea1b82a..05e9557
</span></span><span class=line><span class=cl><span class=o>(</span>Summary of changes<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git branch -d feature-test
</span></span><span class=line><span class=cl>Deleted branch feature-test <span class=o>(</span>was 05e9557<span class=o>)</span>.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git push origin develop
</span></span></code></pre></div><p>合并分支时，添加<code>--no-ff</code> 参数和不添加的区别：</p><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/merge-without-ff@2x.png alt=img></p><p>从 develop 分支创建一个 release 分支，并将版本号改为 1.2 ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout -b release-1.2 develop
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s2>&#34;release-1.2&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./bump-version.sh 1.2
</span></span><span class=line><span class=cl>Files modified successfully, version bumped to 1.2.
</span></span><span class=line><span class=cl>$ git commit -a -m <span class=s2>&#34;Bumped version number to 1.2&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>release-1.2 74d9424<span class=o>]</span> Bumped version number to 1.2
</span></span><span class=line><span class=cl><span class=m>1</span> files changed, <span class=m>1</span> insertions<span class=o>(</span>+<span class=o>)</span>, <span class=m>1</span> deletions<span class=o>(</span>-<span class=o>)</span>
</span></span></code></pre></div><p>release 分支完成开发之后，将 release 分支合并到 master 分支，并创建一个标签：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;master&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git merge --no-ff release-1.2
</span></span><span class=line><span class=cl>Merge made by recursive.
</span></span><span class=line><span class=cl><span class=o>(</span>Summary of changes<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git tag -a 1.2
</span></span></code></pre></div><p>将 release 分支合并到 develop 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;develop&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git merge --no-ff release-1.2
</span></span><span class=line><span class=cl>Merge made by recursive.
</span></span><span class=line><span class=cl><span class=o>(</span>Summary of changes<span class=o>)</span>
</span></span></code></pre></div><p>最后删除 release 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch -d release-1.2
</span></span><span class=line><span class=cl>Deleted branch release-1.2 <span class=o>(</span>was ff452fe<span class=o>)</span>.
</span></span></code></pre></div><p>对于 hoftfix 分支，操作步骤和 release 分支类似，故不在赘述。</p><h2 id=git-flow-工具>git-flow 工具<a hidden class=anchor aria-hidden=true href=#git-flow-工具>#</a></h2><p>git-flow 工具可以简化上面的操作步骤，关于 git-flow 的介绍可以参考文章：<a href=https://jeffkreeftmeijer.com/git-flow/>Using git-flow to automate your git branching workflow</a>。</p><p>macos 上安装 git-flow：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>brew install git-flow
</span></span></code></pre></div><p>git-flow 首先需要初始化，如果不存在 develop 分支，则会新建一个 develop 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow init
</span></span><span class=line><span class=cl>No branches exist yet. Base branches must be created now.
</span></span><span class=line><span class=cl>Branch name <span class=k>for</span> production releases: <span class=o>[</span>master<span class=o>]</span>
</span></span><span class=line><span class=cl>Branch name <span class=k>for</span> <span class=s2>&#34;next release&#34;</span> development: <span class=o>[</span>develop<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>How to name your supporting branch prefixes?
</span></span><span class=line><span class=cl>Feature branches? <span class=o>[</span>feature-<span class=o>]</span>
</span></span><span class=line><span class=cl>Release branches? <span class=o>[</span>release-<span class=o>]</span>
</span></span><span class=line><span class=cl>Hotfix branches? <span class=o>[</span>hotfix/<span class=o>]</span>
</span></span><span class=line><span class=cl>Support branches? <span class=o>[</span>support/<span class=o>]</span>
</span></span><span class=line><span class=cl>Version tag prefix? <span class=o>[]</span>
</span></span></code></pre></div><h3 id=feature-分支>feature 分支<a hidden class=anchor aria-hidden=true href=#feature-分支>#</a></h3><p>开发一个新功能，创建一个新分支 foo</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=err>$</span> <span class=nx>git</span> <span class=nx>flow</span> <span class=nx>feature</span> <span class=nx>start</span> <span class=nx>foo</span>
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#切换到develop分支,确保新的 feature 分支是基于最新的 develop 分支创建的。</span>
</span></span><span class=line><span class=cl>$ git checkout -b feature-foo develop
</span></span></code></pre></div><p>取消正在进行中的功能分支，并且会将分支删除</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow feature delete foo
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch -D feature-foo
</span></span></code></pre></div><p>foo 功能自测通过后，合并到 develop</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow feature finish foo
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>//切换到 develop 分支
</span></span><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl>//将 feature-foo 分支中的更改合并到 develop 分支。 --no-ff 参数将保留 foo 分支的commit记录。
</span></span><span class=line><span class=cl>$ git merge --no-ff feature-foo
</span></span><span class=line><span class=cl>//删除已完成的分支
</span></span><span class=line><span class=cl>$ git branch -d feature-foo
</span></span></code></pre></div><h3 id=release-分支>release 分支<a hidden class=anchor aria-hidden=true href=#release-分支>#</a></h3><p>当所有新的功能和必要的修复已经被彻底的测试过了，那就开始生成一个新的 release , 在此之后不能添加新功能，只有错误修复、文档生成和其他面向发布的任务应该在该分支中进行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 1.0.0 是版本号</span>
</span></span><span class=line><span class=cl>$ git flow release start 1.0.0
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 从 develop 分支 创建release分支</span>
</span></span><span class=line><span class=cl>$ git checkout -b release-1.0.0 develop
</span></span></code></pre></div><p>取消正在进行中的发布分支，并且会将分支删除。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow release delete 1.0.0
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git branch -D release-1.0.0
</span></span></code></pre></div><p>添加完发布文档之后，完成 release</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow release finish 1.0.0
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#切换到 develop 分支。</span>
</span></span><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl><span class=c1>#将 release-1.0.0 分支合并到 develop 分支，--no-ff 选项以保留 feature 分支的 commit 记录</span>
</span></span><span class=line><span class=cl>$ git merge --no-ff release-1.0.0
</span></span><span class=line><span class=cl><span class=c1>#创建一个名为 1.0.0 的标签</span>
</span></span><span class=line><span class=cl>$ git tag -a 1.0.0 -m <span class=s2>&#34;Release 1.0.0&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#切换到 master 分支。</span>
</span></span><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl><span class=c1>#将 release-1.0.0 分支合并到 master 分支，--no-ff 选项以保留 feature 分支的 commit 记录</span>
</span></span><span class=line><span class=cl>$ git merge --no-ff release-1.0.0
</span></span><span class=line><span class=cl><span class=c1>#删除 release-1.0.0 分支。</span>
</span></span><span class=line><span class=cl>$ git branch -d release-1.0.0
</span></span></code></pre></div><h3 id=hotfixes-分支>Hotfixes 分支<a hidden class=anchor aria-hidden=true href=#hotfixes-分支>#</a></h3><p>线上发生问题的时候，先回滚到之前的稳定版本，稳定局势
然后创建热修复分支开始改 BUG</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow hotfix start 1.0.1
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#从master分支 创建一个hotfix/1.0.1分支</span>
</span></span><span class=line><span class=cl>$ git checkout -b hotfix/1.0.1 foo master
</span></span></code></pre></div><p>紧急修复完毕</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git flow hotfix finish 1.0.1
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#切换 master 分支</span>
</span></span><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl><span class=c1>#合并热修复分支到master,--no-ff 选项以保留 feature 分支的 commit 记录</span>
</span></span><span class=line><span class=cl>$ git merge --no-ff hotfix/ohno
</span></span><span class=line><span class=cl><span class=c1>#创建一个名为 1.0.1 的标签</span>
</span></span><span class=line><span class=cl>$ git tag 1.0.1
</span></span><span class=line><span class=cl><span class=c1>#切换到 develop 分支</span>
</span></span><span class=line><span class=cl>$ git checkout develop
</span></span><span class=line><span class=cl><span class=c1>#合并热修复分支到 develop ,--no-ff 选项以保留 feature 分支的 commit 记录</span>
</span></span><span class=line><span class=cl>$ git merge --no-ff hotfix/1.0.1
</span></span><span class=line><span class=cl><span class=c1>#删除热修复分支</span>
</span></span><span class=line><span class=cl>$ git branch -d hotfix/1.0.1
</span></span></code></pre></div><h2 id=git-flow-avh-edition>git-flow (AVH Edition)<a hidden class=anchor aria-hidden=true href=#git-flow-avh-edition>#</a></h2><p>Git-flow (AVH Edition)是 Git Flow 的一个增强版本，由一些 Git Flow 的开发者开发和维护。Git-flow (AVH Edition)在保留 Git Flow 基本思想的前提下，增加了一些新的功能和选项，使得 Git Flow 更加灵活和适用于不同的团队和项目。</p><p>Git-flow (AVH Edition)的主要增强功能包括：</p><ol><li>支持 git-flow init 命令，可以在一个新的 Git 仓库中快速初始化 Git Flow。</li><li>支持 git flow feature pull 命令，可以拉取其他团队成员的 feature 分支。</li><li>支持 git flow feature publish 命令，可以将 feature 分支发布到远程仓库。</li><li>支持 git flow hotfix finish 命令，可以在修复生产环境问题时自动合并到 develop 分支和 master 分支并发布新版本。</li><li>支持 git flow support 分支，可以为旧版本提供长期支持。</li><li>允许使用 Hooks and Filters 来扩展和自定义 Git Flow 的行为。</li></ol><p>除了以上功能之外，Git-flow (AVH Edition)还提供了更多的选项和配置，使得团队可以根据不同的需求和情况来自定义 Git Flow 的分支模型和工作流程。</p><h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3><p>使用下面命令初始化 git fow，<code>-d</code> 是可选参数，表示使用默认参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow init <span class=o>[</span>-d<span class=o>]</span>
</span></span></code></pre></div><h3 id=创建-featurereleasehotfixsupport-分支>创建 feature/release/hotfix/support 分支<a hidden class=anchor aria-hidden=true href=#创建-featurereleasehotfixsupport-分支>#</a></h3><p>查看、开始、完成、删除 feature 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow feature
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># &lt;base&gt; 参数必须是分支名称，缺失时，默认为 develop 分支</span>
</span></span><span class=line><span class=cl>git flow feature start &lt;name&gt; <span class=o>[</span>&lt;base&gt;<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git flow feature finish &lt;name&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git flow feature delete &lt;name&gt;
</span></span></code></pre></div><p>发布或者跟踪 feature 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#如果当前在 feature/name 分支，则可以省略 &lt;name&gt; 参数</span>
</span></span><span class=line><span class=cl>git flow feature publish &lt;name&gt;
</span></span><span class=line><span class=cl>git flow feature track &lt;name&gt;
</span></span></code></pre></div><p>当 feature 分支发布之后，其他人可以拉取该分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git pull
</span></span><span class=line><span class=cl>git checkout feature/&lt;name&gt;
</span></span></code></pre></div><p>类似地，查看、开始、完成、删除 release 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow release
</span></span><span class=line><span class=cl>git flow release start &lt;name&gt; <span class=o>[</span>&lt;base&gt;<span class=o>]</span>
</span></span><span class=line><span class=cl>git flow release finish &lt;name&gt;
</span></span><span class=line><span class=cl>git flow release delete &lt;name&gt;
</span></span></code></pre></div><p>类似地，查看、开始、完成、删除 hotfix 分支：</p><pre tabindex=0><code>git flow hotfix
git flow hotfix start &lt;name&gt; [&lt;base&gt;]
git flow hotfix finish &lt;name&gt;
git flow hotfix delete &lt;name&gt;
</code></pre><p>查看、开始 support 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow support
</span></span><span class=line><span class=cl>git flow support start &lt;name&gt; &lt;base&gt;
</span></span></code></pre></div><h3 id=hooks-和-filters>Hooks 和 Filters<a hidden class=anchor aria-hidden=true href=#hooks-和-filters>#</a></h3><p>Git-flow (AVH Edition)允许使用 Hooks and Filters 来扩展和自定义 Git Flow 的行为。Hooks 和 Filters 是 Git Flow 中的两个关键概念，它们可以在 Git Flow 的不同阶段执行自定义脚本或命令，从而实现 Git Flow 的高度定制化。</p><p>Hooks 是一些脚本或命令，它们会在 Git Flow 的不同阶段被调用。Git Flow (AVH Edition)支持以下 Hooks：</p><ol><li>git-flow-init: 该 Hook 会在 git-flow init 命令执行时被调用。</li><li>git-flow-feature-start: 该 Hook 会在创建新的 feature 分支时被调用。</li><li>git-flow-feature-finish: 该 Hook 会在完成 feature 分支时被调用。</li><li>git-flow-release-start: 该 Hook 会在创建新的 release 分支时被调用。</li><li>git-flow-release-finish: 该 Hook 会在完成 release 分支时被调用。</li><li>git-flow-hotfix-start: 该 Hook 会在创建新的 hotfix 分支时被调用。</li><li>git-flow-hotfix-finish: 该 Hook 会在完成 hotfix 分支时被调用。</li></ol><p>Filters 是一些命令或参数，它们会在 Git Flow 的不同阶段被过滤或修改。Git Flow (AVH Edition)支持以下 Filters：</p><ol><li>git-flow-feature-start-message: 可以用于修改 feature 分支创建时的提交信息。</li><li>git-flow-feature-finish-message: 可以用于修改 feature 分支完成时的提交信息。</li><li>git-flow-release-start-message: 可以用于修改 release 分支创建时的提交信息。</li><li>git-flow-release-finish-message: 可以用于修改 release 分支完成时的提交信息。</li><li>git-flow-hotfix-start-message: 可以用于修改 hotfix 分支创建时的提交信息。</li><li>git-flow-hotfix-finish-message: 可以用于修改 hotfix 分支完成时的提交信息。</li></ol><p>下面是一些使用 Hooks 和 Filters 的例子：</p><ol><li>使用 git-flow-init Hook</li></ol><p>如果需要在执行 git-flow init 命令时执行一些自定义脚本，可以使用 git-flow-init Hook。假设我们想在 git-flow init 命令执行时输出一些信息，可以在<code>.git/hooks/git-flow-init</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;Executing git-flow-init Hook&#34;</span>
</span></span></code></pre></div><ol start=2><li>使用 git-flow-feature-start Hook</li></ol><p>如果需要在创建新的 feature 分支时执行一些自定义脚本，可以使用 git-flow-feature-start Hook。假设我们想在创建新的 feature 分支时自动为该分支设置一些默认值，可以在<code>.git/hooks/git-flow-feature-start</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># Set default values for feature branch</span>
</span></span><span class=line><span class=cl>git config branch.<span class=nv>$GIT_BRANCH_NAME</span>.some_config_value <span class=s2>&#34;default_value&#34;</span>
</span></span></code></pre></div><ol start=3><li>使用 git-flow-feature-finish-message Filter</li></ol><p>如果需要修改 feature 分支完成时的提交信息，可以使用 git-flow-feature-finish-message Filter。假设我们想在 feature 分支完成时强制要求填写提交信息，可以在<code>.git/config</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=p>[</span><span class=nx>gitflow</span> <span class=s2>&#34;feature&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>finishmessage</span> <span class=p>=</span> <span class=nx>Please</span> <span class=nx>provide</span> <span class=nx>a</span> <span class=nx>meaningful</span> <span class=nx>commit</span> <span class=nx>message</span> <span class=nx>for</span> <span class=nx>the</span> <span class=nx>feature</span> <span class=nx>branch</span>
</span></span></code></pre></div><ol start=4><li>使用 git-flow-hotfix-start Hook</li></ol><p>如果需要在创建新的 hotfix 分支时执行一些自定义脚本，可以使用 git-flow-hotfix-start Hook。假设我们想在创建新的 hotfix 分支时自动为该分支设置一些默认值，可以在<code>.git/hooks/git-flow-hotfix-start</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># Set default values for hotfix branch</span>
</span></span><span class=line><span class=cl>git config branch.<span class=nv>$GIT_BRANCH_NAME</span>.some_config_value <span class=s2>&#34;default_value&#34;</span>
</span></span></code></pre></div><ol start=5><li>使用 git-flow-hotfix-finish Hook</li></ol><p>在<code>.git/hooks/git-flow-hotfix-finish</code>文件中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># Update version number in package.json</span>
</span></span><span class=line><span class=cl><span class=nv>VERSION</span><span class=o>=</span><span class=k>$(</span>cat package.json <span class=p>|</span> jq -r <span class=s1>&#39;.version&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>NEW_VERSION</span><span class=o>=</span><span class=k>$(</span><span class=nb>echo</span> <span class=nv>$VERSION</span> <span class=p>|</span> awk -F. <span class=s1>&#39;{$NF++;print}&#39;</span> <span class=p>|</span> sed <span class=s1>&#39;s/ /./g&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>sed -i <span class=s1>&#39;&#39;</span> <span class=s2>&#34;s/\&#34;version\&#34;: \&#34;</span><span class=nv>$VERSION</span><span class=s2>\&#34;/\&#34;version\&#34;: \&#34;</span><span class=nv>$NEW_VERSION</span><span class=s2>\&#34;/g&#34;</span> package.json
</span></span></code></pre></div><blockquote><p>该脚本用于修改前端项目中的版本号。</p></blockquote><h2 id=github-flow-模型>GitHub Flow 模型<a hidden class=anchor aria-hidden=true href=#github-flow-模型>#</a></h2><p>GitHub Flow 是一种基于 GitHub 的分支模型和代码开发工作流程，它是一个简单而灵活的模型，在敏捷开发和持续交付方面具有很高的效率。相比于 Git Flow，GitHub Flow 更加适合团队和开发者进行快速迭代和快速上线。</p><p>GitHub Flow 的分支模型非常简单：只有一个主分支（通常是 master 分支）和多个特性分支。主分支始终处于稳定状态并用于生产环境。每个特性分支用于开发新功能或修复 bug，并在开发人员完成相应的开发和测试工作后合并到主分支中。</p><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/github-flow.png alt="github flow"></p><p>GitHub Flow 遵循以下 6 条原则：</p><ol><li><code>master</code> 分支永远是随时可部署发布的</li><li>需求新增基于 <code>master</code> 分支，并创建一个语义化分支</li><li>定期推送本地分支到远端</li><li>合并到 <code>master</code> 需要提 <code>PR</code></li><li><code>PR</code> 一旦经过 <code>code review</code> 无误后即可合并到 <code>master</code></li><li><code>master</code> 一旦接收到合并请求，即可立即部署发布</li></ol><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/github-flow-whole.png alt=github-flow-whole></p><p>GitHub Flow 的代码开发工作流程如下：</p><ol><li>创建特性分支：从主分支中创建一个新的特性分支，用于开发新功能或修复 bug。</li><li>开发和测试：在特性分支上进行开发和测试，确保代码符合质量标准，并通过自动化测试。</li><li>发起合并请求：将特性分支合并到主分支中，发起一个合并请求（pull request），并邀请其他开发者进行代码审查和讨论。</li><li>代码审查：其他开发者对代码进行审查和讨论，提出意见和建议，并确保代码符合质量标准和最佳实践。</li><li>合并代码：在经过审查和讨论后，将特性分支合并到主分支中，并将代码部署到生产环境。</li><li>部署代码：在合并到主分支后，使用自动化部署工具将代码部署到生产环境。</li></ol><h2 id=gitlab-flow-模型>Gitlab flow 模型<a hidden class=anchor aria-hidden=true href=#gitlab-flow-模型>#</a></h2><p>GitLab Flow 是一个基于 GitLab 的分支模型和开发工作流程，旨在支持敏捷开发和持续交付。</p><p><code>GitLab</code> 在 2014 年提出 <code>11</code> 条最佳实践，更多请点击<a href=https://about.gitlab.com/topics/version-control/what-are-gitlab-flow-best-practices/>这里</a>，其相对 <code>GitHub</code> 增加了环境分支，且代码必须由<code>上游</code>（<code>master</code>）向<code>下游</code>（<code>staging</code>）发展，并且针对持续发布和版本发布都提出了相应的准则，下面是其大致流程图：</p><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/gilab-flow-cidi.png alt=img></p><p>GitLab Flow 的主要特点包括：</p><ol><li>简单的分支模型：GitLab Flow 使用一个简单的分支模型，包括一个主分支（通常命名为“master”或“production”）和一个开发分支（通常命名为“develop”或“staging”）。特性分支从开发分支创建，并在特性或错误修复完成并通过测试后合并回开发分支中。</li><li>持续集成和交付：GitLab Flow 强调持续集成和交付（CI/CD），这意味着每次对代码的更改都会自动构建、测试和部署到测试环境或生产环境（如果测试通过）。</li><li>代码审查：GitLab Flow 鼓励进行代码审查，这意味着每次对代码的更改都会由至少一个其他开发人员进行审查，以确保其符合质量标准并不会引入任何安全漏洞。</li><li>合并请求：GitLab Flow 使用合并请求来管理将代码更改合并到主分支的过程。合并请求允许开发人员在将更改合并到主分支之前对其进行审查和讨论。</li><li>环境管理：GitLab Flow 提供高级的环境管理功能，允许团队创建和管理不同的开发、测试、暂存和生产环境。</li></ol><blockquote><p>GitLab Flow 提供了高级的环境管理功能，可以帮助团队更好地管理不同的开发、测试、暂存和生产环境。以下是使用 GitLab Flow 进行环境管理的一些方法：</p><ol><li>创建不同的环境分支：在 GitLab Flow 中，可以为不同的环境创建分支。例如，可以创建一个名为“develop”的开发分支，一个名为“staging”的暂存分支，和一个名为“production”的生产分支。这些分支可以帮助团队更好地管理不同环境的代码，确保每个环境都有自己的代码版本。</li><li>配置环境变量：在 GitLab 中，可以为每个环境设置不同的环境变量。这些环境变量可以用于配置不同环境中的应用程序和服务，例如数据库连接字符串、API 密钥等。通过设置正确的环境变量，可以确保应用程序在不同环境中正确运行。</li><li>自动化部署和测试：GitLab Flow 支持自动化部署和测试，可以帮助团队更快地部署代码到不同环境中。可以使用 GitLab 的 CI/CD 管道来自动化测试和部署过程，并将代码推送到正确的环境分支中。</li><li>环境监控和报告：GitLab Flow 还支持环境监控和报告功能，可以帮助团队更好地了解不同环境的运行状况和性能。可以使用 GitLab 的监控和报告工具来监视不同环境的性能指标、错误率等，并及时发现和解决问题。</li></ol></blockquote><p>GitLab Flow 的分支模型如下：</p><ol><li>主分支：主分支始终处于稳定状态，并用于生产环境。在 GitLab Flow 中，主分支通常是 master 分支或 production 分支。</li><li>特性分支：特性分支用于开发新功能或修复 bug，并从主分支中创建。在 GitLab Flow 中，特性分支通常以 feature/或 fix/为前缀。</li><li>集成分支：集成分支用于将特性分支集成到主分支中，并进行测试和部署。在 GitLab Flow 中，集成分支通常是 develop 分支或 staging 分支。</li><li>发布分支：发布分支用于将特性分支和集成分支的代码发布到生产环境中。在 GitLab Flow 中，发布分支通常是 release/为前缀的分支。</li></ol><p>GitLab Flow 的开发工作流程如下：</p><ol><li>创建特性分支：从主分支中创建一个新的特性分支，用于开发新功能或修复 bug。</li><li>开发和测试：在特性分支上进行开发和测试，确保代码符合质量标准，并通过自动化测试。</li><li>合并到集成分支：将特性分支合并到集成分支中，并进行集成测试和自动化部署。</li><li>发布到生产环境：将集成分支的代码发布到生产环境中，并进行最终测试和部署。</li><li>合并到主分支：在发布到生产环境后，将集成分支合并到主分支中，并将代码部署到生产环境。</li></ol><p>GitLab Flow 强调 CI/CD 集成和测试自动化，以确保代码质量和快速迭代。它还支持自动化部署和环境管理，以帮助开发人员更轻松地管理不同环境和部署代码。GitLab Flow 是一个灵活和强大的开发工作流程，适用于各种类型的项目和团队。</p><h2 id=gitlab-flowgit-flow-和-github-flow>GitLab Flow、Git Flow 和 GitHub Flow<a hidden class=anchor aria-hidden=true href=#gitlab-flowgit-flow-和-github-flow>#</a></h2><p>GitLab Flow、Git Flow 和 GitHub Flow 都是三种常见的基于 Git 的工作流程。下面是 GitLab Flow 与其他工作流程的主要区别：</p><ol><li>GitLab Flow 与 Git Flow 的比较：</li></ol><ul><li><p>GitLab Flow 比 Git Flow 更简单和更灵活。Git Flow 有一个更复杂的分支模型，包含多个长期存在的分支，而 GitLab Flow 只使用几个主要分支和特性分支。</p></li><li><p>GitLab Flow 强调持续集成和持续部署（CI/CD），鼓励频繁合并到主要分支。Git Flow 更注重版本控制和发布管理。</p></li><li><p>GitLab Flow 与 GitLab 内置的 CI/CD 管道更紧密地集成在一起，更容易自动化开发工作流程。</p></li></ul><ol start=2><li>GitLab Flow 与 GitHub Flow 的比较：</li></ol><ul><li>GitLab Flow 和 GitHub Flow 有许多相似之处，例如它们都以 GitHub 或 GitLab 作为中央仓库，使用特性分支进行开发。</li><li>GitLab Flow 强调 CI/CD 集成和测试自动化，而 GitHub Flow 更注重代码审查和协作。</li><li>GitLab Flow 还提供更高级的环境管理、部署和监控功能，更适合于大型、复杂的项目。</li></ul><p>总体而言，GitLab Flow 比 Git Flow 更简单和更灵活，强调 CI/CD 集成和自动化。与 GitHub Flow 相比，GitLab Flow 提供更高级的环境管理和部署功能，更适合于大型、复杂的项目。选择哪种工作流程最终取决于项目和开发团队的具体需求和要求。</p><h2 id=其他-flow>其他 flow<a hidden class=anchor aria-hidden=true href=#其他-flow>#</a></h2><ul><li>TrunkBased</li><li>OneFlow</li><li>AoneFlow</li></ul><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>目前公司代码部署在自建的 gitlab 上面，对于公司的项目，个人倾向于使用 git-flow 分支模型，并且使用 git-flow (AVH Edition) 来简化操作。</p><p>目前，我参与的大多数项目都是 java 项目并且使用 maven 进行构建。</p><p>在 Maven 项目中，可以使用 Maven 版本控制器来区分 release 版本和 snapshot 版本。</p><ul><li><p><strong>Release 版本</strong></p><p>对于 Git Flow 中的 release 分支，通常用于为生产环境准备代码。</p><p>在 Maven 项目中，可以使用 Maven Release 插件来自动化创建和发布 release 版本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn release:prepare
</span></span><span class=line><span class=cl>mvn release:perform
</span></span></code></pre></div><p>使用这些命令，Maven Release 插件会自动更新项目版本号、创建 tag、构建 release 版本，并发布到 Maven 仓库中。发布的版本号不包含 <code>-SNAPSHOT</code> 后缀。</p><p>或者，使用 <code>mvn versions</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set -DnewVersion<span class=o>=</span>1.0.0-SNAPSHOT
</span></span><span class=line><span class=cl>mvn versions:commit
</span></span></code></pre></div></li><li><p><strong>Snapshot 版本</strong></p><p>对于 Git Flow 中的 feature 和 develop 分支，通常用于开发和测试新功能或 bug 修复，这些分支使用 snapshot 版本。在 Maven 中，snapshot 版本的版本号包含 <code>-SNAPSHOT</code> 后缀，表示当前版本是正在开发的版本。</p></li></ul><p>对于这些项目，git-flow 操作步骤如下：</p><p>1、初始化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow init -d
</span></span></code></pre></div><p>2、开始 feature 分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow feature start <span class=nb>test</span>
</span></span></code></pre></div><p>设置 maven 项目中版本为 snapshot 版本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set -DnewVersion<span class=o>=</span>1.0.0-SNAPSHOT
</span></span><span class=line><span class=cl>mvn versions:commit
</span></span></code></pre></div><p>对于 maven 多模块项目，如果使用 revision 来统一定义版本号，则使用下面命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set-property -Dproperty<span class=o>=</span>revision -DnewVersion<span class=o>=</span>1.0.0-SNAPSHOT
</span></span><span class=line><span class=cl>mvn versions:commit
</span></span></code></pre></div><p>3、本地在 feature 分支上完成一些开发之后，完成 feature 分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow feature finish <span class=nb>test</span>
</span></span></code></pre></div><p>4、开始 release 分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow release start 1.0.0
</span></span></code></pre></div><p>5、本地在 release 分支上完成一些开发之后，完成 feature 分支</p><p>设置 maven 项目中版本为 release 版本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set -DnewVersion<span class=o>=</span>1.0.0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mvn versions:commit
</span></span></code></pre></div><p>对于 maven 多模块项目，如果使用 revision 来统一定义版本号，则使用下面命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn versions:set-property -Dproperty<span class=o>=</span>revision -DnewVersion<span class=o>=</span>1.0.0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mvn versions:commit
</span></span></code></pre></div><p>另外，对于多模块项目，需要在每个模块执行下面命令将 jar 推送到 maven 中央仓库：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn deploy -DskipTests
</span></span></code></pre></div><p>然后完成分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git flow release finish 1.0.0
</span></span></code></pre></div><p>6、推送主分支和开发分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git push origin develop
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git checkout main
</span></span><span class=line><span class=cl>git push origin main
</span></span></code></pre></div><p>以上。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/><span class=title>« Prev</span><br><span>《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/05/10/weekly_review_18/><span class=title>Next »</span><br><span>周报-18｜导出豆瓣数据、Effective Java 3第二章总结</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Git Flow分支模型和使用 on x" href="https://x.com/intent/tweet/?text=Git%20Flow%e5%88%86%e6%94%af%e6%a8%a1%e5%9e%8b%e5%92%8c%e4%bd%bf%e7%94%a8&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f11%2fgit-flow-model-and-usage%2f&amp;hashtags=git"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git Flow分支模型和使用 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f11%2fgit-flow-model-and-usage%2f&amp;title=Git%20Flow%e5%88%86%e6%94%af%e6%a8%a1%e5%9e%8b%e5%92%8c%e4%bd%bf%e7%94%a8&amp;summary=Git%20Flow%e5%88%86%e6%94%af%e6%a8%a1%e5%9e%8b%e5%92%8c%e4%bd%bf%e7%94%a8&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f11%2fgit-flow-model-and-usage%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git Flow分支模型和使用 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f11%2fgit-flow-model-and-usage%2f&title=Git%20Flow%e5%88%86%e6%94%af%e6%a8%a1%e5%9e%8b%e5%92%8c%e4%bd%bf%e7%94%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git Flow分支模型和使用 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f11%2fgit-flow-model-and-usage%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git Flow分支模型和使用 on whatsapp" href="https://api.whatsapp.com/send?text=Git%20Flow%e5%88%86%e6%94%af%e6%a8%a1%e5%9e%8b%e5%92%8c%e4%bd%bf%e7%94%a8%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f11%2fgit-flow-model-and-usage%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git Flow分支模型和使用 on telegram" href="https://telegram.me/share/url?text=Git%20Flow%e5%88%86%e6%94%af%e6%a8%a1%e5%9e%8b%e5%92%8c%e4%bd%bf%e7%94%a8&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f11%2fgit-flow-model-and-usage%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git Flow分支模型和使用 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Git%20Flow%e5%88%86%e6%94%af%e6%a8%a1%e5%9e%8b%e5%92%8c%e4%bd%bf%e7%94%a8&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f11%2fgit-flow-model-and-usage%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>