<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JSR 166规范 | ChenSoul</title><meta name=keywords content="java"><meta name=description content="JSR 介绍 JSR，全称 Java Specification Requests， 即Java规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.com/posts/2023/05/18/jsr-166/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.chensoul.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=msvalidate.01 content="8E787EFCDB0CE747FE1A4DA0ABEC66E4"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="JSR 166规范"><meta property="og:description" content="JSR 介绍 JSR，全称 Java Specification Requests， 即Java规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.com/posts/2023/05/18/jsr-166/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-18T16:00:00+08:00"><meta property="article:modified_time" content="2023-05-18T16:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="JSR 166规范"><meta name=twitter:description content="JSR 介绍 JSR，全称 Java Specification Requests， 即Java规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.com/posts/"},{"@type":"ListItem","position":2,"name":"JSR 166规范","item":"https://blog.chensoul.com/posts/2023/05/18/jsr-166/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JSR 166规范","name":"JSR 166规范","description":"JSR 介绍 JSR，全称 Java Specification Requests， 即Java规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR","keywords":["java"],"articleBody":"JSR 介绍 JSR，全称 Java Specification Requests， 即Java规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间API对应的是 JSR 310。\nJSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。\nJ.U.C，即 java.util.concurrent 的缩写，该包参考自EDU.oswego.cs.dl.util.concurrent，是JSR 166标准规范的一个实现。\nDoug Lea 主页：Doug Lea’s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：\nJSR-166（Java SE 5）：定义了Java并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了Java并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了Java并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java.util.concurrent 包下的类以及引入版本（没有标注版本号的为 1.5 ）：\njava.util.concurrent java.util.concurrent.locks AbstractOwnableSynchronizer 1.6 AbstractQueuedLongSynchronizer 1.6 AbstractQueuedSynchronizer Condition Lock LockSupport ReadWriteLock ReentrantLock ReentrantReadWriteLock StampedLock 1.8 java.util.concurrent.atomic AtomicBoolean AtomicInteger AtomicIntegerArray AtomicIntegerFieldUpdater AtomicLong AtomicLongArray AtomicLongFieldUpdater AtomicMarkableReference AtomicReference AtomicReferenceArray AtomicReferenceFieldUpdater AtomicStampedReference DoubleAccumulator 1.8 DoubleAdder 1.8 LongAccumulator 1.8 LongAdder 1.8 AbstractExecutorService ArrayBlockingQueue BlockingDeque 1.6 BlockingQueue BrokenBarrierException Callable CancellationException CompletableFuture 1.8 CompletionException 1.8 CompletionService CompletionStage 1.8 ConcurrentHashMap ConcurrentLinkedDeque 1.7 ConcurrentLinkedQueue ConcurrentMap ConcurrentNavigableMap 1.6 ConcurrentSkipListMap 1.6 ConcurrentSkipListSet 1.6 CopyOnWriteArrayList CopyOnWriteArraySet CountDownLatch CountedCompleter 1.8 CyclicBarrier Delayed DelayQueue Exchanger ExecutionException Executor ExecutorCompletionService Executors ExecutorService Flow 1.9 ForkJoinPool 1.7 ForkJoinTask 1.7 ForkJoinWorkerThread 1.7 Future FutureTask LinkedBlockingDeque 1.6 LinkedBlockingQueue LinkedTransferQueue 1.7 Phaser 1.7 PriorityBlockingQueue RecursiveAction 1.7 RecursiveTask 1.7 RejectedExecutionException RejectedExecutionHandler RunnableFuture RunnableScheduledFuture ScheduledExecutorService ScheduledFuture ScheduledThreadPoolExecutor Semaphore SubmissionPublisher 1.9 SynchronousQueue ThreadFactory ThreadLocalRandom 1.7 ThreadPoolExecutor TimeoutException TimeUnit TransferQueue 1.7 大致可以分为以下几类：\n原子更新 锁和条件 线程池 并发容器 同步器 在学习 JUC 之前我们需要了解 CAS，AQS 和 Unsafe。\nCAS： AQS： Unsafe： CAS CAS（Compare and Swap）是一种基于原子性操作的并发编程技术，常用于实现线程安全的数据结构和算法。CAS操作由三个参数组成：内存位置V、期望值A、新值B。当且仅当V的值等于A时，CAS操作才会将V的值设置为B，否则不做任何操作。它的实现原理可以简单概括为以下几个步骤：\n读取内存位置V的值，同时记录下该值的版本号或标记位。 检查内存位置V的值是否等于期望值A。如果相等，则执行第3步；否则，操作失败。 将新值B写入内存位置V，并更新其版本号或标记位。 返回操作结果。 CAS操作是一种乐观锁机制，它不需要锁定整个共享资源，而是只针对需要修改的值进行原子性操作，从而避免了锁的竞争和开销。在执行CAS操作时，线程会对内存位置进行读取和写入，但同时也会检查内存位置的版本号或标记位，以保证操作的原子性和一致性。\n需要注意的是，如果多个线程同时执行CAS操作，可能会出现ABA问题。例如，线程A读取内存位置V的值为A，然后线程B将V的值修改为B，最后线程B又将V的值修改为A。此时，线程A执行CAS操作时，会发现内存位置V的值还是A，虽然这个A的版本号或标记位与之前不同，但线程A并不知道V的值曾经被修改过，因此会将新值写入内存位置V，从而导致数据不一致。为了解决ABA问题，可以使用带有版本号或标记位的CAS操作，或者使用其他的并发编程技术，例如锁或读写锁。\nJava中的AtomicXXX类实现了CAS操作，例如AtomicInteger、AtomicLong等。这些类提供了一组原子性操作方法，例如get()、set()、addAndGet()、compareAndSet()等，它们可以被多个线程安全地使用。\nCAS操作虽然免去了锁的开销，但也存在一些问题。首先，CAS操作需要进行多次尝试，直到成功为止。如果并发程度较高，多个线程同时进行CAS操作，可能会导致大量的CAS操作失败，从而降低性能。其次，CAS操作只能保证单个变量的原子性操作，无法保证多个变量之间的操作的原子性，因此需要额外的措施来保证多个变量之间的一致性。\n下面是一个使用AtomicInteger实现简单计数器的例子：\nimport java.util.concurrent.atomic.AtomicInteger; public class Counter { private AtomicInteger value = new AtomicInteger(0); public void increment() { int oldValue, newValue; do { oldValue = value.get(); newValue = oldValue + 1; } while (!value.compareAndSet(oldValue, newValue)); } public int getValue() { return value.get(); } } 在上面的示例中，increment() 方法使用do-while循环和compareAndSet()方法执行CAS操作来增加计数器的值。该方法重复使用get()方法读取计数器的当前值，计算新值，然后尝试使用compareAndSet()方法更新计数器。循环将继续，直到CAS操作成功并且计数器成功更新。\ngetValue() 方法使用get()方法简单地返回计数器的当前值。\n需要注意的是，在使用CAS操作时，需要小心处理潜在的ABA问题，其中共享变量的值可能在初始读取和更新尝试之间多次更改。一种处理方法是在共享变量中使用版本号或时间戳，以确保更新仅在值未更改的情况下成功。\nABA问题是在使用CAS（Compare-and-Swap）操作进行并发编程时经常遇到的一个问题。它发生在一个线程从共享内存位置读取一个值，然后另一个线程将该值更改为另一个值，最后又将其更改回原始值，从而使第一个线程的操作意外成功。\n为了处理ABA问题，常用的方法是在共享内存位置中添加一个版本号或时间戳。版本号或时间戳可以在每次修改内存位置时进行递增或更新。这可以确保CAS操作不仅检查值，还检查内存位置的版本号或时间戳。\n以下是使用版本号处理ABA问题的示例：\nimport java.util.concurrent.atomic.AtomicStampedReference; public class ConcurrentStack\u003cT\u003e { private AtomicStampedReference\u003cNode\u003cT\u003e\u003e top = new AtomicStampedReference\u003c\u003e(null, 0); public void push(T value) { Node\u003cT\u003e newHead = new Node\u003c\u003e(value); int[] stampHolder = new int[1]; Node\u003cT\u003e oldHead; do { oldHead = top.get(stampHolder); newHead.next = oldHead; stampHolder[0]++; } while (!top.compareAndSet(oldHead, newHead, stampHolder[0] - 1, stampHolder[0])); } public T pop() { Node\u003cT\u003e oldHead; int[] stampHolder = new int[1]; do { oldHead = top.get(stampHolder); if (oldHead == null) { return null; } } while (!top.compareAndSet(oldHead, oldHead.next, stampHolder[0], stampHolder[0] + 1)); return oldHead.value; } private static class Node\u003cT\u003e { private final T value; private Node\u003cT\u003e next; private Node(T value) { this.value = value; } } } 在上面的示例中，ConcurrentStack 类使用 AtomicStampedReference 存储栈顶节点。AtomicStampedReference 类存储值的引用和版本号，版本号在引用更改时进行更新。\npush() 方法使用新值创建一个新的 Node，然后尝试使用CAS操作将其推入栈中。循环将继续，直到CAS操作成功，节点成功推入栈中。\npop() 方法尝试使用CAS操作从栈中弹出顶部节点。循环将继续，直到顶部节点成功弹出或栈为空为止。\n通过使用具有版本号的 AtomicStampedReference，ConcurrentStack 类可以处理在并发操作中可能发生的ABA问题。\nAQS AQS（AbstractQueuedSynchronizer）是Java中用于实现同步器（如锁，信号量等）的框架，它提供了一些基本的同步操作，例如获取锁、释放锁、等待条件、唤醒线程等。\nAQS的实现原理基于一个双向链表，用于维护等待线程的队列。当一个线程需要获取同步器时，它会首先尝试使用CAS操作来获取同步器，如果获取成功，则继续执行；如果获取失败，则将线程加入等待队列中，并将其挂起。当同步器释放时，它会唤醒等待队列中的一个或多个线程，并将它们从等待队列中移除，使它们可以继续执行。\nAQS的等待队列是通过一个双向链表来实现的，每个节点代表一个等待线程，节点中包含了线程的状态以及等待条件等信息。等待队列中的节点是按照等待时间的先后顺序排列的，先等待的线程排在前面，后等待的线程排在后面。当一个线程被唤醒时，它会重新尝试获取同步器，如果获取成功，则继续执行；如果获取失败，则它会再次加入等待队列中，并将自己挂起。\nAQS的具体实现是通过重写其内部的一些方法来实现的。例如，tryAcquire() 方法用于实现获取同步器的逻辑，它会首先尝试使用CAS操作来获取同步器，如果获取成功，则返回 true；否则返回 false。tryRelease() 方法用于实现释放同步器的逻辑，它会释放同步器，并唤醒等待队列中的一个或多个线程。tryAcquireShared() 和 tryReleaseShared() 方法则用于实现共享式同步器的逻辑，它们类似于 tryAcquire() 和 tryRelease() 方法，但是可以支持多个线程同时获取或释放同步器。\nUnsafe Unsafe类是Java中一个非常特殊且强大的类，它提供了一些不安全的操作，例如直接操作内存、线程挂起和恢复等。Unsafe类是Java中少数几个不被公开支持的类之一，它主要被用于Java核心库和其他一些高级框架中，如Netty、Hadoop和Kafka等。\n由于Unsafe类提供了一些不安全的操作，因此它的使用需要非常小心。如果不正确地使用Unsafe类，可能会导致程序崩溃或安全漏洞。因此，Java官方并不建议开发人员使用Unsafe类，而是建议开发人员使用更加安全和标准的Java API。\nUnsafe类中一些常用的方法包括：\nallocateMemory(long size)：分配一段指定大小的内存空间。 freeMemory(long address)：释放指定地址的内存空间。 putXXX(Object target, long offset, XXX value)：将指定类型的值写入目标对象的指定偏移量处。 getXXX(Object target, long offset)：从目标对象的指定偏移量处读取指定类型的值。 park(boolean isAbsolute, long time)：挂起当前线程，直到被其他线程唤醒或指定的时间到期。 unpark(Thread thread)：恢复指定线程的运行。 需要注意的是，Unsafe类中的大部分方法都是native方法，实现方式依赖于底层操作系统和硬件平台。这意味着Unsafe类中的方法在不同的平台上可能会有不同的行为，因此需要针对不同的平台进行测试和验证。\nJava 9中官方提出了移除Sun.misc.Unsafe类，并在该版本中将该类标记为不推荐使用。然而，由于Unsafe类在Java语言生态中的应用非常广泛，许多框架和库都依赖于Unsafe类来实现高性能和低层次的操作。因此，在Java 9中，官方引入了jdk.internal.misc.Unsafe类来替代Sun.misc.Unsafe类的功能，以保持对Java生态中使用Unsafe类的支持。\n","wordCount":"4375","inLanguage":"en","datePublished":"2023-05-18T16:00:00+08:00","dateModified":"2023-05-18T16:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.com/posts/2023/05/18/jsr-166/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.com/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.com/categories/ideas title=周报><span>周报</span></a></li><li><a href=https://blog.chensoul.com/categories/notes title=编程><span>编程</span></a></li><li><a href=https://blog.chensoul.com/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.com/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>JSR 166规范</h1><div class=post-meta><span title='2023-05-18 16:00:00 +0800 +0800'>2023-05-18</span>&nbsp;·&nbsp;chensoul</div></header><div class=post-content><h2 id=jsr-介绍>JSR 介绍<a hidden class=anchor aria-hidden=true href=#jsr-介绍>#</a></h2><p>JSR，全称 Java Specification Requests， 即Java规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 <a href="http://jcp.org/en/jsr/detail?id=335">JSR 335</a>，新的日期和时间API对应的是 <a href="http://jcp.org/en/jsr/detail?id=310">JSR 310</a>。</p><p><a href="https://jcp.org/en/jsr/detail?id=166">JSR 166</a> 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。</p><p>J.U.C，即 <code>java.util.concurrent</code> 的缩写，该包参考自EDU.oswego.cs.dl.util.concurrent，是JSR 166标准规范的一个实现。</p><ul><li>Doug Lea 主页：<a href=https://gee.cs.oswego.edu/>Doug Lea&rsquo;s Home Page</a></li><li>JSR-166：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/index.html>Concurrency JSR-166 Interest Site</a></li><li>JSR 166 Slider：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf>JSR-166: Concurrency Utilities</a></li><li>java.util.concurrent JavaDoc: <a href=https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/package-summary.html>JDK 1.5 </a>、 <a href=https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html>JDK 7 </a>、 <a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html>JDK 8 </a>、 <a href=https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/package-summary.html>JDK 9</a></li></ul><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/jsr-166-concurrency-utilities.png alt=jsr-166-concurrency-utilities></p><p>JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：</p><ol><li><code>JSR-166（Java SE 5）</code>：定义了Java并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。</li><li><code>JSR-166x（Java SE 7）</code>：定义了Java并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。</li><li><code>JSR-166y（Java SE 8）</code>：定义了Java并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。</li><li><code>JSR-166z（Java SE 9）</code>：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。</li></ol><h2 id=juc>JUC<a hidden class=anchor aria-hidden=true href=#juc>#</a></h2><p>java.util.concurrent 包下的类以及引入版本（没有标注版本号的为 <code>1.5</code> ）：</p><ul><li>java.util.concurrent<ul><li>java.util.concurrent.locks<ul><li>AbstractOwnableSynchronizer <code>1.6</code></li><li>AbstractQueuedLongSynchronizer <code>1.6</code></li><li>AbstractQueuedSynchronizer</li><li>Condition</li><li>Lock</li><li>LockSupport</li><li>ReadWriteLock</li><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>StampedLock <code>1.8</code></li></ul></li><li>java.util.concurrent.atomic<ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicIntegerArray</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLong</li><li>AtomicLongArray</li><li>AtomicLongFieldUpdater</li><li>AtomicMarkableReference</li><li>AtomicReference</li><li>AtomicReferenceArray</li><li>AtomicReferenceFieldUpdater</li><li>AtomicStampedReference</li><li>DoubleAccumulator <code>1.8</code></li><li>DoubleAdder <code>1.8</code></li><li>LongAccumulator <code>1.8</code></li><li>LongAdder <code>1.8</code></li></ul></li><li>AbstractExecutorService</li><li>ArrayBlockingQueue</li><li>BlockingDeque <code>1.6</code></li><li>BlockingQueue</li><li>BrokenBarrierException</li><li>Callable</li><li>CancellationException</li><li>CompletableFuture <code>1.8</code></li><li>CompletionException <code>1.8</code></li><li>CompletionService</li><li>CompletionStage <code>1.8</code></li><li>ConcurrentHashMap</li><li>ConcurrentLinkedDeque <code>1.7</code></li><li>ConcurrentLinkedQueue</li><li>ConcurrentMap</li><li>ConcurrentNavigableMap <code>1.6</code></li><li>ConcurrentSkipListMap <code>1.6</code></li><li>ConcurrentSkipListSet <code>1.6</code></li><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet</li><li>CountDownLatch</li><li>CountedCompleter <code>1.8</code></li><li>CyclicBarrier</li><li>Delayed</li><li>DelayQueue</li><li>Exchanger</li><li>ExecutionException</li><li>Executor</li><li>ExecutorCompletionService</li><li>Executors</li><li>ExecutorService</li><li>Flow <code>1.9</code></li><li>ForkJoinPool <code>1.7</code></li><li>ForkJoinTask <code>1.7</code></li><li>ForkJoinWorkerThread <code>1.7</code></li><li>Future</li><li>FutureTask</li><li>LinkedBlockingDeque <code>1.6</code></li><li>LinkedBlockingQueue</li><li>LinkedTransferQueue <code>1.7</code></li><li>Phaser <code>1.7</code></li><li>PriorityBlockingQueue</li><li>RecursiveAction <code>1.7</code></li><li>RecursiveTask <code>1.7</code></li><li>RejectedExecutionException</li><li>RejectedExecutionHandler</li><li>RunnableFuture</li><li>RunnableScheduledFuture</li><li>ScheduledExecutorService</li><li>ScheduledFuture</li><li>ScheduledThreadPoolExecutor</li><li>Semaphore</li><li>SubmissionPublisher <code>1.9</code></li><li>SynchronousQueue</li><li>ThreadFactory</li><li>ThreadLocalRandom <code>1.7</code></li><li>ThreadPoolExecutor</li><li>TimeoutException</li><li>TimeUnit</li><li>TransferQueue <code>1.7</code></li></ul></li></ul><p>大致可以分为以下几类：</p><ul><li>原子更新</li><li>锁和条件</li><li>线程池</li><li>并发容器</li><li>同步器</li></ul><p>在学习 <code>JUC</code> 之前我们需要了解 <code>CAS</code>，<code>AQS</code> 和 <code>Unsafe</code>。</p><ul><li>CAS：</li><li>AQS：</li><li>Unsafe：</li></ul><h2 id=cas>CAS<a hidden class=anchor aria-hidden=true href=#cas>#</a></h2><p>CAS（<code>Compare and Swap</code>）是一种基于原子性操作的并发编程技术，常用于实现线程安全的数据结构和算法。CAS操作由三个参数组成：内存位置V、期望值A、新值B。当且仅当V的值等于A时，CAS操作才会将V的值设置为B，否则不做任何操作。它的实现原理可以简单概括为以下几个步骤：</p><ol><li>读取内存位置V的值，同时记录下该值的版本号或标记位。</li><li>检查内存位置V的值是否等于期望值A。如果相等，则执行第3步；否则，操作失败。</li><li>将新值B写入内存位置V，并更新其版本号或标记位。</li><li>返回操作结果。</li></ol><p>CAS操作是一种<code>乐观锁</code>机制，它不需要锁定整个共享资源，而是只针对需要修改的值进行原子性操作，从而避免了锁的竞争和开销。在执行CAS操作时，线程会对内存位置进行读取和写入，但同时也会检查内存位置的版本号或标记位，以保证操作的原子性和一致性。</p><p>需要注意的是，如果多个线程同时执行CAS操作，可能会出现ABA问题。例如，线程A读取内存位置V的值为A，然后线程B将V的值修改为B，最后线程B又将V的值修改为A。此时，线程A执行CAS操作时，会发现内存位置V的值还是A，虽然这个A的版本号或标记位与之前不同，但线程A并不知道V的值曾经被修改过，因此会将新值写入内存位置V，从而导致数据不一致。为了解决ABA问题，可以使用带有版本号或标记位的CAS操作，或者使用其他的并发编程技术，例如锁或读写锁。</p><p>Java中的<code>AtomicXXX</code>类实现了CAS操作，例如AtomicInteger、AtomicLong等。这些类提供了一组原子性操作方法，例如get()、set()、addAndGet()、compareAndSet()等，它们可以被多个线程安全地使用。</p><p>CAS操作虽然免去了锁的开销，但也存在一些问题。首先，CAS操作需要进行多次尝试，直到成功为止。如果并发程度较高，多个线程同时进行CAS操作，可能会导致大量的CAS操作失败，从而降低性能。其次，CAS操作只能保证单个变量的原子性操作，无法保证多个变量之间的操作的原子性，因此需要额外的措施来保证多个变量之间的一致性。</p><p>下面是一个使用AtomicInteger实现简单计数器的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.atomic.AtomicInteger</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Counter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>AtomicInteger</span> <span class=n>value</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicInteger</span><span class=o>(</span><span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>increment</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>oldValue</span><span class=o>,</span> <span class=n>newValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>oldValue</span> <span class=o>=</span> <span class=n>value</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>newValue</span> <span class=o>=</span> <span class=n>oldValue</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>while</span> <span class=o>(!</span><span class=n>value</span><span class=o>.</span><span class=na>compareAndSet</span><span class=o>(</span><span class=n>oldValue</span><span class=o>,</span> <span class=n>newValue</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getValue</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>increment()</code> 方法使用do-while循环和<code>compareAndSet()</code>方法执行CAS操作来增加计数器的值。该方法重复使用<code>get()</code>方法读取计数器的当前值，计算新值，然后尝试使用<code>compareAndSet()</code>方法更新计数器。循环将继续，直到CAS操作成功并且计数器成功更新。</p><p><code>getValue()</code> 方法使用<code>get()</code>方法简单地返回计数器的当前值。</p><p>需要注意的是，在使用CAS操作时，需要小心处理潜在的ABA问题，其中共享变量的值可能在初始读取和更新尝试之间多次更改。一种处理方法是在共享变量中使用版本号或时间戳，以确保更新仅在值未更改的情况下成功。</p><p>ABA问题是在使用CAS（<code>Compare-and-Swap</code>）操作进行并发编程时经常遇到的一个问题。它发生在一个线程从共享内存位置读取一个值，然后另一个线程将该值更改为另一个值，最后又将其更改回原始值，从而使第一个线程的操作意外成功。</p><p>为了处理ABA问题，常用的方法是在共享内存位置中添加一个版本号或时间戳。版本号或时间戳可以在每次修改内存位置时进行递增或更新。这可以确保CAS操作不仅检查值，还检查内存位置的版本号或时间戳。</p><p>以下是使用版本号处理ABA问题的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.atomic.AtomicStampedReference</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ConcurrentStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>AtomicStampedReference</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=n>top</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicStampedReference</span><span class=o>&lt;&gt;(</span><span class=kc>null</span><span class=o>,</span> <span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>push</span><span class=o>(</span><span class=n>T</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>newHead</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>&lt;&gt;(</span><span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span><span class=o>[]</span> <span class=n>stampHolder</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>oldHead</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>oldHead</span> <span class=o>=</span> <span class=n>top</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>stampHolder</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>newHead</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>oldHead</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>stampHolder</span><span class=o>[</span><span class=mi>0</span><span class=o>]++;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>while</span> <span class=o>(!</span><span class=n>top</span><span class=o>.</span><span class=na>compareAndSet</span><span class=o>(</span><span class=n>oldHead</span><span class=o>,</span> <span class=n>newHead</span><span class=o>,</span> <span class=n>stampHolder</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>-</span> <span class=mi>1</span><span class=o>,</span> <span class=n>stampHolder</span><span class=o>[</span><span class=mi>0</span><span class=o>]));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>T</span> <span class=nf>pop</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>oldHead</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span><span class=o>[]</span> <span class=n>stampHolder</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>oldHead</span> <span class=o>=</span> <span class=n>top</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>stampHolder</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>oldHead</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>while</span> <span class=o>(!</span><span class=n>top</span><span class=o>.</span><span class=na>compareAndSet</span><span class=o>(</span><span class=n>oldHead</span><span class=o>,</span> <span class=n>oldHead</span><span class=o>.</span><span class=na>next</span><span class=o>,</span> <span class=n>stampHolder</span><span class=o>[</span><span class=mi>0</span><span class=o>],</span> <span class=n>stampHolder</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>+</span> <span class=mi>1</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>oldHead</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kd>final</span> <span class=n>T</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=nf>Node</span><span class=o>(</span><span class=n>T</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>ConcurrentStack</code> 类使用 <code>AtomicStampedReference</code> 存储栈顶节点。<code>AtomicStampedReference</code> 类存储值的引用和版本号，版本号在引用更改时进行更新。</p><p><code>push()</code> 方法使用新值创建一个新的 <code>Node</code>，然后尝试使用CAS操作将其推入栈中。循环将继续，直到CAS操作成功，节点成功推入栈中。</p><p><code>pop()</code> 方法尝试使用CAS操作从栈中弹出顶部节点。循环将继续，直到顶部节点成功弹出或栈为空为止。</p><p>通过使用具有版本号的 <code>AtomicStampedReference</code>，<code>ConcurrentStack</code> 类可以处理在并发操作中可能发生的ABA问题。</p><h2 id=aqs>AQS<a hidden class=anchor aria-hidden=true href=#aqs>#</a></h2><p>AQS（<code>AbstractQueuedSynchronizer</code>）是Java中用于实现同步器（如锁，信号量等）的框架，它提供了一些基本的同步操作，例如<code>获取锁</code>、<code>释放锁</code>、<code>等待条件</code>、<code>唤醒线程</code>等。</p><p>AQS的实现原理基于一个双向链表，用于维护等待线程的队列。当一个线程需要获取同步器时，它会首先尝试使用CAS操作来获取同步器，如果获取成功，则继续执行；如果获取失败，则将线程加入等待队列中，并将其挂起。当同步器释放时，它会唤醒等待队列中的一个或多个线程，并将它们从等待队列中移除，使它们可以继续执行。</p><p>AQS的等待队列是通过一个双向链表来实现的，每个节点代表一个等待线程，节点中包含了线程的状态以及等待条件等信息。等待队列中的节点是按照等待时间的先后顺序排列的，先等待的线程排在前面，后等待的线程排在后面。当一个线程被唤醒时，它会重新尝试获取同步器，如果获取成功，则继续执行；如果获取失败，则它会再次加入等待队列中，并将自己挂起。</p><p>AQS的具体实现是通过重写其内部的一些方法来实现的。例如，<code>tryAcquire()</code> 方法用于实现获取同步器的逻辑，它会首先尝试使用CAS操作来获取同步器，如果获取成功，则返回 true；否则返回 false。<code>tryRelease()</code> 方法用于实现释放同步器的逻辑，它会释放同步器，并唤醒等待队列中的一个或多个线程。<code>tryAcquireShared()</code> 和 <code>tryReleaseShared()</code> 方法则用于实现共享式同步器的逻辑，它们类似于 <code>tryAcquire()</code> 和 <code>tryRelease()</code> 方法，但是可以支持多个线程同时获取或释放同步器。</p><h2 id=unsafe>Unsafe<a hidden class=anchor aria-hidden=true href=#unsafe>#</a></h2><p>Unsafe类是Java中一个非常特殊且强大的类，它提供了一些不安全的操作，例如直接操作内存、线程挂起和恢复等。Unsafe类是Java中少数几个不被公开支持的类之一，它主要被用于Java核心库和其他一些高级框架中，如Netty、Hadoop和Kafka等。</p><p>由于Unsafe类提供了一些不安全的操作，因此它的使用需要非常小心。如果不正确地使用Unsafe类，可能会导致程序崩溃或安全漏洞。因此，Java官方并不建议开发人员使用Unsafe类，而是建议开发人员使用更加安全和标准的Java API。</p><p>Unsafe类中一些常用的方法包括：</p><ol><li><code>allocateMemory(long size)</code>：分配一段指定大小的内存空间。</li><li><code>freeMemory(long address)</code>：释放指定地址的内存空间。</li><li><code>putXXX(Object target, long offset, XXX value)</code>：将指定类型的值写入目标对象的指定偏移量处。</li><li><code>getXXX(Object target, long offset)</code>：从目标对象的指定偏移量处读取指定类型的值。</li><li><code>park(boolean isAbsolute, long time)</code>：挂起当前线程，直到被其他线程唤醒或指定的时间到期。</li><li><code>unpark(Thread thread)</code>：恢复指定线程的运行。</li></ol><p>需要注意的是，Unsafe类中的大部分方法都是native方法，实现方式依赖于底层操作系统和硬件平台。这意味着Unsafe类中的方法在不同的平台上可能会有不同的行为，因此需要针对不同的平台进行测试和验证。</p><p>Java 9中官方提出了移除Sun.misc.Unsafe类，并在该版本中将该类标记为不推荐使用。然而，由于Unsafe类在Java语言生态中的应用非常广泛，许多框架和库都依赖于Unsafe类来实现高性能和低层次的操作。因此，在Java 9中，官方引入了jdk.internal.misc.Unsafe类来替代Sun.misc.Unsafe类的功能，以保持对Java生态中使用Unsafe类的支持。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.com/tags/java/>java</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.chensoul.com/>ChenSoul</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script async src=https://umami.chensoul.com/script.js data-website-id=f110cfa0-b737-4690-a032-2b9073a57fc3></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>