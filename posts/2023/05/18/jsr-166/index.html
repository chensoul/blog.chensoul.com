<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JSR 166规范 | ChenSoul</title>
<meta name=keywords content="java"><meta name=description content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。
JSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。
J.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。
Doug Lea 主页：Doug Lea&rsquo;s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：
JSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java."><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/05/18/jsr-166/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/05/18/jsr-166/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="JSR 166规范"><meta property="og:description" content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。
JSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。
J.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。
Doug Lea 主页：Doug Lea&rsquo;s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：
JSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/05/18/jsr-166/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-18T00:00:00+08:00"><meta property="article:modified_time" content="2023-05-18T00:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="JSR 166规范"><meta name=twitter:description content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。
JSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。
J.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。
Doug Lea 主页：Doug Lea&rsquo;s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：
JSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"JSR 166规范","item":"https://blog.chensoul.cc/posts/2023/05/18/jsr-166/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JSR 166规范","name":"JSR 166规范","description":"JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。\nJSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。\nJ.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。\nDoug Lea 主页：Doug Lea\u0026rsquo;s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：\nJSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java.","keywords":["java"],"articleBody":"JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。\nJSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。\nJ.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。\nDoug Lea 主页：Doug Lea’s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：\nJSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java.util.concurrent 包下的类以及引入版本（没有标注版本号的为 1.5 ）：\njava.util.concurrent java.util.concurrent.locks AbstractOwnableSynchronizer 1.6 AbstractQueuedLongSynchronizer 1.6 AbstractQueuedSynchronizer Condition Lock LockSupport ReadWriteLock ReentrantLock ReentrantReadWriteLock StampedLock 1.8 java.util.concurrent.atomic AtomicBoolean AtomicInteger AtomicIntegerArray AtomicIntegerFieldUpdater AtomicLong AtomicLongArray AtomicLongFieldUpdater AtomicMarkableReference AtomicReference AtomicReferenceArray AtomicReferenceFieldUpdater AtomicStampedReference DoubleAccumulator 1.8 DoubleAdder 1.8 LongAccumulator 1.8 LongAdder 1.8 AbstractExecutorService ArrayBlockingQueue BlockingDeque 1.6 BlockingQueue BrokenBarrierException Callable CancellationException CompletableFuture 1.8 CompletionException 1.8 CompletionService CompletionStage 1.8 ConcurrentHashMap ConcurrentLinkedDeque 1.7 ConcurrentLinkedQueue ConcurrentMap ConcurrentNavigableMap 1.6 ConcurrentSkipListMap 1.6 ConcurrentSkipListSet 1.6 CopyOnWriteArrayList CopyOnWriteArraySet CountDownLatch CountedCompleter 1.8 CyclicBarrier Delayed DelayQueue Exchanger ExecutionException Executor ExecutorCompletionService Executors ExecutorService Flow 1.9 ForkJoinPool 1.7 ForkJoinTask 1.7 ForkJoinWorkerThread 1.7 Future FutureTask LinkedBlockingDeque 1.6 LinkedBlockingQueue LinkedTransferQueue 1.7 Phaser 1.7 PriorityBlockingQueue RecursiveAction 1.7 RecursiveTask 1.7 RejectedExecutionException RejectedExecutionHandler RunnableFuture RunnableScheduledFuture ScheduledExecutorService ScheduledFuture ScheduledThreadPoolExecutor Semaphore SubmissionPublisher 1.9 SynchronousQueue ThreadFactory ThreadLocalRandom 1.7 ThreadPoolExecutor TimeoutException TimeUnit TransferQueue 1.7 大致可以分为以下几类：\n原子更新 锁和条件 线程池 并发容器 同步器 在学习 JUC 之前我们需要了解 CAS，AQS 和 Unsafe。\nCAS： AQS： Unsafe： CAS CAS（Compare and Swap）是一种基于原子性操作的并发编程技术，常用于实现线程安全的数据结构和算法。CAS 操作由三个参数组成：内存位置 V、期望值 A、新值 B。当且仅当 V 的值等于 A 时，CAS 操作才会将 V 的值设置为 B，否则不做任何操作。它的实现原理可以简单概括为以下几个步骤：\n读取内存位置 V 的值，同时记录下该值的版本号或标记位。 检查内存位置 V 的值是否等于期望值 A。如果相等，则执行第 3 步；否则，操作失败。 将新值 B 写入内存位置 V，并更新其版本号或标记位。 返回操作结果。 CAS 操作是一种乐观锁机制，它不需要锁定整个共享资源，而是只针对需要修改的值进行原子性操作，从而避免了锁的竞争和开销。在执行 CAS 操作时，线程会对内存位置进行读取和写入，但同时也会检查内存位置的版本号或标记位，以保证操作的原子性和一致性。\n需要注意的是，如果多个线程同时执行 CAS 操作，可能会出现 ABA 问题。例如，线程 A 读取内存位置 V 的值为 A，然后线程 B 将 V 的值修改为 B，最后线程 B 又将 V 的值修改为 A。此时，线程 A 执行 CAS 操作时，会发现内存位置 V 的值还是 A，虽然这个 A 的版本号或标记位与之前不同，但线程 A 并不知道 V 的值曾经被修改过，因此会将新值写入内存位置 V，从而导致数据不一致。为了解决 ABA 问题，可以使用带有版本号或标记位的 CAS 操作，或者使用其他的并发编程技术，例如锁或读写锁。\nJava 中的AtomicXXX类实现了 CAS 操作，例如 AtomicInteger、AtomicLong 等。这些类提供了一组原子性操作方法，例如 get()、set()、addAndGet()、compareAndSet()等，它们可以被多个线程安全地使用。\nCAS 操作虽然免去了锁的开销，但也存在一些问题。首先，CAS 操作需要进行多次尝试，直到成功为止。如果并发程度较高，多个线程同时进行 CAS 操作，可能会导致大量的 CAS 操作失败，从而降低性能。其次，CAS 操作只能保证单个变量的原子性操作，无法保证多个变量之间的操作的原子性，因此需要额外的措施来保证多个变量之间的一致性。\n下面是一个使用 AtomicInteger 实现简单计数器的例子：\nimport java.util.concurrent.atomic.AtomicInteger; public class Counter { private AtomicInteger value = new AtomicInteger(0); public void increment() { int oldValue, newValue; do { oldValue = value.get(); newValue = oldValue + 1; } while (!value.compareAndSet(oldValue, newValue)); } public int getValue() { return value.get(); } } 在上面的示例中，increment() 方法使用 do-while 循环和compareAndSet()方法执行 CAS 操作来增加计数器的值。该方法重复使用get()方法读取计数器的当前值，计算新值，然后尝试使用compareAndSet()方法更新计数器。循环将继续，直到 CAS 操作成功并且计数器成功更新。\ngetValue() 方法使用get()方法简单地返回计数器的当前值。\n需要注意的是，在使用 CAS 操作时，需要小心处理潜在的 ABA 问题，其中共享变量的值可能在初始读取和更新尝试之间多次更改。一种处理方法是在共享变量中使用版本号或时间戳，以确保更新仅在值未更改的情况下成功。\nABA 问题是在使用 CAS（Compare-and-Swap）操作进行并发编程时经常遇到的一个问题。它发生在一个线程从共享内存位置读取一个值，然后另一个线程将该值更改为另一个值，最后又将其更改回原始值，从而使第一个线程的操作意外成功。\n为了处理 ABA 问题，常用的方法是在共享内存位置中添加一个版本号或时间戳。版本号或时间戳可以在每次修改内存位置时进行递增或更新。这可以确保 CAS 操作不仅检查值，还检查内存位置的版本号或时间戳。\n以下是使用版本号处理 ABA 问题的示例：\nimport java.util.concurrent.atomic.AtomicStampedReference; public class ConcurrentStack\u003cT\u003e { private AtomicStampedReference\u003cNode\u003cT\u003e\u003e top = new AtomicStampedReference\u003c\u003e(null, 0); public void push(T value) { Node\u003cT\u003e newHead = new Node\u003c\u003e(value); int[] stampHolder = new int[1]; Node\u003cT\u003e oldHead; do { oldHead = top.get(stampHolder); newHead.next = oldHead; stampHolder[0]++; } while (!top.compareAndSet(oldHead, newHead, stampHolder[0] - 1, stampHolder[0])); } public T pop() { Node\u003cT\u003e oldHead; int[] stampHolder = new int[1]; do { oldHead = top.get(stampHolder); if (oldHead == null) { return null; } } while (!top.compareAndSet(oldHead, oldHead.next, stampHolder[0], stampHolder[0] + 1)); return oldHead.value; } private static class Node\u003cT\u003e { private final T value; private Node\u003cT\u003e next; private Node(T value) { this.value = value; } } } 在上面的示例中，ConcurrentStack 类使用 AtomicStampedReference 存储栈顶节点。AtomicStampedReference 类存储值的引用和版本号，版本号在引用更改时进行更新。\npush() 方法使用新值创建一个新的 Node，然后尝试使用 CAS 操作将其推入栈中。循环将继续，直到 CAS 操作成功，节点成功推入栈中。\npop() 方法尝试使用 CAS 操作从栈中弹出顶部节点。循环将继续，直到顶部节点成功弹出或栈为空为止。\n通过使用具有版本号的 AtomicStampedReference，ConcurrentStack 类可以处理在并发操作中可能发生的 ABA 问题。\nAQS AQS（AbstractQueuedSynchronizer）是 Java 中用于实现同步器（如锁，信号量等）的框架，它提供了一些基本的同步操作，例如获取锁、释放锁、等待条件、唤醒线程等。\nAQS 的实现原理基于一个双向链表，用于维护等待线程的队列。当一个线程需要获取同步器时，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则继续执行；如果获取失败，则将线程加入等待队列中，并将其挂起。当同步器释放时，它会唤醒等待队列中的一个或多个线程，并将它们从等待队列中移除，使它们可以继续执行。\nAQS 的等待队列是通过一个双向链表来实现的，每个节点代表一个等待线程，节点中包含了线程的状态以及等待条件等信息。等待队列中的节点是按照等待时间的先后顺序排列的，先等待的线程排在前面，后等待的线程排在后面。当一个线程被唤醒时，它会重新尝试获取同步器，如果获取成功，则继续执行；如果获取失败，则它会再次加入等待队列中，并将自己挂起。\nAQS 的具体实现是通过重写其内部的一些方法来实现的。例如，tryAcquire() 方法用于实现获取同步器的逻辑，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则返回 true；否则返回 false。tryRelease() 方法用于实现释放同步器的逻辑，它会释放同步器，并唤醒等待队列中的一个或多个线程。tryAcquireShared() 和 tryReleaseShared() 方法则用于实现共享式同步器的逻辑，它们类似于 tryAcquire() 和 tryRelease() 方法，但是可以支持多个线程同时获取或释放同步器。\nUnsafe Unsafe 类是 Java 中一个非常特殊且强大的类，它提供了一些不安全的操作，例如直接操作内存、线程挂起和恢复等。Unsafe 类是 Java 中少数几个不被公开支持的类之一，它主要被用于 Java 核心库和其他一些高级框架中，如 Netty、Hadoop 和 Kafka 等。\n由于 Unsafe 类提供了一些不安全的操作，因此它的使用需要非常小心。如果不正确地使用 Unsafe 类，可能会导致程序崩溃或安全漏洞。因此，Java 官方并不建议开发人员使用 Unsafe 类，而是建议开发人员使用更加安全和标准的 Java API。\nUnsafe 类中一些常用的方法包括：\nallocateMemory(long size)：分配一段指定大小的内存空间。 freeMemory(long address)：释放指定地址的内存空间。 putXXX(Object target, long offset, XXX value)：将指定类型的值写入目标对象的指定偏移量处。 getXXX(Object target, long offset)：从目标对象的指定偏移量处读取指定类型的值。 park(boolean isAbsolute, long time)：挂起当前线程，直到被其他线程唤醒或指定的时间到期。 unpark(Thread thread)：恢复指定线程的运行。 需要注意的是，Unsafe 类中的大部分方法都是 native 方法，实现方式依赖于底层操作系统和硬件平台。这意味着 Unsafe 类中的方法在不同的平台上可能会有不同的行为，因此需要针对不同的平台进行测试和验证。\nJava 9 中官方提出了移除 Sun.misc.Unsafe 类，并在该版本中将该类标记为不推荐使用。然而，由于 Unsafe 类在 Java 语言生态中的应用非常广泛，许多框架和库都依赖于 Unsafe 类来实现高性能和低层次的操作。因此，在 Java 9 中，官方引入了 jdk.internal.misc.Unsafe 类来替代 Sun.misc.Unsafe 类的功能，以保持对 Java 生态中使用 Unsafe 类的支持。\n","wordCount":"664","inLanguage":"en","datePublished":"2023-05-18T00:00:00+08:00","dateModified":"2023-05-18T00:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/05/18/jsr-166/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">JSR 166规范</h1><div class=post-meta><span title='2023-05-18 00:00:00 +0800 CST'>2023-05-18</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;664 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#jsr-%e4%bb%8b%e7%bb%8d aria-label="JSR 介绍">JSR 介绍</a></li><li><a href=#juc aria-label=JUC>JUC</a></li><li><a href=#cas aria-label=CAS>CAS</a></li><li><a href=#aqs aria-label=AQS>AQS</a></li><li><a href=#unsafe aria-label=Unsafe>Unsafe</a></li></ul></div></details></div><div class=post-content><h2 id=jsr-介绍>JSR 介绍<a hidden class=anchor aria-hidden=true href=#jsr-介绍>#</a></h2><p>JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 <a href="http://jcp.org/en/jsr/detail?id=335">JSR 335</a>，新的日期和时间 API 对应的是 <a href="http://jcp.org/en/jsr/detail?id=310">JSR 310</a>。</p><p><a href="https://jcp.org/en/jsr/detail?id=166">JSR 166</a> 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。</p><p>J.U.C，即 <code>java.util.concurrent</code> 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。</p><ul><li>Doug Lea 主页：<a href=https://gee.cs.oswego.edu/>Doug Lea&rsquo;s Home Page</a></li><li>JSR-166：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/index.html>Concurrency JSR-166 Interest Site</a></li><li>JSR 166 Slider：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf>JSR-166: Concurrency Utilities</a></li><li>java.util.concurrent JavaDoc: <a href=https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/package-summary.html>JDK 1.5 </a>、 <a href=https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html>JDK 7 </a>、 <a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html>JDK 8 </a>、 <a href=https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/package-summary.html>JDK 9</a></li></ul><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/jsr-166-concurrency-utilities.png alt=jsr-166-concurrency-utilities></p><p>JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：</p><ol><li><code>JSR-166（Java SE 5）</code>：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。</li><li><code>JSR-166x（Java SE 7）</code>：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。</li><li><code>JSR-166y（Java SE 8）</code>：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。</li><li><code>JSR-166z（Java SE 9）</code>：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。</li></ol><h2 id=juc>JUC<a hidden class=anchor aria-hidden=true href=#juc>#</a></h2><p>java.util.concurrent 包下的类以及引入版本（没有标注版本号的为 <code>1.5</code> ）：</p><ul><li>java.util.concurrent<ul><li>java.util.concurrent.locks<ul><li>AbstractOwnableSynchronizer <code>1.6</code></li><li>AbstractQueuedLongSynchronizer <code>1.6</code></li><li>AbstractQueuedSynchronizer</li><li>Condition</li><li>Lock</li><li>LockSupport</li><li>ReadWriteLock</li><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>StampedLock <code>1.8</code></li></ul></li><li>java.util.concurrent.atomic<ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicIntegerArray</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLong</li><li>AtomicLongArray</li><li>AtomicLongFieldUpdater</li><li>AtomicMarkableReference</li><li>AtomicReference</li><li>AtomicReferenceArray</li><li>AtomicReferenceFieldUpdater</li><li>AtomicStampedReference</li><li>DoubleAccumulator <code>1.8</code></li><li>DoubleAdder <code>1.8</code></li><li>LongAccumulator <code>1.8</code></li><li>LongAdder <code>1.8</code></li></ul></li><li>AbstractExecutorService</li><li>ArrayBlockingQueue</li><li>BlockingDeque <code>1.6</code></li><li>BlockingQueue</li><li>BrokenBarrierException</li><li>Callable</li><li>CancellationException</li><li>CompletableFuture <code>1.8</code></li><li>CompletionException <code>1.8</code></li><li>CompletionService</li><li>CompletionStage <code>1.8</code></li><li>ConcurrentHashMap</li><li>ConcurrentLinkedDeque <code>1.7</code></li><li>ConcurrentLinkedQueue</li><li>ConcurrentMap</li><li>ConcurrentNavigableMap <code>1.6</code></li><li>ConcurrentSkipListMap <code>1.6</code></li><li>ConcurrentSkipListSet <code>1.6</code></li><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet</li><li>CountDownLatch</li><li>CountedCompleter <code>1.8</code></li><li>CyclicBarrier</li><li>Delayed</li><li>DelayQueue</li><li>Exchanger</li><li>ExecutionException</li><li>Executor</li><li>ExecutorCompletionService</li><li>Executors</li><li>ExecutorService</li><li>Flow <code>1.9</code></li><li>ForkJoinPool <code>1.7</code></li><li>ForkJoinTask <code>1.7</code></li><li>ForkJoinWorkerThread <code>1.7</code></li><li>Future</li><li>FutureTask</li><li>LinkedBlockingDeque <code>1.6</code></li><li>LinkedBlockingQueue</li><li>LinkedTransferQueue <code>1.7</code></li><li>Phaser <code>1.7</code></li><li>PriorityBlockingQueue</li><li>RecursiveAction <code>1.7</code></li><li>RecursiveTask <code>1.7</code></li><li>RejectedExecutionException</li><li>RejectedExecutionHandler</li><li>RunnableFuture</li><li>RunnableScheduledFuture</li><li>ScheduledExecutorService</li><li>ScheduledFuture</li><li>ScheduledThreadPoolExecutor</li><li>Semaphore</li><li>SubmissionPublisher <code>1.9</code></li><li>SynchronousQueue</li><li>ThreadFactory</li><li>ThreadLocalRandom <code>1.7</code></li><li>ThreadPoolExecutor</li><li>TimeoutException</li><li>TimeUnit</li><li>TransferQueue <code>1.7</code></li></ul></li></ul><p>大致可以分为以下几类：</p><ul><li>原子更新</li><li>锁和条件</li><li>线程池</li><li>并发容器</li><li>同步器</li></ul><p>在学习 <code>JUC</code> 之前我们需要了解 <code>CAS</code>，<code>AQS</code> 和 <code>Unsafe</code>。</p><ul><li>CAS：</li><li>AQS：</li><li>Unsafe：</li></ul><h2 id=cas>CAS<a hidden class=anchor aria-hidden=true href=#cas>#</a></h2><p>CAS（<code>Compare and Swap</code>）是一种基于原子性操作的并发编程技术，常用于实现线程安全的数据结构和算法。CAS 操作由三个参数组成：内存位置 V、期望值 A、新值 B。当且仅当 V 的值等于 A 时，CAS 操作才会将 V 的值设置为 B，否则不做任何操作。它的实现原理可以简单概括为以下几个步骤：</p><ol><li>读取内存位置 V 的值，同时记录下该值的版本号或标记位。</li><li>检查内存位置 V 的值是否等于期望值 A。如果相等，则执行第 3 步；否则，操作失败。</li><li>将新值 B 写入内存位置 V，并更新其版本号或标记位。</li><li>返回操作结果。</li></ol><p>CAS 操作是一种<code>乐观锁</code>机制，它不需要锁定整个共享资源，而是只针对需要修改的值进行原子性操作，从而避免了锁的竞争和开销。在执行 CAS 操作时，线程会对内存位置进行读取和写入，但同时也会检查内存位置的版本号或标记位，以保证操作的原子性和一致性。</p><p>需要注意的是，如果多个线程同时执行 CAS 操作，可能会出现 ABA 问题。例如，线程 A 读取内存位置 V 的值为 A，然后线程 B 将 V 的值修改为 B，最后线程 B 又将 V 的值修改为 A。此时，线程 A 执行 CAS 操作时，会发现内存位置 V 的值还是 A，虽然这个 A 的版本号或标记位与之前不同，但线程 A 并不知道 V 的值曾经被修改过，因此会将新值写入内存位置 V，从而导致数据不一致。为了解决 ABA 问题，可以使用带有版本号或标记位的 CAS 操作，或者使用其他的并发编程技术，例如锁或读写锁。</p><p>Java 中的<code>AtomicXXX</code>类实现了 CAS 操作，例如 AtomicInteger、AtomicLong 等。这些类提供了一组原子性操作方法，例如 get()、set()、addAndGet()、compareAndSet()等，它们可以被多个线程安全地使用。</p><p>CAS 操作虽然免去了锁的开销，但也存在一些问题。首先，CAS 操作需要进行多次尝试，直到成功为止。如果并发程度较高，多个线程同时进行 CAS 操作，可能会导致大量的 CAS 操作失败，从而降低性能。其次，CAS 操作只能保证单个变量的原子性操作，无法保证多个变量之间的操作的原子性，因此需要额外的措施来保证多个变量之间的一致性。</p><p>下面是一个使用 AtomicInteger 实现简单计数器的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.concurrent.atomic.AtomicInteger</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Counter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>AtomicInteger</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicInteger</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>increment</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>oldValue</span><span class=p>,</span><span class=w> </span><span class=n>newValue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>oldValue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>.</span><span class=na>get</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>newValue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>oldValue</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>value</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>oldValue</span><span class=p>,</span><span class=w> </span><span class=n>newValue</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>getValue</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>value</span><span class=p>.</span><span class=na>get</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上面的示例中，<code>increment()</code> 方法使用 do-while 循环和<code>compareAndSet()</code>方法执行 CAS 操作来增加计数器的值。该方法重复使用<code>get()</code>方法读取计数器的当前值，计算新值，然后尝试使用<code>compareAndSet()</code>方法更新计数器。循环将继续，直到 CAS 操作成功并且计数器成功更新。</p><p><code>getValue()</code> 方法使用<code>get()</code>方法简单地返回计数器的当前值。</p><p>需要注意的是，在使用 CAS 操作时，需要小心处理潜在的 ABA 问题，其中共享变量的值可能在初始读取和更新尝试之间多次更改。一种处理方法是在共享变量中使用版本号或时间戳，以确保更新仅在值未更改的情况下成功。</p><p>ABA 问题是在使用 CAS（<code>Compare-and-Swap</code>）操作进行并发编程时经常遇到的一个问题。它发生在一个线程从共享内存位置读取一个值，然后另一个线程将该值更改为另一个值，最后又将其更改回原始值，从而使第一个线程的操作意外成功。</p><p>为了处理 ABA 问题，常用的方法是在共享内存位置中添加一个版本号或时间戳。版本号或时间戳可以在每次修改内存位置时进行递增或更新。这可以确保 CAS 操作不仅检查值，还检查内存位置的版本号或时间戳。</p><p>以下是使用版本号处理 ABA 问题的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.concurrent.atomic.AtomicStampedReference</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ConcurrentStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>AtomicStampedReference</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>top</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicStampedReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=kc>null</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>push</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>newHead</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>stampHolder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>oldHead</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>oldHead</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>top</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>stampHolder</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>newHead</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>oldHead</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>top</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>oldHead</span><span class=p>,</span><span class=w> </span><span class=n>newHead</span><span class=p>,</span><span class=w> </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=nf>pop</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>oldHead</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>stampHolder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>oldHead</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>top</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>stampHolder</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>oldHead</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>top</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>oldHead</span><span class=p>,</span><span class=w> </span><span class=n>oldHead</span><span class=p>.</span><span class=na>next</span><span class=p>,</span><span class=w> </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>oldHead</span><span class=p>.</span><span class=na>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=nf>Node</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上面的示例中，<code>ConcurrentStack</code> 类使用 <code>AtomicStampedReference</code> 存储栈顶节点。<code>AtomicStampedReference</code> 类存储值的引用和版本号，版本号在引用更改时进行更新。</p><p><code>push()</code> 方法使用新值创建一个新的 <code>Node</code>，然后尝试使用 CAS 操作将其推入栈中。循环将继续，直到 CAS 操作成功，节点成功推入栈中。</p><p><code>pop()</code> 方法尝试使用 CAS 操作从栈中弹出顶部节点。循环将继续，直到顶部节点成功弹出或栈为空为止。</p><p>通过使用具有版本号的 <code>AtomicStampedReference</code>，<code>ConcurrentStack</code> 类可以处理在并发操作中可能发生的 ABA 问题。</p><h2 id=aqs>AQS<a hidden class=anchor aria-hidden=true href=#aqs>#</a></h2><p>AQS（<code>AbstractQueuedSynchronizer</code>）是 Java 中用于实现同步器（如锁，信号量等）的框架，它提供了一些基本的同步操作，例如<code>获取锁</code>、<code>释放锁</code>、<code>等待条件</code>、<code>唤醒线程</code>等。</p><p>AQS 的实现原理基于一个双向链表，用于维护等待线程的队列。当一个线程需要获取同步器时，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则继续执行；如果获取失败，则将线程加入等待队列中，并将其挂起。当同步器释放时，它会唤醒等待队列中的一个或多个线程，并将它们从等待队列中移除，使它们可以继续执行。</p><p>AQS 的等待队列是通过一个双向链表来实现的，每个节点代表一个等待线程，节点中包含了线程的状态以及等待条件等信息。等待队列中的节点是按照等待时间的先后顺序排列的，先等待的线程排在前面，后等待的线程排在后面。当一个线程被唤醒时，它会重新尝试获取同步器，如果获取成功，则继续执行；如果获取失败，则它会再次加入等待队列中，并将自己挂起。</p><p>AQS 的具体实现是通过重写其内部的一些方法来实现的。例如，<code>tryAcquire()</code> 方法用于实现获取同步器的逻辑，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则返回 true；否则返回 false。<code>tryRelease()</code> 方法用于实现释放同步器的逻辑，它会释放同步器，并唤醒等待队列中的一个或多个线程。<code>tryAcquireShared()</code> 和 <code>tryReleaseShared()</code> 方法则用于实现共享式同步器的逻辑，它们类似于 <code>tryAcquire()</code> 和 <code>tryRelease()</code> 方法，但是可以支持多个线程同时获取或释放同步器。</p><h2 id=unsafe>Unsafe<a hidden class=anchor aria-hidden=true href=#unsafe>#</a></h2><p>Unsafe 类是 Java 中一个非常特殊且强大的类，它提供了一些不安全的操作，例如直接操作内存、线程挂起和恢复等。Unsafe 类是 Java 中少数几个不被公开支持的类之一，它主要被用于 Java 核心库和其他一些高级框架中，如 Netty、Hadoop 和 Kafka 等。</p><p>由于 Unsafe 类提供了一些不安全的操作，因此它的使用需要非常小心。如果不正确地使用 Unsafe 类，可能会导致程序崩溃或安全漏洞。因此，Java 官方并不建议开发人员使用 Unsafe 类，而是建议开发人员使用更加安全和标准的 Java API。</p><p>Unsafe 类中一些常用的方法包括：</p><ol><li><code>allocateMemory(long size)</code>：分配一段指定大小的内存空间。</li><li><code>freeMemory(long address)</code>：释放指定地址的内存空间。</li><li><code>putXXX(Object target, long offset, XXX value)</code>：将指定类型的值写入目标对象的指定偏移量处。</li><li><code>getXXX(Object target, long offset)</code>：从目标对象的指定偏移量处读取指定类型的值。</li><li><code>park(boolean isAbsolute, long time)</code>：挂起当前线程，直到被其他线程唤醒或指定的时间到期。</li><li><code>unpark(Thread thread)</code>：恢复指定线程的运行。</li></ol><p>需要注意的是，Unsafe 类中的大部分方法都是 native 方法，实现方式依赖于底层操作系统和硬件平台。这意味着 Unsafe 类中的方法在不同的平台上可能会有不同的行为，因此需要针对不同的平台进行测试和验证。</p><p>Java 9 中官方提出了移除 Sun.misc.Unsafe 类，并在该版本中将该类标记为不推荐使用。然而，由于 Unsafe 类在 Java 语言生态中的应用非常广泛，许多框架和库都依赖于 Unsafe 类来实现高性能和低层次的操作。因此，在 Java 9 中，官方引入了 jdk.internal.misc.Unsafe 类来替代 Sun.misc.Unsafe 类的功能，以保持对 Java 生态中使用 Unsafe 类的支持。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/><span class=title>« Prev</span><br><span>Java设计模式：Abstract Factory</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/05/18/weekly_review_19/><span class=title>Next »</span><br><span>周报-19｜武功山看日出、Python初学建议</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share JSR 166规范 on x" href="https://x.com/intent/tweet/?text=JSR%20166%e8%a7%84%e8%8c%83&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f&amp;hashtags=java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JSR 166规范 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f&amp;title=JSR%20166%e8%a7%84%e8%8c%83&amp;summary=JSR%20166%e8%a7%84%e8%8c%83&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JSR 166规范 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f&title=JSR%20166%e8%a7%84%e8%8c%83"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JSR 166规范 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JSR 166规范 on whatsapp" href="https://api.whatsapp.com/send?text=JSR%20166%e8%a7%84%e8%8c%83%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JSR 166规范 on telegram" href="https://telegram.me/share/url?text=JSR%20166%e8%a7%84%e8%8c%83&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JSR 166规范 on ycombinator" href="https://news.ycombinator.com/submitlink?t=JSR%20166%e8%a7%84%e8%8c%83&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>