<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JSR 166规范 | ChenSoul</title>
<meta name=keywords content="java"><meta name=description content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。
JSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。
J.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。
Doug Lea 主页：Doug Lea&rsquo;s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：
JSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java."><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.com/posts/2023/05/18/jsr-166/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.com/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.com/apple-touch-icon.png><meta name=twitter:title content="JSR 166规范 | ChenSoul"><meta name=twitter:description content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。
JSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。
J.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。
Doug Lea 主页：Doug Lea&rsquo;s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：
JSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java."><meta property="og:title" content="JSR 166规范 | ChenSoul"><meta property="og:description" content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。
JSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。
J.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。
Doug Lea 主页：Doug Lea&rsquo;s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：
JSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.com/posts/2023/05/18/jsr-166/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-18T16:00:00+08:00"><meta property="article:modified_time" content="2023-05-18T16:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.com/posts/"},{"@type":"ListItem","position":2,"name":"JSR 166规范","item":"https://blog.chensoul.com/posts/2023/05/18/jsr-166/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JSR 166规范 | ChenSoul","name":"JSR 166规范","description":"JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。\nJSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。\nJ.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。\nDoug Lea 主页：Doug Lea\u0026rsquo;s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：\nJSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java.","keywords":["java"],"wordCount":"664","inLanguage":"en","datePublished":"2023-05-18T16:00:00+08:00","dateModified":"2023-05-18T16:00:00+08:00","author":[{"@type":"Person","name":"chensoul"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.com/posts/2023/05/18/jsr-166/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.com/favicon.ico"}}}</script><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.com/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.com/categories/weekly/ title=周报>周报</a></li><li><a href=https://blog.chensoul.com/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.com/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>JSR 166规范</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-18</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.com/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>4 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#jsr-%e4%bb%8b%e7%bb%8d aria-label="JSR 介绍">JSR 介绍</a></li><li><a href=#juc aria-label=JUC>JUC</a></li><li><a href=#cas aria-label=CAS>CAS</a></li><li><a href=#aqs aria-label=AQS>AQS</a></li><li><a href=#unsafe aria-label=Unsafe>Unsafe</a></li></ul></div></details></div><div class=post-content><h2 id=jsr-介绍>JSR 介绍</h2><p>JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 <a href="http://jcp.org/en/jsr/detail?id=335">JSR 335</a>，新的日期和时间 API 对应的是 <a href="http://jcp.org/en/jsr/detail?id=310">JSR 310</a>。</p><p><a href="https://jcp.org/en/jsr/detail?id=166">JSR 166</a> 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。</p><p>J.U.C，即 <code>java.util.concurrent</code> 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。</p><ul><li>Doug Lea 主页：<a href=https://gee.cs.oswego.edu/>Doug Lea&rsquo;s Home Page</a></li><li>JSR-166：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/index.html>Concurrency JSR-166 Interest Site</a></li><li>JSR 166 Slider：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf>JSR-166: Concurrency Utilities</a></li><li>java.util.concurrent JavaDoc: <a href=https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/package-summary.html>JDK 1.5 </a>、 <a href=https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html>JDK 7 </a>、 <a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html>JDK 8 </a>、 <a href=https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/package-summary.html>JDK 9</a></li></ul><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/jsr-166-concurrency-utilities.png alt=jsr-166-concurrency-utilities></p><p>JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：</p><ol><li><code>JSR-166（Java SE 5）</code>：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。</li><li><code>JSR-166x（Java SE 7）</code>：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。</li><li><code>JSR-166y（Java SE 8）</code>：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。</li><li><code>JSR-166z（Java SE 9）</code>：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。</li></ol><h2 id=juc>JUC</h2><p>java.util.concurrent 包下的类以及引入版本（没有标注版本号的为 <code>1.5</code> ）：</p><ul><li>java.util.concurrent<ul><li>java.util.concurrent.locks<ul><li>AbstractOwnableSynchronizer <code>1.6</code></li><li>AbstractQueuedLongSynchronizer <code>1.6</code></li><li>AbstractQueuedSynchronizer</li><li>Condition</li><li>Lock</li><li>LockSupport</li><li>ReadWriteLock</li><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>StampedLock <code>1.8</code></li></ul></li><li>java.util.concurrent.atomic<ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicIntegerArray</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLong</li><li>AtomicLongArray</li><li>AtomicLongFieldUpdater</li><li>AtomicMarkableReference</li><li>AtomicReference</li><li>AtomicReferenceArray</li><li>AtomicReferenceFieldUpdater</li><li>AtomicStampedReference</li><li>DoubleAccumulator <code>1.8</code></li><li>DoubleAdder <code>1.8</code></li><li>LongAccumulator <code>1.8</code></li><li>LongAdder <code>1.8</code></li></ul></li><li>AbstractExecutorService</li><li>ArrayBlockingQueue</li><li>BlockingDeque <code>1.6</code></li><li>BlockingQueue</li><li>BrokenBarrierException</li><li>Callable</li><li>CancellationException</li><li>CompletableFuture <code>1.8</code></li><li>CompletionException <code>1.8</code></li><li>CompletionService</li><li>CompletionStage <code>1.8</code></li><li>ConcurrentHashMap</li><li>ConcurrentLinkedDeque <code>1.7</code></li><li>ConcurrentLinkedQueue</li><li>ConcurrentMap</li><li>ConcurrentNavigableMap <code>1.6</code></li><li>ConcurrentSkipListMap <code>1.6</code></li><li>ConcurrentSkipListSet <code>1.6</code></li><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet</li><li>CountDownLatch</li><li>CountedCompleter <code>1.8</code></li><li>CyclicBarrier</li><li>Delayed</li><li>DelayQueue</li><li>Exchanger</li><li>ExecutionException</li><li>Executor</li><li>ExecutorCompletionService</li><li>Executors</li><li>ExecutorService</li><li>Flow <code>1.9</code></li><li>ForkJoinPool <code>1.7</code></li><li>ForkJoinTask <code>1.7</code></li><li>ForkJoinWorkerThread <code>1.7</code></li><li>Future</li><li>FutureTask</li><li>LinkedBlockingDeque <code>1.6</code></li><li>LinkedBlockingQueue</li><li>LinkedTransferQueue <code>1.7</code></li><li>Phaser <code>1.7</code></li><li>PriorityBlockingQueue</li><li>RecursiveAction <code>1.7</code></li><li>RecursiveTask <code>1.7</code></li><li>RejectedExecutionException</li><li>RejectedExecutionHandler</li><li>RunnableFuture</li><li>RunnableScheduledFuture</li><li>ScheduledExecutorService</li><li>ScheduledFuture</li><li>ScheduledThreadPoolExecutor</li><li>Semaphore</li><li>SubmissionPublisher <code>1.9</code></li><li>SynchronousQueue</li><li>ThreadFactory</li><li>ThreadLocalRandom <code>1.7</code></li><li>ThreadPoolExecutor</li><li>TimeoutException</li><li>TimeUnit</li><li>TransferQueue <code>1.7</code></li></ul></li></ul><p>大致可以分为以下几类：</p><ul><li>原子更新</li><li>锁和条件</li><li>线程池</li><li>并发容器</li><li>同步器</li></ul><p>在学习 <code>JUC</code> 之前我们需要了解 <code>CAS</code>，<code>AQS</code> 和 <code>Unsafe</code>。</p><ul><li>CAS：</li><li>AQS：</li><li>Unsafe：</li></ul><h2 id=cas>CAS</h2><p>CAS（<code>Compare and Swap</code>）是一种基于原子性操作的并发编程技术，常用于实现线程安全的数据结构和算法。CAS 操作由三个参数组成：内存位置 V、期望值 A、新值 B。当且仅当 V 的值等于 A 时，CAS 操作才会将 V 的值设置为 B，否则不做任何操作。它的实现原理可以简单概括为以下几个步骤：</p><ol><li>读取内存位置 V 的值，同时记录下该值的版本号或标记位。</li><li>检查内存位置 V 的值是否等于期望值 A。如果相等，则执行第 3 步；否则，操作失败。</li><li>将新值 B 写入内存位置 V，并更新其版本号或标记位。</li><li>返回操作结果。</li></ol><p>CAS 操作是一种<code>乐观锁</code>机制，它不需要锁定整个共享资源，而是只针对需要修改的值进行原子性操作，从而避免了锁的竞争和开销。在执行 CAS 操作时，线程会对内存位置进行读取和写入，但同时也会检查内存位置的版本号或标记位，以保证操作的原子性和一致性。</p><p>需要注意的是，如果多个线程同时执行 CAS 操作，可能会出现 ABA 问题。例如，线程 A 读取内存位置 V 的值为 A，然后线程 B 将 V 的值修改为 B，最后线程 B 又将 V 的值修改为 A。此时，线程 A 执行 CAS 操作时，会发现内存位置 V 的值还是 A，虽然这个 A 的版本号或标记位与之前不同，但线程 A 并不知道 V 的值曾经被修改过，因此会将新值写入内存位置 V，从而导致数据不一致。为了解决 ABA 问题，可以使用带有版本号或标记位的 CAS 操作，或者使用其他的并发编程技术，例如锁或读写锁。</p><p>Java 中的<code>AtomicXXX</code>类实现了 CAS 操作，例如 AtomicInteger、AtomicLong 等。这些类提供了一组原子性操作方法，例如 get()、set()、addAndGet()、compareAndSet()等，它们可以被多个线程安全地使用。</p><p>CAS 操作虽然免去了锁的开销，但也存在一些问题。首先，CAS 操作需要进行多次尝试，直到成功为止。如果并发程度较高，多个线程同时进行 CAS 操作，可能会导致大量的 CAS 操作失败，从而降低性能。其次，CAS 操作只能保证单个变量的原子性操作，无法保证多个变量之间的操作的原子性，因此需要额外的措施来保证多个变量之间的一致性。</p><p>下面是一个使用 AtomicInteger 实现简单计数器的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.concurrent.atomic.AtomicInteger</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Counter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>AtomicInteger</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicInteger</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>increment</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>oldValue</span><span class=p>,</span><span class=w> </span><span class=n>newValue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>oldValue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>.</span><span class=na>get</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>newValue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>oldValue</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>value</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>oldValue</span><span class=p>,</span><span class=w> </span><span class=n>newValue</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>getValue</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>value</span><span class=p>.</span><span class=na>get</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上面的示例中，<code>increment()</code> 方法使用 do-while 循环和<code>compareAndSet()</code>方法执行 CAS 操作来增加计数器的值。该方法重复使用<code>get()</code>方法读取计数器的当前值，计算新值，然后尝试使用<code>compareAndSet()</code>方法更新计数器。循环将继续，直到 CAS 操作成功并且计数器成功更新。</p><p><code>getValue()</code> 方法使用<code>get()</code>方法简单地返回计数器的当前值。</p><p>需要注意的是，在使用 CAS 操作时，需要小心处理潜在的 ABA 问题，其中共享变量的值可能在初始读取和更新尝试之间多次更改。一种处理方法是在共享变量中使用版本号或时间戳，以确保更新仅在值未更改的情况下成功。</p><p>ABA 问题是在使用 CAS（<code>Compare-and-Swap</code>）操作进行并发编程时经常遇到的一个问题。它发生在一个线程从共享内存位置读取一个值，然后另一个线程将该值更改为另一个值，最后又将其更改回原始值，从而使第一个线程的操作意外成功。</p><p>为了处理 ABA 问题，常用的方法是在共享内存位置中添加一个版本号或时间戳。版本号或时间戳可以在每次修改内存位置时进行递增或更新。这可以确保 CAS 操作不仅检查值，还检查内存位置的版本号或时间戳。</p><p>以下是使用版本号处理 ABA 问题的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.concurrent.atomic.AtomicStampedReference</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ConcurrentStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>AtomicStampedReference</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>top</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicStampedReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=kc>null</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>push</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>newHead</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>stampHolder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>oldHead</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>oldHead</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>top</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>stampHolder</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>newHead</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>oldHead</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>top</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>oldHead</span><span class=p>,</span><span class=w> </span><span class=n>newHead</span><span class=p>,</span><span class=w> </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=nf>pop</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>oldHead</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>stampHolder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>oldHead</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>top</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>stampHolder</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>oldHead</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>top</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>oldHead</span><span class=p>,</span><span class=w> </span><span class=n>oldHead</span><span class=p>.</span><span class=na>next</span><span class=p>,</span><span class=w> </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>stampHolder</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>oldHead</span><span class=p>.</span><span class=na>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=nf>Node</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上面的示例中，<code>ConcurrentStack</code> 类使用 <code>AtomicStampedReference</code> 存储栈顶节点。<code>AtomicStampedReference</code> 类存储值的引用和版本号，版本号在引用更改时进行更新。</p><p><code>push()</code> 方法使用新值创建一个新的 <code>Node</code>，然后尝试使用 CAS 操作将其推入栈中。循环将继续，直到 CAS 操作成功，节点成功推入栈中。</p><p><code>pop()</code> 方法尝试使用 CAS 操作从栈中弹出顶部节点。循环将继续，直到顶部节点成功弹出或栈为空为止。</p><p>通过使用具有版本号的 <code>AtomicStampedReference</code>，<code>ConcurrentStack</code> 类可以处理在并发操作中可能发生的 ABA 问题。</p><h2 id=aqs>AQS</h2><p>AQS（<code>AbstractQueuedSynchronizer</code>）是 Java 中用于实现同步器（如锁，信号量等）的框架，它提供了一些基本的同步操作，例如<code>获取锁</code>、<code>释放锁</code>、<code>等待条件</code>、<code>唤醒线程</code>等。</p><p>AQS 的实现原理基于一个双向链表，用于维护等待线程的队列。当一个线程需要获取同步器时，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则继续执行；如果获取失败，则将线程加入等待队列中，并将其挂起。当同步器释放时，它会唤醒等待队列中的一个或多个线程，并将它们从等待队列中移除，使它们可以继续执行。</p><p>AQS 的等待队列是通过一个双向链表来实现的，每个节点代表一个等待线程，节点中包含了线程的状态以及等待条件等信息。等待队列中的节点是按照等待时间的先后顺序排列的，先等待的线程排在前面，后等待的线程排在后面。当一个线程被唤醒时，它会重新尝试获取同步器，如果获取成功，则继续执行；如果获取失败，则它会再次加入等待队列中，并将自己挂起。</p><p>AQS 的具体实现是通过重写其内部的一些方法来实现的。例如，<code>tryAcquire()</code> 方法用于实现获取同步器的逻辑，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则返回 true；否则返回 false。<code>tryRelease()</code> 方法用于实现释放同步器的逻辑，它会释放同步器，并唤醒等待队列中的一个或多个线程。<code>tryAcquireShared()</code> 和 <code>tryReleaseShared()</code> 方法则用于实现共享式同步器的逻辑，它们类似于 <code>tryAcquire()</code> 和 <code>tryRelease()</code> 方法，但是可以支持多个线程同时获取或释放同步器。</p><h2 id=unsafe>Unsafe</h2><p>Unsafe 类是 Java 中一个非常特殊且强大的类，它提供了一些不安全的操作，例如直接操作内存、线程挂起和恢复等。Unsafe 类是 Java 中少数几个不被公开支持的类之一，它主要被用于 Java 核心库和其他一些高级框架中，如 Netty、Hadoop 和 Kafka 等。</p><p>由于 Unsafe 类提供了一些不安全的操作，因此它的使用需要非常小心。如果不正确地使用 Unsafe 类，可能会导致程序崩溃或安全漏洞。因此，Java 官方并不建议开发人员使用 Unsafe 类，而是建议开发人员使用更加安全和标准的 Java API。</p><p>Unsafe 类中一些常用的方法包括：</p><ol><li><code>allocateMemory(long size)</code>：分配一段指定大小的内存空间。</li><li><code>freeMemory(long address)</code>：释放指定地址的内存空间。</li><li><code>putXXX(Object target, long offset, XXX value)</code>：将指定类型的值写入目标对象的指定偏移量处。</li><li><code>getXXX(Object target, long offset)</code>：从目标对象的指定偏移量处读取指定类型的值。</li><li><code>park(boolean isAbsolute, long time)</code>：挂起当前线程，直到被其他线程唤醒或指定的时间到期。</li><li><code>unpark(Thread thread)</code>：恢复指定线程的运行。</li></ol><p>需要注意的是，Unsafe 类中的大部分方法都是 native 方法，实现方式依赖于底层操作系统和硬件平台。这意味着 Unsafe 类中的方法在不同的平台上可能会有不同的行为，因此需要针对不同的平台进行测试和验证。</p><p>Java 9 中官方提出了移除 Sun.misc.Unsafe 类，并在该版本中将该类标记为不推荐使用。然而，由于 Unsafe 类在 Java 语言生态中的应用非常广泛，许多框架和库都依赖于 Unsafe 类来实现高性能和低层次的操作。因此，在 Java 9 中，官方引入了 jdk.internal.misc.Unsafe 类来替代 Sun.misc.Unsafe 类的功能，以保持对 Java 生态中使用 Unsafe 类的支持。</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://blog.chensoul.com/posts/2023/05/18/weekly_review_19/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>周报-19｜武功山看日出、Python初学建议</span>
</a><a class=next href=https://blog.chensoul.com/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.chensoul.com/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script async src=https://umami.chensoul.com/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script><script>mediumZoom(".entry-cover img"),mediumZoom(".post-content img:not([no-zoom])")</script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>