<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。"><title>《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法 | ChenSoul</title>
<link rel=canonical href=https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/images/favicon.webp"><meta name=twitter:title content="《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法"><meta name=twitter:description content="本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法"><meta property="og:description" content="本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-23T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-23T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="og:image" content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=name content="《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法"><meta itemprop=description content="本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。"><meta itemprop=datePublished content="2023-05-23T00:00:00+00:00"><meta itemprop=dateModified content="2023-05-23T00:00:00+00:00"><meta itemprop=wordCount content="522"><meta itemprop=image content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=keywords content="Java"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法","headline":"《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/","description":"\u003cp\u003e本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。\u003c/p\u003e","wordCount":"522","keywords":["java"],"datePublished":"2023-05-23T00:00:00Z","dateModified":"2023-05-23T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://twitter.com/","https://github.com/chensoul","https://www.linkedin.com/in/"]}]}</script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/ rel=bookmark title="《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法">《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法</a></h2><hr><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2023-05-23T00:00:00>2023-05-23
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/java/ title=java>java</a></span></div></header><div style=background-color:#f1f3f5;margin-top:20px><aside style=margin:5px><span style=font-size:20px;font-weight:700>Table of Contents</span><div style=padding-left:30px><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#总结>总结</a></li></ul></nav></div></aside></div><div class=entry-content><p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。</p><h2 id=介绍>介绍</h2><p><strong>在覆盖了 equals 方法的类中，必须覆盖 hashCode 方法。</strong> 如果你没有这样做，该类将违反 hashCode 方法的一般约定，这将阻止该类在 HashMap 和 HashSet 等集合中正常运行。以下是根据 Object 规范修改的约定：</p><ul><li>应用程序执行期间对对象重复调用 hashCode 方法时，它必须一致地返回相同的值，前提是不对 equals 方法中用于比较的信息进行修改。这个值不需要在应用程序的不同执行之间保持一致。</li><li>如果根据 <code>equals(Object)</code> 方法判断出两个对象是相等的，那么在两个对象上调用 hashCode 方法必须产生相同的整数结果。</li></ul><p>如果根据 <code>equals(Object)</code> 方法判断出两个对象不相等，则不需要在每个对象上调用 hashCode 方法时必须产生不同的结果。但是，程序员应该知道，为不相等的对象生成不同的结果可能会提高散列表的性能。</p><p><strong>当你无法覆盖 hashCode 方法时，将违反第二个关键条款：相等的对象必须具有相等的散列码。</strong> 根据类的 equals 方法，两个不同的实例在逻辑上可能是相等的，但是对于对象的 hashCode 方法来说，它们只是两个没有共同之处的对象。因此，Object 的 hashCode 方法返回两个看似随机的数字，而不是约定要求的两个相等的数字。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>PhoneNumber, String<span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>m.<span style=color:#a6e22e>put</span>(<span style=color:#66d9ef>new</span> PhoneNumber(707, 867, 5309), <span style=color:#e6db74>&#34;Jenny&#34;</span>);
</span></span></code></pre></div><p>此时，你可能期望 <code>m.get(new PhoneNumber(707, 867,5309))</code> 返回「Jenny」，但是它返回 null。注意，这里涉及到两个 PhoneNumber 实例：一个用于插入到 HashMap 中，另一个相等的实例（被试图）用于检索。由于 PhoneNumber 类未能覆盖 hashCode 方法，导致两个相等的实例具有不相等的散列码，这违反了 hashCode 方法约定。因此，get 方法查找电话号码的散列桶可能会与 put 方法存储电话号码的散列桶不同。即使这两个实例碰巧分配在同一个散列桶上，get 方法几乎肯定会返回 null，因为 HashMap 有一个优化，它缓存每个条目相关联的散列码，如果散列码不匹配，就不会检查对象是否相等。</p><p>解决这个问题就像为 PhoneNumber 编写一个正确的 hashCode 方法一样简单。那么 hashCode 方法应该是什么样的呢？写一个反面例子很容易。例如，以下方法是合法的，但是不应该被使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// The worst possible legal hashCode implementation - never use!</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() { <span style=color:#66d9ef>return</span> 42; }
</span></span></code></pre></div><p>它是合法的，因为它确保了相等的对象具有相同的散列码。同时它也很糟糕，因为它使每个对象都有相同的散列码。因此，每个对象都分配到同一个桶中，散列表退化为链表。这样，原本应该在线性阶 <code>O(n)</code> 运行的程序将在平方阶 <code>O(n^2)</code> 运行。对于大型散列表，这是工作和不工作的区别。</p><p>一个好的散列算法倾向于为不相等的实例生成不相等的散列码。这正是 hashCode 方法约定第三部分的含义。理想情况下，一个散列算法应该在所有 int 值上均匀合理分布所有不相等实例集合。实现这个理想是很困难的。幸运的是，实现一个类似的并不太难。这里有一个简单的方式：</p><ul><li><p>1、声明一个名为 result 的 int 变量，并将其初始化为对象中第一个重要字段的散列码 c，如步骤 2.a 中计算的那样。（回想一下 <a href=https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md target=_blank>Item-10</a> 中的重要字段会对比较产生影响）</p></li><li><p>2、对象中剩余的重要字段 f，执行以下操作：</p><ul><li><p>为字段计算一个整数散列码 c：</p><ul><li>如果字段是基本数据类型，计算 <code>Type.hashCode(f)</code>，其中 type 是与 f 类型对应的包装类。</li><li>如果字段是对象引用，并且该类的 equals 方法通过递归调用 equals 方法来比较字段，则递归调用字段上的 hashCode 方法。如果需要更复杂的比较，则为该字段计算一个「canonical representation」，并在 canonical representation 上调用 hashCode 方法。如果字段的值为空，则使用 0（或其他常数，但 0 是惯用的）。</li><li>如果字段是一个数组，则将其每个重要元素都视为一个单独的字段。也就是说，通过递归地应用这些规则计算每个重要元素的散列码，并将每个步骤 2.b 的值组合起来。如果数组中没有重要元素，则使用常量，最好不是 0。如果所有元素都很重要，那么使用 <code>Arrays.hashCode</code>。</li></ul></li><li><p>将步骤 2.a 中计算的散列码 c 合并到 result 变量，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>result <span style=color:#f92672>=</span> 31 <span style=color:#f92672>*</span> result <span style=color:#f92672>+</span> c;
</span></span></code></pre></div></li></ul></li><li><p>3、返回 result 变量。</p></li></ul><p>当你完成了 hashCode 方法的编写之后，问问自己现在相同的实例是否具有相同的散列码。编写单元测试来验证你的直觉（除非你使用 AutoValue 生成你的 equals 方法和 hashCode 方法，在这种情况下你可以安全地省略这些测试）。如果相同的实例有不相等的散列码，找出原因并修复问题。</p><p>可以从散列码计算中排除派生字段。换句话说，你可以忽略任何可以从包含的字段计算其值的字段。你必须排除不用 <code>equals</code> 比较的任何字段，否则你可能会违反 hashCode 方法约定的第二个条款。</p><p>在步骤 2.b 中使用的乘法将使结果取决于字段的顺序，如果类有多个相似的字段，则会产生一个更好的散列算法。例如，如果字符串散列算法中省略了乘法，那么所有的字母顺序都有相同的散列码。选择 31 是因为它是奇素数。如果是偶数，乘法运算就会溢出，信息就会丢失，因为乘法运算等同于移位。使用素数的好处不太明显，但它是传统用法。31 有一个很好的特性，可以用移位和减法来代替乘法，从而在某些体系结构上获得更好的性能：<code>31 * i == (i &lt;&lt;5) – i</code>。现代虚拟机自动进行这种优化。</p><p>让我们将前面的方法应用到 PhoneNumber 类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Typical hashCode method</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> Short.<span style=color:#a6e22e>hashCode</span>(areaCode);
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> 31 <span style=color:#f92672>*</span> result <span style=color:#f92672>+</span> Short.<span style=color:#a6e22e>hashCode</span>(prefix);
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> 31 <span style=color:#f92672>*</span> result <span style=color:#f92672>+</span> Short.<span style=color:#a6e22e>hashCode</span>(lineNum);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为这个方法返回一个简单的确定的计算结果，它的唯一输入是 PhoneNumber 实例中的三个重要字段，所以很明显，相等的 PhoneNumber 实例具有相等的散列码。实际上，这个方法是 PhoneNumber 的一个非常好的 hashCode 方法实现，与 Java 库中的 hashCode 方法实现相当。它很简单，速度也相当快，并且合理地将不相等的电话号码分散到不同的散列桶中。</p><p>虽然本条目中的方法产生了相当不错的散列算法，但它们并不是最先进的。它们的质量可与 Java 库的值类型中的散列算法相媲美，对于大多数用途来说都是足够的。如果你确实需要不太可能产生冲突的散列算法，请参阅 Guava 的 com.google.common.hash.Hashing [Guava]。</p><p>Objects 类有一个静态方法，它接受任意数量的对象并返回它们的散列码。这个名为 <code>hash</code> 的方法允许你编写只有一行代码的 hashCode 方法，这些方法的质量可以与本条目中提供的编写方法媲美。不幸的是，它们运行得更慢，因为它们需要创建数组来传递可变数量的参数，如果任何参数是原始类型的，则需要进行装箱和拆箱。推荐只在性能不重要的情况下使用这种散列算法。下面是使用这种技术编写的 PhoneNumber 的散列算法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// One-line hashCode method - mediocre performance</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Objects.<span style=color:#a6e22e>hash</span>(lineNum, prefix, areaCode);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果一个类是不可变的，并且计算散列码的成本非常高，那么你可以考虑在对象中缓存散列码，而不是在每次请求时重新计算它。如果你认为这种类型的大多数对象都将用作散列键，那么你应该在创建实例时计算散列码。否则，你可以选择在第一次调用 hashCode 方法时延迟初始化散列码。在一个延迟初始化的字段的情况下，需要注意以确保该类仍然是线程安全的。我们的 PhoneNumber 类不值得进行这种处理，但只是为了向你展示它是如何实现的，如下所示。注意，散列字段的初始值（在本例中为 0）不应该是通常创建的实例的散列码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// hashCode method with lazily initialized cached hash code</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> hashCode; <span style=color:#75715e>// Automatically initialized to 0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> hashCode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (result <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> Short.<span style=color:#a6e22e>hashCode</span>(areaCode);
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> 31 <span style=color:#f92672>*</span> result <span style=color:#f92672>+</span> Short.<span style=color:#a6e22e>hashCode</span>(prefix);
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> 31 <span style=color:#f92672>*</span> result <span style=color:#f92672>+</span> Short.<span style=color:#a6e22e>hashCode</span>(lineNum);
</span></span><span style=display:flex><span>        hashCode <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>不要试图从散列码计算中排除重要字段，以提高性能。</strong> 虽然得到的散列算法可能运行得更快，但其糟糕的质量可能会将散列表的性能降低到无法使用的程度。特别是，散列算法可能会遇到大量实例，这些实例在你选择忽略的不同区域。如果发生这种情况，散列算法将把所有这些实例映射很少一部分散列码，使得原本应该在线性阶 <code>O(n)</code> 运行的程序将在平方阶 <code>O(n^2)</code> 运行。</p><p>这不仅仅是一个理论问题。在 Java 2 之前，字符串散列算法在字符串中，以第一个字符开始，最多使用 16 个字符。对于大量且分层次的集合（如 url），该函数完全展示了前面描述的病态行为。</p><p><strong>不要为 hashCode 返回的值提供详细的规范，这样客户端就不能理所应当的依赖它。这（也）给了你更改它的余地。</strong> Java 库中的许多类，例如 String 和 Integer，都将 hashCode 方法返回的确切值指定为实例值的函数。这不是一个好主意，而是一个我们不得不面对的错误：它阻碍了在未来版本中提高散列算法的能力。如果你保留了未指定的细节，并且在散列算法中发现了缺陷，或者发现了更好的散列算法，那么你可以在后续版本中更改它。</p><p>总之，每次覆盖 equals 方法时都必须覆盖 hashCode 方法，否则程序将无法正确运行。你的 hashCode 方法必须遵守 Object 中指定的通用约定，并且必须合理地将不相等的散列码分配给不相等的实例。这很容易实现，如果有点枯燥，可使用第 51 页的方法。AutoValue 框架提供了一种能很好的替代手动编写 equals 方法和 hashCode 方法的功能，IDE 也提供了这种功能。</p><h2 id=总结>总结</h2><p>在《Effective Java 3》第三章《对象的通用方法》中，确实提到了一个重要的原则，即在覆盖 equals 方法时，总要覆盖 hashCode 方法。</p><p>这是因为，如果两个对象在 equals 方法中被认为是相等的，那么它们的 hashCode 方法也必须返回相同的值。这是因为在 Java 中，如果两个对象的 hashCode 不同，则它们将被认为是不同的对象，即使它们在 equals 方法中被认为是相等的。</p><p>因此，如果不覆盖 hashCode 方法，那么可能会导致在使用哈希表、哈希集合或哈希映射等数据结构时出现问题。这些数据结构通常使用 hashCode 方法来确定对象在数据结构中的位置，如果 hashCode 方法没有正确实现，那么可能会导致对象无法正确添加、删除或查找。</p><p>因此，当覆盖 equals 方法时，总要覆盖 hashCode 方法，并确保 hashCode 方法的实现与 equals 方法的实现一致。在实现 hashCode 方法时，通常需要考虑对象的所有属性，并根据属性的值计算一个哈希码，以保证不同的对象具有不同的哈希码，相同的对象具有相同的哈希码。</p><p>在 Java 中，可以使用 Objects 类的 hash 方法来计算对象的哈希码，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Objects.<span style=color:#a6e22e>hash</span>(property1, property2, ...);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中，property1、property2 等为对象的属性，可以根据实际情况进行调整。</p><p>总之，在覆盖 equals 方法时，总要覆盖 hashCode 方法，并确保 hashCode 方法的实现与 equals 方法的实现一致。这是 Java 编程中一个重要的原则，应该在实际编程中加以注意。</p><p>以下是一些在 Java 中实现 hashCode 时需要避免的常见错误：</p><ol><li>不考虑所有相关字段：在实现 hashCode 时，需要考虑所有相关字段，这些字段对于对象的标识至关重要。如果省略了一个字段，那么可能会导致相等的对象具有不同的哈希码，这可能会在使用哈希表或哈希集合等数据结构时出现问题。</li><li>使用可变字段：如果对象具有可变字段，则不应将它们包含在 hashCode 计算中。这是因为对象的哈希码应该在其生命周期内保持不变，包含可变字段可能会导致哈希码发生变化，即使对象的标识保持不变。</li><li>分布不均匀：良好的 hashCode 实现应该生成在哈希表中均匀分布的哈希码。如果哈希码不均匀分布，可能会导致哈希表性能下降或冲突。</li><li>不使用质数：在计算 hashCode 时，常常使用质数来避免冲突。如果不使用质数，可能会导致更多的冲突和较差的性能。</li><li>使用默认实现：如果不重写 hashCode，将使用 Object 类提供的默认实现，该实现只返回对象的内存地址。这可能对某些情况足够，但不能保证生成唯一的哈希码，可能会在使用哈希表或哈希集合等数据结构时出现问题。</li><li>与 equals 不一致：hashCode 实现应该与 equals 实现保持一致，这意味着如果根据 equals 实现，两个对象相等，则它们应该具有相同的 hashCode。如果未确保一致性，可能会在使用哈希表或哈希集合等数据结构时出现问题。</li><li>不缓存哈希码：计算对象的哈希码可能是一个昂贵的操作，因此通常需要在计算出哈希码后缓存它。如果不缓存哈希码，可能会导致性能问题，特别是在使用哈希表或哈希集合等数据结构时。</li></ol><p>要确保 hashCode 分布均匀，可以采用以下方法：</p><ol><li>使用所有相关字段：在计算 hashCode 时，需要使用所有相关字段，以确保所有字段都对生成的哈希码有贡献。如果省略字段，则可能会导致相等的对象具有不同的哈希码，从而影响哈希表或哈希集合等数据结构的性能。</li><li>选择适当的哈希函数：选择适当的哈希函数可以确保生成的哈希码分布均匀。例如，Java 中的 Objects 类提供了一些哈希函数，例如 hash、hashCombine 等，可以根据需要选择适当的哈希函数。</li><li>使用质数：使用质数可以避免哈希冲突。在计算 hashCode 时，可以使用质数来计算不同字段的哈希码，然后将它们组合起来以生成最终的哈希码。</li><li>压缩哈希码：在生成哈希码后，可以将其压缩到哈希表的合法范围内，以确保哈希码分布均匀。例如，如果哈希表大小为 2 的 n 次方，可以通过将哈希码与 2 的 n 次方-1 进行按位与运算来压缩哈希码，以确保哈希码在 0 到 2 的 n 次方-1 之间均匀分布。</li><li>使用哈希码随机化：在生成哈希码后，可以对其进行随机化，以避免敌手攻击和哈希冲突。例如，可以使用一个随机数，将其与哈希码混合，以生成最终的哈希码。</li></ol><p>哈希冲突是指不同的键（key）在哈希表中映射到相同的位置（索引）的情况。为了处理哈希冲突，可以采用以下几种方法：</p><ol><li>开放地址法：开放地址法是一种常用的处理哈希冲突的方法，它的思想是在哈希表中寻找一个空槽，将冲突的键放入该槽中。常用的开放地址法包括线性探测、二次探测和双重散列等。</li><li>链地址法：链地址法是另一种常用的处理哈希冲突的方法，它的思想是将哈希表中同一个位置的所有键放在一个链表中。当发生哈希冲突时，只需要将冲突的键添加到链表的末尾即可。链地址法适用于存储大量数据的哈希表。</li><li>再哈希法：再哈希法是一种处理哈希冲突的方法，它的思想是使用另一个哈希函数来计算冲突键的哈希值。当发生哈希冲突时，使用另一个哈希函数重新计算哈希值，直到找到一个空槽插入键为止。</li><li>建立公共溢出区：建立公共溢出区是一种处理哈希冲突的方法，它的思想是在哈希表中保留一些位置，用于存储哈希冲突的键。当发生哈希冲突时，将冲突的键放入公共溢出区中，而不是在哈希表的其他位置中。</li></ol><p>无论采用哪种方法，处理哈希冲突时需要考虑以下几个方面：</p><ol><li>效率：处理哈希冲突的方法应该具有高效性，能够在不影响性能的情况下解决哈希冲突。</li><li>冲突解决度：处理哈希冲突的方法应该具有良好的冲突解决度，能够尽可能地减少哈希冲突的发生。</li><li>实现复杂度：处理哈希冲突的方法应该易于实现和维护。</li></ol></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b011%ef%bc%9a%e5%bd%93%e8%a6%86%e7%9b%96%20equals%20%e6%96%b9%e6%b3%95%e6%97%b6%ef%bc%8c%e6%80%bb%e8%a6%81%e8%a6%86%e7%9b%96%20hashCode%20%e6%96%b9%e6%b3%95 https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f23%2falways-override-hashcode-when-you-override-equals%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f23%2falways-override-hashcode-when-you-override-equals%2f&title=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b011%ef%bc%9a%e5%bd%93%e8%a6%86%e7%9b%96%20equals%20%e6%96%b9%e6%b3%95%e6%97%b6%ef%bc%8c%e6%80%bb%e8%a6%81%e8%a6%86%e7%9b%96%20hashCode%20%e6%96%b9%e6%b3%95" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b011%ef%bc%9a%e5%bd%93%e8%a6%86%e7%9b%96%20equals%20%e6%96%b9%e6%b3%95%e6%97%b6%ef%bc%8c%e6%80%bb%e8%a6%81%e8%a6%86%e7%9b%96%20hashCode%20%e6%96%b9%e6%b3%95&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f23%2falways-override-hashcode-when-you-override-equals%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f23%2falways-override-hashcode-when-you-override-equals%2f&title=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b011%ef%bc%9a%e5%bd%93%e8%a6%86%e7%9b%96%20equals%20%e6%96%b9%e6%b3%95%e6%97%b6%ef%bc%8c%e6%80%bb%e8%a6%81%e8%a6%86%e7%9b%96%20hashCode%20%e6%96%b9%e6%b3%95" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f23%2falways-override-hashcode-when-you-override-equals%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b011%ef%bc%9a%e5%bd%93%e8%a6%86%e7%9b%96%20equals%20%e6%96%b9%e6%b3%95%e6%97%b6%ef%bc%8c%e6%80%bb%e8%a6%81%e8%a6%86%e7%9b%96%20hashCode%20%e6%96%b9%e6%b3%95%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f23%2falways-override-hashcode-when-you-override-equals%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2023/05/25/weekly_review_20/ rel=next><span class=post-title>周报-20｜自动生成每日早报、周末团建</span></a></div><div class=nav-next><a href=/posts/2023/05/23/python-comment-and-variable/ rel=prev><span class=post-title>Python学习1：注释、变量和常量</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2023/12/14/all-things-about-microprofile/>All things about MicroProfile</a></li><li><a href=/posts/2023/11/02/jhipster-intro/>JHipster安装和介绍</a></li><li><a href=/posts/2023/10/26/java-design-patterns-circuit-breaker/>Java设计模式：Circuit Breaker</a></li><li><a href=/posts/2023/10/16/java-design-patterns-chain/>Java设计模式：Chain</a></li><li><a href=/posts/2023/10/13/java-design-patterns-callback/>Java设计模式：Callback</a></li><li><a href=/posts/2023/09/25/java-design-patterns-cahcing/>Java设计模式：Caching</a></li><li><a href=/posts/2023/09/22/java-design-patterns-bytecode/>Java设计模式：Bytecode</a></li><li><a href=/posts/2023/09/05/java-design-patterns-builder/>Java设计模式：Builder</a></li><li><a href=/posts/2023/09/05/java-design-patterns-business-delegate/>Java设计模式：Business Delegate</a></li><li><a href=/posts/2023/08/28/java-design-patterns-bridge/>Java设计模式：Bridge</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link><a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a>
Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a>
<a style=margin-left:20px href=/privacy_policy/ target=_blank rel="noopener noreferrer">Privacy Policy</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>