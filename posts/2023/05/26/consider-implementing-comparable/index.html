<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。"><title>《Effective Java 3》笔记14：考虑实现 Comparable 接口 | ChenSoul</title>
<link rel=canonical href=https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/images/favicon.webp"><meta name=twitter:title content="《Effective Java 3》笔记14：考虑实现 Comparable 接口"><meta name=twitter:description content="本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。"><meta name=twitter:creator content="@ichensoul"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="《Effective Java 3》笔记14：考虑实现 Comparable 接口"><meta property="og:description" content="本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-26T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-26T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="og:image" content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=name content="《Effective Java 3》笔记14：考虑实现 Comparable 接口"><meta itemprop=description content="本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。"><meta itemprop=datePublished content="2023-05-26T00:00:00+00:00"><meta itemprop=dateModified content="2023-05-26T00:00:00+00:00"><meta itemprop=wordCount content="719"><meta itemprop=image content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=keywords content="Java"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"《Effective Java 3》笔记14：考虑实现 Comparable 接口","headline":"《Effective Java 3》笔记14：考虑实现 Comparable 接口","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/","description":"\u003cp\u003e本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。\u003c/p\u003e","wordCount":"719","keywords":["java"],"datePublished":"2023-05-26T00:00:00Z","dateModified":"2023-05-26T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://x.com/ichensoul","https://github.com/chensoul","https://www.linkedin.com/in/","https://www.youtube.com/@chensoul","https://t.me/chensouls"]}]}</script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/ rel=bookmark title="《Effective Java 3》笔记14：考虑实现 Comparable 接口">《Effective Java 3》笔记14：考虑实现 Comparable 接口</a></h2><hr><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2023-05-26T00:00:00>2023-05-26
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/java/ title=java>java</a></span></div></header><div style=background-color:#f1f3f5;margin-top:20px><aside style=margin:5px><span style=font-size:20px;font-weight:700>Table of Contents</span><div style=padding-left:30px><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#总结>总结</a></li></ul></nav></div></aside></div><div class=entry-content><p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。</p><h2 id=介绍>介绍</h2><p>与本章讨论的其他方法不同，compareTo 方法不是在 Object 中声明的。相反，它是 Comparable 接口中的唯一方法。它在性质上类似于 Object 的 equals 方法，除了简单的相等比较之外，它还允许顺序比较，而且它是通用的。一个类实现 Comparable，表明实例具有自然顺序。对实现 Comparable 的对象数组进行排序非常简单：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Arrays.<span style=color:#a6e22e>sort</span>(a);
</span></span></code></pre></div><p>类似地，搜索、计算极值和维护 Comparable 对象的自动排序集合也很容易。例如，下面的程序依赖于 String 实现 Comparable 这一事实，将命令行参数列表按字母顺序打印出来，并消除重复：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WordList</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> s <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeSet<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        Collections.<span style=color:#a6e22e>addAll</span>(s, args);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过让类实现 Comparable，就可与依赖于此接口的所有通用算法和集合实现进行互操作。你只需付出一点点努力就能获得强大的功能。实际上，Java 库中的所有值类以及所有枚举类型都实现了 Comparable。如果编写的值类具有明显的自然顺序，如字母顺序、数字顺序或时间顺序，则应实现 Comparable 接口：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Comparable</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compareTo</span>(T t);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>compareTo 方法的一般约定类似于 equals 方法：</p><p>将一个对象与指定的对象进行顺序比较。当该对象小于、等于或大于指定对象时，对应返回一个负整数、零或正整数。如果指定对象的类型阻止它与该对象进行比较，则抛出 ClassCastException。</p><p>在下面的描述中，<code>sgn(expression)</code> 表示数学中的符号函数，它被定义为：根据传入表达式的值是负数、零或正数，对应返回 -1、0 或 1。</p><ul><li>实现者必须确保所有 x 和 y 满足 <code>sgn(x.compareTo(y)) == -sgn(y.compareTo(x))</code>（这意味着 <code>x.compareTo(y)</code> 当且仅当 <code>y.compareTo(x)</code> 抛出异常时才抛出异常）。</li><li>实现者还必须确保关系是可传递的：<code>(x.compareTo(y) > 0 && y.compareTo(z) > 0)</code> 意味着 <code>x.compareTo(z) > 0</code>。</li><li>最后，实现者必须确保 <code>x.compareTo(y) == 0</code> 时，所有的 z 满足 <code>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</code>。</li><li>强烈建议 <code>(x.compareTo(y)== 0) == (x.equals(y))</code> 成立，但不是必需的。一般来说，任何实现 Comparable 接口并违反此条件的类都应该清楚地注明这一事实。推荐使用的表述是「注意：该类的自然顺序与 equals 不一致。」</li></ul><p>不要被这些约定的数学性质所影响。就像 equals 约定一样，这个约定并不像看起来那么复杂。与 equals 方法不同，equals 方法对所有对象都施加了全局等价关系，compareTo 不需要跨越不同类型的对象工作：当遇到不同类型的对象时，compareTo 允许抛出 ClassCastException。通常，它就是这么做的。该约定确实允许类型间比较，这种比较通常在被比较对象实现的接口中定义。</p><p>就像违反 hashCode 约定的类可以破坏依赖 hash 的其他类一样，违反 compareTo 约定的类也可以破坏依赖 Comparable 的其他类。依赖 Comparable 的类包括排序集合 TreeSet 和 TreeMap，以及实用工具类 Collections 和 Arrays，它们都包含搜索和排序算法。</p><p>让我们看一下 compareTo 约定的细节。第一个规定指出，如果你颠倒两个对象引用之间的比较的方向，就应当发生这样的情况：如果第一个对象小于第二个对象，那么第二个对象必须大于第一个；如果第一个对象等于第二个对象，那么第二个对象一定等于第一个对象；如果第一个对象大于第二个对象，那么第二个对象一定小于第一个对象。第二个规定指出，如果一个对象大于第二个，第二个大于第三个，那么第一个对象一定大于第三个对象。最后一个规定指出，所有 compareTo 结果为相等的对象分别与任何其他对象相比，必须产生相同的结果。</p><p>这三种规定的一个结果是，由 compareTo 方法进行的相等性检验必须遵守由 equals 约定进行的相同的限制：反身性、对称性和传递性。因此，同样的警告也适用于此：除非你愿意放弃面向对象的抽象优点，否则无法在保留 compareTo 约定的同时使用新值组件扩展可实例化类。同样的解决方案也适用。如果要向实现 Comparable 的类中添加值组件，不要继承它；编写一个不相关的类，其中包含第一个类的实例。然后提供返回所包含实例的「视图」方法。这使你可以自由地在包含类上实现你喜欢的任何 compareTo 方法，同时允许它的客户端在需要时将包含类的实例视为包含类的实例。</p><p>compareTo 约定的最后一段是一个强烈的建议，而不是一个真正的要求，它只是简单地说明了 compareTo 方法所施加的同等性检验通常应该与 equals 方法返回相同的结果。如果遵守了这一规定，则 compareTo 方法所施加的排序与 equals 方法一致。如果违反这条建议，那么它的顺序就与 equals 不一致。如果一个类的 compareTo 方法强加了一个与 equals 不一致的顺序，那么这个类仍然可以工作，但是包含该类元素的有序集合可能无法遵守集合接口（Collection、Set 或 Map）的一般约定。这是因为这些接口的一般约定是根据 equals 方法定义的，但是有序集合使用 compareTo 代替了 equals 实施同等性检验。如果发生这种情况，这不是一场灾难，但这是需要注意的。</p><p>例如，考虑 BigDecimal 类，它的 compareTo 方法与 equals 不一致。如果你创建一个空的 HashSet 实例，然后添加 <code>new BigDecimal("1.0")</code> 和 <code>new BigDecimal("1.00")</code>，那么该 HashSet 将包含两个元素，因为添加到该集合的两个 BigDecimal 实例在使用 equals 方法进行比较时结果是不相等的。但是，如果你使用 TreeSet 而不是 HashSet 执行相同的过程，那么该集合将只包含一个元素，因为使用 compareTo 方法比较两个 BigDecimal 实例时结果是相等的。（有关详细信息，请参阅 BigDecimal 文档。）</p><p>编写 compareTo 方法类似于编写 equals 方法，但是有一些关键的区别。因为 Comparable 接口是参数化的，compareTo 方法是静态类型的，所以不需要进行类型检查或强制转换它的参数。如果参数类型错误，则该调用将不能编译。如果参数为 null，则调用应该抛出 NullPointerException，并且在方法尝试访问其成员时抛出该异常。</p><p>在 compareTo 方法中，字段是按顺序而不是按同等性来比较的。要比较对象引用字段，要递归调用 compareTo 方法。如果一个字段没有实现 Comparable，或者需要一个非标准的排序，那么应使用 Comparator。可以编写自定义的比较器，或使用现有的比较器，如 CaseInsensitiveString 的 compareTo 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Single-field Comparable with object reference field</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CaseInsensitiveString</span> <span style=color:#66d9ef>implements</span> Comparable<span style=color:#f92672>&lt;</span>CaseInsensitiveString<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compareTo</span>(CaseInsensitiveString cis) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> String.<span style=color:#a6e22e>CASE_INSENSITIVE_ORDER</span>.<span style=color:#a6e22e>compare</span>(s, cis.<span style=color:#a6e22e>s</span>);
</span></span><span style=display:flex><span>    } ... <span style=color:#75715e>// Remainder omitted</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意 CaseInsensitiveString 实现了 <code>Comparable&lt;CaseInsensitiveString></code>。这意味着 CaseInsensitiveString 引用只能与另一个 CaseInsensitiveString 引用进行比较。这是在声明实现 Comparable 的类时要遵循的常规模式。</p><p>本书的旧版本建议 compareTo 方法使用关系运算符 &lt; 和 > 来比较整数基本类型字段，使用静态方法 <code>Double.compare</code> 和 <code>Float.compare</code> 来比较浮点基本类型字段。在 Java 7 中，静态比较方法被添加到所有 Java 的包装类中。<strong>在 compareTo 方法中使用关系运算符 &lt; 和 > 冗长且容易出错，因此不再推荐使用。</strong></p><p>如果一个类有多个重要字段，那么比较它们的顺序非常关键。从最重要的字段开始，一步步往下。如果比较的结果不是 0（用 0 表示相等），那么就完成了；直接返回结果。如果最重要的字段是相等的，就比较下一个最重要的字段，以此类推，直到找到一个不相等的字段或比较到最不重要的字段为止。下面是 PhoneNumber 类的 compareTo 方法，演示了这种技术：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Multiple-field Comparable with primitive fields</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compareTo</span>(PhoneNumber pn) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> Short.<span style=color:#a6e22e>compare</span>(areaCode, pn.<span style=color:#a6e22e>areaCode</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (result <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> Short.<span style=color:#a6e22e>compare</span>(prefix, pn.<span style=color:#a6e22e>prefix</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (result <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>            result <span style=color:#f92672>=</span> Short.<span style=color:#a6e22e>compare</span>(lineNum, pn.<span style=color:#a6e22e>lineNum</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 Java 8 中，Comparator 接口配备了一组比较器构造方法，可以流畅地构造比较器。然后可以使用这些比较器来实现 Comparator 接口所要求的 compareTo 方法。许多程序员更喜欢这种方法的简明，尽管它存在一些性能成本：在我的机器上，PhoneNumber 实例的数组排序要慢 10% 左右。在使用这种方法时，请考虑使用 Java 的静态导入功能，这样你就可以通过静态比较器构造方法的简单名称来引用它们，以获得清晰和简洁。下面是 PhoneNumber 类的 compareTo 方法改进后的样子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Comparable with comparator construction methods</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Comparator<span style=color:#f92672>&lt;</span>PhoneNumber<span style=color:#f92672>&gt;</span> COMPARATOR <span style=color:#f92672>=</span> comparingInt((PhoneNumber pn) <span style=color:#f92672>-&gt;</span> pn.<span style=color:#a6e22e>areaCode</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>thenComparingInt</span>(pn <span style=color:#f92672>-&gt;</span> pn.<span style=color:#a6e22e>prefix</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>thenComparingInt</span>(pn <span style=color:#f92672>-&gt;</span> pn.<span style=color:#a6e22e>lineNum</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compareTo</span>(PhoneNumber pn) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> COMPARATOR.<span style=color:#a6e22e>compare</span>(<span style=color:#66d9ef>this</span>, pn);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个实现在类初始化时使用两个比较器构造方法构建一个比较器。第一个是 comparingInt。它是一个静态方法，接受一个 key 提取器函数，该函数将对象引用映射到 int 类型的 key ，并返回一个比较器，比较器根据该 key 对实例进行排序。在上述的示例中，comparingInt 使用 lambda 表达式从 PhoneNumber 中提取 areaCode，并返回 <code>Comparator&lt;PhoneNumber></code>，按区号来排序电话号码。注意，lambda 表达式显式地指定其输入参数的类型为 PhoneNumber。事实证明，在这种情况下，Java 的类型推断并没有强大到足以自己判断类型，因此我们不得不帮助它来编译程序。</p><p>如果两个电话号码有相同的区号，我们需要进一步改进比较，这正是第二个 comparator 构造方法 thenComparingInt 所做的。它是 Comparator 上的一个实例方法，它接受一个 int 类型的 key 提取函数，并返回一个比较器，该比较器首先应用原始比较器，然后使用提取的 key 来断开连接。你可以任意堆叠对 thenComparingInt 的调用，从而形成字典顺序。在上面的例子中，我们将两个对 thenComparingInt 的调用叠加起来，得到一个排序，它的第二个 key 是 prefix，而第三个 key 是 lineNum。注意，我们不必指定传递给两个调用 thenComparingInt 的 key 提取器函数的参数类型：Java 的类型推断足够智能，可以自行解决这个问题。</p><p>Comparator 类具有完整的构造方法。对于 long 和 double 的基本类型，有类似 comparingInt 和 thenComparingInt 的方法。int 版本还可以用于范围更小的整数类型，如 PhoneNumber 示例中的 short。double 版本也可以用于 float。Comparator 类提供的构造方法覆盖了所有 Java 数值基本类型。</p><p>也有对象引用类型的比较器构造方法。静态方法名为 compare，它有两个重载。一个是使用 key 提取器并使用 key 的自然顺序。第二种方法同时使用 key 提取器和比较器对提取的 key 进行比较。实例方法有三种重载，称为 thenComparing。一个重载只需要一个比较器并使用它来提供一个二级顺序。第二个重载只接受一个 key 提取器，并将 key 的自然顺序用作二级顺序。最后的重载需要一个 key 提取器和一个比较器来对提取的 key 进行比较。</p><p>有时候，你可能会看到 compareTo 或 compare 方法，它们依赖于以下事实：如果第一个值小于第二个值，则两个值之间的差为负；如果两个值相等，则为零；如果第一个值大于零，则为正。下面是一个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// BROKEN difference-based comparator - violates transitivity!</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> Comparator<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> hashCodeOrder <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Comparator<span style=color:#f92672>&lt;&gt;</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compare</span>(Object o1, Object o2) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> o1.<span style=color:#a6e22e>hashCode</span>() <span style=color:#f92672>-</span> o2.<span style=color:#a6e22e>hashCode</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>不要使用这种技术。它充满了来自整数溢出和 IEEE 754 浮点运算构件的危险 [JLS 15.20.1, 15.21.1]。此外，生成的方法不太可能比使用本项目中描述的技术编写的方法快得多。应使用静态比较方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Comparator based on static compare method</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> Comparator<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> hashCodeOrder <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Comparator<span style=color:#f92672>&lt;&gt;</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compare</span>(Object o1, Object o2) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Integer.<span style=color:#a6e22e>compare</span>(o1.<span style=color:#a6e22e>hashCode</span>(), o2.<span style=color:#a6e22e>hashCode</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>或比较器构造方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Comparator based on Comparator construction method</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> Comparator<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> hashCodeOrder <span style=color:#f92672>=</span> Comparator
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>comparingInt</span>(o <span style=color:#f92672>-&gt;</span> o.<span style=color:#a6e22e>hashCode</span>());
</span></span></code></pre></div><p>总之，无论何时实现具有排序性质的值类，都应该让类实现 Comparable 接口，这样就可以轻松地对实例进行排序、搜索，并与依赖于此接口的集合实现进行互操作。在 compareTo 方法的实现中比较字段值时，避免使用 &lt; 和 > 操作符，应使用包装类中的静态比较方法或 Comparator 接口中的 comparator 构造方法。</p><h2 id=总结>总结</h2><p>建议在实现比较功能时，应该考虑实现 <code>Comparable</code> 接口。<code>Comparable</code> 接口是一个泛型接口，其中只包含一个方法 <code>compareTo(T o)</code>，用于比较当前对象和另一个对象的大小关系。实现 <code>Comparable</code> 接口可以使得一个类具有可比性，从而可以进行排序等操作。</p><p>以下是在实现 <code>Comparable</code> 接口时需要注意的一些问题：</p><ol><li>首先，需要确保类实现了 <code>Comparable</code> 接口，并实现了 <code>compareTo</code> 方法。在实现 <code>compareTo</code> 方法时，需要考虑到对象的比较顺序，并返回一个整数值表示两个对象之间的大小关系。</li><li>在实现 <code>compareTo</code> 方法时，需要确保比较结果的一致性、对称性和传递性。具体来说，如果 <code>a.compareTo(b)</code> 返回正整数，那么 <code>b.compareTo(a)</code> 应该返回负整数；如果 <code>a.compareTo(b)</code> 和 <code>b.compareTo(c)</code> 的返回值都是正整数，那么 <code>a.compareTo(c)</code> 的返回值也应该是正整数。</li><li>如果一个类有多个可以比较的属性，那么在实现 <code>compareTo</code> 方法时需要按照比较的优先级进行比较。通常，可以先比较第一个属性，如果相等再比较第二个属性，以此类推。</li><li>如果一个类实现了 <code>Comparable</code> 接口，那么通常也应该同时实现 <code>equals</code> 和 <code>hashCode</code> 方法。在实现 <code>equals</code> 方法时，需要考虑到比较的对象是否为 null、对象类型是否相同等因素。在实现 <code>hashCode</code> 方法时，通常需要使用类中可比较属性的哈希值，以确保哈希表等数据结构能够正确地处理该类的对象。</li><li>如果一个类需要支持多种比较方式，那么可以考虑使用策略模式或者比较器（Comparator）接口来实现。使用比较器接口可以在运行时动态地指定比较方式，从而更加灵活。</li></ol><p>实现 <code>Comparable</code> 接口的示例代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>implements</span> Comparable<span style=color:#f92672>&lt;</span>Person<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name,<span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 实现 compareTo 方法，按照年龄升序排序</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compareTo</span>(Person o) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Integer.<span style=color:#a6e22e>compare</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>, o.<span style=color:#a6e22e>age</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 实现 equals 方法和 hashCode 方法</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span>(Object obj) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (obj <span style=color:#f92672>==</span> <span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(obj <span style=color:#66d9ef>instanceof</span> Person)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Person other <span style=color:#f92672>=</span> (Person) obj;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Objects.<span style=color:#a6e22e>equals</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>, other.<span style=color:#a6e22e>name</span>) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>==</span> other.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Objects.<span style=color:#a6e22e>hash</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面的示例代码中，<code>Person</code> 类实现了 <code>Comparable</code> 接口，并实现了 <code>compareTo</code> 方法。在该方法中，我们按照对象的年龄升序排序。为了确保 <code>equals</code> 方法和 <code>hashCode</code> 方法的正确性，我们也实现了这两个方法，以确保 <code>Person</code> 对象在使用哈希表等数据结构时能够正常工作。</p></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b014%ef%bc%9a%e8%80%83%e8%99%91%e5%ae%9e%e7%8e%b0%20Comparable%20%e6%8e%a5%e5%8f%a3 https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f26%2fconsider-implementing-comparable%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f26%2fconsider-implementing-comparable%2f&title=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b014%ef%bc%9a%e8%80%83%e8%99%91%e5%ae%9e%e7%8e%b0%20Comparable%20%e6%8e%a5%e5%8f%a3" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b014%ef%bc%9a%e8%80%83%e8%99%91%e5%ae%9e%e7%8e%b0%20Comparable%20%e6%8e%a5%e5%8f%a3&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f26%2fconsider-implementing-comparable%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f26%2fconsider-implementing-comparable%2f&title=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b014%ef%bc%9a%e8%80%83%e8%99%91%e5%ae%9e%e7%8e%b0%20Comparable%20%e6%8e%a5%e5%8f%a3" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f26%2fconsider-implementing-comparable%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=%e3%80%8aEffective%20Java%203%e3%80%8b%e7%ac%94%e8%ae%b014%ef%bc%9a%e8%80%83%e8%99%91%e5%ae%9e%e7%8e%b0%20Comparable%20%e6%8e%a5%e5%8f%a3%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f26%2fconsider-implementing-comparable%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2023/05/26/override-clone-judiciously/ rel=next><span class=post-title>《Effective Java 3》笔记13：明智地覆盖 clone 方法</span></a></div><div class=nav-next><a href=/posts/2023/05/26/java-design-patterns-active-object/ rel=prev><span class=post-title>Java设计模式：Active Object</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2023/12/14/all-things-about-microprofile/>All things about MicroProfile</a></li><li><a href=/posts/2023/11/02/jhipster-intro/>JHipster安装和介绍</a></li><li><a href=/posts/2023/10/26/java-design-patterns-circuit-breaker/>Java设计模式：Circuit Breaker</a></li><li><a href=/posts/2023/10/16/java-design-patterns-chain/>Java设计模式：Chain</a></li><li><a href=/posts/2023/10/13/java-design-patterns-callback/>Java设计模式：Callback</a></li><li><a href=/posts/2023/09/25/java-design-patterns-cahcing/>Java设计模式：Caching</a></li><li><a href=/posts/2023/09/22/java-design-patterns-bytecode/>Java设计模式：Bytecode</a></li><li><a href=/posts/2023/09/05/java-design-patterns-builder/>Java设计模式：Builder</a></li><li><a href=/posts/2023/09/05/java-design-patterns-business-delegate/>Java设计模式：Business Delegate</a></li><li><a href=/posts/2023/08/28/java-design-patterns-bridge/>Java设计模式：Bridge</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link><a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a>
Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a>
<a style=margin-left:20px href=/privacy_policy/ target=_blank rel="noopener noreferrer">Privacy Policy</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>