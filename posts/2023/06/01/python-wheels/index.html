<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]什么是 Python Wheels，你为什么要关心它？ | ChenSoul</title>
<meta name=keywords content="python"><meta name=description content="
Python .whl 文件或 wheels 是 Python 中很少被讨论的部分，但它们对 Python 包的安装过程大有裨益。如果您使用 pip 安装了 Python 包，那么 Wheels 很可能使安装更快、更高效。
Wheels 是 Python 生态系统的一个组件，有助于使包安装正常工作。它们允许更快的安装和更稳定的包分发过程。在本教程中，您将深入了解 Wheels 是什么，它们有什么好处，以及它们如何获得牵引力并使 Python 使用起来更加愉快。"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/06/01/python-wheels/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.899d9a536396b9b03c9eae0c99cc6ec954a90da94036f5390d131eb8071bb417.css integrity="sha256-iZ2aU2OWubA8nq4MmcxuyVSpDalANvU5DRMeuAcbtBc=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/06/01/python-wheels/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="[译]什么是 Python Wheels，你为什么要关心它？"><meta property="og:description" content="
Python .whl 文件或 wheels 是 Python 中很少被讨论的部分，但它们对 Python 包的安装过程大有裨益。如果您使用 pip 安装了 Python 包，那么 Wheels 很可能使安装更快、更高效。
Wheels 是 Python 生态系统的一个组件，有助于使包安装正常工作。它们允许更快的安装和更稳定的包分发过程。在本教程中，您将深入了解 Wheels 是什么，它们有什么好处，以及它们如何获得牵引力并使 Python 使用起来更加愉快。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/06/01/python-wheels/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-01T00:00:00+08:00"><meta property="article:modified_time" content="2023-06-01T00:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]什么是 Python Wheels，你为什么要关心它？"><meta name=twitter:description content="
Python .whl 文件或 wheels 是 Python 中很少被讨论的部分，但它们对 Python 包的安装过程大有裨益。如果您使用 pip 安装了 Python 包，那么 Wheels 很可能使安装更快、更高效。
Wheels 是 Python 生态系统的一个组件，有助于使包安装正常工作。它们允许更快的安装和更稳定的包分发过程。在本教程中，您将深入了解 Wheels 是什么，它们有什么好处，以及它们如何获得牵引力并使 Python 使用起来更加愉快。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]什么是 Python Wheels，你为什么要关心它？","item":"https://blog.chensoul.cc/posts/2023/06/01/python-wheels/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]什么是 Python Wheels，你为什么要关心它？","name":"[译]什么是 Python Wheels，你为什么要关心它？","description":"\nPython .whl 文件或 wheels 是 Python 中很少被讨论的部分，但它们对 Python 包的安装过程大有裨益。如果您使用 pip 安装了 Python 包，那么 Wheels 很可能使安装更快、更高效。\nWheels 是 Python 生态系统的一个组件，有助于使包安装正常工作。它们允许更快的安装和更稳定的包分发过程。在本教程中，您将深入了解 Wheels 是什么，它们有什么好处，以及它们如何获得牵引力并使 Python 使用起来更加愉快。\n","keywords":["python"],"articleBody":"\nPython .whl 文件或 wheels 是 Python 中很少被讨论的部分，但它们对 Python 包的安装过程大有裨益。如果您使用 pip 安装了 Python 包，那么 Wheels 很可能使安装更快、更高效。\nWheels 是 Python 生态系统的一个组件，有助于使包安装正常工作。它们允许更快的安装和更稳定的包分发过程。在本教程中，您将深入了解 Wheels 是什么，它们有什么好处，以及它们如何获得牵引力并使 Python 使用起来更加愉快。\n在本教程中，您将学习：\n什么是 Wheels 以及它们与源代码分发的比较 如何使用 Wheels 来控制包安装过程 如何为您自己的 Python 包创建和分发 Wheels 您将从用户和开发人员的角度看到使用流行的开源 Python 包的示例。\n免费赠品：单击此处获取 Python 备忘单并学习 Python 3 的基础知识，例如使用数据类型、字典、列表和 Python 函数。\n安装 接下来，激活虚拟环境并确保安装了最新版本的 pip 、 wheel 和 setuptools ：\n1 2 3 $ python -m venv env \u0026\u0026 source ./env/bin/activate $ python -m pip install -U pip wheel setuptools Successfully installed pip 20.1 setuptools-46.1.3 wheel-0.34.2 这就是您尝试安装和构建 Wheels 所需的全部内容！\nPython 打包变得更好：Python Wheels 简介 在学习如何将项目打包到 wheel 之前，从用户的角度了解使用 wheel 的样子会很有帮助。这听起来可能有点落后，但了解 Wheels 如何工作的一个好方法是从安装一个不是 Wheels 的东西开始。\n您可以像往常一样，通过将 Python 包安装到您的环境中来开始这个实验。在这种情况下，安装 uWSGI 版本 2.0.x：\n1 2 3 4 5 6 7 8 9 10 11 $ python -m pip install 'uwsgi==2.0.*' Collecting uwsgi==2.0.* Downloading uwsgi-2.0.18.tar.gz (801 kB) |████████████████████████████████| 801 kB 1.1 MB/s Building wheels for collected packages: uwsgi Building wheel for uwsgi (setup.py) ... done Created wheel for uwsgi ... uWSGI-2.0.18-cp38-cp38-macosx_10_15_x86_64.whl Stored in directory: /private/var/folders/jc/8_hqsz0x1tdbp05 ... Successfully built uwsgi Installing collected packages: uwsgi Successfully installed uwsgi-2.0.18 为了完全安装 uWSGI， pip 通过几个不同的步骤进行：\n在第 3 行，它下载了一个名为 uwsgi-2.0.18.tar.gz 的 TAR 文件 (tarball)，该文件已使用 gzip 压缩。\n在第 6 行，它获取 tarball 并通过调用 setup.py 构建一个 .whl 文件。\n在第 7 行，它将 wheel 标记为 uWSGI-2.0.18-cp38-cp38-macosx_10_15_x86_64.whl 。\n在第 10 行，它在构建 wheel 后安装实际的包。\npip 检索到的 tar.gz tarball 是源代码分发版或 sdist ，而不是 wheel。在某些方面， sdist 与 wheel 相反。\n注意：如果您看到 uWSGI 安装错误，您可能需要安装 Python 开发头文件。\n源代码分发包含源代码。这不仅包括 Python 代码，还包括与包捆绑在一起的任何扩展模块（通常是 C 或 C++）的源代码。对于源代码分发，扩展模块是在用户端而不是开发人员端编译的。\n源分发版还包含一组元数据，位于名为 .egg-info 的目录中。此元数据有助于构建和安装包，但用户实际上不需要对其执行任何操作。\n从开发人员的角度来看，源代码分发是在您运行以下命令时创建的：\n1 $ python setup.py sdist 现在尝试安装不同的包 chardet：\n1 2 3 4 5 6 $ python -m pip install 'chardet==3.*' Collecting chardet Downloading chardet-3.0.4-py2.py3-none-any.whl (133 kB) |████████████████████████████████| 133 kB 1.5 MB/s Installing collected packages: chardet Successfully installed chardet-3.0.4 您可以看到与 uWSGI 安装明显不同的输出。\n安装 chardet 会直接从 PyPI 下载一个 .whl 文件。 Wheels 名称 chardet-3.0.4-py2.py3-none-any.whl 遵循您稍后将看到的特定命名约定。从用户的角度来看，更重要的是当 pip 在 PyPI 上找到兼容的 wheel 时，没有构建阶段。\n从开发人员的角度来看，wheel 是运行以下命令的结果：\n1 $ python setup.py bdist_wheel 为什么 uWSGI 给你一个源代码分发而 chardet 提供一个 wheel？您可以通过查看 PyPI 上每个项目的页面并导航到下载文件区域来了解其原因。本节将向您展示 pip 在 PyPI 索引服务器上实际看到的内容：\n出于与项目复杂性相关的原因，uWSGI 仅提供了一个源代码分发（ uwsgi-2.0.18.tar.gz ）。\nchardet 提供了 wheel 和源代码分发，但如果它与您的系统兼容， pip 会更喜欢 wheel。稍后您将看到如何确定兼容性。\n用于 wheel 安装的兼容性检查的另一个示例是 psycopg2 ，它为 Windows 提供了广泛的 wheels，但不为 Linux 或 macOS 客户端提供任何 wheels。这意味着 pip install psycopg2 可以根据您的特定设置获取 Wheels 或源代码分发。\n为了避免这些类型的兼容性问题，一些包提供了多个 wheels，每个 wheels 都针对特定的 Python 实现和底层操作系统。\n到目前为止，您已经看到了 wheel 和 sdist 之间的一些明显区别，但更重要的是这些差异对安装过程的影响。\nWheels 让事情变得快速 在上面，您看到了获取预制 wheels 的安装与下载 sdist 的安装的比较。 Wheels 使 Python 包的端到端安装更快，原因有二：\n在其他条件相同的情况下，wheels 的尺寸通常比源分发小，这意味着它们可以在网络中更快地移动。 直接从 wheels 安装避免了从源分发构建包的中间步骤。 几乎可以保证 chardet 安装只用了 uWSGI 所需时间的一小部分。然而，这可以说是一个不公平的苹果与橘子的比较，因为 chardet 是一个小得多且不那么复杂的包。\n使用不同的命令，您可以创建更直接的比较，以证明 wheels 的差异有多大。\n您可以通过传递 --no-binary 选项让 pip 忽略它对 wheels 的倾斜：\n1 2 3 4 5 $ time python -m pip install \\ --no-cache-dir \\ --force-reinstall \\ --no-binary=:all: \\ cryptography 此命令计时 cryptography 包的安装，告诉 pip 使用源代码分发，即使有合适的 Wheels 可用。包含 :all: 会使规则适用于 cryptography 及其所有依赖项。\n在我的机器上，这从开始到结束大约需要 32 秒。不仅安装需要很长时间，而且构建 cryptography 还需要您拥有 OpenSSL 开发标头并可供 Python 使用。\n注意：对于 --no-binary ，您很可能会看到有关缺少 cryptography 安装所需的头文件的错误，这是使用源代码分发令人沮丧的部分原因。如果是这样， cryptography 文档的安装部分会就特定操作系统需要哪些库和头文件提供建议。\n现在您可以重新安装 cryptography ，但这次要确保 pip 使用 PyPI 的 Wheels 。因为 pip 更喜欢 Wheels ，这类似于不带任何参数调用 pip install 。但在这种情况下，您可以通过要求带有 --only-binary 的 Wheels 来明确意图：\n1 2 3 4 5 $ time python -m pip install \\ --no-cache-dir \\ --force-reinstall \\ --only-binary=cryptography \\ cryptography 此选项只需要四秒多一点，或者是仅使用 cryptography 及其依赖项的源代码分发时所用时间的八分之一。\n什么是 Python Wheel？ Python .whl 文件本质上是一个 ZIP ( .zip ) 存档，带有特制的文件名，告诉安装者 Wheels 将支持哪些 Python 版本和平台。\nWheels 是一种内置分发。在这种情况下，built 意味着 wheel 以可立即安装的格式出现，并允许您跳过源代码分发所需的构建阶段。\n注意：值得一提的是，尽管使用了术语构建，但 Wheels 不包含 .pyc 文件或编译的 Python 字节码。\nwheel 文件名被分成由连字符分隔的部分：\n1 {dist}-{version}(-{build})?-{python}-{abi}-{platform}.whl {brackets} 中的每个部分都是一个标签，或者是 wheel 名称的一个组成部分，它带有一些关于 wheel 包含的内容以及 wheel 将在何处工作或不工作的含义。\n这是一个使用 cryptography Wheels 的说明性示例：\n1 cryptography-2.9.2-cp35-abi3-macosx_10_9_x86_64.whl cryptography 分配多个 Wheels 。每个 Wheels 都是一个平台 Wheels ，这意味着它仅支持 Python 版本、Python ABI、操作系统和机器架构的特定组合。您可以将命名约定分解为多个部分：\ncryptography 是包名。 2.9.2 是 cryptography 的包版本。版本是符合 PEP 440 的字符串，例如 2.9.2 、 3.4 或 3.9.0.a3 。 cp35 是 Python 标签，表示 Wheels 需要的 Python 实现和版本。 cp 代表 CPython，Python 的参考实现，而 35 代表 Python 3.5。例如，这个 Wheels 与 Jython 不兼容。 abi3 是 ABI 标签。 ABI 代表应用程序二进制接口。你真的不需要担心它需要什么，但是 abi3 是一个单独的版本，用于 Python C API 的二进制兼容性。 macosx_10_9_x86_64 是平台标签，正好比较啰嗦。在这种情况下，它可以进一步细分为子部分： macosx 是 macOS 操作系统。 10_9 是用于编译 Python 的 macOS 开发人员工具 SDK 版本，而 Python 又构建了这个 Wheels 。 x86_64 是对 x86-64 指令集架构的引用。 最后一个组件在技术上不是标签，而是标准的 .whl 文件扩展名。组合起来，上述组件表明此 cryptography Wheels 设计的目标机器。\n现在让我们转向另一个例子。以下是您在上述 chardet 案例中看到的内容：\n1 chardet-3.0.4-py2.py3-none-any.whl 您可以将其分解为标签：\nchardet 是包名。 3.0.4 是 chardet 的包版本。 py2.py3 是 Python 标签，这意味着 Wheels 支持 Python 2 和 3 以及任何 Python 实现。 none 是 ABI 标签，意味着 ABI 不是一个因素。 any 是平台。这个 Wheels 几乎可以在任何平台上运行。 Wheels 名称的 py2.py3-none-any.whl 段很常见。这是一个万能 Wheels ，可以在具有任何 ABI 的任何平台上与 Python 2 或 3 一起安装。如果 Wheels 以 none-any.whl 结尾，那么它很可能是一个不关心特定 Python ABI 或 CPU 架构的纯 Python 包。\n另一个例子是 jinja2 模板引擎。如果您导航到 Jinja 3.x alpha 版本的下载页面，您将看到以下 Wheels ：\n1 Jinja2-3.0.0a1-py3-none-any.whl 注意这里缺少 py2 。这是一个纯 Python 项目，可以在任何 Python 3.x 版本上运行，但它不是万能 Wheels ，因为它不支持 Python 2。相反，它被称为纯 Python Wheels 。\n注意：在 2020 年，许多项目也放弃了对 Python 2 的支持，Python 2 于 2020 年 1 月 1 日达到生命周期结束 (EOL)。Jinja 版本 3.x 于 2020 年 2 月放弃了对 Python 2 的支持。\n以下是为一些流行的开源包分发的 .whl 名称的更多示例：\nWheel What It Is 这是什么 PyYAML-5.3.1-cp38-cp38-win_amd64.whl PyYAML for CPython 3.8 on Windows with AMD64 (x86-64) architecture numpy-1.18.4-cp38-cp38-win32.whl NumPy for CPython 3.8 on Windows 32-bit scipy-1.4.1-cp36-cp36m-macosx_10_6_intel.whl SciPy for CPython 3.6 on macOS 10.6 SDK with fat binary (multiple instruction sets) 现在您已经彻底了解什么是 Wheels ，是时候谈谈它们有什么好处了。\nWheels 的优势 这是来自 Python Packaging Authority (PyPA) 的 wheels 证明：\n并非所有开发人员都有正确的工具或经验来构建这些用这些编译语言编写的组件，因此 Python 创造了 wheel，这是一种旨在运送带有编译工件的库的包格式。事实上，Python 的包安装程序 pip 总是更喜欢 wheel，因为安装总是更快，所以即使是纯 Python 包也能更好地使用 wheel。 （ 来源）\n更完整的描述是，wheels 在以下几个方面使 Python 包的用户和维护者都受益：\n对于纯 Python 包和扩展模块，Wheels 的安装速度比源代码分发快。 Wheels 比源分布小。例如， six Wheels 大约是相应源分布大小的三分之一。当您考虑到单个包的 pip install 实际上可能会开始下载依赖项链时，这种差异变得更加重要。 Wheels 将 setup.py 执行排除在外。从源分发版安装会运行该项目的 setup.py 中包含的任何内容。正如 PEP 427 所指出的，这相当于任意代码执行。 Wheels 完全避免了这种情况。 编译器不需要安装包含已编译扩展模块的 Wheels 。扩展模块包含在针对特定平台和 Python 版本的 wheel 中。 pip 自动在 wheel 中生成与正确的 Python 解释器匹配的 .pyc 文件。 Wheels 通过减少安装软件包时涉及的许多变量来提供一致性。 您可以使用 PyPI 上项目的下载文件选项卡来查看可用的不同发行版。例如，pandas 分发了各种各样的 Wheels 。\n告诉 pip 要下载什么 可以对 pip 进行细粒度控制并告诉它首选或避免哪种格式。您可以使用 --only-binary 和 --no-binary 选项来执行此操作。您在前面有关安装 cryptography 包的部分中看到了它们的使用，但值得仔细研究一下它们的作用：\n1 2 3 4 5 6 $ pushd \"$(mktemp -d)\" $ python -m pip download --only-binary :all: --dest . --no-cache six Collecting six Downloading six-1.14.0-py2.py3-none-any.whl (10 kB) Saved ./six-1.14.0-py2.py3-none-any.whl Successfully downloaded six 在此示例中，您更改为一个临时目录以存储带有 pushd \"$(mktemp -d)\" 的下载。您使用 pip download 而不是 pip install 以便您可以检查生成的 Wheels ，但您可以将 download 替换为 install 同时保持相同的选项集。\n您下载带有几个标志的 six 模块：\n--only-binary :all: 告诉 pip 限制自己使用 Wheels 并忽略源代码分发。如果没有这个选项， pip 只会更喜欢 Wheels ，但在某些情况下会退回到源代码分发。 --dest . 告诉 pip 将 six 下载到当前目录。 --no-cache 告诉 pip 不要查看其本地下载缓存。你使用这个选项只是为了说明从 PyPI 的实时下载，因为你可能在某处有一个 six 缓存。 我之前提到过，wheel 文件本质上是一个 .zip 存档。你可以从字面上理解这个陈述，并这样对待 Wheels 。例如，如果你想查看一个 Wheels 的内容，你可以使用 unzip ：\n1 2 3 4 5 6 7 8 9 10 11 12 $ unzip -l six*.whl Archive: six-1.14.0-py2.py3-none-any.whl Length Date Time Name --------- ---------- ----- ---- 34074 01-15-2020 18:10 six.py 1066 01-15-2020 18:10 six-1.14.0.dist-info/LICENSE 1795 01-15-2020 18:10 six-1.14.0.dist-info/METADATA 110 01-15-2020 18:10 six-1.14.0.dist-info/WHEEL 4 01-15-2020 18:10 six-1.14.0.dist-info/top_level.txt 435 01-15-2020 18:10 six-1.14.0.dist-info/RECORD --------- ------- 37484 6 files six 是一个特例：它实际上是一个单独的 Python 模块，而不是一个完整的包。 Wheel 文件也可以复杂得多，稍后您将看到。\n与 --only-binary 相反，你可以使用 --no-binary 来做相反的事情：\n1 2 3 4 5 6 $ python -m pip download --no-binary :all: --dest . --no-cache six Collecting six Downloading six-1.14.0.tar.gz (33 kB) Saved ./six-1.14.0.tar.gz Successfully downloaded six $ popd 此示例中的唯一更改是切换到 --no-binary :all: 。这告诉 pip 忽略 Wheels ，即使它们可用，而是下载源分发。\n--no-binary 什么时候有用？以下是几个案例：\n对应的 Wheels 坏了。这是对 Wheels 的讽刺。它们旨在减少故障的发生，但在某些情况下， Wheels 可能会配置错误。在这种情况下，为自己下载和构建源代码分发可能是一个可行的选择。 您想要对项目应用一个小的更改或补丁文件，然后安装它。这是从版本控制系统 URL 克隆项目的替代方法。 您还可以将上述标志与 pip install 一起使用。此外，与 :all: 不同， --only-binary 规则不仅适用于您正在安装的包，还适用于它的所有依赖项，您可以传递特定包的列表 --only-binary 和 --no-binary 来应用该规则规则到。\n下面是几个安装 URL 库 yarl 的例子。它包含 Cython 代码并依赖于 multidict ，其中包含纯 C 代码。有几个选项可以严格使用或严格忽略 yarl 及其依赖项的 Wheels ：\n1 2 3 4 5 6 7 8 9 10 11 $ # Install `yarl` and use only wheels for yarl and all dependencies $ python -m pip install --only-binary :all: yarl $ # Install `yarl` and use wheels only for the `multidict` dependency $ python -m pip install --only-binary multidict yarl $ # Install `yarl` and don't use wheels for yarl or any dependencies $ python -m pip install --no-binary :all: yarl $ # Install `yarl` and don't use wheels for the `multidict` dependency $ python -m pip install --no-binary multidict yarl 在本节中，您大致了解了如何微调 pip install 将使用的分发类型。虽然常规的 pip install 应该没有任何选项，但了解这些用于特殊情况的选项会很有帮助。\nWheel manylinux 标签 Linux 有许多变体和风格，例如 Debian、CentOS、Fedora 和 Pacman。其中每一个都可能在共享库（例如 libncurses ）和核心 C 库（例如 glibc ）中使用细微的变化。\n如果您正在编写 C/C++ 扩展，那么这可能会产生问题。用 C 编写并在 Ubuntu Linux 上编译的源文件不能保证在 CentOS 机器或 Arch Linux 发行版上可执行。\n您是否需要为每个 Linux 变体构建一个单独的 Wheels ？\n幸运的是，答案是否定的，这要归功于一组专门设计的标签，称为 manylinux 平台标签系列。目前有以下三种变体：\nmanylinux1 是 PEP 513 中指定的原始格式。 manylinux2010 是 PEP 571 中指定的更新，它升级到 CentOS 6 作为 Docker 镜像所基于的底层操作系统。理由是 CentOS 5.11，即 manylinux1 中允许的库列表的来源，于 2017 年 3 月达到 EOL 并停止接收安全补丁和错误修复。 manylinux2014 是 PEP 599 中指定的升级到 CentOS 7 的更新，因为 CentOS 6 计划于 2020 年 11 月达到 EOL。 您可以在 pandas 项目中找到 manylinux 分布的示例。以下是 PyPI 的可用 pandas 下载列表中的两个（最多的）：\n1 2 pandas-1.0.3-cp37-cp37m-manylinux1_x86_64.whl pandas-1.0.3-cp37-cp37m-manylinux1_i686.whl 在这种情况下，pandas 为支持 x86-64 和 i686 架构的 CPython 3.7 构建了 manylinux1 wheels。\nmanylinux 的核心是基于特定版本的 CentOS 操作系统构建的 Docker 镜像。它捆绑了一个编译器套件、多个版本的 Python 和 pip ，以及一组允许的共享库。\n注意：术语 allowed 表示默认情况下假定存在于几乎所有 Linux 系统上的低级库。这个想法是，依赖项应该存在于基本操作系统上，而不需要额外安装。\n截至 2020 年年中， manylinux1 仍然是主要的 manylinux 标签。原因之一可能只是习惯。另一个可能是客户端（用户）端对 manylinux2010 及更高版本的支持仅限于更新版本的 pip ：\nTag Requirement manylinux1 pip 8.1.0 或更高版本 manylinux2010 pip 19.0 或更高版本 manylinux2014 pip 19.3 或更高版本 换句话说，如果您是构建 manylinux2010 wheels 的包开发人员，那么使用您的包的人将需要 pip 19.0（2019 年 1 月发布）或更高版本才能让 pip 从 PyPI 找到并安装 manylinux2010 wheels .\n幸运的是，虚拟环境变得越来越普遍，这意味着开发人员可以在不接触系统 pip 的情况下更新虚拟环境的 pip 。然而，情况并非总是如此，一些 Linux 发行版仍然附带 pip 的过时版本。\n这就是说，如果您要在 Linux 主机上安装 Python 包，那么如果包维护者不遗余力地创建 manylinux Wheels ，您就认为自己很幸运。这几乎可以保证无论您的特定 Linux 变体或版本如何，都可以轻松安装软件包。\n警告：请注意 PyPI wheels 不能在 Alpine Linux（或 BusyBox）上运行。这是因为 Alpine 使用 musl 代替标准的 glibc 。 musl libc 库自称是“一个新的 libc ，力求快速、简单、轻量级、免费和正确”。不幸的是，说到 Wheels ， glibc 不是。\n平台 Wheels 的安全注意事项 从用户安全的角度来看，wheels 的一个值得考虑的特性是 wheels 可能会受到版本腐烂的影响，因为它们捆绑了二进制依赖项，而不是允许系统包管理器更新该依赖项。\n例如，如果一个 wheel 合并了 libfortran 共享库，那么即使您使用包管理器（如 @ 3#、 yum 或 brew 。\n如果您在安全防范措施得到加强的环境中进行开发，则需要注意某些平台 Wheels 的这一特性。\n召集所有开发人员：构建您的 Wheels 本教程的标题是“你为什么要关心？”作为一名开发人员，如果您打算向社区分发 Python 包，那么您应该非常关心为您的项目分发 Wheels ，因为它们使最终用户的安装过程更简洁、更简单。\n您可以使用兼容的 Wheels 支持的目标平台越多，您看到的标题为“安装在 XYZ 平台上损坏”之类的 GitHub 问题就越少。为您的 Python 包分发 wheel 客观上降低了包的用户在安装过程中遇到问题的可能性。\n要在本地构建 Wheels ，您需要做的第一件事是安装 wheel 。确保 setuptools 也是最新的也没什么坏处：\n1 $ python -m pip install -U wheel setuptools 接下来的几节将引导您完成为各种不同场景构建 Wheels 的过程。\n不同类型的 Wheels 正如本教程中提到的， Wheels 有几种不同的变体， Wheels 的类型反映在它的文件名中：\n万向 Wheels 包含 py2.py3-none-any.whl 。它在任何操作系统和平台上都支持 Python 2 和 Python 3。 Python Wheels 网站上列出的大多数 Wheels 都是通用 Wheels 。 纯 Python Wheels 包含 py3-none-any.whl 或 py2.none-any.whl 。它支持 Python 3 或 Python 2，但不支持两者。它在其他方面与万向 Wheels 相同，但它会标有 py2 或 py3 而不是 py2.py3 标签。 平台 Wheels 支持特定的 Python 版本和平台。它包含指示特定 Python 版本、ABI、操作系统或体系结构的段。 wheel 类型之间的差异取决于它们支持的 Python 版本以及它们是否针对特定平台。以下是 Wheels 变体之间差异的简要总结：\nWheel Type 支持 Python 2 和 3 支持每个 ABI、操作系统和平台 Universal ✓ ✓ Pure-Python ✓ Platform 正如您接下来将看到的，您可以通过相对较少的设置构建通用 Wheels 和纯 Python Wheels ，但平台 Wheels 可能需要一些额外的步骤。\n构建一个纯 Python Wheels 您可以使用 setuptools 为任何项目构建纯 Python Wheels 或通用 Wheels ，只需一个命令：\n1 $ python setup.py sdist bdist_wheel 这将创建一个源代码分发 ( sdist ) 和一个 Wheels ( bdist_wheel )。默认情况下，两者都会放在当前目录下的 dist/ 中。要亲眼看看，您可以为 HTTPie 构建一个 Wheels ，一个用 Python 编写的命令行 HTTP 客户端，以及一个 sdist 。\n下面是为 HTTPie 包构建两种类型的发行版的结果：\n1 2 3 4 5 6 $ git clone -q git@github.com:jakubroztocil/httpie.git $ cd httpie $ python setup.py -q sdist bdist_wheel $ ls -1 dist/ httpie-2.2.0.dev0-py3-none-any.whl httpie-2.2.0.dev0.tar.gz 仅此而已。您克隆该项目，移至其根目录，然后调用 python setup.py sdist bdist_wheel 。您可以看到 dist/ 包含一个 Wheels 和一个源代码分发。\n默认情况下，生成的分布放在 dist/ 中，但您可以使用 -d / --dist-dir 选项更改它。您可以将它们放在一个临时目录中，而不是用于构建隔离：\n1 2 3 4 5 6 7 8 9 $ tempdir=\"$(mktemp -d)\" # Create a temporary directory $ file \"$tempdir\" /var/folders/jc/8_kd8uusys7ak09_lpmn30rw0000gk/T/tmp.GIXy7XKV: directory $ python setup.py sdist -d \"$tempdir\" $ python setup.py bdist_wheel --dist-dir \"$tempdir\" $ ls -1 \"$tempdir\" httpie-2.2.0.dev0-py3-none-any.whl httpie-2.2.0.dev0.tar.gz 您可以将 sdist 和 bdist_wheel 步骤合二为一，因为 setup.py 可以采用多个子命令：\n1 $ python setup.py sdist -d \"$tempdir\" bdist_wheel -d \"$tempdir\" 如此处所示，您需要将 -d 等选项传递给每个子命令。\n指定通用 Wheel 通用 Wheels 是用于同时支持 Python 2 和 3 的纯 Python 项目的 Wheels 。有多种方法可以告诉 setuptools 和 distutils Wheels 应该是通用的。\n选项 1 是在项目的 setup.cfg 文件中指定选项：\n1 2 [bdist_wheel] universal = 1 选项 2 是在命令行传递恰当命名的 --universal 标志：\n1 $ python setup.py bdist_wheel --universal 选项 3 是使用其 options 参数告诉 setup() 本身有关该标志的信息：\n1 2 3 4 5 6 7 8 # setup.py from setuptools import setup setup( # .... options={\"bdist_wheel\": {\"universal\": True}} # .... ) 虽然这三个选项中的任何一个都应该有效，但前两个选项最常用。您可以在 chardet 设置配置中看到这样的示例。之后，您可以使用 bdist_wheel 命令，如前所示：\n1 $ python setup.py sdist bdist_wheel 无论您选择哪个选项，生成的 Wheels 都是等效的。选择在很大程度上取决于开发人员的偏好以及最适合您的工作流程。\n构建平台 Wheels （macOS 和 Windows） 二进制发行版是包含已编译扩展的构建发行版的子集。扩展是非 Python 依赖项或 Python 包的组件。\n通常，这意味着您的包包含扩展模块或依赖于用静态类型语言（例如 C、C++、Fortran，甚至 Rust 或 Go）编写的库。平台 Wheels 的存在主要是因为它们包含或依赖于扩展模块。\n综上所述，是时候构建平台 Wheels 了！\n根据您现有的开发环境，您可能需要完成一个或两个额外的先决条件步骤来构建平台 Wheels 。下面的步骤将帮助您设置构建 C 和 C++ 扩展模块，这是迄今为止最常见的类型。\n在 macOS 上，您需要通过 xcode 获得的命令行开发人员工具：\n1 $ xcode-select --install 在 Windows 上，您需要安装 Microsoft Visual C++：\n在浏览器中打开 Visual Studio 下载页面。 选择 Visual Studio 工具 → Visual Studio 构建工具 → 下载。 运行生成的 .exe 安装程序。 在安装程序中，选择 C++ Build Tools → Install。 重新启动机器。 在 Linux 上，您需要一个编译器，例如 gcc 或 g++ / c++ 。\n有了这些，您就可以为 UltraJSON ( ujson ) 构建一个平台 Wheels ，UltraJSON 是一个用纯 C 语言编写并带有 Python 3 绑定的 JSON 编码器和解码器。使用 ujson 是一个很好的玩具示例，因为它涵盖了几个基础：\n它包含一个扩展模块， ujson 。 它依赖于 Python 开发标头进行编译 ( #include )，但并不过分复杂。 ujson 旨在做一件事并且做好，就是读写 JSON！ 您可以从 GitHub 克隆该项目，导航到其目录并构建它：\n1 2 3 $ git clone -q --branch 2.0.3 git@github.com:ultrajson/ultrajson.git $ cd ultrajson $ python setup.py bdist_wheel 您应该会看到大量输出。这是 macOS 上的精简版，其中使用了 Clang 编译器驱动程序：\n1 2 3 4 clang -Wno-unused-result -Wsign-compare -Wunreachable-code -DNDEBUG -g ... ... creating 'dist/ujson-2.0.3-cp38-cp38-macosx_10_15_x86_64.whl' adding 'ujson.cpython-38-darwin.so' 以 clang 开头的行显示了对编译器的实际调用，其中包含大量编译标志。您可能还会看到诸如 MSVC (Windows) 或 gcc (Linux) 之类的工具，具体取决于操作系统。\n如果在执行上述代码后遇到 fatal error ，请不要担心。您可以展开下面的框以了解如何处理此问题。\nsetup.py bdist_wheel 对 ujson 的调用需要 Python 开发头文件，因为 ujson.c 引入了 。如果您没有将它们放在可搜索的位置，那么您可能会看到如下错误：\n1 2 fatal error: 'Python.h' file not found #include 要编译扩展模块，您需要将开发标头保存在编译器可以找到的地方。\n如果您使用的是最新版本的 Python 3 和虚拟环境工具（如 venv ），则 Python 开发标头可能会默认包含在编译和链接中。\n如果没有，那么您可能会看到一个错误，表明找不到头文件：\n1 2 fatal error: 'Python.h' file not found #include 在这种情况下，您可以通过设置 CFLAGS 来告诉 setup.py 还可以在哪里查找头文件。要查找头文件本身，可以使用 python3-config ：\n1 2 $ python3-config --include -I/Users//.pyenv/versions/3.8.2/include/python3.8 这告诉您 Python 开发标头位于显示的目录中，您现在可以将其与 python setup.py bdist_wheel 一起使用：\n1 $ CFLAGS=\"$(python3-config --include)\" python setup.py bdist_wheel 更一般地说，您可以传递您需要的任何路径：\n1 $ CFLAGS='-I/path/to/include' python setup.py bdist_wheel 在 Linux 上，您可能还需要单独安装头文件：\n1 2 $ apt-get install -y python3-dev # Debian, Ubuntu $ yum install -y python3-devel # CentOS, Fedora, RHEL 如果你检查 UltraJSON 的 setup.py ，你会看到它自定义了一些编译器标志，例如 -D_GNU_SOURCE 。通过 setup.py 控制编译过程的复杂性超出了本教程的范围，但您应该知道可以对编译和链接的发生方式进行细粒度控制。\n如果您查看 dist ，那么您应该会看到创建的 Wheels ：\n1 2 $ ls dist/ ujson-2.0.3-cp38-cp38-macosx_10_15_x86_64.whl 请注意，名称可能因您的平台而异。例如，您会在 64 位 Windows 上看到 win_amd64.whl 。\n您可以查看 wheel 文件并看到它包含已编译的扩展名：\n1 2 3 4 5 6 $ unzip -l dist/ujson-*.whl ... Length Date Time Name --------- ---------- ----- ---- 105812 05-10-2020 19:47 ujson.cpython-38-darwin.so ... 此示例显示 macOS 的输出， ujson.cpython-38-darwin.so ，这是一个共享对象 ( .so ) 文件，也称为动态库。\n构建 manylinux Wheels 作为软件包开发人员，您很少会希望为单个 Linux 变体构建 Wheels 。 Linux wheels 需要一套专门的约定和工具，以便它们可以跨不同的 Linux 环境工作。\n与 macOS 和 Windows 的 wheel 不同，构建在一个 Linux 变体上的 wheel 不能保证在另一个 Linux 变体上工作，即使是具有相同机器架构的 Linux 变体。\n事实上，如果您在开箱即用的 Linux 容器上构建一个 Wheels ，那么如果您尝试上传它，PyPI 甚至不会接受该 Wheels ！\n如果您希望您的包在一系列 Linux 客户端上可用，那么您需要一个 manylinux Wheels 。 manylinux wheel 是一种特殊类型的平台 wheel，被大多数 Linux 变体接受。它必须在特定环境中构建，并且需要一个名为 auditwheel 的工具来重命名 wheel 文件以表明它是一个 manylinux wheel。\n注意：即使您是从开发人员而不是用户的角度来学习本教程，请确保您在继续本节之前已阅读有关 manylinux wheel 标签的部分。\n构建一个 manylinux Wheels 可以让你瞄准更广泛的用户平台。 PEP 513 指定了一个特定的（和古老的）CentOS 版本，其中包含一系列可用的 Python 版本。 CentOS 和 Ubuntu 或任何其他发行版之间的选择没有任何特殊区别。\n重点是构建环境由一个普通的 Linux 操作系统和一组有限的外部共享库组成，这些共享库对于不同的 Linux 变体是通用的。\n值得庆幸的是，您不必自己执行此操作。 PyPA 提供了一组 Docker 镜像，只需单击几下鼠标即可为您提供此环境：\n选项 1 是从您的开发机器运行 docker 并使用 Docker 卷挂载您的项目，以便它可以在容器文件系统中访问。 选项 2 是使用 CI/CD 解决方案，例如 CircleCI、GitHub Actions、Azure DevOps 或 Travis-CI，这将拉取您的项目并在推送或标记等操作上运行构建。 为不同的 manylinux 风格提供了 Docker 镜像：\nmanylinux Tag Architecture Docker Image manylinux1 x86-64 quay.io/pypa/manylinux1_x86_64 manylinux1 i686 quay.io/pypa/manylinux1_i686 manylinux2010 x86-64 quay.io/pypa/manylinux2010_x86_64 manylinux2010 i686 quay.io/pypa/manylinux2010_i686 manylinux2014 x86-64 quay.io/pypa/manylinux2014_x86_64 manylinux2014 i686 quay.io/pypa/manylinux2014_i686 manylinux2014 aarch64 quay.io/pypa/manylinux2014_aarch64 manylinux2014 ppc64le quay.io/pypa/manylinux2014_ppc64le manylinux2014 s390x quay.io/pypa/manylinux2014_s390x 首先，PyPA 还提供了一个示例存储库 python-manylinux-demo，这是一个用于与 Travis-CI 一起构建 manylinux wheels 的演示项目。\n虽然构建 wheels 作为远程托管 CI 解决方案的一部分很常见，但您也可以在本地构建 manylinux wheels。为此，您需要安装 Docker。 Docker Desktop 适用于 macOS、Windows 和 Linux。\n首先，克隆演示项目：\n1 2 $ git clone -q git@github.com:pypa/python-manylinux-demo.git $ cd python-manylinux-demo 接下来，分别为 manylinux1 Docker 镜像和平台定义几个 shell 变量：\n1 2 $ DOCKER_IMAGE='quay.io/pypa/manylinux1_x86_64' $ PLAT='manylinux1_x86_64' DOCKER_IMAGE 变量是由 PyPA 维护的用于构建 manylinux Wheels 的图像，托管在 Quay.io。平台 ( PLAT ) 是提供给 auditwheel 的必要信息，让它知道要应用哪个平台标签。\n现在您可以拉取 Docker 镜像并在容器中运行 wheel-builder 脚本：\n1 2 3 4 5 $ docker pull \"$DOCKER_IMAGE\" $ docker container run -t --rm \\ -e PLAT=$PLAT \\ -v \"$(pwd)\":/io \\ \"$DOCKER_IMAGE\" /io/travis/build-wheels.sh 这告诉 Docker 在 manylinux1_x86_64 Docker 容器内运行 build-wheels.sh shell 脚本，将 PLAT 作为容器中可用的环境变量传递。由于您使用 -v （或 --volume ）绑定挂载卷，因此容器中生成的 Wheels 现在可以在主机上的 wheelhouse 目录中访问：\n1 2 3 4 5 6 7 $ ls -1 wheelhouse python_manylinux_demo-1.0-cp27-cp27m-manylinux1_x86_64.whl python_manylinux_demo-1.0-cp27-cp27mu-manylinux1_x86_64.whl python_manylinux_demo-1.0-cp35-cp35m-manylinux1_x86_64.whl python_manylinux_demo-1.0-cp36-cp36m-manylinux1_x86_64.whl python_manylinux_demo-1.0-cp37-cp37m-manylinux1_x86_64.whl python_manylinux_demo-1.0-cp38-cp38-manylinux1_x86_64.whl 在几个简短的命令中，您拥有一组适用于 CPython 2.7 到 3.8 的 manylinux1 Wheels 。一种常见的做法是迭代不同的架构。例如，您可以对 quay.io/pypa/manylinux1_i686 Docker 映像重复此过程。这将构建针对 32 位 (i686) 架构的 manylinux1 Wheels 。\n如果您想更深入地研究造 Wheels ，那么下一步就是向最好的人学习。从 Python Wheels 页面开始，选择一个项目，导航到它的源代码（在 GitHub、GitLab 或 Bitbucket 等地方），然后亲眼看看它是如何构建 Wheels 的。\nPython Wheels 页面上的许多项目都是纯 Python 项目并分发通用 Wheels 。如果您正在寻找更复杂的案例，请留意使用扩展模块的包。这里有两个例子可以激发你的胃口：\nlxml 使用从 manylinux1 Docker 容器中调用的单独构建脚本。 ultrajson 做同样的事情并使用 GitHub Actions 调用构建脚本。 如果您有兴趣构建 manylinux Wheels ，这两个都是著名的项目，它们提供了很好的示例供您学习。\n捆绑共享库 另一个挑战是为依赖于外部共享库的包构建 Wheels 。 manylinux 图像包含一组预筛选的库，例如 libpthread.so.0 和 libc.so.6 。但是，如果您依赖该列表之外的东西怎么办，例如 ATLAS 或 GFortran？\n在这种情况下，有几种解决方案可以解决问题：\nauditwheel 会将外部库捆绑到一个已经构建好的 Wheels 中。 delocate 在 macOS 上做同样的事情。 方便的是， auditwheel 出现在 manylinux Docker 镜像上。使用 auditwheel 和 delocate 只需一个命令。只需告诉他们有关 wheel 文件的信息，他们就会完成剩下的工作：\n1 2 $ auditwheel repair # For manylinux $ delocate-wheel # For macOS 这将通过项目的 setup.py 检测所需的外部库，并将它们捆绑到 wheel 中，就好像它们是项目的一部分一样。\n利用 auditwheel 和 delocate 的项目示例是 pycld3 ，它为 Compact Language Detector v3 (CLD3) 提供 Python 绑定。\npycld3 包依赖于 libprotobuf ，它不是一个通常安装的库。如果你查看 pycld3 macOS Wheels 内部，你会看到 libprotobuf.22.dylib 包含在那里。这是一个捆绑到 Wheels 中的动态链接共享库：\n1 2 3 4 5 6 7 $ unzip -l pycld3-0.20-cp38-cp38-macosx_10_15_x86_64.whl ... 51 04-10-2020 11:46 cld3/__init__.py 939984 04-10-2020 07:50 cld3/_cld3.cpython-38-darwin.so 2375836 04-10-2020 07:50 cld3/.dylibs/libprotobuf.22.dylib --------- ------- 3339279 8 files Wheels 预包装有 libprotobuf 。 .dylib 类似于 Unix .so 文件或 Windows .dll 文件，但我承认我不知道除此之外的具体区别。\nauditwheel 和 delocate 知道包含 libprotobuf 因为 setup.py 通过 libraries 参数告诉他们：\n1 2 3 4 5 setup( # ... libraries=[\"protobuf\"], # ... ) 这意味着 auditwheel 和 delocate 为用户省去了安装 protobuf 的麻烦，只要他们从具有匹配 Wheels 的平台和 Python 组合进行安装即可。\n如果您要分发的包具有这样的外部依赖项，那么您可以通过使用 auditwheel 或 delocate 来帮您的用户一个忙，让他们省去自己安装依赖项的额外步骤。\n在持续集成中构建 Wheels 在本地机器上构建 Wheels 的替代方法是在项目的 CI 管道中自动构建它们。\n有无数与主要代码托管服务集成的 CI 解决方案。其中包括 Appveyor、Azure DevOps、BitBucket Pipelines、Circle CI、GitLab、GitHub Actions、Jenkins 和 Travis CI，仅举几例。\n本教程的目的不是要判断哪种 CI 服务最适合构建 Wheels ，以及考虑到 CI 支持的发展速度，任何支持哪些容器的 CI 服务列表很快就会过时。\n但是，本节可以帮助您入门。\n如果你正在开发一个纯 Python 包， bdist_wheel 一步是一个幸福的单行：它在很大程度上与你在哪个容器操作系统和平台上构建 Wheels 无关。几乎所有主要的 CI 服务都应该使您能够通过在项目内的特殊 YAML 文件中定义步骤来以简洁的方式执行此操作。\n例如，这是您可以用于 GitHub Actions 的语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 name: Python wheels on: release: types: - created jobs: wheels: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up Python 3.x uses: actions/setup-python@v2 with: python-version: \"3.x\" - name: Install dependencies run: python -m pip install --upgrade setuptools wheel - name: Build wheels run: python setup.py bdist_wheel - uses: actions/upload-artifact@v2 with: name: dist path: dist 在此配置文件中，您使用以下步骤构建一个 Wheels ：\n在第 8 行，您指定该作业应在 Ubuntu 机器上运行。 在第 10 行中，您使用 checkout 操作来设置您的项目存储库。 在第 14 行，您告诉 CI 运行器使用最新稳定版本的 Python 3。 在第 21 行中，您请求将生成的 Wheels 作为工件提供，您可以在作业完成后从 UI 下载该工件。 但是，如果您有一个复杂的项目（可能是一个带有 C 扩展或 Cython 代码的项目）并且您正在努力构建一个 CI/CD 管道以自动构建 Wheels ，那么可能会涉及额外的步骤。以下是一些您可以通过示例学习的项目：\nyarl msgpack markupsafe cryptography 许多项目推出了自己的 CI 配置。然而，一些解决方案已经出现，用于减少配置文件中指定的代码量来构建 Wheels 。您可以直接在 CI 服务器上使用 cibuildwheel 工具来减少构建多个平台 Wheels 所需的代码行和配置。还有 multibuild，它提供了一组 shell 脚本，用于协助在 Travis CI 和 AppVeyor 上构建 Wheels 。\n确保你的 Wheels 旋转正确 构建结构正确的 Wheels 可能是一项精细的操作。例如，如果您的 Python 包使用 src 布局而您忘记在 setup.py 中正确指定它，那么生成的 Wheels 可能包含错误位置的目录。\n您可以在 bdist_wheel 之后使用的一项检查是 check-wheel-contents 工具。它查找常见问题，例如包目录结构异常或存在重复文件：\n1 2 $ check-wheel-contents dist/*.whl dist/ujson-2.0.3-cp38-cp38-macosx_10_15_x86_64.whl: OK 在本例中， check-wheel-contents 表示带 ujson Wheels 的所有内容都已检出。如果不是， stdout 将显示可能问题的摘要，就像 flake8 之类的 linter。\n另一种确认您构建的 Wheels 是否正确的方法是使用 TestPyPI。首先，您可以在那里上传包：\n1 2 3 $ python -m twine upload \\ --repository-url https://test.pypi.org/legacy/ \\ dist/* 然后，您可以下载相同的包进行测试，就好像它是真实的一样：\n1 2 3 $ python -m pip install \\ --index-url https://test.pypi.org/simple/ \\ 这允许您通过上传然后下载您自己的项目来测试您的 Wheels 。\n将 Python Wheels 上传到 PyPI 现在是时候上传你的 Python 包了。由于 sdist 和 wheel 默认情况下都放在 dist/ 目录中，您可以使用 twine 工具上传它们，这是一个用于将包发布到 PyPI 的实用程序：\n1 2 $ python -m pip install -U twine $ python -m twine upload dist/* 由于默认情况下 sdist 和 bdist_wheel 都输出到 dist/ ，您可以安全地告诉 twine 使用 shell 通配符( dist/* ) 上传 dist/ 下的所有内容。\n结论 了解 Wheels 在 Python 生态系统中扮演的关键角色可以让您作为 Python 包的用户和开发人员的生活更轻松。\n此外，在 Wheels 方面提高你的 Python 素养将帮助你更好地理解安装包时发生了什么，以及在越来越罕见的情况下，该操作何时出错。\n在本教程中，您学习了：\n什么是 Wheels 以及它们与源代码分布的比较 如何使用 Wheels 来控制包安装过程 通用 Wheels 、纯 Python Wheels 和平台 Wheels 之间有什么区别 如何为您自己的 Python 包创建和分发 Wheels 您现在已经从用户和开发人员的角度对 Wheels 有了深入的了解。您完全有能力构建自己的 Wheels ，并使项目的安装过程快速、方便和稳定。\n请参阅下面的部分以获取一些额外的阅读材料，以更深入地了解快速扩展的 wheel 生态系统。\n资源 Python Wheels页面专门跟踪 PyPI 上下载次数最多的 360 个包中对 wheels 的支持。在编写本教程时，采用率非常可观，为 360 分之 331，即 91% 左右。\n已经有许多 Python 增强提案 (PEP) 帮助了 wheel 格式的规范和发展：\nPEP 425 - Compatibility Tags for Built Distributions PEP 427 - The Wheel Binary Package Format 1.0 PEP 491 - The Wheel Binary Package Format 1.9 PEP 513 - A Platform Tag for Portable Linux Built Distributions PEP 571 - The manylinux2010 Platform Tag PEP 599 - The manylinux2014 Platform Tag 以下是本教程中提到的各种 wheel 打包工具的候选清单：\npypa/wheel pypa/auditwheel pypa/manylinux pypa/python-manylinux-demo jwodder/check-wheel-contents matthew-brett/delocate matthew-brett/multibuild joerick/cibuildwheel Python 文档有几篇文章涵盖了 Wheels 和源代码分发：\nGenerating Distribution Archives Creating a Source Distribution 最后，这里有一些来自 PyPA 的更有用的链接：\nPackaging your Project An Overview of Packaging for Python 原文地址：https://realpython.com/python-wheels/\n","wordCount":"11726","inLanguage":"en","datePublished":"2023-06-01T00:00:00+08:00","dateModified":"2023-06-01T00:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/06/01/python-wheels/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[译]什么是 Python Wheels，你为什么要关心它？</h1><div class=post-meta><span title='2023-06-01 00:00:00 +0800 CST'>2023-06-01</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;11726 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%ae%89%e8%a3%85 aria-label=安装>安装</a></li><li><a href=#python-%e6%89%93%e5%8c%85%e5%8f%98%e5%be%97%e6%9b%b4%e5%a5%bdpython-wheels-%e7%ae%80%e4%bb%8b aria-label="Python 打包变得更好：Python Wheels 简介">Python 打包变得更好：Python Wheels 简介</a><ul><li><a href=#wheels-%e8%ae%a9%e4%ba%8b%e6%83%85%e5%8f%98%e5%be%97%e5%bf%ab%e9%80%9f aria-label="Wheels 让事情变得快速">Wheels 让事情变得快速</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-python-wheel aria-label="什么是 Python Wheel？">什么是 Python Wheel？</a></li><li><a href=#wheels-%e7%9a%84%e4%bc%98%e5%8a%bf aria-label="Wheels 的优势">Wheels 的优势</a></li><li><a href=#%e5%91%8a%e8%af%89-pip-%e8%a6%81%e4%b8%8b%e8%bd%bd%e4%bb%80%e4%b9%88 aria-label="告诉 pip 要下载什么">告诉 pip 要下载什么</a></li><li><a href=#wheel-manylinux-%e6%a0%87%e7%ad%be aria-label="Wheel manylinux 标签">Wheel manylinux 标签</a></li><li><a href=#%e5%b9%b3%e5%8f%b0-wheels-%e7%9a%84%e5%ae%89%e5%85%a8%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label="平台 Wheels 的安全注意事项">平台 Wheels 的安全注意事项</a></li></ul></li><li><a href=#%e5%8f%ac%e9%9b%86%e6%89%80%e6%9c%89%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98%e6%9e%84%e5%bb%ba%e6%82%a8%e7%9a%84-wheels aria-label="召集所有开发人员：构建您的 Wheels">召集所有开发人员：构建您的 Wheels</a><ul><li><a href=#%e4%b8%8d%e5%90%8c%e7%b1%bb%e5%9e%8b%e7%9a%84-wheels aria-label="不同类型的 Wheels">不同类型的 Wheels</a></li><li><a href=#%e6%9e%84%e5%bb%ba%e4%b8%80%e4%b8%aa%e7%ba%af-python-wheels aria-label="构建一个纯 Python Wheels">构建一个纯 Python Wheels</a></li><li><a href=#%e6%8c%87%e5%ae%9a%e9%80%9a%e7%94%a8-wheel aria-label="指定通用 Wheel">指定通用 Wheel</a></li><li><a href=#%e6%9e%84%e5%bb%ba%e5%b9%b3%e5%8f%b0-wheels-macos-%e5%92%8c-windows aria-label="构建平台 Wheels （macOS 和 Windows）">构建平台 Wheels （macOS 和 Windows）</a></li><li><a href=#%e6%9e%84%e5%bb%ba-manylinux-wheels aria-label="构建 manylinux Wheels">构建 manylinux Wheels</a></li><li><a href=#%e6%8d%86%e7%bb%91%e5%85%b1%e4%ba%ab%e5%ba%93 aria-label=捆绑共享库>捆绑共享库</a></li><li><a href=#%e5%9c%a8%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90%e4%b8%ad%e6%9e%84%e5%bb%ba-wheels aria-label="在持续集成中构建 Wheels">在持续集成中构建 Wheels</a></li><li><a href=#%e7%a1%ae%e4%bf%9d%e4%bd%a0%e7%9a%84-wheels-%e6%97%8b%e8%bd%ac%e6%ad%a3%e7%a1%ae aria-label="确保你的 Wheels 旋转正确">确保你的 Wheels 旋转正确</a></li><li><a href=#%e5%b0%86-python-wheels-%e4%b8%8a%e4%bc%a0%e5%88%b0-pypi aria-label="将 Python Wheels 上传到 PyPI">将 Python Wheels 上传到 PyPI</a></li></ul></li><li><a href=#%e7%bb%93%e8%ae%ba aria-label=结论>结论</a></li><li><a href=#%e8%b5%84%e6%ba%90 aria-label=资源>资源</a></li></ul></div></details></div><div class=post-content><p><img alt="What Are Python Wheels and Why Should You Care?" loading=lazy src=https://files.realpython.com/media/What-are-Python-Wheels-and-Why-Should-You-Care_Watermarked.22246cad13be.jpg></p><p>Python <code>.whl</code> 文件或 <a href=https://packaging.python.org/glossary/#term-wheel target=_blank>wheels</a> 是 Python 中很少被讨论的部分，但它们对 <a href=https://realpython.com/python-modules-packages/ target=_blank>Python 包</a>的安装过程大有裨益。如果您使用 <a href=https://realpython.com/what-is-pip/ target=_blank>pip</a> 安装了 Python 包，那么 Wheels 很可能使安装更快、更高效。</p><p>Wheels 是 Python 生态系统的一个组件，有助于使包安装正常工作。它们允许更快的安装和更稳定的包分发过程。在本教程中，您将深入了解 Wheels 是什么，它们有什么好处，以及它们如何获得牵引力并使 Python 使用起来更加愉快。</p><p><strong>在本教程中，您将学习：</strong></p><ul><li>什么是 Wheels 以及它们与源代码分发的比较</li><li>如何使用 Wheels 来控制包安装过程</li><li>如何为您自己的 Python 包创建和分发 Wheels</li></ul><p>您将从用户和开发人员的角度看到使用流行的开源 Python 包的示例。</p><blockquote><p>免费赠品：单击<a href=https://realpython.com/python-wheels/ target=_blank>此处</a>获取 Python 备忘单并学习 Python 3 的基础知识，例如使用数据类型、字典、列表和 Python 函数。</p></blockquote><h2 id=安装>安装<a hidden class=anchor aria-hidden=true href=#安装>#</a></h2><p>接下来，激活虚拟环境并确保安装了最新版本的 <code>pip</code> 、 <code>wheel</code> 和 <code>setuptools</code> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python -m venv env <span class=o>&amp;&amp;</span> <span class=nb>source</span> ./env/bin/activate
</span></span><span class=line><span class=cl>$ python -m pip install -U pip wheel setuptools
</span></span><span class=line><span class=cl>Successfully installed pip 20.1 setuptools-46.1.3 wheel-0.34.2
</span></span></code></pre></td></tr></table></div></div><p>这就是您尝试安装和构建 Wheels 所需的全部内容！</p><h2 id=python-打包变得更好python-wheels-简介>Python 打包变得更好：Python Wheels 简介<a hidden class=anchor aria-hidden=true href=#python-打包变得更好python-wheels-简介>#</a></h2><p>在学习如何将项目打包到 wheel 之前，从用户的角度了解使用 wheel 的样子会很有帮助。这听起来可能有点落后，但了解 Wheels 如何工作的一个好方法是从安装一个不是 Wheels 的东西开始。</p><p>您可以像往常一样，通过将 Python 包安装到您的环境中来开始这个实验。在这种情况下，安装 <a href=https://github.com/unbit/uwsgi target=_blank>uWSGI</a> 版本 2.0.x：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python -m pip install <span class=s1>&#39;uwsgi==2.0.*&#39;</span>
</span></span><span class=line><span class=cl>Collecting <span class=nv>uwsgi</span><span class=o>==</span>2.0.*
</span></span><span class=line><span class=cl>  Downloading uwsgi-2.0.18.tar.gz <span class=o>(</span><span class=m>801</span> kB<span class=o>)</span>
</span></span><span class=line><span class=cl>     <span class=p>|</span>████████████████████████████████<span class=p>|</span> <span class=m>801</span> kB 1.1 MB/s
</span></span><span class=line><span class=cl>Building wheels <span class=k>for</span> collected packages: uwsgi
</span></span><span class=line><span class=cl>  Building wheel <span class=k>for</span> uwsgi <span class=o>(</span>setup.py<span class=o>)</span> ... <span class=k>done</span>
</span></span><span class=line><span class=cl>  Created wheel <span class=k>for</span> uwsgi ... uWSGI-2.0.18-cp38-cp38-macosx_10_15_x86_64.whl
</span></span><span class=line><span class=cl>  Stored in directory: /private/var/folders/jc/8_hqsz0x1tdbp05 ...
</span></span><span class=line><span class=cl>Successfully built uwsgi
</span></span><span class=line><span class=cl>Installing collected packages: uwsgi
</span></span><span class=line><span class=cl>Successfully installed uwsgi-2.0.18
</span></span></code></pre></td></tr></table></div></div><p>为了完全安装 uWSGI， <code>pip</code> 通过几个不同的步骤进行：</p><ul><li><p>在第 3 行，它下载了一个名为 <code>uwsgi-2.0.18.tar.gz</code> 的 TAR 文件 (tarball)，该文件已使用 <a href=https://www.gnu.org/software/gzip/manual/gzip.html target=_blank>gzip</a> 压缩。</p></li><li><p>在第 6 行，它获取 tarball 并通过调用 <code>setup.py</code> 构建一个 <code>.whl</code> 文件。</p></li><li><p>在第 7 行，它将 wheel 标记为 <code>uWSGI-2.0.18-cp38-cp38-macosx_10_15_x86_64.whl</code> 。</p></li><li><p>在第 10 行，它在构建 wheel 后安装实际的包。</p></li></ul><p><code>pip</code> 检索到的 <code>tar.gz</code> tarball 是源代码分发版或 <code>sdist</code> ，而不是 wheel。在某些方面， <code>sdist</code> 与 wheel 相反。</p><blockquote><p>注意：如果您看到 uWSGI 安装错误，您可能需要<a href=https://uwsgi-docs.readthedocs.io/en/latest/Install.html#installing-from-source target=_blank>安装 Python 开发头文件</a>。</p></blockquote><p><a href=https://packaging.python.org/glossary/#term-source-distribution-or-sdist target=_blank>源代码分发</a>包含源代码。这不仅包括 Python 代码，还包括与包捆绑在一起的任何扩展模块（通常是 C 或 C++）的源代码。对于源代码分发，扩展模块是在用户端而不是开发人员端编译的。</p><p>源分发版还包含一组元数据，位于名为 <code>&lt;package-name>.egg-info</code> 的目录中。此元数据有助于构建和安装包，但用户实际上不需要对其执行任何操作。</p><p>从开发人员的角度来看，源代码分发是在您运行以下命令时创建的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python setup.py sdist
</span></span></code></pre></td></tr></table></div></div><p>现在尝试安装不同的包 <a href=https://github.com/chardet/chardet/blob/master/docs/index.rst target=_blank>chardet</a>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python -m pip install <span class=s1>&#39;chardet==3.*&#39;</span>
</span></span><span class=line><span class=cl>Collecting chardet
</span></span><span class=line><span class=cl>  Downloading chardet-3.0.4-py2.py3-none-any.whl <span class=o>(</span><span class=m>133</span> kB<span class=o>)</span>
</span></span><span class=line><span class=cl>     <span class=p>|</span>████████████████████████████████<span class=p>|</span> <span class=m>133</span> kB 1.5 MB/s
</span></span><span class=line><span class=cl>Installing collected packages: chardet
</span></span><span class=line><span class=cl>Successfully installed chardet-3.0.4
</span></span></code></pre></td></tr></table></div></div><p>您可以看到与 uWSGI 安装明显不同的输出。</p><p>安装 chardet 会直接从 PyPI 下载一个 <code>.whl</code> 文件。 Wheels 名称 <code>chardet-3.0.4-py2.py3-none-any.whl</code> 遵循您稍后将看到的特定命名约定。从用户的角度来看，更重要的是当 <code>pip</code> 在 PyPI 上找到兼容的 wheel 时，没有构建阶段。</p><p>从开发人员的角度来看，wheel 是运行以下命令的结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python setup.py bdist_wheel
</span></span></code></pre></td></tr></table></div></div><p>为什么 uWSGI 给你一个源代码分发而 chardet 提供一个 wheel？您可以通过查看 PyPI 上每个项目的页面并导航到下载文件区域来了解其原因。本节将向您展示 <code>pip</code> 在 PyPI 索引服务器上实际看到的内容：</p><ul><li><p>出于与项目复杂性相关的原因，uWSGI 仅提供了一个<a href=https://pypi.org/project/uWSGI/2.0.18/#files target=_blank>源代码分发</a>（ <code>uwsgi-2.0.18.tar.gz</code> ）。</p></li><li><p>chardet 提供了 <a href=https://pypi.org/project/chardet/3.0.4/#files target=_blank>wheel 和源代码分发</a>，但如果它与您的系统兼容， <code>pip</code> 会更喜欢 wheel。稍后您将看到如何确定兼容性。</p></li></ul><p>用于 wheel 安装的兼容性检查的另一个示例是 <code>psycopg2</code> ，它为 Windows 提供了广泛的 wheels，但不为 Linux 或 macOS 客户端提供任何 wheels。这意味着 <code>pip install psycopg2</code> 可以根据您的特定设置获取 Wheels 或源代码分发。</p><p>为了避免这些类型的兼容性问题，一些包提供了多个 wheels，每个 wheels 都针对特定的 Python 实现和底层操作系统。</p><p>到目前为止，您已经看到了 wheel 和 <code>sdist</code> 之间的一些明显区别，但更重要的是这些差异对安装过程的影响。</p><h3 id=wheels-让事情变得快速>Wheels 让事情变得快速<a hidden class=anchor aria-hidden=true href=#wheels-让事情变得快速>#</a></h3><p>在上面，您看到了获取预制 wheels 的安装与下载 <code>sdist</code> 的安装的比较。 Wheels 使 Python 包的端到端安装更快，原因有二：</p><ul><li>在其他条件相同的情况下，wheels 的尺寸通常比源分发小，这意味着它们可以在网络中更快地移动。</li><li>直接从 wheels 安装避免了从源分发构建包的中间步骤。</li></ul><p>几乎可以保证 chardet 安装只用了 uWSGI 所需时间的一小部分。然而，这可以说是一个不公平的苹果与橘子的比较，因为 chardet 是一个小得多且不那么复杂的包。</p><p>使用不同的命令，您可以创建更直接的比较，以证明 wheels 的差异有多大。</p><p>您可以通过传递 <code>--no-binary</code> 选项让 <code>pip</code> 忽略它对 wheels 的倾斜：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>time</span> python -m pip install <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      --no-cache-dir <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      --force-reinstall <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      --no-binary<span class=o>=</span>:all: <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      cryptography
</span></span></code></pre></td></tr></table></div></div><p>此命令计时 <a href=https://pypi.org/project/cryptography/ target=_blank>cryptography</a> 包的安装，告诉 <code>pip</code> 使用源代码分发，即使有合适的 Wheels 可用。包含 <code>:all:</code> 会使规则适用于 <code>cryptography</code> 及其所有<a href=https://realpython.com/courses/managing-python-dependencies/ target=_blank>依赖项</a>。</p><p>在我的机器上，这从开始到结束大约需要 32 秒。不仅安装需要很长时间，而且构建 <code>cryptography</code> 还需要您拥有 OpenSSL 开发标头并可供 Python 使用。</p><p>注意：对于 <code>--no-binary</code> ，您很可能会看到有关缺少 <code>cryptography</code> 安装所需的头文件的错误，这是使用源代码分发令人沮丧的部分原因。如果是这样， <code>cryptography</code> 文档的<a href=https://cryptography.io/en/latest/installation/#building-cryptography-on-linux target=_blank>安装部分</a>会就特定操作系统需要哪些库和头文件提供建议。</p><p>现在您可以重新安装 <code>cryptography</code> ，但这次要确保 <code>pip</code> 使用 PyPI 的 Wheels 。因为 <code>pip</code> 更喜欢 Wheels ，这类似于不带任何参数调用 <code>pip install</code> 。但在这种情况下，您可以通过要求带有 <code>--only-binary</code> 的 Wheels 来明确意图：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>time</span> python -m pip install <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      --no-cache-dir <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      --force-reinstall <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      --only-binary<span class=o>=</span>cryptography <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      cryptography
</span></span></code></pre></td></tr></table></div></div><p>此选项只需要四秒多一点，或者是仅使用 <code>cryptography</code> 及其依赖项的源代码分发时所用时间的八分之一。</p><h3 id=什么是-python-wheel>什么是 Python Wheel？<a hidden class=anchor aria-hidden=true href=#什么是-python-wheel>#</a></h3><p>Python <code>.whl</code> 文件本质上是一个 ZIP ( <code>.zip</code> ) 存档，带有特制的文件名，告诉安装者 Wheels 将支持哪些 Python 版本和平台。</p><p>Wheels 是一种<a href=https://packaging.python.org/glossary/#term-built-distribution target=_blank>内置分发</a>。在这种情况下，built 意味着 wheel 以可立即安装的格式出现，并允许您跳过源代码分发所需的构建阶段。</p><blockquote><p>注意：值得一提的是，尽管使用了术语构建，但 Wheels 不包含 <code>.pyc</code> 文件或编译的 Python 字节码。</p></blockquote><p>wheel 文件名被分成由连字符分隔的部分：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>{</span>dist<span class=o>}</span>-<span class=o>{</span>version<span class=o>}(</span>-<span class=o>{</span>build<span class=o>})</span>?-<span class=o>{</span>python<span class=o>}</span>-<span class=o>{</span>abi<span class=o>}</span>-<span class=o>{</span>platform<span class=o>}</span>.whl
</span></span></code></pre></td></tr></table></div></div><p><code>{brackets}</code> 中的每个部分都是一个标签，或者是 wheel 名称的一个组成部分，它带有一些关于 wheel 包含的内容以及 wheel 将在何处工作或不工作的含义。</p><p>这是一个使用 <code>cryptography</code> Wheels 的说明性示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cryptography-2.9.2-cp35-abi3-macosx_10_9_x86_64.whl
</span></span></code></pre></td></tr></table></div></div><p><code>cryptography</code> 分配多个 Wheels 。每个 Wheels 都是一个平台 Wheels ，这意味着它仅支持 Python 版本、Python ABI、操作系统和机器架构的特定组合。您可以将命名约定分解为多个部分：</p><ul><li><code>cryptography</code> 是包名。</li><li><code>2.9.2</code> 是 <code>cryptography</code> 的包版本。版本是符合 PEP 440 的字符串，例如 <code>2.9.2</code> 、 <code>3.4</code> 或 <code>3.9.0.a3</code> 。</li><li><code>cp35</code> 是 <a href=https://www.python.org/dev/peps/pep-0425/#python-tag target=_blank>Python 标签</a>，表示 Wheels 需要的 Python 实现和版本。 <code>cp</code> 代表 <a href=https://realpython.com/cpython-source-code-guide/ target=_blank>CPython</a>，Python 的参考实现，而 <code>35</code> 代表 Python <a href=https://docs.python.org/3/whatsnew/3.5.html target=_blank>3.5</a>。例如，这个 Wheels 与 <a href=https://www.jython.org/ target=_blank>Jython</a> 不兼容。</li><li><code>abi3</code> 是 ABI 标签。 ABI 代表<a href=https://docs.python.org/3/c-api/stable.html target=_blank>应用程序二进制接口</a>。你真的不需要担心它需要什么，但是 <code>abi3</code> 是一个单独的版本，用于 Python C API 的二进制兼容性。</li><li><code>macosx_10_9_x86_64</code> 是平台标签，正好比较啰嗦。在这种情况下，它可以进一步细分为子部分：<ul><li><code>macosx</code> 是 macOS 操作系统。</li><li><code>10_9</code> 是用于编译 Python 的 macOS 开发人员工具 SDK 版本，而 Python 又构建了这个 Wheels 。</li><li><code>x86_64</code> 是对 x86-64 指令集架构的引用。</li></ul></li></ul><p>最后一个组件在技术上不是标签，而是标准的 <code>.whl</code> 文件扩展名。组合起来，上述组件表明此 <code>cryptography</code> Wheels 设计的目标机器。</p><p>现在让我们转向另一个例子。以下是您在上述 chardet 案例中看到的内容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>chardet-3.0.4-py2.py3-none-any.whl
</span></span></code></pre></td></tr></table></div></div><p>您可以将其分解为标签：</p><ul><li><code>chardet</code> 是包名。</li><li><code>3.0.4</code> 是 chardet 的包版本。</li><li><code>py2.py3</code> 是 Python 标签，这意味着 Wheels 支持 Python 2 和 3 以及任何 Python 实现。</li><li><code>none</code> 是 ABI 标签，意味着 ABI 不是一个因素。</li><li><code>any</code> 是平台。这个 Wheels 几乎可以在任何平台上运行。</li></ul><p>Wheels 名称的 <code>py2.py3-none-any.whl</code> 段很常见。这是一个万能 Wheels ，可以在具有任何 <a href=https://stackoverflow.com/a/2456882/7954504 target=_blank>ABI</a> 的任何平台上与 Python 2 或 3 一起安装。如果 Wheels 以 <code>none-any.whl</code> 结尾，那么它很可能是一个不关心特定 Python ABI 或 CPU 架构的纯 Python 包。</p><p>另一个例子是 <code>jinja2</code> 模板引擎。如果您导航到 Jinja 3.x alpha 版本的<a href=https://pypi.org/project/Jinja2/3.0.0a1/#files target=_blank>下载页面</a>，您将看到以下 Wheels ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Jinja2-3.0.0a1-py3-none-any.whl
</span></span></code></pre></td></tr></table></div></div><p>注意这里缺少 <code>py2</code> 。这是一个纯 Python 项目，可以在任何 Python 3.x 版本上运行，但它不是万能 Wheels ，因为它不支持 Python 2。相反，它被称为纯 Python Wheels 。</p><blockquote><p>注意：在 2020 年，许多项目也放弃了对 Python 2 的支持，Python 2 于 2020 年 1 月 1 日达到生命周期结束 (EOL)。Jinja 版本 3.x 于 2020 年 2 月放弃了对 Python 2 的支持。</p></blockquote><p>以下是为一些流行的开源包分发的 <code>.whl</code> 名称的更多示例：</p><table><thead><tr><th>Wheel</th><th>What It Is 这是什么</th></tr></thead><tbody><tr><td><code>PyYAML-5.3.1-cp38-cp38-win_amd64.whl</code></td><td><a href=https://pypi.org/project/PyYAML/5.3.1/#files target=_blank>PyYAML</a> for CPython 3.8 on Windows with AMD64 (x86-64) architecture</td></tr><tr><td><code>numpy-1.18.4-cp38-cp38-win32.whl</code></td><td><a href=https://pypi.org/project/numpy/1.18.4/#files target=_blank>NumPy</a> for CPython 3.8 on Windows 32-bit</td></tr><tr><td><code>scipy-1.4.1-cp36-cp36m-macosx_10_6_intel.whl</code></td><td><a href=https://pypi.org/project/scipy/1.4.1/#files target=_blank>SciPy</a> for CPython 3.6 on macOS 10.6 SDK with fat binary (multiple instruction sets)</td></tr></tbody></table><p>现在您已经彻底了解什么是 Wheels ，是时候谈谈它们有什么好处了。</p><h3 id=wheels-的优势>Wheels 的优势<a hidden class=anchor aria-hidden=true href=#wheels-的优势>#</a></h3><p>这是来自 <a href=https://www.pypa.io/en/latest/ target=_blank>Python Packaging Authority</a> (PyPA) 的 wheels 证明：</p><blockquote><p>并非所有开发人员都有正确的工具或经验来构建这些用这些编译语言编写的组件，因此 Python 创造了 wheel，这是一种旨在运送带有编译工件的库的包格式。事实上，Python 的包安装程序 <code>pip</code> 总是更喜欢 wheel，因为安装总是更快，所以即使是纯 Python 包也能更好地使用 wheel。 （ <a href=https://packaging.python.org/overview/#python-binary-distributions target=_blank>来源</a>）</p></blockquote><p>更完整的描述是，wheels 在以下几个方面使 <a href=https://pythonwheels.com/#advantages target=_blank>Python 包的用户和维护者</a>都受益：</p><ul><li>对于纯 Python 包和<a href=https://realpython.com/build-python-c-extension-module/ target=_blank>扩展模块</a>，Wheels 的安装速度比源代码分发快。</li><li>Wheels 比源分布小。例如， <a href=https://pypi.org/project/six/#files target=_blank>six</a> Wheels 大约是相应源分布<a href=https://pypi.org/project/six/#files target=_blank>大小的三分之一</a>。当您考虑到单个包的 <code>pip install</code> 实际上可能会开始下载依赖项链时，这种差异变得更加重要。</li><li>Wheels 将 <code>setup.py</code> 执行排除在外。从源分发版安装会运行该项目的 <code>setup.py</code> 中包含的任何内容。正如 <a href=https://www.python.org/dev/peps/pep-0427/#rationale target=_blank>PEP 427</a> 所指出的，这相当于任意代码执行。 Wheels 完全避免了这种情况。</li><li>编译器不需要安装包含已编译扩展模块的 Wheels 。扩展模块包含在针对特定平台和 Python 版本的 wheel 中。</li><li><code>pip</code> 自动在 wheel 中生成与正确的 Python 解释器匹配的 <code>.pyc</code> 文件。</li><li>Wheels 通过减少安装软件包时涉及的许多变量来提供一致性。</li></ul><p>您可以使用 PyPI 上项目的下载文件选项卡来查看可用的不同发行版。例如，<a href=https://pypi.org/project/pandas/#files target=_blank>pandas</a> 分发了各种各样的 Wheels 。</p><h3 id=告诉-pip-要下载什么>告诉 <code>pip</code> 要下载什么<a hidden class=anchor aria-hidden=true href=#告诉-pip-要下载什么>#</a></h3><p>可以对 <code>pip</code> 进行细粒度控制并告诉它首选或避免哪种格式。您可以使用 <code>--only-binary</code> 和 <code>--no-binary</code> 选项来执行此操作。您在前面有关安装 <code>cryptography</code> 包的部分中看到了它们的使用，但值得仔细研究一下它们的作用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>pushd</span> <span class=s2>&#34;</span><span class=k>$(</span>mktemp -d<span class=k>)</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>$ python -m pip download --only-binary :all: --dest . --no-cache six
</span></span><span class=line><span class=cl>Collecting six
</span></span><span class=line><span class=cl>  Downloading six-1.14.0-py2.py3-none-any.whl <span class=o>(</span><span class=m>10</span> kB<span class=o>)</span>
</span></span><span class=line><span class=cl>  Saved ./six-1.14.0-py2.py3-none-any.whl
</span></span><span class=line><span class=cl>Successfully downloaded six
</span></span></code></pre></td></tr></table></div></div><p>在此示例中，您更改为一个临时目录以存储带有 <code>pushd "$(mktemp -d)"</code> 的下载。您使用 <code>pip download</code> 而不是 <code>pip install</code> 以便您可以检查生成的 Wheels ，但您可以将 <code>download</code> 替换为 <code>install</code> 同时保持相同的选项集。</p><p>您下载带有几个标志的 <code>six</code> 模块：</p><ul><li><code>--only-binary :all:</code> 告诉 <code>pip</code> 限制自己使用 Wheels 并忽略源代码分发。如果没有这个选项， <code>pip</code> 只会更喜欢 Wheels ，但在某些情况下会退回到源代码分发。</li><li><code>--dest .</code> 告诉 <code>pip</code> 将 <code>six</code> 下载到当前目录。</li><li><code>--no-cache</code> 告诉 <code>pip</code> 不要查看其本地下载缓存。你使用这个选项只是为了说明从 PyPI 的实时下载，因为你可能在某处有一个 <code>six</code> 缓存。</li></ul><p>我之前提到过，wheel 文件本质上是一个 <code>.zip</code> 存档。你可以从字面上理解这个陈述，并这样对待 Wheels 。例如，如果你想查看一个 Wheels 的内容，你可以使用 <code>unzip</code> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ unzip -l six*.whl
</span></span><span class=line><span class=cl>Archive:  six-1.14.0-py2.py3-none-any.whl
</span></span><span class=line><span class=cl>  Length      Date    Time    Name
</span></span><span class=line><span class=cl>---------  ---------- -----   ----
</span></span><span class=line><span class=cl>    <span class=m>34074</span>  01-15-2020 18:10   six.py
</span></span><span class=line><span class=cl>     <span class=m>1066</span>  01-15-2020 18:10   six-1.14.0.dist-info/LICENSE
</span></span><span class=line><span class=cl>     <span class=m>1795</span>  01-15-2020 18:10   six-1.14.0.dist-info/METADATA
</span></span><span class=line><span class=cl>      <span class=m>110</span>  01-15-2020 18:10   six-1.14.0.dist-info/WHEEL
</span></span><span class=line><span class=cl>        <span class=m>4</span>  01-15-2020 18:10   six-1.14.0.dist-info/top_level.txt
</span></span><span class=line><span class=cl>      <span class=m>435</span>  01-15-2020 18:10   six-1.14.0.dist-info/RECORD
</span></span><span class=line><span class=cl>---------                     -------
</span></span><span class=line><span class=cl>    <span class=m>37484</span>                     <span class=m>6</span> files
</span></span></code></pre></td></tr></table></div></div><p><code>six</code> 是一个特例：它实际上是一个单独的 Python 模块，而不是一个完整的包。 Wheel 文件也可以复杂得多，稍后您将看到。</p><p>与 <code>--only-binary</code> 相反，你可以使用 <code>--no-binary</code> 来做相反的事情：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python -m pip download --no-binary :all: --dest . --no-cache six
</span></span><span class=line><span class=cl>Collecting six
</span></span><span class=line><span class=cl>  Downloading six-1.14.0.tar.gz <span class=o>(</span><span class=m>33</span> kB<span class=o>)</span>
</span></span><span class=line><span class=cl>  Saved ./six-1.14.0.tar.gz
</span></span><span class=line><span class=cl>Successfully downloaded six
</span></span><span class=line><span class=cl>$ <span class=nb>popd</span>
</span></span></code></pre></td></tr></table></div></div><p>此示例中的唯一更改是切换到 <code>--no-binary :all:</code> 。这告诉 <code>pip</code> 忽略 Wheels ，即使它们可用，而是下载源分发。</p><p><code>--no-binary</code> 什么时候有用？以下是几个案例：</p><ul><li>对应的 Wheels 坏了。这是对 Wheels 的讽刺。它们旨在减少故障的发生，但在某些情况下， Wheels 可能会配置错误。在这种情况下，为自己下载和构建源代码分发可能是一个可行的选择。</li><li>您想要对项目应用一个小的更改或<a href=https://en.wikipedia.org/wiki/Patch_%28Unix%29 target=_blank>补丁文件</a>，然后安装它。这是从<a href=https://realpython.com/python-git-github-intro/#version-control target=_blank>版本控制系统</a> URL 克隆项目的替代方法。</li></ul><p>您还可以将上述标志与 <code>pip install</code> 一起使用。此外，与 <code>:all:</code> 不同， <code>--only-binary</code> 规则不仅适用于您正在安装的包，还适用于它的所有依赖项，您可以传递特定包的列表 <code>--only-binary</code> 和 <code>--no-binary</code> 来应用该规则规则到。</p><p>下面是几个安装 URL 库 <a href=https://github.com/aio-libs/yarl/ target=_blank>yarl</a> 的例子。它包含 Cython 代码并依赖于 <a href=https://github.com/aio-libs/multidict target=_blank>multidict</a> ，其中包含纯 C 代码。有几个选项可以严格使用或严格忽略 <code>yarl</code> 及其依赖项的 Wheels ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=c1># Install `yarl` and use only wheels for yarl and all dependencies</span>
</span></span><span class=line><span class=cl>$ python -m pip install --only-binary :all: yarl
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ <span class=c1># Install `yarl` and use wheels only for the `multidict` dependency</span>
</span></span><span class=line><span class=cl>$ python -m pip install --only-binary multidict yarl
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ <span class=c1># Install `yarl` and don&#39;t use wheels for yarl or any dependencies</span>
</span></span><span class=line><span class=cl>$ python -m pip install --no-binary :all: yarl
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ <span class=c1># Install `yarl` and don&#39;t use wheels for the `multidict` dependency</span>
</span></span><span class=line><span class=cl>$ python -m pip install --no-binary multidict yarl
</span></span></code></pre></td></tr></table></div></div><p>在本节中，您大致了解了如何微调 <code>pip install</code> 将使用的分发类型。虽然常规的 <code>pip install</code> 应该没有任何选项，但了解这些用于特殊情况的选项会很有帮助。</p><h3 id=wheel-manylinux-标签>Wheel manylinux 标签<a hidden class=anchor aria-hidden=true href=#wheel-manylinux-标签>#</a></h3><p>Linux 有许多变体和风格，例如 Debian、CentOS、Fedora 和 Pacman。其中每一个都可能在共享库（例如 <code>libncurses</code> ）和核心 C 库（例如 <code>glibc</code> ）中使用细微的变化。</p><p>如果您正在编写 C/C++ 扩展，那么这可能会产生问题。用 C 编写并在 Ubuntu Linux 上编译的源文件不能保证在 CentOS 机器或 Arch Linux 发行版上可执行。</p><p>您是否需要为每个 Linux 变体构建一个单独的 Wheels ？</p><p>幸运的是，答案是否定的，这要归功于一组专门设计的标签，称为 <code>manylinux</code> 平台标签系列。目前有以下三种变体：</p><ol><li><code>manylinux1</code> 是 <a href=https://www.python.org/dev/peps/pep-0513/ target=_blank>PEP 513</a> 中指定的原始格式。</li><li><code>manylinux2010</code> 是 <a href=https://www.python.org/dev/peps/pep-0571/ target=_blank>PEP 571</a> 中指定的更新，它升级到 CentOS 6 作为 Docker 镜像所基于的底层操作系统。理由是 CentOS 5.11，即 <code>manylinux1</code> 中允许的库列表的来源，于 2017 年 3 月达到 EOL 并停止接收安全补丁和错误修复。</li><li><code>manylinux2014</code> 是 <a href=https://www.python.org/dev/peps/pep-0599/ target=_blank>PEP 599</a> 中指定的升级到 CentOS 7 的更新，因为 CentOS 6 计划于 2020 年 11 月达到 EOL。</li></ol><p>您可以在 pandas 项目中找到 <code>manylinux</code> 分布的示例。以下是 PyPI 的可用 pandas 下载列表中的两个（最多的）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pandas-1.0.3-cp37-cp37m-manylinux1_x86_64.whl
</span></span><span class=line><span class=cl>pandas-1.0.3-cp37-cp37m-manylinux1_i686.whl
</span></span></code></pre></td></tr></table></div></div><p>在这种情况下，pandas 为支持 x86-64 和 <a href=https://en.wikipedia.org/wiki/P6_%28microarchitecture%29 target=_blank>i686</a> 架构的 CPython 3.7 构建了 <code>manylinux1</code> wheels。</p><p><code>manylinux</code> 的核心是基于特定版本的 CentOS 操作系统构建的 Docker 镜像。它捆绑了一个编译器套件、多个版本的 Python 和 <code>pip</code> ，以及一组允许的共享库。</p><blockquote><p>注意：术语 allowed 表示<a href=https://www.python.org/dev/peps/pep-0513/#rationale target=_blank>默认情况下假定存在</a>于几乎所有 Linux 系统上的低级库。这个想法是，依赖项应该存在于基本操作系统上，而不需要额外安装。</p></blockquote><p>截至 2020 年年中， <code>manylinux1</code> 仍然是主要的 <code>manylinux</code> 标签。原因之一可能只是习惯。另一个可能是客户端（用户）端对 <code>manylinux2010</code> 及更高版本的支持仅限于更新版本的 <code>pip</code> ：</p><table><thead><tr><th>Tag</th><th>Requirement</th></tr></thead><tbody><tr><td><code>manylinux1</code></td><td><code>pip</code> 8.1.0 或更高版本</td></tr><tr><td><code>manylinux2010</code></td><td><code>pip</code> 19.0 或更高版本</td></tr><tr><td><code>manylinux2014</code></td><td><code>pip</code> 19.3 或更高版本</td></tr></tbody></table><p>换句话说，如果您是构建 <code>manylinux2010</code> wheels 的包开发人员，那么使用您的包的人将需要 <code>pip</code> 19.0（2019 年 1 月发布）或更高版本才能让 <code>pip</code> 从 PyPI 找到并安装 <code>manylinux2010</code> wheels .</p><p>幸运的是，虚拟环境变得越来越普遍，这意味着开发人员可以在不接触系统 <code>pip</code> 的情况下更新虚拟环境的 <code>pip</code> 。然而，情况并非总是如此，一些 Linux 发行版仍然附带 <code>pip</code> 的过时版本。</p><p>这就是说，如果您要在 Linux 主机上安装 Python 包，那么如果包维护者不遗余力地创建 <code>manylinux</code> Wheels ，您就认为自己很幸运。这几乎可以保证无论您的特定 Linux 变体或版本如何，都可以轻松安装软件包。</p><blockquote><p>警告：请注意 <a href=https://pythonspeed.com/articles/alpine-docker-python/ target=_blank>PyPI wheels 不能在 Alpine Linux</a>（或 <a href=https://hub.docker.com/_/busybox/ target=_blank>BusyBox</a>）上运行。这是因为 Alpine 使用 <a href=https://wiki.musl-libc.org/ target=_blank>musl</a> 代替标准的 <a href=https://www.gnu.org/software/libc/libc.html target=_blank>glibc</a> 。 <code>musl libc</code> 库自称是“一个新的 <code>libc</code> ，力求快速、简单、轻量级、免费和正确”。不幸的是，说到 Wheels ， <code>glibc</code> 不是。</p></blockquote><h3 id=平台-wheels-的安全注意事项>平台 Wheels 的安全注意事项<a hidden class=anchor aria-hidden=true href=#平台-wheels-的安全注意事项>#</a></h3><p>从用户安全的角度来看，wheels 的一个值得考虑的特性是 wheels <a href=https://github.com/asottile/no-manylinux#what-why target=_blank>可能会受到版本腐烂</a>的影响，因为它们捆绑了二进制依赖项，而不是允许系统包管理器更新该依赖项。</p><p>例如，如果一个 wheel 合并了 <code>libfortran</code> 共享库，那么即使您使用包管理器（如 @ 3#、 <code>yum</code> 或 <code>brew</code> 。</p><p>如果您在安全防范措施得到加强的环境中进行开发，则需要注意某些平台 Wheels 的这一特性。</p><h2 id=召集所有开发人员构建您的-wheels>召集所有开发人员：构建您的 Wheels<a hidden class=anchor aria-hidden=true href=#召集所有开发人员构建您的-wheels>#</a></h2><p>本教程的标题是“你为什么要关心？”作为一名开发人员，如果您打算向社区分发 Python 包，那么您应该非常关心为您的项目分发 Wheels ，因为它们使最终用户的安装过程更简洁、更简单。</p><p>您可以使用兼容的 Wheels 支持的目标平台越多，您看到的标题为“安装在 XYZ 平台上损坏”之类的 GitHub 问题就越少。为您的 Python 包分发 wheel 客观上降低了包的用户在安装过程中遇到问题的可能性。</p><p>要在本地构建 Wheels ，您需要做的第一件事是安装 <code>wheel</code> 。确保 <code>setuptools</code> 也是最新的也没什么坏处：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python -m pip install -U wheel setuptools
</span></span></code></pre></td></tr></table></div></div><p>接下来的几节将引导您完成为各种不同场景构建 Wheels 的过程。</p><h3 id=不同类型的-wheels>不同类型的 Wheels<a hidden class=anchor aria-hidden=true href=#不同类型的-wheels>#</a></h3><p>正如本教程中提到的， Wheels 有几种不同的变体， Wheels 的类型反映在它的文件名中：</p><ul><li>万向 Wheels 包含 <code>py2.py3-none-any.whl</code> 。它在任何操作系统和平台上都支持 Python 2 和 Python 3。 Python Wheels 网站上列出的大多数 Wheels 都是通用 Wheels 。</li><li>纯 Python Wheels 包含 <code>py3-none-any.whl</code> 或 <code>py2.none-any.whl</code> 。它支持 Python 3 或 Python 2，但不支持两者。它在其他方面与万向 Wheels 相同，但它会标有 <code>py2</code> 或 <code>py3</code> 而不是 <code>py2.py3</code> 标签。</li><li>平台 Wheels 支持特定的 Python 版本和平台。它包含指示特定 Python 版本、ABI、操作系统或体系结构的段。</li></ul><p>wheel 类型之间的差异取决于它们支持的 Python 版本以及它们是否针对特定平台。以下是 Wheels 变体之间差异的简要总结：</p><table><thead><tr><th>Wheel Type</th><th>支持 Python 2 和 3</th><th>支持每个 ABI、操作系统和平台</th></tr></thead><tbody><tr><td>Universal</td><td>✓</td><td>✓</td></tr><tr><td>Pure-Python</td><td></td><td>✓</td></tr><tr><td>Platform</td><td></td><td></td></tr></tbody></table><p>正如您接下来将看到的，您可以通过相对较少的设置构建通用 Wheels 和纯 Python Wheels ，但平台 Wheels 可能需要一些额外的步骤。</p><h3 id=构建一个纯-python-wheels>构建一个纯 Python Wheels<a hidden class=anchor aria-hidden=true href=#构建一个纯-python-wheels>#</a></h3><p>您可以使用 <code>setuptools</code> 为任何项目构建纯 Python Wheels 或通用 Wheels ，只需一个命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python setup.py sdist bdist_wheel
</span></span></code></pre></td></tr></table></div></div><p>这将创建一个源代码分发 ( <code>sdist</code> ) 和一个 Wheels ( <code>bdist_wheel</code> )。默认情况下，两者都会放在当前目录下的 <code>dist/</code> 中。要亲眼看看，您可以为 <a href=https://github.com/jakubroztocil/httpie target=_blank>HTTPie</a> 构建一个 Wheels ，一个用 Python 编写的命令行 HTTP 客户端，以及一个 <code>sdist</code> 。</p><p>下面是为 HTTPie 包构建两种类型的发行版的结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git clone -q git@github.com:jakubroztocil/httpie.git
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> httpie
</span></span><span class=line><span class=cl>$ python setup.py -q sdist bdist_wheel
</span></span><span class=line><span class=cl>$ ls -1 dist/
</span></span><span class=line><span class=cl>httpie-2.2.0.dev0-py3-none-any.whl
</span></span><span class=line><span class=cl>httpie-2.2.0.dev0.tar.gz
</span></span></code></pre></td></tr></table></div></div><p>仅此而已。您克隆该项目，移至其根目录，然后调用 <code>python setup.py sdist bdist_wheel</code> 。您可以看到 <code>dist/</code> 包含一个 Wheels 和一个源代码分发。</p><p>默认情况下，生成的分布放在 <code>dist/</code> 中，但您可以使用 <code>-d</code> / <code>--dist-dir</code> 选项更改它。您可以将它们放在一个临时目录中，而不是用于构建隔离：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nv>tempdir</span><span class=o>=</span><span class=s2>&#34;</span><span class=k>$(</span>mktemp -d<span class=k>)</span><span class=s2>&#34;</span>  <span class=c1># Create a temporary directory</span>
</span></span><span class=line><span class=cl>$ file <span class=s2>&#34;</span><span class=nv>$tempdir</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>/var/folders/jc/8_kd8uusys7ak09_lpmn30rw0000gk/T/tmp.GIXy7XKV: directory
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ python setup.py sdist -d <span class=s2>&#34;</span><span class=nv>$tempdir</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>$ python setup.py bdist_wheel --dist-dir <span class=s2>&#34;</span><span class=nv>$tempdir</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>$ ls -1 <span class=s2>&#34;</span><span class=nv>$tempdir</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>httpie-2.2.0.dev0-py3-none-any.whl
</span></span><span class=line><span class=cl>httpie-2.2.0.dev0.tar.gz
</span></span></code></pre></td></tr></table></div></div><p>您可以将 <code>sdist</code> 和 <code>bdist_wheel</code> 步骤合二为一，因为 <code>setup.py</code> 可以采用多个子命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python setup.py sdist -d <span class=s2>&#34;</span><span class=nv>$tempdir</span><span class=s2>&#34;</span> bdist_wheel -d <span class=s2>&#34;</span><span class=nv>$tempdir</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>如此处所示，您需要将 <code>-d</code> 等选项传递给每个子命令。</p><h3 id=指定通用-wheel>指定通用 Wheel<a hidden class=anchor aria-hidden=true href=#指定通用-wheel>#</a></h3><p>通用 Wheels 是用于同时支持 Python 2 和 3 的纯 Python 项目的 Wheels 。有多种方法可以告诉 <code>setuptools</code> 和 <code>distutils</code> Wheels 应该是通用的。</p><p>选项 1 是在项目的 <a href=https://docs.python.org/3/distutils/configfile.html target=_blank>setup.cfg</a> 文件中指定选项：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=p>[</span><span class=nx>bdist_wheel</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>universal</span> <span class=p>=</span> <span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><p>选项 2 是在命令行传递恰当命名的 <code>--universal</code> 标志：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python setup.py bdist_wheel --universal
</span></span></code></pre></td></tr></table></div></div><p>选项 3 是使用其 <code>options</code> 参数告诉 <code>setup()</code> 本身有关该标志的信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># setup.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>setuptools</span> <span class=kn>import</span> <span class=n>setup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>setup</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=c1># ....</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=o>=</span><span class=p>{</span><span class=s2>&#34;bdist_wheel&#34;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&#34;universal&#34;</span><span class=p>:</span> <span class=kc>True</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=c1># ....</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>虽然这三个选项中的任何一个都应该有效，但前两个选项最常用。您可以在 <a href=https://github.com/chardet/chardet/blob/master/setup.cfg target=_blank>chardet 设置配置</a>中看到这样的示例。之后，您可以使用 <code>bdist_wheel</code> 命令，如前所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python setup.py sdist bdist_wheel
</span></span></code></pre></td></tr></table></div></div><p>无论您选择哪个选项，生成的 Wheels 都是等效的。选择在很大程度上取决于开发人员的偏好以及最适合您的工作流程。</p><h3 id=构建平台-wheels-macos-和-windows>构建平台 Wheels （macOS 和 Windows）<a hidden class=anchor aria-hidden=true href=#构建平台-wheels-macos-和-windows>#</a></h3><p>二进制发行版是包含已编译扩展的构建发行版的子集。扩展是非 Python 依赖项或 Python 包的组件。</p><p>通常，这意味着您的包包含扩展模块或依赖于用静态类型语言（例如 C、C++、Fortran，甚至 Rust 或 Go）编写的库。平台 Wheels 的存在主要是因为它们包含或依赖于扩展模块。</p><p>综上所述，是时候构建平台 Wheels 了！</p><p>根据您现有的开发环境，您可能需要完成一个或两个额外的先决条件步骤来构建平台 Wheels 。下面的步骤将帮助您设置构建 C 和 C++ 扩展模块，这是迄今为止最常见的类型。</p><p>在 macOS 上，您需要通过 <a href=https://www.unix.com/man-page/OSX/1/xcode-select/ target=_blank>xcode</a> 获得的命令行开发人员工具：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ xcode-select --install
</span></span></code></pre></td></tr></table></div></div><p>在 Windows 上，您需要安装 <a href="https://docs.microsoft.com/en-us/cpp/?view=vs-2019" target=_blank>Microsoft Visual C++</a>：</p><ul><li>在浏览器中打开 Visual Studio 下载页面。</li><li>选择 Visual Studio 工具 → Visual Studio 构建工具 → 下载。</li><li>运行生成的 <code>.exe</code> 安装程序。</li><li>在安装程序中，选择 C++ Build Tools → Install。</li><li>重新启动机器。</li></ul><p>在 Linux 上，您需要一个编译器，例如 <code>gcc</code> 或 <code>g++</code> / <code>c++</code> 。</p><p>有了这些，您就可以为 UltraJSON ( <code>ujson</code> ) 构建一个平台 Wheels ，UltraJSON 是一个用纯 C 语言编写并带有 Python 3 绑定的 <a href=https://realpython.com/python-json/ target=_blank>JSON</a> 编码器和解码器。使用 <code>ujson</code> 是一个很好的玩具示例，因为它涵盖了几个基础：</p><ul><li>它包含一个扩展模块， <a href=https://github.com/ultrajson/ultrajson/blob/master/python/ujson.c target=_blank>ujson</a> 。</li><li>它依赖于 Python 开发标头进行编译 ( <code>#include &lt;Python.h></code> )，但并不过分复杂。 <code>ujson</code> 旨在做一件事并且做好，就是读写 JSON！</li></ul><p>您可以从 GitHub 克隆该项目，导航到其目录并构建它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git clone -q --branch 2.0.3 git@github.com:ultrajson/ultrajson.git
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> ultrajson
</span></span><span class=line><span class=cl>$ python setup.py bdist_wheel
</span></span></code></pre></td></tr></table></div></div><p>您应该会看到大量输出。这是 macOS 上的精简版，其中使用了 Clang 编译器驱动程序：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>clang -Wno-unused-result -Wsign-compare -Wunreachable-code -DNDEBUG -g ...
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>creating <span class=s1>&#39;dist/ujson-2.0.3-cp38-cp38-macosx_10_15_x86_64.whl&#39;</span>
</span></span><span class=line><span class=cl>adding <span class=s1>&#39;ujson.cpython-38-darwin.so&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>以 <code>clang</code> 开头的行显示了对编译器的实际调用，其中包含大量编译标志。您可能还会看到诸如 <code>MSVC</code> (Windows) 或 <code>gcc</code> (Linux) 之类的工具，具体取决于操作系统。</p><p>如果在执行上述代码后遇到 <code>fatal error</code> ，请不要担心。您可以展开下面的框以了解如何处理此问题。</p><blockquote><p><code>setup.py bdist_wheel</code> 对 <code>ujson</code> 的调用需要 Python 开发头文件，因为 <code>ujson.c</code> 引入了 <code>&lt;Python.h></code> 。如果您没有将它们放在可搜索的位置，那么您可能会看到如下错误：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>fatal error: <span class=s1>&#39;Python.h&#39;</span> file not found
</span></span><span class=line><span class=cl><span class=c1>#include &lt;Python.h&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>要编译扩展模块，您需要将开发标头保存在编译器可以找到的地方。</p><p>如果您使用的是最新版本的 Python 3 和虚拟环境工具（如 <code>venv</code> ），则 Python 开发标头可能会默认包含在编译和链接中。</p><p>如果没有，那么您可能会看到一个错误，表明找不到头文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>fatal error: <span class=s1>&#39;Python.h&#39;</span> file not found
</span></span><span class=line><span class=cl><span class=c1>#include &lt;Python.h&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>在这种情况下，您可以通过设置 <code>CFLAGS</code> 来告诉 <code>setup.py</code> 还可以在哪里查找头文件。要查找头文件本身，可以使用 <code>python3-config</code> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python3-config --include
</span></span><span class=line><span class=cl>-I/Users/&lt;username&gt;/.pyenv/versions/3.8.2/include/python3.8
</span></span></code></pre></td></tr></table></div></div><p>这告诉您 Python 开发标头位于显示的目录中，您现在可以将其与 <code>python setup.py bdist_wheel</code> 一起使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nv>CFLAGS</span><span class=o>=</span><span class=s2>&#34;</span><span class=k>$(</span>python3-config --include<span class=k>)</span><span class=s2>&#34;</span> python setup.py bdist_wheel
</span></span></code></pre></td></tr></table></div></div><p>更一般地说，您可以传递您需要的任何路径：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nv>CFLAGS</span><span class=o>=</span><span class=s1>&#39;-I/path/to/include&#39;</span> python setup.py bdist_wheel
</span></span></code></pre></td></tr></table></div></div><p>在 Linux 上，您可能还需要单独安装头文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ apt-get install -y python3-dev  <span class=c1># Debian, Ubuntu</span>
</span></span><span class=line><span class=cl>$ yum install -y python3-devel  <span class=c1># CentOS, Fedora, RHEL</span>
</span></span></code></pre></td></tr></table></div></div></blockquote><p>如果你检查 UltraJSON 的 <a href=https://github.com/ultrajson/ultrajson/blob/master/setup.py target=_blank>setup.py</a> ，你会看到它自定义了一些编译器标志，例如 <code>-D_GNU_SOURCE</code> 。通过 <code>setup.py</code> 控制编译过程的复杂性超出了本教程的范围，但您应该知道可以<a href=https://pythonextensionpatterns.readthedocs.io/en/latest/compiler_flags.html#setting-flags-automatically-in-setup-py target=_blank>对编译和链接的发生方式进行细粒度控制</a>。</p><p>如果您查看 <code>dist</code> ，那么您应该会看到创建的 Wheels ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ls dist/
</span></span><span class=line><span class=cl>ujson-2.0.3-cp38-cp38-macosx_10_15_x86_64.whl
</span></span></code></pre></td></tr></table></div></div><p>请注意，名称可能因您的平台而异。例如，您会在 64 位 Windows 上看到 <code>win_amd64.whl</code> 。</p><p>您可以查看 wheel 文件并看到它包含已编译的扩展名：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ unzip -l dist/ujson-*.whl
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>  Length      Date    Time    Name
</span></span><span class=line><span class=cl>---------  ---------- -----   ----
</span></span><span class=line><span class=cl>   <span class=m>105812</span>  05-10-2020 19:47   ujson.cpython-38-darwin.so
</span></span><span class=line><span class=cl>   ...
</span></span></code></pre></td></tr></table></div></div><p>此示例显示 macOS 的输出， <code>ujson.cpython-38-darwin.so</code> ，这是一个共享对象 ( <code>.so</code> ) 文件，也称为动态库。</p><h3 id=构建-manylinux-wheels>构建 <code>manylinux</code> Wheels<a hidden class=anchor aria-hidden=true href=#构建-manylinux-wheels>#</a></h3><p>作为软件包开发人员，您很少会希望为单个 Linux 变体构建 Wheels 。 Linux wheels 需要一套专门的约定和工具，以便它们可以跨不同的 Linux 环境工作。</p><p>与 macOS 和 Windows 的 wheel 不同，构建在一个 Linux 变体上的 wheel 不能保证在另一个 Linux 变体上工作，即使是具有相同机器架构的 Linux 变体。</p><p>事实上，如果您在开箱即用的 Linux 容器上构建一个 Wheels ，那么如果您尝试上传它，PyPI 甚至不会接受该 Wheels ！</p><p>如果您希望您的包在一系列 Linux 客户端上可用，那么您需要一个 <code>manylinux</code> Wheels 。 <code>manylinux</code> wheel 是一种特殊类型的平台 wheel，被大多数 Linux 变体接受。它必须在特定环境中构建，并且需要一个名为 <code>auditwheel</code> 的工具来重命名 wheel 文件以表明它是一个 <code>manylinux</code> wheel。</p><blockquote><p>注意：即使您是从开发人员而不是用户的角度来学习本教程，请确保您在继续本节之前已阅读有关 <code>manylinux</code> wheel 标签的部分。</p></blockquote><p>构建一个 <code>manylinux</code> Wheels 可以让你瞄准更广泛的用户平台。 PEP 513 指定了一个特定的（和古老的）CentOS 版本，其中包含一系列可用的 Python 版本。 CentOS 和 Ubuntu 或任何其他发行版之间的选择没有任何特殊区别。</p><p>重点是构建环境由一个普通的 Linux 操作系统和一组有限的外部共享库组成，这些共享库对于不同的 Linux 变体是通用的。</p><p>值得庆幸的是，您不必自己执行此操作。 PyPA 提供了一组 <a href=https://github.com/pypa/manylinux target=_blank>Docker 镜像</a>，只需单击几下鼠标即可为您提供此环境：</p><ul><li>选项 1 是从您的开发机器运行 <code>docker</code> 并使用 Docker 卷挂载您的项目，以便它可以在容器文件系统中访问。</li><li>选项 2 是使用 CI/CD 解决方案，例如 CircleCI、GitHub Actions、Azure DevOps 或 Travis-CI，这将拉取您的项目并在推送或标记等操作上运行构建。</li></ul><p>为不同的 <code>manylinux</code> 风格提供了 Docker 镜像：</p><table><thead><tr><th><code>manylinux</code> Tag</th><th>Architecture</th><th>Docker Image</th></tr></thead><tbody><tr><td><code>manylinux1</code></td><td>x86-64</td><td><a href=https://quay.io/pypa/manylinux1_x86_64 target=_blank>quay.io/pypa/manylinux1_x86_64</a></td></tr><tr><td><code>manylinux1</code></td><td>i686</td><td><a href=https://quay.io/pypa/manylinux1_i686 target=_blank>quay.io/pypa/manylinux1_i686</a></td></tr><tr><td><code>manylinux2010</code></td><td>x86-64</td><td><a href=https://quay.io/pypa/manylinux2010_x86_64 target=_blank>quay.io/pypa/manylinux2010_x86_64</a></td></tr><tr><td><code>manylinux2010</code></td><td>i686</td><td><a href=https://quay.io/pypa/manylinux2010_i686 target=_blank>quay.io/pypa/manylinux2010_i686</a></td></tr><tr><td><code>manylinux2014</code></td><td>x86-64</td><td><a href=https://quay.io/pypa/manylinux2014_x86_64 target=_blank>quay.io/pypa/manylinux2014_x86_64</a></td></tr><tr><td><code>manylinux2014</code></td><td>i686</td><td><a href=https://quay.io/pypa/manylinux2014_i686 target=_blank>quay.io/pypa/manylinux2014_i686</a></td></tr><tr><td><code>manylinux2014</code></td><td>aarch64</td><td><a href=https://quay.io/pypa/manylinux2014_aarch64 target=_blank>quay.io/pypa/manylinux2014_aarch64</a></td></tr><tr><td><code>manylinux2014</code></td><td>ppc64le</td><td><a href=https://quay.io/pypa/manylinux2014_ppc64le target=_blank>quay.io/pypa/manylinux2014_ppc64le</a></td></tr><tr><td><code>manylinux2014</code></td><td>s390x</td><td><a href=https://quay.io/pypa/manylinux2014_s390x target=_blank>quay.io/pypa/manylinux2014_s390x</a></td></tr></tbody></table><p>首先，PyPA 还提供了一个示例存储库 <a href=https://github.com/pypa/python-manylinux-demo target=_blank>python-manylinux-demo</a>，这是一个用于与 Travis-CI 一起构建 <code>manylinux</code> wheels 的演示项目。</p><p>虽然构建 wheels 作为远程托管 CI 解决方案的一部分很常见，但您也可以在本地构建 <code>manylinux</code> wheels。为此，您需要安装 Docker。 Docker Desktop 适用于 macOS、Windows 和 Linux。</p><p>首先，克隆演示项目：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git clone -q git@github.com:pypa/python-manylinux-demo.git
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> python-manylinux-demo
</span></span></code></pre></td></tr></table></div></div><p>接下来，分别为 <code>manylinux1</code> Docker 镜像和平台定义几个 shell 变量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nv>DOCKER_IMAGE</span><span class=o>=</span><span class=s1>&#39;quay.io/pypa/manylinux1_x86_64&#39;</span>
</span></span><span class=line><span class=cl>$ <span class=nv>PLAT</span><span class=o>=</span><span class=s1>&#39;manylinux1_x86_64&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>DOCKER_IMAGE</code> 变量是由 PyPA 维护的用于构建 <code>manylinux</code> Wheels 的图像，托管在 <a href=https://quay.io/ target=_blank>Quay.io</a>。平台 ( <code>PLAT</code> ) 是提供给 <code>auditwheel</code> 的必要信息，让它知道要应用哪个平台标签。</p><p>现在您可以拉取 Docker 镜像并在容器中运行 wheel-builder 脚本：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker pull <span class=s2>&#34;</span><span class=nv>$DOCKER_IMAGE</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>$ docker container run -t --rm <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      -e <span class=nv>PLAT</span><span class=o>=</span><span class=nv>$PLAT</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      -v <span class=s2>&#34;</span><span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span><span class=s2>&#34;</span>:/io <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      <span class=s2>&#34;</span><span class=nv>$DOCKER_IMAGE</span><span class=s2>&#34;</span> /io/travis/build-wheels.sh
</span></span></code></pre></td></tr></table></div></div><p>这告诉 Docker 在 <code>manylinux1_x86_64</code> Docker 容器内运行 <code>build-wheels.sh</code> shell 脚本，将 <code>PLAT</code> 作为容器中可用的环境变量传递。由于您使用 <code>-v</code> （或 <code>--volume</code> ）绑定挂载卷，因此容器中生成的 Wheels 现在可以在主机上的 <code>wheelhouse</code> 目录中访问：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ls -1 wheelhouse
</span></span><span class=line><span class=cl>python_manylinux_demo-1.0-cp27-cp27m-manylinux1_x86_64.whl
</span></span><span class=line><span class=cl>python_manylinux_demo-1.0-cp27-cp27mu-manylinux1_x86_64.whl
</span></span><span class=line><span class=cl>python_manylinux_demo-1.0-cp35-cp35m-manylinux1_x86_64.whl
</span></span><span class=line><span class=cl>python_manylinux_demo-1.0-cp36-cp36m-manylinux1_x86_64.whl
</span></span><span class=line><span class=cl>python_manylinux_demo-1.0-cp37-cp37m-manylinux1_x86_64.whl
</span></span><span class=line><span class=cl>python_manylinux_demo-1.0-cp38-cp38-manylinux1_x86_64.whl
</span></span></code></pre></td></tr></table></div></div><p>在几个简短的命令中，您拥有一组适用于 CPython 2.7 到 3.8 的 <code>manylinux1</code> Wheels 。一种常见的做法是迭代不同的架构。例如，您可以对 <code>quay.io/pypa/manylinux1_i686</code> Docker 映像重复此过程。这将构建针对 32 位 (i686) 架构的 <code>manylinux1</code> Wheels 。</p><p>如果您想更深入地研究造 Wheels ，那么下一步就是向最好的人学习。从 Python Wheels 页面开始，选择一个项目，导航到它的源代码（在 GitHub、GitLab 或 Bitbucket 等地方），然后亲眼看看它是如何构建 Wheels 的。</p><p>Python Wheels 页面上的许多项目都是纯 Python 项目并分发通用 Wheels 。如果您正在寻找更复杂的案例，请留意使用扩展模块的包。这里有两个例子可以激发你的胃口：</p><ul><li><code>lxml</code> 使用从 <code>manylinux1</code> Docker 容器中调用的单独构建脚本。</li><li><code>ultrajson</code> 做同样的事情并使用 GitHub Actions 调用构建脚本。</li></ul><p>如果您有兴趣构建 <code>manylinux</code> Wheels ，这两个都是著名的项目，它们提供了很好的示例供您学习。</p><h3 id=捆绑共享库>捆绑共享库<a hidden class=anchor aria-hidden=true href=#捆绑共享库>#</a></h3><p>另一个挑战是为依赖于外部共享库的包构建 Wheels 。 <code>manylinux</code> 图像包含一组预筛选的库，例如 <code>libpthread.so.0</code> 和 <code>libc.so.6</code> 。但是，如果您依赖该列表之外的东西怎么办，例如 ATLAS 或 GFortran？</p><p>在这种情况下，有几种解决方案可以解决问题：</p><ul><li><code>auditwheel</code> 会将外部库捆绑到一个已经构建好的 Wheels 中。</li><li><code>delocate</code> 在 macOS 上做同样的事情。</li></ul><p>方便的是， <code>auditwheel</code> 出现在 <code>manylinux</code> Docker 镜像上。使用 <code>auditwheel</code> 和 <code>delocate</code> 只需一个命令。只需告诉他们有关 wheel 文件的信息，他们就会完成剩下的工作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ auditwheel repair &lt;path-to-wheel.whl&gt;  <span class=c1># For manylinux</span>
</span></span><span class=line><span class=cl>$ delocate-wheel &lt;path-to-wheel.whl&gt;  <span class=c1># For macOS</span>
</span></span></code></pre></td></tr></table></div></div><p>这将通过项目的 <code>setup.py</code> 检测所需的外部库，并将它们捆绑到 wheel 中，就好像它们是项目的一部分一样。</p><p>利用 <code>auditwheel</code> 和 <code>delocate</code> 的项目示例是 <code>pycld3</code> ，它为 Compact Language Detector v3 (CLD3) 提供 Python 绑定。</p><p><code>pycld3</code> 包依赖于 <code>libprotobuf</code> ，它不是一个通常安装的库。如果你查看 <code>pycld3</code> macOS Wheels 内部，你会看到 <code>libprotobuf.22.dylib</code> 包含在那里。这是一个捆绑到 Wheels 中的动态链接共享库：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ unzip -l pycld3-0.20-cp38-cp38-macosx_10_15_x86_64.whl
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>       <span class=m>51</span>  04-10-2020 11:46   cld3/__init__.py
</span></span><span class=line><span class=cl>   <span class=m>939984</span>  04-10-2020 07:50   cld3/_cld3.cpython-38-darwin.so
</span></span><span class=line><span class=cl>  <span class=m>2375836</span>  04-10-2020 07:50   cld3/.dylibs/libprotobuf.22.dylib
</span></span><span class=line><span class=cl>---------                     -------
</span></span><span class=line><span class=cl>  <span class=m>3339279</span>                     <span class=m>8</span> files
</span></span></code></pre></td></tr></table></div></div><p>Wheels 预包装有 <code>libprotobuf</code> 。 <code>.dylib</code> 类似于 Unix <code>.so</code> 文件或 Windows <code>.dll</code> 文件，但我承认我不知道除此之外的具体区别。</p><p><code>auditwheel</code> 和 <code>delocate</code> 知道包含 <code>libprotobuf</code> 因为 <code>setup.py</code> 通过 <code>libraries</code> 参数告诉他们：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>setup</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=c1># ...</span>
</span></span><span class=line><span class=cl>    <span class=n>libraries</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;protobuf&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=c1># ...</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这意味着 <code>auditwheel</code> 和 <code>delocate</code> 为用户省去了安装 <code>protobuf</code> 的麻烦，只要他们从具有匹配 Wheels 的平台和 Python 组合进行安装即可。</p><p>如果您要分发的包具有这样的外部依赖项，那么您可以通过使用 <code>auditwheel</code> 或 <code>delocate</code> 来帮您的用户一个忙，让他们省去自己安装依赖项的额外步骤。</p><h3 id=在持续集成中构建-wheels>在持续集成中构建 Wheels<a hidden class=anchor aria-hidden=true href=#在持续集成中构建-wheels>#</a></h3><p>在本地机器上构建 Wheels 的替代方法是在项目的 <a href=https://realpython.com/python-continuous-integration/ target=_blank>CI 管道</a>中自动构建它们。</p><p>有无数与主要代码托管服务集成的 CI 解决方案。其中包括 <a href=https://www.appveyor.com/ target=_blank>Appveyor</a>、<a href=https://azure.microsoft.com/en-us/services/devops/ target=_blank>Azure DevOps</a>、<a href=https://bitbucket.org/product/features/pipelines target=_blank>BitBucket Pipelines</a>、<a href=https://circleci.com/ target=_blank>Circle CI</a>、<a href=https://about.gitlab.com/stages-devops-lifecycle/continuous-integration/ target=_blank>GitLab</a>、<a href=https://github.com/features/actions target=_blank>GitHub Actions</a>、<a href=https://www.jenkins.io/ target=_blank>Jenkins</a> 和 <a href=https://travis-ci.org/ target=_blank>Travis CI</a>，仅举几例。</p><p>本教程的目的不是要判断哪种 CI 服务最适合构建 Wheels ，以及考虑到 CI 支持的发展速度，任何支持哪些容器的 CI 服务列表很快就会过时。</p><p>但是，本节可以帮助您入门。</p><p>如果你正在开发一个纯 Python 包， <code>bdist_wheel</code> 一步是一个幸福的单行：它在很大程度上与你在哪个容器操作系统和平台上构建 Wheels 无关。几乎所有主要的 CI 服务都应该使您能够通过在项目内的特殊 YAML 文件中定义步骤来以简洁的方式执行此操作。</p><p>例如，这是您可以用于 GitHub Actions 的语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Python wheels</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>release</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>types</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>created</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>wheels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Set up Python 3.x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/setup-python@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>python-version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.x&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install dependencies</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>python -m pip install --upgrade setuptools wheel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Build wheels</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>python setup.py bdist_wheel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/upload-artifact@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dist</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>dist</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在此配置文件中，您使用以下步骤构建一个 Wheels ：</p><ul><li>在第 8 行，您指定该作业应在 Ubuntu 机器上运行。</li><li>在第 10 行中，您使用 <code>checkout</code> 操作来设置您的项目存储库。</li><li>在第 14 行，您告诉 CI 运行器使用最新稳定版本的 Python 3。</li><li>在第 21 行中，您请求将生成的 Wheels 作为工件提供，您可以在作业完成后从 UI 下载该工件。</li></ul><p>但是，如果您有一个复杂的项目（可能是一个带有 C 扩展或 Cython 代码的项目）并且您正在努力构建一个 CI/CD 管道以自动构建 Wheels ，那么可能会涉及额外的步骤。以下是一些您可以通过示例学习的项目：</p><ul><li><a href=https://github.com/aio-libs/yarl target=_blank><code>yarl</code></a></li><li><a href=https://github.com/msgpack/msgpack-python target=_blank><code>msgpack</code></a></li><li><a href=https://github.com/pallets/markupsafe target=_blank><code>markupsafe</code></a></li><li><a href=https://github.com/pyca/cryptography target=_blank><code>cryptography</code></a></li></ul><p>许多项目推出了自己的 CI 配置。然而，一些解决方案已经出现，用于减少配置文件中指定的代码量来构建 Wheels 。您可以直接在 CI 服务器上使用 <a href=https://github.com/joerick/cibuildwheel target=_blank>cibuildwheel</a> 工具来减少构建多个平台 Wheels 所需的代码行和配置。还有 <a href=https://github.com/matthew-brett/multibuild target=_blank>multibuild</a>，它提供了一组 shell 脚本，用于协助在 Travis CI 和 AppVeyor 上构建 Wheels 。</p><h3 id=确保你的-wheels-旋转正确>确保你的 Wheels 旋转正确<a hidden class=anchor aria-hidden=true href=#确保你的-wheels-旋转正确>#</a></h3><p>构建结构正确的 Wheels 可能是一项精细的操作。例如，如果您的 Python 包使用 <code>src</code> 布局而您忘记在 <code>setup.py</code> 中正确指定它，那么生成的 Wheels 可能包含错误位置的目录。</p><p>您可以在 <code>bdist_wheel</code> 之后使用的一项检查是 <code>check-wheel-contents</code> 工具。它查找常见问题，例如包目录结构异常或存在重复文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ check-wheel-contents dist/*.whl
</span></span><span class=line><span class=cl>dist/ujson-2.0.3-cp38-cp38-macosx_10_15_x86_64.whl: OK
</span></span></code></pre></td></tr></table></div></div><p>在本例中， <code>check-wheel-contents</code> 表示带 <code>ujson</code> Wheels 的所有内容都已检出。如果不是， <code>stdout</code> 将显示可能问题的摘要，就像 <code>flake8</code> 之类的 linter。</p><p>另一种确认您构建的 Wheels 是否正确的方法是使用 TestPyPI。首先，您可以在那里上传包：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python -m twine upload <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      --repository-url https://test.pypi.org/legacy/ <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      dist/*
</span></span></code></pre></td></tr></table></div></div><p>然后，您可以下载相同的包进行测试，就好像它是真实的一样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python -m pip install <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      --index-url https://test.pypi.org/simple/ <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      &lt;pkg-name&gt;
</span></span></code></pre></td></tr></table></div></div><p>这允许您通过上传然后下载您自己的项目来测试您的 Wheels 。</p><h3 id=将-python-wheels-上传到-pypi>将 Python Wheels 上传到 PyPI<a hidden class=anchor aria-hidden=true href=#将-python-wheels-上传到-pypi>#</a></h3><p>现在是时候上传你的 Python 包了。由于 <code>sdist</code> 和 wheel 默认情况下都放在 <code>dist/</code> 目录中，您可以使用 <code>twine</code> 工具上传它们，这是一个用于将包发布到 PyPI 的实用程序：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python -m pip install -U twine
</span></span><span class=line><span class=cl>$ python -m twine upload dist/*
</span></span></code></pre></td></tr></table></div></div><p>由于默认情况下 <code>sdist</code> 和 <code>bdist_wheel</code> 都输出到 <code>dist/</code> ，您可以安全地告诉 <code>twine</code> 使用 shell 通配符( <code>dist/*</code> ) 上传 <code>dist/</code> 下的所有内容。</p><h2 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h2><p>了解 Wheels 在 Python 生态系统中扮演的关键角色可以让您作为 Python 包的用户和开发人员的生活更轻松。</p><p>此外，在 Wheels 方面提高你的 Python 素养将帮助你更好地理解安装包时发生了什么，以及在越来越罕见的情况下，该操作何时出错。</p><p><strong>在本教程中，您学习了：</strong></p><ul><li>什么是 Wheels 以及它们与源代码分布的比较</li><li>如何使用 Wheels 来控制包安装过程</li><li>通用 Wheels 、纯 Python Wheels 和平台 Wheels 之间有什么区别</li><li>如何为您自己的 Python 包创建和分发 Wheels</li></ul><p>您现在已经从用户和开发人员的角度对 Wheels 有了深入的了解。您完全有能力构建自己的 Wheels ，并使项目的安装过程快速、方便和稳定。</p><p>请参阅下面的部分以获取一些额外的阅读材料，以更深入地了解快速扩展的 wheel 生态系统。</p><h2 id=资源>资源<a hidden class=anchor aria-hidden=true href=#资源>#</a></h2><p><a href=https://pythonwheels.com/ target=_blank>Python Wheels</a>页面专门跟踪 PyPI 上下载次数最多的 360 个包中对 wheels 的支持。在编写本教程时，采用率非常可观，为 360 分之 331，即 91% 左右。</p><p>已经有许多 Python 增强提案 (PEP) 帮助了 wheel 格式的规范和发展：</p><ul><li><a href=https://www.python.org/dev/peps/pep-0425/ target=_blank>PEP 425 - Compatibility Tags for Built Distributions</a></li><li><a href=https://www.python.org/dev/peps/pep-0427/ target=_blank>PEP 427 - The Wheel Binary Package Format 1.0</a></li><li><a href=https://www.python.org/dev/peps/pep-0491/ target=_blank>PEP 491 - The Wheel Binary Package Format 1.9</a></li><li><a href=https://www.python.org/dev/peps/pep-0513/ target=_blank>PEP 513 - A Platform Tag for Portable Linux Built Distributions</a></li><li><a href=https://www.python.org/dev/peps/pep-0571/ target=_blank>PEP 571 - The manylinux2010 Platform Tag</a></li><li><a href=https://www.python.org/dev/peps/pep-0599/ target=_blank>PEP 599 - The manylinux2014 Platform Tag</a></li></ul><p>以下是本教程中提到的各种 wheel 打包工具的候选清单：</p><ul><li><a href=https://github.com/pypa/wheel target=_blank>pypa/wheel</a></li><li><a href=https://github.com/pypa/auditwheel target=_blank>pypa/auditwheel</a></li><li><a href=https://github.com/pypa/manylinux target=_blank>pypa/manylinux</a></li><li><a href=https://github.com/pypa/python-manylinux-demo target=_blank>pypa/python-manylinux-demo</a></li><li><a href=https://github.com/jwodder/check-wheel-contents target=_blank>jwodder/check-wheel-contents</a></li><li><a href=https://github.com/matthew-brett/delocate target=_blank>matthew-brett/delocate</a></li><li><a href=https://github.com/matthew-brett/multibuild target=_blank>matthew-brett/multibuild</a></li><li><a href=https://github.com/joerick/cibuildwheel target=_blank>joerick/cibuildwheel</a></li></ul><p>Python 文档有几篇文章涵盖了 Wheels 和源代码分发：</p><ul><li><a href=https://packaging.python.org/tutorials/packaging-projects/#generating-distribution-archives target=_blank>Generating Distribution Archives</a></li><li><a href=https://docs.python.org/3/distutils/sourcedist.html target=_blank>Creating a Source Distribution</a></li></ul><p>最后，这里有一些来自 PyPA 的更有用的链接：</p><ul><li><a href=https://packaging.python.org/guides/distributing-packages-using-setuptools/#packaging-your-project target=_blank>Packaging your Project</a></li><li><a href=https://packaging.python.org/overview/ target=_blank>An Overview of Packaging for Python</a></li></ul><p>原文地址：<a href=https://realpython.com/python-wheels/ target=_blank>https://realpython.com/python-wheels/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/><span class=title>« Prev</span><br><span>Java设计模式：Visitor</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/06/01/what-is-pip/><span class=title>Next »</span><br><span>[译]使用 Python 的 pip 管理项目的依赖关系</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]什么是 Python Wheels，你为什么要关心它？ on x" href="https://x.com/intent/tweet/?text=%5b%e8%af%91%5d%e4%bb%80%e4%b9%88%e6%98%af%20Python%20Wheels%ef%bc%8c%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e5%bf%83%e5%ae%83%ef%bc%9f&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f01%2fpython-wheels%2f&amp;hashtags=python"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]什么是 Python Wheels，你为什么要关心它？ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f01%2fpython-wheels%2f&amp;title=%5b%e8%af%91%5d%e4%bb%80%e4%b9%88%e6%98%af%20Python%20Wheels%ef%bc%8c%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e5%bf%83%e5%ae%83%ef%bc%9f&amp;summary=%5b%e8%af%91%5d%e4%bb%80%e4%b9%88%e6%98%af%20Python%20Wheels%ef%bc%8c%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e5%bf%83%e5%ae%83%ef%bc%9f&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f01%2fpython-wheels%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]什么是 Python Wheels，你为什么要关心它？ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f01%2fpython-wheels%2f&title=%5b%e8%af%91%5d%e4%bb%80%e4%b9%88%e6%98%af%20Python%20Wheels%ef%bc%8c%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e5%bf%83%e5%ae%83%ef%bc%9f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]什么是 Python Wheels，你为什么要关心它？ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f01%2fpython-wheels%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]什么是 Python Wheels，你为什么要关心它？ on whatsapp" href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5d%e4%bb%80%e4%b9%88%e6%98%af%20Python%20Wheels%ef%bc%8c%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e5%bf%83%e5%ae%83%ef%bc%9f%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f01%2fpython-wheels%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]什么是 Python Wheels，你为什么要关心它？ on telegram" href="https://telegram.me/share/url?text=%5b%e8%af%91%5d%e4%bb%80%e4%b9%88%e6%98%af%20Python%20Wheels%ef%bc%8c%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e5%bf%83%e5%ae%83%ef%bc%9f&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f01%2fpython-wheels%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]什么是 Python Wheels，你为什么要关心它？ on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%e8%af%91%5d%e4%bb%80%e4%b9%88%e6%98%af%20Python%20Wheels%ef%bc%8c%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e5%bf%83%e5%ae%83%ef%bc%9f&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f01%2fpython-wheels%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>