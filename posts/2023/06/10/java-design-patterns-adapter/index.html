<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java设计模式：Adapter | ChenSoul</title>
<meta name=keywords content="java"><meta name=description content='本文主要介绍 Adapter 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。
适配器模式(Adapter Pattern)是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一种接口。适配器模式通常用于连接两个不兼容的接口或类，以便它们可以协同工作。
解释 现实世界例子
考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。
用直白的话来说
适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。
维基百科中说
在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。
适配器模式由三个主要角色组成：
目标接口(Target Interface)：客户端所期望的接口。适配器模式会创建一个实现目标接口的新类，以便客户端可以通过该接口调用它。
适配器(Adapter)：该类实现了目标接口，并将客户端的请求转换为对适配者的调用。适配器通常会聚合一个适配者对象，以便将请求委托给它。
适配者(Adapteree)：适配器模式的实际工作内容。适配者是客户端所期望的接口之外的类，它实现了客户端需要的功能，但其接口与客户端所期望的接口不兼容。
编程样例(对象适配器)
假如有一个船长他只会划船，但不会航行。
首先我们有接口RowingBoat和FishingBoat
public interface RowingBoat { void row(); } @Slf4j public class FishingBoat { public void sail() { LOGGER.info("The fishing boat is sailing"); } } 船长希望有一个RowingBoat接口的实现，这样就可以移动
public class Captain { private final RowingBoat rowingBoat; // default constructor and setter for rowingBoat public Captain(RowingBoat rowingBoat) { this.rowingBoat = rowingBoat; } public void row() { rowingBoat.'><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Java设计模式：Adapter"><meta property="og:description" content='本文主要介绍 Adapter 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。
适配器模式(Adapter Pattern)是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一种接口。适配器模式通常用于连接两个不兼容的接口或类，以便它们可以协同工作。
解释 现实世界例子
考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。
用直白的话来说
适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。
维基百科中说
在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。
适配器模式由三个主要角色组成：
目标接口(Target Interface)：客户端所期望的接口。适配器模式会创建一个实现目标接口的新类，以便客户端可以通过该接口调用它。
适配器(Adapter)：该类实现了目标接口，并将客户端的请求转换为对适配者的调用。适配器通常会聚合一个适配者对象，以便将请求委托给它。
适配者(Adapteree)：适配器模式的实际工作内容。适配者是客户端所期望的接口之外的类，它实现了客户端需要的功能，但其接口与客户端所期望的接口不兼容。
编程样例(对象适配器)
假如有一个船长他只会划船，但不会航行。
首先我们有接口RowingBoat和FishingBoat
public interface RowingBoat { void row(); } @Slf4j public class FishingBoat { public void sail() { LOGGER.info("The fishing boat is sailing"); } } 船长希望有一个RowingBoat接口的实现，这样就可以移动
public class Captain { private final RowingBoat rowingBoat; // default constructor and setter for rowingBoat public Captain(RowingBoat rowingBoat) { this.rowingBoat = rowingBoat; } public void row() { rowingBoat.'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-10T09:00:00+08:00"><meta property="article:modified_time" content="2023-06-10T09:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java设计模式：Adapter"><meta name=twitter:description content='本文主要介绍 Adapter 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。
适配器模式(Adapter Pattern)是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一种接口。适配器模式通常用于连接两个不兼容的接口或类，以便它们可以协同工作。
解释 现实世界例子
考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。
用直白的话来说
适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。
维基百科中说
在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。
适配器模式由三个主要角色组成：
目标接口(Target Interface)：客户端所期望的接口。适配器模式会创建一个实现目标接口的新类，以便客户端可以通过该接口调用它。
适配器(Adapter)：该类实现了目标接口，并将客户端的请求转换为对适配者的调用。适配器通常会聚合一个适配者对象，以便将请求委托给它。
适配者(Adapteree)：适配器模式的实际工作内容。适配者是客户端所期望的接口之外的类，它实现了客户端需要的功能，但其接口与客户端所期望的接口不兼容。
编程样例(对象适配器)
假如有一个船长他只会划船，但不会航行。
首先我们有接口RowingBoat和FishingBoat
public interface RowingBoat { void row(); } @Slf4j public class FishingBoat { public void sail() { LOGGER.info("The fishing boat is sailing"); } } 船长希望有一个RowingBoat接口的实现，这样就可以移动
public class Captain { private final RowingBoat rowingBoat; // default constructor and setter for rowingBoat public Captain(RowingBoat rowingBoat) { this.rowingBoat = rowingBoat; } public void row() { rowingBoat.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"Java设计模式：Adapter","item":"https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java设计模式：Adapter","name":"Java设计模式：Adapter","description":"本文主要介绍 Adapter 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。\nJava Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。\nJava Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。\n对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。\n此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。\n中文网站：https://java-design-patterns.com/zh/\nGithub 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns\n目的 将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。\n适配器模式(Adapter Pattern)是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一种接口。适配器模式通常用于连接两个不兼容的接口或类，以便它们可以协同工作。\n解释 现实世界例子\n考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。\n用直白的话来说\n适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。\n维基百科中说\n在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。\n适配器模式由三个主要角色组成：\n目标接口(Target Interface)：客户端所期望的接口。适配器模式会创建一个实现目标接口的新类，以便客户端可以通过该接口调用它。\n适配器(Adapter)：该类实现了目标接口，并将客户端的请求转换为对适配者的调用。适配器通常会聚合一个适配者对象，以便将请求委托给它。\n适配者(Adapteree)：适配器模式的实际工作内容。适配者是客户端所期望的接口之外的类，它实现了客户端需要的功能，但其接口与客户端所期望的接口不兼容。\n编程样例(对象适配器)\n假如有一个船长他只会划船，但不会航行。\n首先我们有接口RowingBoat和FishingBoat\npublic interface RowingBoat { void row(); } @Slf4j public class FishingBoat { public void sail() { LOGGER.info(\u0026#34;The fishing boat is sailing\u0026#34;); } } 船长希望有一个RowingBoat接口的实现，这样就可以移动\npublic class Captain { private final RowingBoat rowingBoat; // default constructor and setter for rowingBoat public Captain(RowingBoat rowingBoat) { this.rowingBoat = rowingBoat; } public void row() { rowingBoat.","keywords":["java"],"articleBody":"本文主要介绍 Adapter 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。\nJava Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。\nJava Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。\n对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。\n此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。\n中文网站：https://java-design-patterns.com/zh/\nGithub 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns\n目的 将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。\n适配器模式(Adapter Pattern)是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一种接口。适配器模式通常用于连接两个不兼容的接口或类，以便它们可以协同工作。\n解释 现实世界例子\n考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。\n用直白的话来说\n适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。\n维基百科中说\n在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。\n适配器模式由三个主要角色组成：\n目标接口(Target Interface)：客户端所期望的接口。适配器模式会创建一个实现目标接口的新类，以便客户端可以通过该接口调用它。\n适配器(Adapter)：该类实现了目标接口，并将客户端的请求转换为对适配者的调用。适配器通常会聚合一个适配者对象，以便将请求委托给它。\n适配者(Adapteree)：适配器模式的实际工作内容。适配者是客户端所期望的接口之外的类，它实现了客户端需要的功能，但其接口与客户端所期望的接口不兼容。\n编程样例(对象适配器)\n假如有一个船长他只会划船，但不会航行。\n首先我们有接口RowingBoat和FishingBoat\npublic interface RowingBoat { void row(); } @Slf4j public class FishingBoat { public void sail() { LOGGER.info(\"The fishing boat is sailing\"); } } 船长希望有一个RowingBoat接口的实现，这样就可以移动\npublic class Captain { private final RowingBoat rowingBoat; // default constructor and setter for rowingBoat public Captain(RowingBoat rowingBoat) { this.rowingBoat = rowingBoat; } public void row() { rowingBoat.row(); } } 现在海盗来了，我们的船长需要逃跑但是只有一个渔船可用。我们需要创建一个可以让船长使用其划船技能来操作渔船的适配器。\n@Slf4j public class FishingBoatAdapter implements RowingBoat { private final FishingBoat boat; public FishingBoatAdapter() { boat = new FishingBoat(); } @Override public void row() { boat.sail(); } } 现在 船长 可以使用FishingBoat接口来逃离海盗了。\nvar captain = new Captain(new FishingBoatAdapter()); captain.row(); 类图 优缺点 适配器模式的主要优点是，它可以将不兼容的类和接口连接起来，以便它们可以协同工作。适配器模式还可以减少代码重复，因为它可以将现有的类重用在新的上下文中。此外，适配器模式可以帮助应对不稳定的接口，因为它可以将接口变化隔离到适配器中。\n适配器模式的主要缺点是，它可能会导致系统调用链的增加，因为它需要添加额外的对象来进行转换。此外，适配器模式可能会导致性能下降，因为它需要执行额外的处理来进行转换。\n应用 适配器模式通常用于以下场景：\n将现有的类或接口与新的代码集成：适配器可以将现有的类或接口与新的代码集成，以便它们可以协同工作。 与第三方库或组件集成：适配器可以将第三方库或组件的接口与应用程序的接口进行转换，以便它们可以协同工作。 应对不稳定的接口：适配器可以将不稳定的接口封装在一个适配器中，以便将来接口变化时只需要更改适配器即可。 实现多个接口：适配器可以实现多个接口，以便一个对象可以同时被多个类使用。 在测试中使用：适配器可以在测试中模拟接口的行为，以便测试程序的各种用例。 兼容不同版本：如果应用程序需要与多个版本的同一接口进行交互，可以使用适配器模式来处理不同版本之间的差异。 重用现有代码：如果需要重用现有的代码，但其接口与所需接口不兼容，则可以使用适配器模式来重用代码。 数据库驱动程序：数据库驱动程序通常使用适配器模式，以便将数据库的不同接口转换为 Java JDBC 接口。 日志记录：日志记录库通常使用适配器模式，以便将不同的日志记录接口转换为通用的接口。 扩展现有功能：如果需要扩展现有功能，但其接口与所需接口不兼容，则可以使用适配器模式来扩展现有功能。 以下是一个使用适配器模式的日志记录库的示例：\n目标接口：定义通用的日志记录器接口。 public interface Logger { void log(String message); } 适配器：定义一个适配器类，实现目标接口，并聚合不同日志框架的对象。 public class LogAdapter implements Logger { private Log4j log; public LogAdapter(Log4j log) { this.log = log; } @Override public void log(String message) { log.trace(message); } } 适配者：定义一个 Log4j 日志框架的类。 public class Log4j { public void trace(String message) { // 使用Log4j进行日志记录 } } 现在，我们可以使用适配器来将不同的日志框架转换为通用的 Logger 接口：\nLog4j log4j = new Log4j(); Logger logger = new LogAdapter(log4j); logger.log(\"This is a log message\"); 在上面的示例中，适配器模式允许我们将 Log4j 框架的接口转换为通用的 Logger 接口，以便我们可以使用 Logger 接口记录日志而不必关心具体使用的日志框架。如果我们需要切换到其他日志框架，只需要创建一个新的适配器即可。\n除了适配器模式的应用场景和常见开源框架中的使用示例外，适配器还有其他一些相关的概念和技术：\n对象适配器和类适配器：适配器模式可以分为对象适配器和类适配器两种。对象适配器使用组合的方式来实现适配器模式，而类适配器使用继承的方式来实现适配器模式。 双向适配器：在一些情况下，需要将两个不兼容的接口互相适配。这种情况下，可以使用双向适配器模式来实现双向的适配。 接口适配器：当一个接口中有太多的方法，而实现该接口的类只需要其中的一部分方法时，可以使用接口适配器模式来解决这个问题。接口适配器模式将一个接口拆分成多个接口，并提供一个默认的空实现，使得实现该接口的类可以只实现自己需要的方法。 下面是一个双向适配器的示例：\n假设有两个接口，分别是 Shape 和 IRectangle，其中 Shape 表示一个形状，IRectangle 表示一个矩形。Shape 接口有两个方法 draw() 和 resize()，而 IRectangle 接口有三个方法 setOrigin(), setWidth() 和 setHeight()。\n现在，我们需要将这两个接口互相适配。我们可以定义一个双向适配器 ShapeToRectangleAdapter，它实现了这两个接口，并且可以将一个 Shape 对象适配到一个 IRectangle 对象中，也可以将一个 IRectangle 对象适配到一个 Shape 对象中。具体实现如下：\npublic interface Shape { void draw(); void resize(int width, int height); void move(int x, int y); } public interface IRectangle { void setOrigin(int x, int y); void setWidth(int width); void setHeight(int height); void paint(); void stretch(); } public class ShapeToRectangleAdapter implements Shape, IRectangle { private Shape shape; private IRectangle rectangle; public ShapeToRectangleAdapter(Shape shape) { this.shape = shape; } public ShapeToRectangleAdapter(IRectangle rectangle) { this.rectangle = rectangle; } // 将 Shape 适配到 IRectangle 中 public void setOrigin(int x, int y) { shape.move(x, y); } public void setWidth(int width) { shape.resize(width, shape.getHeight()); } public void setHeight(int height) { shape.resize(shape.getWidth(), height); } // 将 IRectangle 适配到 Shape 中 public void draw() { rectangle.paint(); } public void resize(int width, int height) { rectangle.setWidth(width); rectangle.setHeight(height); } public void move(int x, int y) { rectangle.setOrigin(x, y); } public int getWidth() { return rectangle.getWidth(); } public int getHeight() { return rectangle.getHeight(); } public void paint() { shape.draw(); } public void stretch() { shape.resize(shape.getWidth() * 2, shape.getHeight() * 2); } } 在上面的代码中，ShapeToRectangleAdapter 适配器实现了 Shape 和 IRectangle 接口，并且在构造函数中接收一个 Shape 对象或 IRectangle 对象作为参数，以便将其适配到另一个接口中。\n当需要将一个 Shape 对象适配到一个 IRectangle 对象中时，适配器实现了 setOrigin()、setWidth() 和 setHeight() 方法，将 Shape 对象的位置和大小适配到 IRectangle 对象中。\n当需要将一个 IRectangle 对象适配到一个 Shape 对象中时，适配器实现了 draw() 和 resize() 方法，将 IRectangle 对象的绘制和大小调整适配到 Shape 对象中。\n这样，通过双向适配器，我们可以将 Shape 和 IRectangle 接口互相适配，使得它们可以在需要的时候互相调用。\n对比 适配器模式和装饰器模式都是常见的结构型设计模式，它们的作用都是为了增强类的功能。虽然这两种模式具有某些相似之处，但它们之间也存在一些重要的区别。下面是适配器模式和装饰器模式之间的区别：\n目的不同：适配器模式的目的是将一个类的接口转换为另一个类的接口，以便这两个类可以协同工作。而装饰器模式的目的是为一个对象添加新的功能，同时不改变其原有的接口和实现。 适配方式不同：适配器模式通常使用对象适配器或类适配器来实现。对象适配器使用组合关系将适配器包装在另一个对象中，而类适配器使用多重继承来实现适配器。而装饰器模式始终使用对象组合来实现。 使用场景不同：适配器模式通常用于集成第三方类或接口，或是将不兼容的接口转换为兼容的接口。而装饰器模式通常用于在运行时动态地为一个对象添加新的功能。 对象的关系不同：适配器模式中，适配器与被适配者之间是一种静态关系，它们之间的关系在编译时就已经确定。而装饰器模式中，装饰器与被装饰者之间是一种动态关系，它们之间的关系在运行时才能确定。 适配器模式的应用场景：\n在集成第三方类或接口时，可以使用适配器模式将其接口转换为应用程序所需的接口。 当需要使用某个类的方法，但该类的接口与应用程序的接口不兼容时，可以使用适配器模式将该类的接口转换为应用程序所需的接口。 当需要将一种数据格式转换为另一种数据格式时，可以使用适配器模式将数据格式转换为应用程序所需的格式。 例如，将一个电器插头插入到墙上的插座中，这两个接口是不兼容的。我们可以使用一个插头适配器，将电器插头的接口转换为墙上插座的接口，以便电器可以与墙上的插座协同工作。\n装饰器模式的应用场景：\n当需要为一个对象动态地添加新的功能时，可以使用装饰器模式。 当需要为一个对象添加的多个功能具有不同的组合方式时，可以使用装饰器模式。 例如，在一个在线商店中，用户可以购买商品并进行支付。我们可以使用装饰器模式来为订单对象添加新的功能，例如添加优惠券、添加礼品包装、添加快递保险等。这些功能可以根据用户的需求进行组合，并且可以在运行时动态地添加或删除。\n总之，适配器模式和装饰器模式都是为了增强类的功能，但它们的目的和实现方式不同。适配器模式是为了解决接口不兼容的问题，而装饰器模式是为了动态地为一个对象添加新的功能。\n举例 以下是常见开源框架中使用适配器模式的一些示例：\nSpring 框架：Spring 框架中的 HandlerAdapter 接口就是一个适配器模式的应用。不同的 HandlerAdapter 实现类可以将不同类型的控制器（如 Servlet、Struts、JSF）适配到 Spring MVC 框架中。 Hibernate 框架：Hibernate 框架中的 ConnectionProvider 接口也是一个适配器模式的应用。不同的 ConnectionProvider 实现类可以将不同类型的数据源（如 JDBC、JTA）适配到 Hibernate 框架中。 Log4j 框架：Log4j 框架中的 Appender 接口也是一个适配器模式的应用。不同的 Appender 实现类可以将不同类型的日志输出适配到 Log4j 框架中。 JUnit 框架：JUnit 框架中的 Test 接口也是一个适配器模式的应用。不同的 Test 实现类可以将不同类型的测试用例适配到 JUnit 框架中。 Java Swing 框架：Java Swing 框架中的 JList 组件也是一个适配器模式的应用。JList 组件可以使用适配器将不同类型的数据源（如数组、集合）适配到 JList 组件中。 Apache Commons 框架：Apache Commons 框架中的 FileFilter 接口也是一个适配器模式的应用。不同的 FileFilter 实现类可以将不同类型的文件过滤器适配到 Apache Commons 框架中。 Apache Shiro 框架：Apache Shiro 框架中的 Realm 接口也是一个适配器模式的应用。不同的 Realm 实现类可以将不同类型的身份验证和授权机制适配到 Apache Shiro 框架中。 Apache Struts 框架：Apache Struts 框架中的 Action 接口也是一个适配器模式的应用。不同的 Action 实现类可以将不同类型的请求处理适配到 Apache Struts 框架中。 Android 框架：Android 框架中的 ArrayAdapter 类也是一个适配器模式的应用。ArrayAdapter 类可以使用适配器将不同类型的数据源（如数组、集合）适配到 Android UI 组件中。 Spring Boot 框架：Spring Boot 框架中的 CommandLineRunner 接口也是一个适配器模式的应用。不同的 CommandLineRunner 实现类可以将不同类型的命令行参数适配到 Spring Boot 框架中。 Apache Camel 框架：Apache Camel 框架中的 Component 接口也是一个适配器模式的应用。不同的 Component 实现类可以将不同类型的消息传输协议（如 HTTP、FTP 等）适配到 Apache Camel 框架中。 Jersey 框架：Jersey 框架中的 MessageBodyReader 和 MessageBodyWriter 接口也是适配器模式的应用。这两个接口可以将不同类型的请求或响应消息适配到 Jersey 框架中。 Retrofit 框架：Retrofit 框架中的 Converter 接口也是一个适配器模式的应用。不同的 Converter 实现类可以将不同类型的响应消息转换为 Java 对象，并适配到 Retrofit 框架中。 Logback 框架：Logback 框架中的 Appender 接口也是适配器模式的应用。不同的 Appender 实现类可以将不同类型的日志输出适配到 Logback 框架中。 Apache Kafka 框架：Apache Kafka 框架中的 Consumer 和 Producer 接口也是适配器模式的应用。不同的 Consumer 和 Producer 实现类可以将不同类型的消息传输协议适配到 Apache Kafka 框架中。 以下是 jdk 中使用适配器模式的例子：\njava.util.Arrays#asList() 该方法将数组转换为 List 集合。由于数组和 List 集合的接口不兼容，所以该方法使用了适配器模式将数组转换为 List 集合。 java.util.Collections#list() 该方法接受一个 Enumeration 对象作为参数，并将该 Enumeration 对象转换为一个 List。 java.util.Collections#enumeration() 该方法接受一个 Collection 对象作为参数，并将该 Collection 对象转换为一个 Enumeration 对象。 javax.xml.bind.annotation.adapters.XMLAdapter 该类是用于 XML 序列化和反序列化的适配器。它可以将 Java 对象转换为 XML 元素，并在反序列化时将 XML 元素转换回 Java 对象。 java.io.InputStreamReader 和 java.io.OutputStreamWriter 类：这两个类是用于读写字符流的包装器类。它们使用适配器模式将字节流转换为字符流，以便读写字符数据。 javax.servlet.ServletRequestWrapper 和 javax.servlet.ServletResponseWrapper 类：这两个类是用于 HTTP 请求和响应的包装器类。它们使用适配器模式将 HTTP 请求和响应转换为 Servlet API 中定义的接口，以便在 Servlet 中使用。 ","wordCount":"715","inLanguage":"en","datePublished":"2023-06-10T09:00:00+08:00","dateModified":"2023-06-10T09:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Java设计模式：Adapter</h1><div class=post-meta><span title='2023-06-10 09:00:00 +0800 +0800'>2023-06-10</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;715 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%9b%ae%e7%9a%84 aria-label=目的>目的</a></li><li><a href=#%e8%a7%a3%e9%87%8a aria-label=解释>解释</a></li><li><a href=#%e7%b1%bb%e5%9b%be aria-label=类图>类图</a></li><li><a href=#%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=优缺点>优缺点</a></li><li><a href=#%e5%ba%94%e7%94%a8 aria-label=应用>应用</a></li><li><a href=#%e5%af%b9%e6%af%94 aria-label=对比>对比</a></li><li><a href=#%e4%b8%be%e4%be%8b aria-label=举例>举例</a></li></ul></div></details></div><div class=post-content><p>本文主要介绍 Adapter 模式，在 <a href=https://java-design-patterns.com/>Java Design Patterns</a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。</p><blockquote><p><a href=https://java-design-patterns.com/>Java Design Patterns</a> 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。</p><p>Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。</p><p>对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。</p><p>此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。</p><p>中文网站：<a href=https://java-design-patterns.com/zh/>https://java-design-patterns.com/zh/</a></p><p>Github 上源码仓库（非官方）：<a href=https://github.com/iluwatar/java-design-patterns>https://github.com/iluwatar/java-design-patterns</a></p></blockquote><h2 id=目的>目的<a hidden class=anchor aria-hidden=true href=#目的>#</a></h2><p>将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。</p><blockquote><p>适配器模式(Adapter Pattern)是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一种接口。适配器模式通常用于连接两个不兼容的接口或类，以便它们可以协同工作。</p></blockquote><h2 id=解释>解释<a hidden class=anchor aria-hidden=true href=#解释>#</a></h2><p>现实世界例子</p><blockquote><p>考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。</p></blockquote><p>用直白的话来说</p><blockquote><p>适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。</p></blockquote><p>维基百科中说</p><blockquote><p>在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。</p></blockquote><p>适配器模式由三个主要角色组成：</p><ol><li><p>目标接口(Target Interface)：客户端所期望的接口。适配器模式会创建一个实现目标接口的新类，以便客户端可以通过该接口调用它。</p></li><li><p>适配器(Adapter)：该类实现了目标接口，并将客户端的请求转换为对适配者的调用。适配器通常会聚合一个适配者对象，以便将请求委托给它。</p></li><li><p>适配者(Adapteree)：适配器模式的实际工作内容。适配者是客户端所期望的接口之外的类，它实现了客户端需要的功能，但其接口与客户端所期望的接口不兼容。</p></li></ol><p><strong>编程样例(对象适配器)</strong></p><p>假如有一个船长他只会划船，但不会航行。</p><p>首先我们有接口<code>RowingBoat</code>和<code>FishingBoat</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>RowingBoat</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>row</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Slf4j</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>FishingBoat</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sail</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;The fishing boat is sailing&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>船长希望有一个<code>RowingBoat</code>接口的实现，这样就可以移动</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Captain</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>RowingBoat</span><span class=w> </span><span class=n>rowingBoat</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// default constructor and setter for rowingBoat</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=nf>Captain</span><span class=p>(</span><span class=n>RowingBoat</span><span class=w> </span><span class=n>rowingBoat</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>rowingBoat</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rowingBoat</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>row</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>rowingBoat</span><span class=p>.</span><span class=na>row</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>现在海盗来了，我们的船长需要逃跑但是只有一个渔船可用。我们需要创建一个可以让船长使用其划船技能来操作渔船的适配器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>FishingBoatAdapter</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>RowingBoat</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>FishingBoat</span><span class=w> </span><span class=n>boat</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=nf>FishingBoatAdapter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>boat</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>FishingBoat</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>row</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>boat</span><span class=p>.</span><span class=na>sail</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>现在 <code>船长</code> 可以使用<code>FishingBoat</code>接口来逃离海盗了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=n>captain</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Captain</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>FishingBoatAdapter</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>captain</span><span class=p>.</span><span class=na>row</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><h2 id=类图>类图<a hidden class=anchor aria-hidden=true href=#类图>#</a></h2><p><img loading=lazy src=https://java-design-patterns.com/assets/adapter.urm-beb4eb0d.png alt="alt text"></p><h2 id=优缺点>优缺点<a hidden class=anchor aria-hidden=true href=#优缺点>#</a></h2><p>适配器模式的主要优点是，它可以将不兼容的类和接口连接起来，以便它们可以协同工作。适配器模式还可以减少代码重复，因为它可以将现有的类重用在新的上下文中。此外，适配器模式可以帮助应对不稳定的接口，因为它可以将接口变化隔离到适配器中。</p><p>适配器模式的主要缺点是，它可能会导致系统调用链的增加，因为它需要添加额外的对象来进行转换。此外，适配器模式可能会导致性能下降，因为它需要执行额外的处理来进行转换。</p><h2 id=应用>应用<a hidden class=anchor aria-hidden=true href=#应用>#</a></h2><p>适配器模式通常用于以下场景：</p><ol><li>将现有的类或接口与新的代码集成：适配器可以将现有的类或接口与新的代码集成，以便它们可以协同工作。</li><li>与第三方库或组件集成：适配器可以将第三方库或组件的接口与应用程序的接口进行转换，以便它们可以协同工作。</li><li>应对不稳定的接口：适配器可以将不稳定的接口封装在一个适配器中，以便将来接口变化时只需要更改适配器即可。</li><li>实现多个接口：适配器可以实现多个接口，以便一个对象可以同时被多个类使用。</li><li>在测试中使用：适配器可以在测试中模拟接口的行为，以便测试程序的各种用例。</li><li>兼容不同版本：如果应用程序需要与多个版本的同一接口进行交互，可以使用适配器模式来处理不同版本之间的差异。</li><li>重用现有代码：如果需要重用现有的代码，但其接口与所需接口不兼容，则可以使用适配器模式来重用代码。</li><li>数据库驱动程序：数据库驱动程序通常使用适配器模式，以便将数据库的不同接口转换为 Java JDBC 接口。</li><li>日志记录：日志记录库通常使用适配器模式，以便将不同的日志记录接口转换为通用的接口。</li><li>扩展现有功能：如果需要扩展现有功能，但其接口与所需接口不兼容，则可以使用适配器模式来扩展现有功能。</li></ol><p>以下是一个使用适配器模式的日志记录库的示例：</p><ol><li>目标接口：定义通用的日志记录器接口。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>Logger</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>log</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li>适配器：定义一个适配器类，实现目标接口，并聚合不同日志框架的对象。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>LogAdapter</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Log4j</span><span class=w> </span><span class=n>log</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>LogAdapter</span><span class=p>(</span><span class=n>Log4j</span><span class=w> </span><span class=n>log</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>log</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>log</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>log</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>trace</span><span class=p>(</span><span class=n>message</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol start=3><li>适配者：定义一个 Log4j 日志框架的类。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Log4j</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>trace</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 使用Log4j进行日志记录</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>现在，我们可以使用适配器来将不同的日志框架转换为通用的 Logger 接口：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Log4j</span><span class=w> </span><span class=n>log4j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Log4j</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Logger</span><span class=w> </span><span class=n>logger</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LogAdapter</span><span class=p>(</span><span class=n>log4j</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>logger</span><span class=p>.</span><span class=na>log</span><span class=p>(</span><span class=s>&#34;This is a log message&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>在上面的示例中，适配器模式允许我们将 Log4j 框架的接口转换为通用的 Logger 接口，以便我们可以使用 Logger 接口记录日志而不必关心具体使用的日志框架。如果我们需要切换到其他日志框架，只需要创建一个新的适配器即可。</p><p>除了适配器模式的应用场景和常见开源框架中的使用示例外，适配器还有其他一些相关的概念和技术：</p><ol><li>对象适配器和类适配器：适配器模式可以分为对象适配器和类适配器两种。对象适配器使用组合的方式来实现适配器模式，而类适配器使用继承的方式来实现适配器模式。</li><li>双向适配器：在一些情况下，需要将两个不兼容的接口互相适配。这种情况下，可以使用双向适配器模式来实现双向的适配。</li><li>接口适配器：当一个接口中有太多的方法，而实现该接口的类只需要其中的一部分方法时，可以使用接口适配器模式来解决这个问题。接口适配器模式将一个接口拆分成多个接口，并提供一个默认的空实现，使得实现该接口的类可以只实现自己需要的方法。</li></ol><p>下面是一个双向适配器的示例：</p><p>假设有两个接口，分别是 <code>Shape</code> 和 <code>IRectangle</code>，其中 <code>Shape</code> 表示一个形状，<code>IRectangle</code> 表示一个矩形。<code>Shape</code> 接口有两个方法 <code>draw()</code> 和 <code>resize()</code>，而 <code>IRectangle</code> 接口有三个方法 <code>setOrigin()</code>, <code>setWidth()</code> 和 <code>setHeight()</code>。</p><p>现在，我们需要将这两个接口互相适配。我们可以定义一个双向适配器 <code>ShapeToRectangleAdapter</code>，它实现了这两个接口，并且可以将一个 <code>Shape</code> 对象适配到一个 <code>IRectangle</code> 对象中，也可以将一个 <code>IRectangle</code> 对象适配到一个 <code>Shape</code> 对象中。具体实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>Shape</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>draw</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>resize</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>width</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>height</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=kt>void</span><span class=w> </span><span class=nf>move</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>IRectangle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>setOrigin</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>setWidth</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>width</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>setHeight</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>height</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>paint</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>stretch</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ShapeToRectangleAdapter</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Shape</span><span class=p>,</span><span class=w> </span><span class=n>IRectangle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Shape</span><span class=w> </span><span class=n>shape</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>IRectangle</span><span class=w> </span><span class=n>rectangle</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>ShapeToRectangleAdapter</span><span class=p>(</span><span class=n>Shape</span><span class=w> </span><span class=n>shape</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>shape</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>shape</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>ShapeToRectangleAdapter</span><span class=p>(</span><span class=n>IRectangle</span><span class=w> </span><span class=n>rectangle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>rectangle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rectangle</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将 Shape 适配到 IRectangle 中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setOrigin</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>shape</span><span class=p>.</span><span class=na>move</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setWidth</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>width</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>shape</span><span class=p>.</span><span class=na>resize</span><span class=p>(</span><span class=n>width</span><span class=p>,</span><span class=w> </span><span class=n>shape</span><span class=p>.</span><span class=na>getHeight</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setHeight</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>height</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>shape</span><span class=p>.</span><span class=na>resize</span><span class=p>(</span><span class=n>shape</span><span class=p>.</span><span class=na>getWidth</span><span class=p>(),</span><span class=w> </span><span class=n>height</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将 IRectangle 适配到 Shape 中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>draw</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rectangle</span><span class=p>.</span><span class=na>paint</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>resize</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>width</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>height</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rectangle</span><span class=p>.</span><span class=na>setWidth</span><span class=p>(</span><span class=n>width</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rectangle</span><span class=p>.</span><span class=na>setHeight</span><span class=p>(</span><span class=n>height</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>move</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rectangle</span><span class=p>.</span><span class=na>setOrigin</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>getWidth</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>rectangle</span><span class=p>.</span><span class=na>getWidth</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>getHeight</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>rectangle</span><span class=p>.</span><span class=na>getHeight</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>paint</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>shape</span><span class=p>.</span><span class=na>draw</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>stretch</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>shape</span><span class=p>.</span><span class=na>resize</span><span class=p>(</span><span class=n>shape</span><span class=p>.</span><span class=na>getWidth</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>2</span><span class=p>,</span><span class=w> </span><span class=n>shape</span><span class=p>.</span><span class=na>getHeight</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上面的代码中，<code>ShapeToRectangleAdapter</code> 适配器实现了 <code>Shape</code> 和 <code>IRectangle</code> 接口，并且在构造函数中接收一个 <code>Shape</code> 对象或 <code>IRectangle</code> 对象作为参数，以便将其适配到另一个接口中。</p><p>当需要将一个 <code>Shape</code> 对象适配到一个 <code>IRectangle</code> 对象中时，适配器实现了 <code>setOrigin()</code>、<code>setWidth()</code> 和 <code>setHeight()</code> 方法，将 <code>Shape</code> 对象的位置和大小适配到 <code>IRectangle</code> 对象中。</p><p>当需要将一个 <code>IRectangle</code> 对象适配到一个 <code>Shape</code> 对象中时，适配器实现了 <code>draw()</code> 和 <code>resize()</code> 方法，将 <code>IRectangle</code> 对象的绘制和大小调整适配到 <code>Shape</code> 对象中。</p><p>这样，通过双向适配器，我们可以将 <code>Shape</code> 和 <code>IRectangle</code> 接口互相适配，使得它们可以在需要的时候互相调用。</p><h2 id=对比>对比<a hidden class=anchor aria-hidden=true href=#对比>#</a></h2><p>适配器模式和装饰器模式都是常见的结构型设计模式，它们的作用都是为了增强类的功能。虽然这两种模式具有某些相似之处，但它们之间也存在一些重要的区别。下面是适配器模式和装饰器模式之间的区别：</p><ol><li>目的不同：适配器模式的目的是将一个类的接口转换为另一个类的接口，以便这两个类可以协同工作。而装饰器模式的目的是为一个对象添加新的功能，同时不改变其原有的接口和实现。</li><li>适配方式不同：适配器模式通常使用对象适配器或类适配器来实现。对象适配器使用组合关系将适配器包装在另一个对象中，而类适配器使用多重继承来实现适配器。而装饰器模式始终使用对象组合来实现。</li><li>使用场景不同：适配器模式通常用于集成第三方类或接口，或是将不兼容的接口转换为兼容的接口。而装饰器模式通常用于在运行时动态地为一个对象添加新的功能。</li><li>对象的关系不同：适配器模式中，适配器与被适配者之间是一种静态关系，它们之间的关系在编译时就已经确定。而装饰器模式中，装饰器与被装饰者之间是一种动态关系，它们之间的关系在运行时才能确定。</li></ol><p>适配器模式的应用场景：</p><ol><li>在集成第三方类或接口时，可以使用适配器模式将其接口转换为应用程序所需的接口。</li><li>当需要使用某个类的方法，但该类的接口与应用程序的接口不兼容时，可以使用适配器模式将该类的接口转换为应用程序所需的接口。</li><li>当需要将一种数据格式转换为另一种数据格式时，可以使用适配器模式将数据格式转换为应用程序所需的格式。</li></ol><p>例如，将一个电器插头插入到墙上的插座中，这两个接口是不兼容的。我们可以使用一个插头适配器，将电器插头的接口转换为墙上插座的接口，以便电器可以与墙上的插座协同工作。</p><p>装饰器模式的应用场景：</p><ol><li>当需要为一个对象动态地添加新的功能时，可以使用装饰器模式。</li><li>当需要为一个对象添加的多个功能具有不同的组合方式时，可以使用装饰器模式。</li></ol><p>例如，在一个在线商店中，用户可以购买商品并进行支付。我们可以使用装饰器模式来为订单对象添加新的功能，例如添加优惠券、添加礼品包装、添加快递保险等。这些功能可以根据用户的需求进行组合，并且可以在运行时动态地添加或删除。</p><p>总之，适配器模式和装饰器模式都是为了增强类的功能，但它们的目的和实现方式不同。适配器模式是为了解决接口不兼容的问题，而装饰器模式是为了动态地为一个对象添加新的功能。</p><h2 id=举例>举例<a hidden class=anchor aria-hidden=true href=#举例>#</a></h2><p>以下是常见开源框架中使用适配器模式的一些示例：</p><ol><li>Spring 框架：Spring 框架中的 <code>HandlerAdapter</code> 接口就是一个适配器模式的应用。不同的 <code>HandlerAdapter</code> 实现类可以将不同类型的控制器（如 Servlet、Struts、JSF）适配到 Spring MVC 框架中。</li><li>Hibernate 框架：Hibernate 框架中的 <code>ConnectionProvider</code> 接口也是一个适配器模式的应用。不同的 <code>ConnectionProvider</code> 实现类可以将不同类型的数据源（如 JDBC、JTA）适配到 Hibernate 框架中。</li><li>Log4j 框架：Log4j 框架中的 <code>Appender</code> 接口也是一个适配器模式的应用。不同的 <code>Appender</code> 实现类可以将不同类型的日志输出适配到 Log4j 框架中。</li><li>JUnit 框架：JUnit 框架中的 <code>Test</code> 接口也是一个适配器模式的应用。不同的 <code>Test</code> 实现类可以将不同类型的测试用例适配到 JUnit 框架中。</li><li>Java Swing 框架：Java Swing 框架中的 <code>JList</code> 组件也是一个适配器模式的应用。<code>JList</code> 组件可以使用适配器将不同类型的数据源（如数组、集合）适配到 <code>JList</code> 组件中。</li><li>Apache Commons 框架：Apache Commons 框架中的 <code>FileFilter</code> 接口也是一个适配器模式的应用。不同的 <code>FileFilter</code> 实现类可以将不同类型的文件过滤器适配到 Apache Commons 框架中。</li><li>Apache Shiro 框架：Apache Shiro 框架中的 <code>Realm</code> 接口也是一个适配器模式的应用。不同的 <code>Realm</code> 实现类可以将不同类型的身份验证和授权机制适配到 Apache Shiro 框架中。</li><li>Apache Struts 框架：Apache Struts 框架中的 <code>Action</code> 接口也是一个适配器模式的应用。不同的 <code>Action</code> 实现类可以将不同类型的请求处理适配到 Apache Struts 框架中。</li><li>Android 框架：Android 框架中的 <code>ArrayAdapter</code> 类也是一个适配器模式的应用。<code>ArrayAdapter</code> 类可以使用适配器将不同类型的数据源（如数组、集合）适配到 Android UI 组件中。</li><li>Spring Boot 框架：Spring Boot 框架中的 <code>CommandLineRunner</code> 接口也是一个适配器模式的应用。不同的 <code>CommandLineRunner</code> 实现类可以将不同类型的命令行参数适配到 Spring Boot 框架中。</li><li>Apache Camel 框架：Apache Camel 框架中的 <code>Component</code> 接口也是一个适配器模式的应用。不同的 <code>Component</code> 实现类可以将不同类型的消息传输协议（如 HTTP、FTP 等）适配到 Apache Camel 框架中。</li><li>Jersey 框架：Jersey 框架中的 <code>MessageBodyReader</code> 和 <code>MessageBodyWriter</code> 接口也是适配器模式的应用。这两个接口可以将不同类型的请求或响应消息适配到 Jersey 框架中。</li><li>Retrofit 框架：Retrofit 框架中的 <code>Converter</code> 接口也是一个适配器模式的应用。不同的 <code>Converter</code> 实现类可以将不同类型的响应消息转换为 Java 对象，并适配到 Retrofit 框架中。</li><li>Logback 框架：Logback 框架中的 <code>Appender</code> 接口也是适配器模式的应用。不同的 <code>Appender</code> 实现类可以将不同类型的日志输出适配到 Logback 框架中。</li><li>Apache Kafka 框架：Apache Kafka 框架中的 <code>Consumer</code> 和 <code>Producer</code> 接口也是适配器模式的应用。不同的 <code>Consumer</code> 和 <code>Producer</code> 实现类可以将不同类型的消息传输协议适配到 Apache Kafka 框架中。</li></ol><p>以下是 jdk 中使用适配器模式的例子：</p><ul><li><a href=http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList(T...)>java.util.Arrays#asList()</a> 该方法将数组转换为 List 集合。由于数组和 List 集合的接口不兼容，所以该方法使用了适配器模式将数组转换为 List 集合。</li><li><a href=https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration->java.util.Collections#list()</a> 该方法接受一个 <code>Enumeration</code> 对象作为参数，并将该 <code>Enumeration</code> 对象转换为一个 <code>List</code>。</li><li><a href=https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection->java.util.Collections#enumeration()</a> 该方法接受一个 <code>Collection</code> 对象作为参数，并将该 <code>Collection</code> 对象转换为一个 <code>Enumeration</code> 对象。</li><li><a href=http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType->javax.xml.bind.annotation.adapters.XMLAdapter</a> 该类是用于 XML 序列化和反序列化的适配器。它可以将 Java 对象转换为 XML 元素，并在反序列化时将 XML 元素转换回 Java 对象。</li><li>java.io.InputStreamReader 和 java.io.OutputStreamWriter 类：这两个类是用于读写字符流的包装器类。它们使用适配器模式将字节流转换为字符流，以便读写字符数据。</li><li>javax.servlet.ServletRequestWrapper 和 javax.servlet.ServletResponseWrapper 类：这两个类是用于 HTTP 请求和响应的包装器类。它们使用适配器模式将 HTTP 请求和响应转换为 Servlet API 中定义的接口，以便在 Servlet 中使用。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/06/10/python-data-type/><span class=title>« Prev</span><br><span>Python学习2：数据类型</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/06/09/weekly_review_22/><span class=title>Next »</span><br><span>周报-22｜微信读书笔记助手</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Adapter on x" href="https://x.com/intent/tweet/?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aAdapter&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f10%2fjava-design-patterns-adapter%2f&amp;hashtags=java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Adapter on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f10%2fjava-design-patterns-adapter%2f&amp;title=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aAdapter&amp;summary=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aAdapter&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f10%2fjava-design-patterns-adapter%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Adapter on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f10%2fjava-design-patterns-adapter%2f&title=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aAdapter"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Adapter on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f10%2fjava-design-patterns-adapter%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Adapter on whatsapp" href="https://api.whatsapp.com/send?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aAdapter%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f10%2fjava-design-patterns-adapter%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Adapter on telegram" href="https://telegram.me/share/url?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aAdapter&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f10%2fjava-design-patterns-adapter%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Adapter on ycombinator" href="https://news.ycombinator.com/submitlink?t=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aAdapter&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f06%2f10%2fjava-design-patterns-adapter%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>