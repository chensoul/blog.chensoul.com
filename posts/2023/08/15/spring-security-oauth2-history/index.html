<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring Security和OAuth2发展过程 | ChenSoul</title><meta name=keywords content="java,spring,oauth2"><meta name=description content="Spring Security的发展过程 Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.com/posts/2023/08/15/spring-security-oauth2-history/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="8E787EFCDB0CE747FE1A4DA0ABEC66E4"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.chensoul.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Spring Security和OAuth2发展过程"><meta property="og:description" content="Spring Security的发展过程 Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.com/posts/2023/08/15/spring-security-oauth2-history/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-15T08:00:00+08:00"><meta property="article:modified_time" content="2023-08-15T08:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spring Security和OAuth2发展过程"><meta name=twitter:description content="Spring Security的发展过程 Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.com/posts/"},{"@type":"ListItem","position":2,"name":"Spring Security和OAuth2发展过程","item":"https://blog.chensoul.com/posts/2023/08/15/spring-security-oauth2-history/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring Security和OAuth2发展过程","name":"Spring Security和OAuth2发展过程","description":"Spring Security的发展过程 Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分","keywords":["java","spring","oauth2"],"articleBody":"Spring Security的发展过程 Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分，于2004年发布，现在已经成为 Spring 生态系统的核心组件。 Spring Security 的发展过程可以分为三个阶段：\n第一阶段：Spring Security起源于一个名为Acegi Security的开源项目，初期重点实现了Spring应用的身份认证和授权服务功能。2003年，Acegi Security作为一个孵化项目被捐献给Spring社区。2004年，正式作为Spring框架的核心组件之一Absorbed进Spring。并更名为Spring Security。Spring Security 1.0 版本 Spring Security 1.0 版本发布于 2004 年。它提供了最基本的安全功能，包括身份验证和授权。身份验证是验证用户是否是他们所声称的人的过程。授权是确定用户是否有权访问特定资源的过程。 Spring Security 1.0 版本使用了以下技术来实现身份验证和授权：\n表单身份验证：表单身份验证是通过用户提交表单来验证用户身份的过程。 基于角色的访问控制 (RBAC)：RBAC 是一种授权模型，它将用户分配到角色，然后这些角色被授予对特定资源的访问权限。 第二阶段：Spring Security 2.0 版本 Spring Security 2.0 版本发布于 2006 年。它提供了更多的安全功能，包括加密和会话管理。加密是将数据转换成无法被他人理解的形式的过程。会话管理是跟踪用户会话的状态的过程。 Spring Security 2.0 版本使用了以下技术来实现加密和会话管理：\n安全套接字层 (SSL)：SSL 是一种加密协议，它可以保护数据在传输过程中不被窃听。 会话管理：Spring Security 提供了自己的会话管理实现，它可以跟踪用户会话的状态。 第三阶段：Spring Security 3.0 版本 Spring Security 3.0 版本发布于 2008 年。它是一个重大的版本更新，它提供了许多新的安全功能，包括 OAuth、SAML 和 OpenID。 OAuth 是一种授权框架，它允许第三方应用程序访问用户的资源。SAML 是一种单点登录 (SSO) 协议，它允许用户在一个地方登录，然后访问多个网站。OpenID 是一种开放的身份验证协议，它允许用户使用他们选择的身份提供商来验证他们的身份。 Spring Security 3.0 版本使用了以下技术来实现 OAuth、SAML 和 OpenID：\nOAuth：Spring Security 提供了自己的 OAuth 实现，它可以让你轻松地在你的应用程序中使用 OAuth。\nSAML：Spring Security 提供了自己的 SAML 实现，它可以让你轻松地在你的应用程序中使用 SAML。\nOpenID：Spring Security 提供了自己的 OpenID 实现，它可以让你轻松地在你的应用程序中使用 OpenID。\n以下是 Spring Security 的详细的发展过程和版本变化：\nAcegi Security：Acegi Security 是 Spring Security 的前身，最初由 Ben Alex 创建并于2004年发布。Acegi Security 提供了一组基于 Spring 的安全性功能，用于保护 Web 应用程序、Web 服务和基于 Spring 的应用程序。\nSpring Security 2：Spring Security 2 是 Acegi Security 的继任者，于2006年发布。Spring Security 2 提供了一些新的功能和改进，例如对 OpenID、LDAP 和 CAS 的支持，以及更好的集成和配置选项。\nSpring Security 3：Spring Security 3 于2009年发布，是 Spring Security 的一个重大更新。Spring Security 3 提供了更多的安全功能和改进，例如对 RESTful Web 服务的支持、基于注解的安全性、更好的 CSRF 防护、更好的密码存储和认证管理等。\nSpring Security 4：Spring Security 4 于2015年发布，带来了一些新的功能和改进，例如对 OAuth2、JWT 和 Spring Boot 的支持、更好的 SSO 和多因素认证等。\nSpring Security 5：Spring Security 5 于2017年发布，是一个重大的更新，带来了一些新的功能和改进，例如对 WebFlux 和 Reactive Spring 的支持、更好的 OAuth2 和 OpenID Connect 的支持、更好的密码编码和认证管理等。\nSpring Security 5.1：Spring Security 5.1 发布于 2018 年，主要提供了对 Spring Boot 2.1 的支持和一些新的功能，如 Kotlin DSL、OAuth2 支持的私有证书、JWT 生成器等。\nSpring Security 5.2：Spring Security 5.2 发布于 2019 年，带来了许多改进和新特性，包括对 Spring Cloud Gateway 和 Spring MVC 的 WebFlux 支持、OAuth2 和 OpenID Connect 的改进、更好的密码管理和认证、更好的跨域资源共享（CORS）支持等。\nSpring Security 5.3：Spring Security 5.3 发布于 2020 年，主要提供了更好的 WebFlux 和 RSocket 支持、更好的 OAuth2 支持、更好的测试和性能、更好的 Kotlin 支持、更好的 JUnit 5 支持等。\nSpring Security 5.4：Spring Security 5.4 发布于 2021 年，带来了一些新的功能和改进，例如对 Spring Boot 2.4 的支持、更好的 JWT 和 OAuth2 支持、更好的密码编码、更好的 WebFlux 和 RSocket 支持、更好的测试和性能等。\nSpring Security 5.5：是当前最新的版本，于2022年发布。Spring Security 5.5 带来了一些新的功能和改进，包括对 Spring Framework 6 和 Java 17 的支持、更好的密码编码和认证管理、更好的 OAuth2 和 OpenID Connect 支持、更好的 WebFlux 和 RSocket 支持、更好的测试和性能等。\n除了不断改进和增强现有功能之外，Spring Security 还增加了对新的安全威胁的防御和支持，例如 CSRF、XSS、CSP 等。此外，Spring Security 还提供了许多有用的扩展和插件，例如 Spring Security OAuth、Spring Security SAML、Spring Security Kerberos 等，以满足不同的安全需求。\nSpring Security OAuth2 发展 Spring Security OAuth2 是一个用于构建安全的 OAuth2-based 网络应用的框架，它是 Spring Security 的一部分。下面是 Spring Security OAuth2 的发展过程：\n1. Spring Security OAuth2 V1.x – V2.0 最初的几个版本是为了构建一个安全的 OAuth2-based 网络应用。核心的功能包括：\n支持 OAuth2 协议的四种授权方式：授权码（authorization code）、隐式授权（implicit）、密码授权（resource owner password credentials）和客户端凭据（client credentials） 提供了一个简单易用的 API 用于构建 OAuth2 服务器和客户端 支持 JWT（JSON Web Tokens） 提供了详细的文档和示例代码 2. Spring Security OAuth2 V2.1 在 2.1 版本中，Spring Security OAuth2 进行了一系列的改进和扩展，包括：\n支持 OpenID Connect 1.0 支持 Token Introspection Endpoint 更好的支持 JWT，包括 JWS（JSON Web Signatures）和 JWE（JSON Web Encryption） 3. Spring Security 5.0 OAuth2 Login and OAuth2 Client 在 Spring Security 5.0 中，Spring Security OAuth2 的部分功能被合并到了 Spring Security 5.0 中，提供了 OAuth2 登录和客户端支持。\n4. Spring Security 5.1 OAuth2 Resource Server 在 Spring Security 5.1 中，Spring Security OAuth2 的资源服务器功能被合并到了 Spring Security 中。\n5. Spring Security 5.2 OAuth2 Authorization Server 在 Spring Security 5.2 中，Spring Security OAuth2 的授权服务器功能被合并到了 Spring Security 中。这是 Spring Security OAuth2 的最后一个独立版本。\n6. Spring Authorization Server 在 2020 年 4 月，Spring 宣布了一个新的项目——Spring Authorization Server，该项目旨在提供一个用于实现 OAuth 2.1 授权服务器的基础。\n7. Spring Security 5.3 and beyond 在 Spring Security 5.3 和之后的版本中，Spring Security OAuth2 的所有功能都被合并到了 Spring Security 中，而 Spring Security OAuth2 作为一个独立的项目已经停止开发。与之相对应的 Spring Security OAuth Boot 2 Autoconfig 也停止了开发。\n总结一下，目前，Spring Security OAuth2 的最新版本为 2.5.2.RELEASE，并且所有类都标注为 @Deprecated，官方也提供了一个迁移文档 OAuth 2.0 Migration Guide。\nSpring Boot和Spring OAuth2版本关系 Spring Boot和Spring OAuth2是可以配合使用的，主要注意版本匹配即可。\nSpring Boot使用了特定版本的Spring OAuth2作为依赖。所以使用对应的Spring Boot版本，就会自动获取匹配的Spring OAuth2版本。\n举几个版本的例子：\nSpring Boot 1.5.x 使用 Spring OAuth2 2.0.x Spring Boot 2.0.x 使用 Spring OAuth2 2.0.x Spring Boot 2.1.x 使用 Spring OAuth2 2.1.x Spring Boot 2.2.x 使用 Spring OAuth2 2.2.x Spring Boot 2.3.x 使用 Spring OAuth2 2.3.x 所以使用Spring Boot时，不需要额外指定Spring OAuth2的版本，只需要选择匹配的Spring Boot版本即可。\n在配置和使用Spring OAuth2时，只需要参考Spring OAuth2的文档即可，不需要特别关注其版本。Spring Boot会负责管理版本匹配。\n此外，从Spring Boot 1.5开始，Spring Security已经集成了OAuth2的实现，可以直接使用Spring Security来实现OAuth2，无需引入Spring OAuth项目。\n总之，Spring Boot大大简化了Spring OAuth2的使用，只需要关注Spring Boot版本即可自动获取正确的Spring OAuth2版本。\nSpring Cloud和Spring OAuth2版本关系 Spring Cloud和Spring OAuth2版本之间没有固定的对应关系，但通常来说建议符合以下情况：\nSpring Cloud版本越新，内置的Spring OAuth支持也会更稳定和完善。 Spring Cloud Hoxton/Greenwich等主流版本，内置的Spring OAuth支持正常使用Spring Security OAuth2版本2.x。 Spring Cloud Edgware及更早版本，内置的Spring OAuth支持建议使用Spring Security OAuth2版本1.x。 即使Spring Cloud版本和Spring Security OAuth版本不完全匹配，也无大碍，但功能和兼容性会受一定影响。 所以一般来说：\nSpring Cloud Finch/ Greenwich等最新版本，建议使用Spring Security OAuth2版本2.3.x及以上。 Spring Cloud Edgware到Hoxton，建议使用Spring Security OAuth2版本1.5.x到2.3.x都可以。 Spring Cloud版本比较早，如Dalston以下，建议使用Spring Security OAuth2版本1.0.x到1.5.x。 但不是说版本一定要完全匹配，主要看自己需要用到的Spring OAuth功能是否得到支持。选择版本时优先考虑Spring Cloud版本的内置支持程度。此外，也可以根据项目其他依赖选择一个相对稳定的Spring Security OAuth版本。\nSpring Cloud Security Spring Cloud Security提供了一种集成化的方式来实现微服务应用的安全功能。主要有以下几点：\n身份认证(Authentication) Spring Cloud Security支持常见的认证方式，比如基于OAuth2.0的认证协议。可以实现集中式的认证管理，登入后获取访问令牌并在各个微服务之间传递。\n授权(Authorization) 支持基于RBAC和ABAC等授权模型。可以实现集中式的授权管理，给不同用户或组分配不同的访问权限。\n安全终端(Security Endpoints) 提供了安全终端的实现，比如/oauth/token令牌访问端点、/userinfo用户信息端点等。\n加密通信(Encryption) 支持在微服务之间进行安全的HTTP通信，通过TLS/SSL加密数据传输和服务间调用。\n日志审计(Logging \u0026 Auditing) 支持收集和记录安全相关的审计日志，比如授权错误日志、登入/登出日志等，方便管理和监控。\n安全配置(Security Configuration) 提供了弹性和易用的安全配置能力，如动态配置安全相关Bean等。\n集成支持(Integration Support) 天然支持Spring Cloud和Springboot项目，无缝集成从认证到授权的全套安全功能。\n所以总体来说，Spring Cloud Security提供了一种标准化和集成的方式来实现微服务环境下的安全需求。开发人员可以更便捷地利用其丰富的功能。\n示例 Spring Security如何实现JSON Web Token的功能？ Spring Security可以通过如下方式实现JSON Web Token(JWT)的功能：\n导入spring-security-jwt依赖。 org.springframework.boot spring-boot-starter-security org.springframework.security spring-security-jwt spring-boot-starter-security版本信息如下：\nspring-boot-starter-parent版本号：2.7.5 依赖的spring-boot-starter-security版本号：2.7.5 spring-boot-starter-security是Spring Boot安全功能的启动器依赖，它会自动引入核心安全依赖：\nspring-security-core：Spring Security的核心模块，提供认证、授权、安全相关的主要接口和组件。\nspring-security-config：提供了Spring Security的基础配置能力，包含过滤器链、密码编码器等。\nspring-security-web：提供了web安全相关的支持，如过滤器、登录表单、注解等。\nspring-security-crypto：包含密码哈希功能的实现类，用于对密码进行安全的加密存储。\nspring-security-data：包含了支持JDBC和LDAP等后端数据源的安全组件。\nspring-security-oauth2-client：提供了对OAuth2客户端功能的支持。主要提供以下OAuth2客户端相关功能：\n客户端注册和资源服务器配置：支持为客户端应用配置clientId、secret等信息。 客户端凭证获取：支持BasicAuth和密码模式获取client credentials。 访问令牌请求：实现客户端向授权服务器请求访问令牌的功能，支持password、refresh_token等grant类型。 令牌存储：提供TokenStore接口的实现，支持在会话或数据库中存储/获取访问令牌。 资源服务器访问：通过访问令牌来访问受保护的资源，支持从请求头或参数中提取令牌。 刷新令牌：实现使用refresh_token来刷新过期的访问令牌功能。 用户授权：提供类似@PreAuthorize注解来处理用户授权逻辑。 客户端详情：封装ClientDetails实现类，包含客户端注册信息。 默认令牌服务：DefaultTokenServices实现类管理令牌生命周期。 请求工厂：提供RestTemplate和Apache HTTP Components等请求客户端。 spring-security-oauth2-client模块同时也提供部分支持其他授权类型：\n授权码模式(authorization_code)：主流模式，客户端通过auth code获取access token。 密码模式(password)：客户端直接提供用户名密码获取token，适合trusted客户端。 隐藏式授权模式(implicit)：客户端直接获取access token，不支持refresh。 客户端模式(client_credentials)：客户端以自身名义请求资源服务，适合机密客户端。 资主授权模式(owner)：类似密码模式但用户需确认通过用户界面。 运行时审批模式(approval_prompt)：用户每次访问都需确认授权。 除了上述常见授权类型外，spring-security-oauth2-client还提供了对以下模式的选择性支持：\n断路器模式(urn:ietf:params:oauth:grant-type:device_code) 分阶段授权模式(urn:ietf:params:oauth:grant-type:stage) 令牌交换模式(urn:ietf:params:oauth:grant-type:token-exchange) spring-security-oauth2-core：OAuth2协议支持的核心部件。\n因此spring-boot-starter-security的版本始终保持与spring-boot-starters版本一致。\n当前较为主流和稳定的spring-boot版本有：\nSpring Boot 2.7.x 最新版 Spring Boot 2.6.x Spring Boot 2.5.x 对应的spring-boot-starter-security版本如下：\nSpring Boot 2.7.x - spring-boot-starter-security 2.7.x Spring Boot 2.6.x - spring-boot-starter-security 2.6.x Spring Boot 2.5.x - spring-boot-starter-security 2.5.x 所以在选择spring boot版本时，直接依赖spring-boot-starter-security而不用单独指定版本，就可以保证安全功能的版本一致性。\n目前大多数场景下可以使用Spring Boot 2.6.x或者2.7.x作为选择，它们内置的spring-boot-starter-security版本都很成熟。\n配置JwtToken enhancer来生成JWT令牌。 @Bean public JwtAccessTokenConverter jwtTokenEnhancer() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(\"123456\"); return converter; } 定义JwtTokenStore来保存JWT令牌。 @Bean public TokenStore tokenStore() { return new JwtTokenStore(jwtTokenEnhancer()); } 在AuthorizationServerConfigurerAdapter配置类中设置tokenStore。 @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) { endpoints.tokenStore(tokenStore()); } 客户端使用JWT令牌进行认证访问资源服务器。\n资源服务器使用JwtTokenStore和JwtAccessTokenConverter校验JWT令牌的合法性。\n解析JWTpayload获取用户信息，实现鉴权决策。\nString username = ((Jwt)authentication.getPrincipal()).getSubject(); 完整代码，配置类：\n@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public JwtAccessTokenConverter accessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(\"as123456dfsdf\"); return converter; } @Bean public TokenStore tokenStore() { return new JwtTokenStore(accessTokenConverter()); } @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable(); http .authorizeRequests() .antMatchers(\"/oauth/**\").permitAll(); } @Bean @Primary public DefaultTokenServices tokenServices() { DefaultTokenServices defaultTokenServices = new DefaultTokenServices(); defaultTokenServices.setTokenStore(tokenStore()); defaultTokenServices.setSupportRefreshToken(true); return defaultTokenServices; } } 授权服务器配置，使用客户端模式配置：\n@Configuration public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { @Autowired private TokenStore tokenStore; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\"clientapp\") .secret(\"$2a$10$6aQQyhlhol4M1KAncczPdu4zX7/TgvjpOU.sWzt7j5Xl6W/z5V4cC\") .authorizedGrantTypes(\"password\"， \"refresh_token\") .scopes(\"read\"， \"write\") .accessTokenValiditySeconds(3600); } @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.tokenStore(tokenStore) .authenticationManager(authenticationManager()); } } 主要配置：\n使用ClientDetailsServiceConfigurer配置客户端信息，如clientId、secret等 配置tokenStore 配置authenticationManager来获取用户信息 这样就实现了基于客户端模式下的授权服务配置，客户端可以使用clientId/secret获取访问令牌而无需用户登录。\n客户端访问示例：\ncurl -X POST http://localhost:8080/oauth/token -d \"grant_type=password\u0026username=user\u0026password=password\u0026client_id=clientapp\u0026client_secret=secret\" 让客户端在后台获取访问令牌，资源服务再使用令牌验证授权。\n","wordCount":"6838","inLanguage":"en","datePublished":"2023-08-15T08:00:00+08:00","dateModified":"2023-08-15T08:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.com/posts/2023/08/15/spring-security-oauth2-history/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.com/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.com/categories/ideas title=周报><span>周报</span></a></li><li><a href=https://blog.chensoul.com/categories/notes title=编程><span>编程</span></a></li><li><a href=https://blog.chensoul.com/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.com/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Spring Security和OAuth2发展过程</h1><div class=post-meta><span title='2023-08-15 08:00:00 +0800 +0800'>2023-08-15</span>&nbsp;·&nbsp;chensoul</div></header><div class=post-content><h2 id=spring-security的发展过程>Spring Security的发展过程<a hidden class=anchor aria-hidden=true href=#spring-security的发展过程>#</a></h2><p>Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分，于2004年发布，现在已经成为 Spring 生态系统的核心组件。 Spring Security 的发展过程可以分为三个阶段：</p><p>第一阶段：Spring Security起源于一个名为Acegi Security的开源项目，初期重点实现了Spring应用的身份认证和授权服务功能。2003年，Acegi Security作为一个孵化项目被捐献给Spring社区。2004年，正式作为Spring框架的核心组件之一Absorbed进Spring。并更名为Spring Security。Spring Security 1.0 版本 Spring Security 1.0 版本发布于 2004 年。它提供了最基本的安全功能，包括身份验证和授权。身份验证是验证用户是否是他们所声称的人的过程。授权是确定用户是否有权访问特定资源的过程。 Spring Security 1.0 版本使用了以下技术来实现身份验证和授权：</p><ul><li>表单身份验证：表单身份验证是通过用户提交表单来验证用户身份的过程。</li><li>基于角色的访问控制 (RBAC)：RBAC 是一种授权模型，它将用户分配到角色，然后这些角色被授予对特定资源的访问权限。</li></ul><p>第二阶段：Spring Security 2.0 版本 Spring Security 2.0 版本发布于 2006 年。它提供了更多的安全功能，包括加密和会话管理。加密是将数据转换成无法被他人理解的形式的过程。会话管理是跟踪用户会话的状态的过程。 Spring Security 2.0 版本使用了以下技术来实现加密和会话管理：</p><ul><li>安全套接字层 (SSL)：SSL 是一种加密协议，它可以保护数据在传输过程中不被窃听。</li><li>会话管理：Spring Security 提供了自己的会话管理实现，它可以跟踪用户会话的状态。</li></ul><p>第三阶段：Spring Security 3.0 版本 Spring Security 3.0 版本发布于 2008 年。它是一个重大的版本更新，它提供了许多新的安全功能，包括 OAuth、SAML 和 OpenID。 OAuth 是一种授权框架，它允许第三方应用程序访问用户的资源。SAML 是一种单点登录 (SSO) 协议，它允许用户在一个地方登录，然后访问多个网站。OpenID 是一种开放的身份验证协议，它允许用户使用他们选择的身份提供商来验证他们的身份。 Spring Security 3.0 版本使用了以下技术来实现 OAuth、SAML 和 OpenID：</p><ul><li><p>OAuth：Spring Security 提供了自己的 OAuth 实现，它可以让你轻松地在你的应用程序中使用 OAuth。</p></li><li><p>SAML：Spring Security 提供了自己的 SAML 实现，它可以让你轻松地在你的应用程序中使用 SAML。</p></li><li><p>OpenID：Spring Security 提供了自己的 OpenID 实现，它可以让你轻松地在你的应用程序中使用 OpenID。</p></li></ul><p>以下是 Spring Security 的详细的发展过程和版本变化：</p><ol><li><p>Acegi Security：Acegi Security 是 Spring Security 的前身，最初由 Ben Alex 创建并于2004年发布。Acegi Security 提供了一组基于 Spring 的安全性功能，用于保护 Web 应用程序、Web 服务和基于 Spring 的应用程序。</p></li><li><p>Spring Security 2：Spring Security 2 是 Acegi Security 的继任者，于2006年发布。Spring Security 2 提供了一些新的功能和改进，例如对 OpenID、LDAP 和 CAS 的支持，以及更好的集成和配置选项。</p></li><li><p>Spring Security 3：Spring Security 3 于2009年发布，是 Spring Security 的一个重大更新。Spring Security 3 提供了更多的安全功能和改进，例如对 RESTful Web 服务的支持、基于注解的安全性、更好的 CSRF 防护、更好的密码存储和认证管理等。</p></li><li><p>Spring Security 4：Spring Security 4 于2015年发布，带来了一些新的功能和改进，例如对 OAuth2、JWT 和 Spring Boot 的支持、更好的 SSO 和多因素认证等。</p></li><li><p>Spring Security 5：Spring Security 5 于2017年发布，是一个重大的更新，带来了一些新的功能和改进，例如对 WebFlux 和 Reactive Spring 的支持、更好的 OAuth2 和 OpenID Connect 的支持、更好的密码编码和认证管理等。</p></li><li><p>Spring Security 5.1：Spring Security 5.1 发布于 2018 年，主要提供了对 Spring Boot 2.1 的支持和一些新的功能，如 Kotlin DSL、OAuth2 支持的私有证书、JWT 生成器等。</p></li><li><p>Spring Security 5.2：Spring Security 5.2 发布于 2019 年，带来了许多改进和新特性，包括对 Spring Cloud Gateway 和 Spring MVC 的 WebFlux 支持、OAuth2 和 OpenID Connect 的改进、更好的密码管理和认证、更好的跨域资源共享（CORS）支持等。</p></li><li><p>Spring Security 5.3：Spring Security 5.3 发布于 2020 年，主要提供了更好的 WebFlux 和 RSocket 支持、更好的 OAuth2 支持、更好的测试和性能、更好的 Kotlin 支持、更好的 JUnit 5 支持等。</p></li><li><p>Spring Security 5.4：Spring Security 5.4 发布于 2021 年，带来了一些新的功能和改进，例如对 Spring Boot 2.4 的支持、更好的 JWT 和 OAuth2 支持、更好的密码编码、更好的 WebFlux 和 RSocket 支持、更好的测试和性能等。</p></li><li><p>Spring Security 5.5：是当前最新的版本，于2022年发布。Spring Security 5.5 带来了一些新的功能和改进，包括对 Spring Framework 6 和 Java 17 的支持、更好的密码编码和认证管理、更好的 OAuth2 和 OpenID Connect 支持、更好的 WebFlux 和 RSocket 支持、更好的测试和性能等。</p><p>除了不断改进和增强现有功能之外，Spring Security 还增加了对新的安全威胁的防御和支持，例如 CSRF、XSS、CSP 等。此外，Spring Security 还提供了许多有用的扩展和插件，例如 Spring Security OAuth、Spring Security SAML、Spring Security Kerberos 等，以满足不同的安全需求。</p></li></ol><h2 id=spring-security-oauth2-发展>Spring Security OAuth2 发展<a hidden class=anchor aria-hidden=true href=#spring-security-oauth2-发展>#</a></h2><p><a href=https://github.com/spring-attic/spring-security-oauth>Spring Security OAuth2</a> 是一个用于构建安全的 OAuth2-based 网络应用的框架，它是 Spring Security 的一部分。下面是 Spring Security OAuth2 的发展过程：</p><h3 id=1-spring-security-oauth2-v1x--v20>1. Spring Security OAuth2 V1.x – V2.0<a hidden class=anchor aria-hidden=true href=#1-spring-security-oauth2-v1x--v20>#</a></h3><p>最初的几个版本是为了构建一个安全的 OAuth2-based 网络应用。核心的功能包括：</p><ul><li>支持 OAuth2 协议的四种授权方式：授权码（authorization code）、隐式授权（implicit）、密码授权（resource owner password credentials）和客户端凭据（client credentials）</li><li>提供了一个简单易用的 API 用于构建 OAuth2 服务器和客户端</li><li>支持 JWT（JSON Web Tokens）</li><li>提供了详细的文档和示例代码</li></ul><h3 id=2-spring-security-oauth2-v21>2. Spring Security OAuth2 V2.1<a hidden class=anchor aria-hidden=true href=#2-spring-security-oauth2-v21>#</a></h3><p>在 2.1 版本中，Spring Security OAuth2 进行了一系列的改进和扩展，包括：</p><ul><li>支持 OpenID Connect 1.0</li><li>支持 Token Introspection Endpoint</li><li>更好的支持 JWT，包括 JWS（JSON Web Signatures）和 JWE（JSON Web Encryption）</li></ul><h3 id=3-spring-security-50-oauth2-login-and-oauth2-client>3. Spring Security 5.0 OAuth2 Login and OAuth2 Client<a hidden class=anchor aria-hidden=true href=#3-spring-security-50-oauth2-login-and-oauth2-client>#</a></h3><p>在 Spring Security 5.0 中，Spring Security OAuth2 的部分功能被合并到了 Spring Security 5.0 中，提供了 OAuth2 登录和客户端支持。</p><h3 id=4-spring-security-51-oauth2-resource-server>4. Spring Security 5.1 OAuth2 Resource Server<a hidden class=anchor aria-hidden=true href=#4-spring-security-51-oauth2-resource-server>#</a></h3><p>在 Spring Security 5.1 中，Spring Security OAuth2 的资源服务器功能被合并到了 Spring Security 中。</p><h3 id=5-spring-security-52-oauth2-authorization-server>5. Spring Security 5.2 OAuth2 Authorization Server<a hidden class=anchor aria-hidden=true href=#5-spring-security-52-oauth2-authorization-server>#</a></h3><p>在 Spring Security 5.2 中，Spring Security OAuth2 的授权服务器功能被合并到了 Spring Security 中。这是 Spring Security OAuth2 的最后一个独立版本。</p><h3 id=6-spring-authorization-server>6. Spring Authorization Server<a hidden class=anchor aria-hidden=true href=#6-spring-authorization-server>#</a></h3><p>在 2020 年 4 月，Spring 宣布了一个新的项目——Spring Authorization Server，该项目旨在提供一个用于实现 OAuth 2.1 授权服务器的基础。</p><h3 id=7-spring-security-53-and-beyond>7. Spring Security 5.3 and beyond<a hidden class=anchor aria-hidden=true href=#7-spring-security-53-and-beyond>#</a></h3><p>在 Spring Security 5.3 和之后的版本中，Spring Security OAuth2 的所有功能都被合并到了 Spring Security 中，而 <a href=https://github.com/spring-attic/spring-security-oauth>Spring Security OAuth2</a> 作为一个独立的项目已经停止开发。与之相对应的 <a href=https://github.com/spring-attic/spring-security-oauth2-boot>Spring Security OAuth Boot 2 Autoconfig</a> 也停止了开发。</p><p>总结一下，目前，Spring Security OAuth2 的最新版本为 2.5.2.RELEASE，并且所有类都标注为 @Deprecated，官方也提供了一个迁移文档 <a href=https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Migration-Guide>OAuth 2.0 Migration Guide</a>。</p><h2 id=spring-boot和spring-oauth2版本关系>Spring Boot和Spring OAuth2版本关系<a hidden class=anchor aria-hidden=true href=#spring-boot和spring-oauth2版本关系>#</a></h2><p>Spring Boot和Spring OAuth2是可以配合使用的，主要注意版本匹配即可。</p><p>Spring Boot使用了特定版本的Spring OAuth2作为依赖。所以使用对应的Spring Boot版本，就会自动获取匹配的Spring OAuth2版本。</p><p>举几个版本的例子：</p><ul><li>Spring Boot 1.5.x 使用 Spring OAuth2 2.0.x</li><li>Spring Boot 2.0.x 使用 Spring OAuth2 2.0.x</li><li>Spring Boot 2.1.x 使用 Spring OAuth2 2.1.x</li><li>Spring Boot 2.2.x 使用 Spring OAuth2 2.2.x</li><li>Spring Boot 2.3.x 使用 Spring OAuth2 2.3.x</li></ul><p>所以使用Spring Boot时，不需要额外指定Spring OAuth2的版本，只需要选择匹配的Spring Boot版本即可。</p><p>在配置和使用Spring OAuth2时，只需要参考Spring OAuth2的文档即可，不需要特别关注其版本。Spring Boot会负责管理版本匹配。</p><p>此外，从Spring Boot 1.5开始，Spring Security已经集成了OAuth2的实现，可以直接使用Spring Security来实现OAuth2，无需引入Spring OAuth项目。</p><p>总之，Spring Boot大大简化了Spring OAuth2的使用，只需要关注Spring Boot版本即可自动获取正确的Spring OAuth2版本。</p><h2 id=spring-cloud和spring-oauth2版本关系>Spring Cloud和Spring OAuth2版本关系<a hidden class=anchor aria-hidden=true href=#spring-cloud和spring-oauth2版本关系>#</a></h2><p>Spring Cloud和Spring OAuth2版本之间没有固定的对应关系，但通常来说建议符合以下情况：</p><ul><li>Spring Cloud版本越新，内置的Spring OAuth支持也会更稳定和完善。</li><li>Spring Cloud Hoxton/Greenwich等主流版本，内置的Spring OAuth支持正常使用Spring Security OAuth2版本2.x。</li><li>Spring Cloud Edgware及更早版本，内置的Spring OAuth支持建议使用Spring Security OAuth2版本1.x。</li><li>即使Spring Cloud版本和Spring Security OAuth版本不完全匹配，也无大碍，但功能和兼容性会受一定影响。</li></ul><p>所以一般来说：</p><ul><li>Spring Cloud Finch/ Greenwich等最新版本，建议使用Spring Security OAuth2版本2.3.x及以上。</li><li>Spring Cloud Edgware到Hoxton，建议使用Spring Security OAuth2版本1.5.x到2.3.x都可以。</li><li>Spring Cloud版本比较早，如Dalston以下，建议使用Spring Security OAuth2版本1.0.x到1.5.x。</li></ul><p>但不是说版本一定要完全匹配，主要看自己需要用到的Spring OAuth功能是否得到支持。选择版本时优先考虑Spring Cloud版本的内置支持程度。此外，也可以根据项目其他依赖选择一个相对稳定的Spring Security OAuth版本。</p><h2 id=spring-cloud-security>Spring Cloud Security<a hidden class=anchor aria-hidden=true href=#spring-cloud-security>#</a></h2><p>Spring Cloud Security提供了一种集成化的方式来实现微服务应用的安全功能。主要有以下几点：</p><ol><li>身份认证(Authentication)</li></ol><p>Spring Cloud Security支持常见的认证方式，比如基于OAuth2.0的认证协议。可以实现集中式的认证管理，登入后获取访问令牌并在各个微服务之间传递。</p><ol><li>授权(Authorization)</li></ol><p>支持基于RBAC和ABAC等授权模型。可以实现集中式的授权管理，给不同用户或组分配不同的访问权限。</p><ol><li>安全终端(Security Endpoints)</li></ol><p>提供了安全终端的实现，比如/oauth/token令牌访问端点、/userinfo用户信息端点等。</p><ol><li>加密通信(Encryption)</li></ol><p>支持在微服务之间进行安全的HTTP通信，通过TLS/SSL加密数据传输和服务间调用。</p><ol><li>日志审计(Logging & Auditing)</li></ol><p>支持收集和记录安全相关的审计日志，比如授权错误日志、登入/登出日志等，方便管理和监控。</p><ol><li>安全配置(Security Configuration)</li></ol><p>提供了弹性和易用的安全配置能力，如动态配置安全相关Bean等。</p><ol><li>集成支持(Integration Support)</li></ol><p>天然支持Spring Cloud和Springboot项目，无缝集成从认证到授权的全套安全功能。</p><p>所以总体来说，Spring Cloud Security提供了一种标准化和集成的方式来实现微服务环境下的安全需求。开发人员可以更便捷地利用其丰富的功能。</p><h2 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h2><h3 id=spring-security如何实现json-web-token的功能>Spring Security如何实现JSON Web Token的功能？<a hidden class=anchor aria-hidden=true href=#spring-security如何实现json-web-token的功能>#</a></h3><p>Spring Security可以通过如下方式实现JSON Web Token(JWT)的功能：</p><ol><li>导入spring-security-jwt依赖。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;dependency&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;groupId&gt;</span>org.springframework.boot<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;artifactId&gt;</span>spring-boot-starter-security<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/dependency&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nt>&lt;dependency&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;groupId&gt;</span>org.springframework.security<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;artifactId&gt;</span>spring-security-jwt<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>spring-boot-starter-security版本信息如下：</p><ul><li>spring-boot-starter-parent版本号：2.7.5</li><li>依赖的spring-boot-starter-security版本号：2.7.5</li></ul><p>spring-boot-starter-security是Spring Boot安全功能的启动器依赖，它会自动引入核心安全依赖：</p><ul><li><p>spring-security-core：Spring Security的核心模块，提供认证、授权、安全相关的主要接口和组件。</p></li><li><p>spring-security-config：提供了Spring Security的基础配置能力，包含过滤器链、密码编码器等。</p></li><li><p>spring-security-web：提供了web安全相关的支持，如过滤器、登录表单、注解等。</p></li><li><p>spring-security-crypto：包含密码哈希功能的实现类，用于对密码进行安全的加密存储。</p></li><li><p>spring-security-data：包含了支持JDBC和LDAP等后端数据源的安全组件。</p></li><li><p>spring-security-oauth2-client：提供了对OAuth2客户端功能的支持。主要提供以下OAuth2客户端相关功能：</p><ul><li>客户端注册和资源服务器配置：支持为客户端应用配置clientId、secret等信息。</li><li>客户端凭证获取：支持BasicAuth和密码模式获取client credentials。</li><li>访问令牌请求：实现客户端向授权服务器请求访问令牌的功能，支持password、refresh_token等grant类型。</li><li>令牌存储：提供TokenStore接口的实现，支持在会话或数据库中存储/获取访问令牌。</li><li>资源服务器访问：通过访问令牌来访问受保护的资源，支持从请求头或参数中提取令牌。</li><li>刷新令牌：实现使用refresh_token来刷新过期的访问令牌功能。</li><li>用户授权：提供类似@PreAuthorize注解来处理用户授权逻辑。</li><li>客户端详情：封装ClientDetails实现类，包含客户端注册信息。</li><li>默认令牌服务：DefaultTokenServices实现类管理令牌生命周期。</li><li>请求工厂：提供RestTemplate和Apache HTTP Components等请求客户端。</li></ul><p>spring-security-oauth2-client模块同时也提供部分支持其他授权类型：</p><ul><li>授权码模式(authorization_code)：主流模式，客户端通过auth code获取access token。</li><li>密码模式(password)：客户端直接提供用户名密码获取token，适合trusted客户端。</li><li>隐藏式授权模式(implicit)：客户端直接获取access token，不支持refresh。</li><li>客户端模式(client_credentials)：客户端以自身名义请求资源服务，适合机密客户端。</li><li>资主授权模式(owner)：类似密码模式但用户需确认通过用户界面。</li><li>运行时审批模式(approval_prompt)：用户每次访问都需确认授权。</li></ul><p>除了上述常见授权类型外，spring-security-oauth2-client还提供了对以下模式的选择性支持：</p><ul><li>断路器模式(urn:ietf:params:oauth:grant-type:device_code)</li><li>分阶段授权模式(urn:ietf:params:oauth:grant-type:stage)</li><li>令牌交换模式(urn:ietf:params:oauth:grant-type:token-exchange)</li></ul></li><li><p>spring-security-oauth2-core：OAuth2协议支持的核心部件。</p></li></ul><p>因此spring-boot-starter-security的版本始终保持与spring-boot-starters版本一致。</p><p>当前较为主流和稳定的spring-boot版本有：</p><ul><li>Spring Boot 2.7.x 最新版</li><li>Spring Boot 2.6.x</li><li>Spring Boot 2.5.x</li></ul><p>对应的spring-boot-starter-security版本如下：</p><ul><li>Spring Boot 2.7.x - spring-boot-starter-security 2.7.x</li><li>Spring Boot 2.6.x - spring-boot-starter-security 2.6.x</li><li>Spring Boot 2.5.x - spring-boot-starter-security 2.5.x</li></ul><p>所以在选择spring boot版本时，直接依赖spring-boot-starter-security而不用单独指定版本，就可以保证安全功能的版本一致性。</p><p>目前大多数场景下可以使用Spring Boot 2.6.x或者2.7.x作为选择，它们内置的spring-boot-starter-security版本都很成熟。</p><ol start=2><li>配置JwtToken enhancer来生成JWT令牌。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>JwtAccessTokenConverter</span> <span class=nf>jwtTokenEnhancer</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>JwtAccessTokenConverter</span> <span class=n>converter</span> <span class=o>=</span> <span class=k>new</span> <span class=n>JwtAccessTokenConverter</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=n>converter</span><span class=o>.</span><span class=na>setSigningKey</span><span class=o>(</span><span class=s>&#34;123456&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>converter</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ol start=3><li>定义JwtTokenStore来保存JWT令牌。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>TokenStore</span> <span class=nf>tokenStore</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>new</span> <span class=n>JwtTokenStore</span><span class=o>(</span><span class=n>jwtTokenEnhancer</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ol start=4><li>在AuthorizationServerConfigurerAdapter配置类中设置tokenStore。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>configure</span><span class=o>(</span><span class=n>AuthorizationServerEndpointsConfigurer</span> <span class=n>endpoints</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>endpoints</span><span class=o>.</span><span class=na>tokenStore</span><span class=o>(</span><span class=n>tokenStore</span><span class=o>());</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ol start=5><li><p>客户端使用JWT令牌进行认证访问资源服务器。</p></li><li><p>资源服务器使用JwtTokenStore和JwtAccessTokenConverter校验JWT令牌的合法性。</p></li><li><p>解析JWTpayload获取用户信息，实现鉴权决策。</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span> <span class=n>username</span> <span class=o>=</span>  <span class=o>((</span><span class=n>Jwt</span><span class=o>)</span><span class=n>authentication</span><span class=o>.</span><span class=na>getPrincipal</span><span class=o>()).</span><span class=na>getSubject</span><span class=o>();</span>
</span></span></code></pre></div><p>完整代码，配置类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span>
</span></span><span class=line><span class=cl><span class=nd>@EnableWebSecurity</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SecurityConfig</span> <span class=kd>extends</span> <span class=n>WebSecurityConfigurerAdapter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Bean</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=n>JwtAccessTokenConverter</span> <span class=nf>accessTokenConverter</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>JwtAccessTokenConverter</span> <span class=n>converter</span> <span class=o>=</span> <span class=k>new</span> <span class=n>JwtAccessTokenConverter</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>converter</span><span class=o>.</span><span class=na>setSigningKey</span><span class=o>(</span><span class=s>&#34;as123456dfsdf&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>converter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Bean</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=n>TokenStore</span> <span class=nf>tokenStore</span><span class=o>()</span> <span class=o>{</span>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=n>JwtTokenStore</span><span class=o>(</span><span class=n>accessTokenConverter</span><span class=o>());</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>  <span class=kd>protected</span> <span class=kt>void</span> <span class=nf>configure</span><span class=o>(</span><span class=n>HttpSecurity</span> <span class=n>http</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>http</span><span class=o>.</span><span class=na>csrf</span><span class=o>().</span><span class=na>disable</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>http</span> 
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>authorizeRequests</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>antMatchers</span><span class=o>(</span><span class=s>&#34;/oauth/**&#34;</span><span class=o>).</span><span class=na>permitAll</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Bean</span>
</span></span><span class=line><span class=cl>  <span class=nd>@Primary</span> 
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=n>DefaultTokenServices</span> <span class=nf>tokenServices</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DefaultTokenServices</span> <span class=n>defaultTokenServices</span> <span class=o>=</span> <span class=k>new</span> <span class=n>DefaultTokenServices</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>defaultTokenServices</span><span class=o>.</span><span class=na>setTokenStore</span><span class=o>(</span><span class=n>tokenStore</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=n>defaultTokenServices</span><span class=o>.</span><span class=na>setSupportRefreshToken</span><span class=o>(</span><span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>defaultTokenServices</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>授权服务器配置，使用客户端模式配置：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>AuthorizationServerConfig</span> <span class=kd>extends</span> <span class=n>AuthorizationServerConfigurerAdapter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Autowired</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>TokenStore</span> <span class=n>tokenStore</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>configure</span><span class=o>(</span><span class=n>ClientDetailsServiceConfigurer</span> <span class=n>clients</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>clients</span><span class=o>.</span><span class=na>inMemory</span><span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>withClient</span><span class=o>(</span><span class=s>&#34;clientapp&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>secret</span><span class=o>(</span><span class=s>&#34;$2a$10$6aQQyhlhol4M1KAncczPdu4zX7/TgvjpOU.sWzt7j5Xl6W/z5V4cC&#34;</span><span class=o>)</span> 
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>authorizedGrantTypes</span><span class=o>(</span><span class=s>&#34;password&#34;</span><span class=err>，</span> <span class=s>&#34;refresh_token&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>scopes</span><span class=o>(</span><span class=s>&#34;read&#34;</span><span class=err>，</span> <span class=s>&#34;write&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>accessTokenValiditySeconds</span><span class=o>(</span><span class=n>3600</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>configure</span><span class=o>(</span><span class=n>AuthorizationServerEndpointsConfigurer</span> <span class=n>endpoints</span><span class=o>)</span> 
</span></span><span class=line><span class=cl>      <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>endpoints</span><span class=o>.</span><span class=na>tokenStore</span><span class=o>(</span><span class=n>tokenStore</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>authenticationManager</span><span class=o>(</span><span class=n>authenticationManager</span><span class=o>());</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>主要配置：</p><ol><li>使用ClientDetailsServiceConfigurer配置客户端信息，如clientId、secret等</li><li>配置tokenStore</li><li>配置authenticationManager来获取用户信息</li></ol><p>这样就实现了基于客户端模式下的授权服务配置，客户端可以使用clientId/secret获取访问令牌而无需用户登录。</p><p>客户端访问示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -X POST http://localhost:8080/oauth/token -d <span class=s2>&#34;grant_type=password&amp;username=user&amp;password=password&amp;client_id=clientapp&amp;client_secret=secret&#34;</span>
</span></span></code></pre></div><p>让客户端在后台获取访问令牌，资源服务再使用令牌验证授权。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.com/tags/java/>java</a></li><li><a href=https://blog.chensoul.com/tags/spring/>spring</a></li><li><a href=https://blog.chensoul.com/tags/oauth2/>oauth2</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.chensoul.com/>ChenSoul</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script async src=https://umami.chensoul.com/script.js data-website-id=96086d6c-67d3-4bd4-820b-6c4733c7b608></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>