<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]为 Spring Boot 应用程序创建优化的 Docker 映像 | ChenSoul</title><meta name=keywords content="java,spring boot,spring,docker"><meta name=description content="容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。 本文着眼于容器化 Spring Boot 应用程序的不同方法： 使用 Docker 文件构"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.com/posts/2023/08/16/spring-boot-docker/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="8E787EFCDB0CE747FE1A4DA0ABEC66E4"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.chensoul.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.chensoul.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="[译]为 Spring Boot 应用程序创建优化的 Docker 映像"><meta property="og:description" content="容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。 本文着眼于容器化 Spring Boot 应用程序的不同方法： 使用 Docker 文件构"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.com/posts/2023/08/16/spring-boot-docker/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-16T14:00:00+08:00"><meta property="article:modified_time" content="2023-08-16T14:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]为 Spring Boot 应用程序创建优化的 Docker 映像"><meta name=twitter:description content="容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。 本文着眼于容器化 Spring Boot 应用程序的不同方法： 使用 Docker 文件构"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.com/posts/"},{"@type":"ListItem","position":2,"name":"[译]为 Spring Boot 应用程序创建优化的 Docker 映像","item":"https://blog.chensoul.com/posts/2023/08/16/spring-boot-docker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]为 Spring Boot 应用程序创建优化的 Docker 映像","name":"[译]为 Spring Boot 应用程序创建优化的 Docker 映像","description":"容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。 本文着眼于容器化 Spring Boot 应用程序的不同方法： 使用 Docker 文件构","keywords":["java","spring boot","spring","docker"],"articleBody":"容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。\n本文着眼于容器化 Spring Boot 应用程序的不同方法：\n使用 Docker 文件构建 Docker 镜像， 使用 Cloud-Native Buildpack 从源代码构建 OCI 映像， 通过使用分层工具将 JAR 的各个部分拆分为不同的层，在运行时优化映像。 示例代码 本文附有 GitHub 上的工作代码示例。\n容器术语 我们将从整篇文章中使用的容器术语开始：\nContainer image: 具有特定格式的文件。我们通过运行构建工具将应用程序转换为容器映像。 Container: 容器镜像的运行时实例。 Container engine: t负责运行Container的守护进程。 Container host: 容器引擎运行的主机。 Container registry: 用于发布和分发容器映像的共享位置。 OCI Standard: 开放容器倡议 (OCI) 是在 Linux 基金会下形成的一个轻量级、开放的治理结构。 OCI 镜像规范定义了容器镜像格式和运行时的行业标准，以确保所有容器引擎都可以运行任何构建工具生成的容器镜像。 为了容器化应用程序，我们将应用程序封装在容器映像中，并将该映像发布到共享注册表。容器运行时从注册表中提取该映像，解压该映像，然后在其中运行应用程序。\nSpring Boot 2.3 版本提供了用于构建 OCI 映像的插件。\nDocker 恰好是最常用的容器实现，并且我们在示例中使用 Docker，因此本文中所有后续对容器的引用都将指 Docker。\n以传统方式构建容器镜像 通过向 Docker 文件添加一些指令，可以非常轻松地创建 Spring Boot 应用程序的 Docker 镜像。\n我们首先构建一个可执行 JAR，并作为 Docker 文件指令的一部分，在应用必要的自定义后将可执行 JAR 复制到基本 JRE 映像上。\n让我们从 Spring Initializr 创建带有 web 、 lombok 和 actuator 依赖项的 Spring Boot 应用程序。我们还添加了一个休息控制器来使用 GET 方法公开 API。\n创建 Docker 文件 接下来，我们通过添加 Dockerfile 来容器化该应用程序：\nFROM adoptopenjdk:11-jre-hotspot ARG JAR_FILE=target/*.jar COPY ${JAR_FILE} application.jar EXPOSE 8080 ENTRYPOINT [\"java\",\"-jar\",\"/application.jar\"] 我们的 Docker 文件包含来自 adoptopenjdk 的基本映像，我们在该映像上复制 JAR 文件，然后公开将侦听请求的端口 8080 。\n构建应用程序 我们首先使用 Maven 或 Gradle 构建应用程序。我们在这里使用 Maven：\nmvn clean package 这将创建应用程序的可执行 JAR。我们需要将这个可执行 JAR 转换为 Docker 映像，以便在 Docker 引擎中运行。\n构建容器镜像 接下来，我们通过从包含之前创建的 Docker 文件的根项目目录运行 docker build 命令，将此可执行 JAR 放入 Docker 映像中：\ndocker build -t usersignup:v1 . 我们可以看到使用以下命令列出的图像：\ndocker images 上述命令的输出包括我们的映像 usersignup 以及 Docker 文件中指定的基础映像 adoptopenjdk 。\nREPOSITORY TAG SIZE usersignup v1 249MB adoptopenjdk 11-jre-hotspot 229MB 查看容器镜像内的层 让我们看看图像内的图层堆栈。我们将使用 dive tool 来查看这些图层：\ndive usersignup:v1 以下是运行 Dive 命令的部分输出：\n正如我们所看到的，应用层构成了图像大小的重要组成部分。作为优化的一部分，我们的目标是在以下部分中减小该层的大小。\n使用 Buildpack 构建容器镜像 Buildpacks 是各种平台即服务 (PAAS) 产品使用的通用术语，用于从源代码构建容器映像。它由 Heroku 于 2011 年发起，此后已被 Cloud Foundry、Google App Engine、Gitlab、Knative 等采用。\n云原生 Buildpack 的优势 使用 Buildpack 构建映像的一个主要优点是，可以在集中位置（构建器）管理对映像配置的更改，并将其传播到使用该构建器的所有应用程序。\nBuildpack 与平台紧密耦合。云原生 Buildpack 通过支持 OCI 映像格式实现跨平台标准化，确保映像可以由 Docker 引擎运行。\n使用 Spring Boot 插件 Spring Boot 插件使用 Buildpack 从源代码创建 OCI 映像。映像是使用 bootBuildImage 任务 (Gradle) 或 spring-boot:build-image 目标 (Maven) 和本地 Docker 安装构建的。\n我们可以通过在 image tag 中指定名称来自定义推送到 Docker 注册表所需的镜像名称：\norg.springframework.boot spring-boot-maven-plugin docker.io/pratikdas/${project.artifactId}:v1 让我们使用 Maven 运行 build-image 目标来构建应用程序并创建容器映像。我们现在没有使用任何 Docker 文件。\nmvn spring-boot:build-image 运行此命令将产生类似于以下内容的输出：\n[INFO] --- spring-boot-maven-plugin:2.3.3.RELEASE:build-image (default-cli) @ usersignup --- [INFO] Building image 'docker.io/pratikdas/usersignup:v1' [INFO] [INFO] \u003e Pulling builder image 'gcr.io/paketo-buildpacks/builder:base-platform-api-0.3' 0% . . .. [creator] Adding label 'org.springframework.boot.version' .. [creator] *** Images (c311fe74ec73): .. [creator] docker.io/pratikdas/usersignup:v1 [INFO] [INFO] Successfully built image 'docker.io/pratikdas/usersignup:v1' 从输出中，我们可以看到 paketo Cloud-Native buildpack 被用来构建可运行的 OCI 映像。正如我们之前所做的那样，我们可以通过运行以下命令来查看列为 Docker 映像的映像：\ndocker images 输出：\nREPOSITORY SIZE paketobuildpacks/run 84.3MB gcr.io/paketo-buildpacks/builder 652MB pratikdas/usersignup 257MB 使用 Jib 构建容器镜像 Jib 是 Google 的一个镜像构建器插件，提供了一种从源代码构建容器镜像的替代方法。\n我们在pom.xml中配置 jib-maven-plugin ：\ncom.google.cloud.tools jib-maven-plugin 2.5.2 接下来，我们使用 Maven 命令触发 Jib 插件来构建应用程序并创建容器映像。和以前一样，我们在这里没有使用任何 Docker 文件：\nmvn compile jib:build -Dimage=/usersignup:v1 运行上述 Maven 命令后，我们得到以下输出：\n[INFO] Containerizing application to pratikdas/usersignup:v1... . . [INFO] Container entrypoint set to [java, -cp, /app/resources:/app/classes:/app/libs/*, io.pratik.users.UsersignupApplication] [INFO] [INFO] Built and pushed image as pratikdas/usersignup:v1 [INFO] Executing tasks: [INFO] [==============================] 100.0% complete 输出显示容器映像已构建并推送到注册表。\n构建优化镜像的动机和技术 我们优化的主要动机有两个：\n性能：在容器编排系统中，容器镜像从镜像仓库拉取到运行容器引擎的主机上。这个过程称为调度。从注册表中提取大型映像会导致容器编排系统中的调度时间较长以及 CI 管道中的构建时间较长。 安全性：大尺寸图像也有更大的漏洞表面积。 Docker 镜像由一堆层组成，每个层代表 Dockerfile 中的一条指令。每一层都是底层变化的增量。当我们从注册中心拉取Docker镜像时，它是被分层拉取并缓存在主机中的。\nSpring Boot 使用“fat JAR”作为其默认打包格式。当我们检查 fat JAR 时，我们可以看到该应用程序只占整个 JAR 的很小一部分。这是变化最频繁的部分。其余部分由 Spring 框架依赖项组成。\n优化公式的核心是将应用程序与 Spring 框架依赖项隔离到一个单独的层中。\n构成 fat JAR 大部分的依赖项层仅下载一次并缓存在主机系统中。\n在应用程序更新和容器调度期间，仅拉取应用程序的薄层，如下图所示：\n让我们在接下来的部分中了解如何为 Spring Boot 应用程序构建这些优化的映像。\n使用 Buildpack 为 Spring Boot 应用程序构建优化的容器映像 Spring Boot 2.3 通过将 fat JAR 的各个部分提取到单独的层中来支持分层。分层功能默认关闭，需要使用 Spring Boot Maven 插件显式启用：\norg.springframework.boot spring-boot-maven-plugin true 我们将使用此配置首先使用 Buildpack 生成容器映像，然后在以下部分中使用 Docker 生成容器映像。\n让我们运行 Maven build-image 目标来创建容器映像：images/stock/-1200x628-branded.jpg\nmvn spring-boot:build-image 如果我们运行 Dive 来查看生成图像中的各层，我们可以看到应用程序层（以红色圈出）在千字节范围内比我们使用 fat JAR 格式获得的要小得多：\n使用 Docker 为 Spring Boot 应用程序构建优化的容器映像 我们还可以使用 Docker 文件创建分层的 JAR Docker 镜像，而不是使用 Maven 或 Gradle 插件。\n当我们使用 Docker 时，我们需要执行两个额外的步骤来提取层并将其复制到最终映像中。\n使用 Maven 构建并启用分层功能后，生成的 JAR 内容将如下所示：\nMETA-INF/ . BOOT-INF/lib/ . BOOT-INF/lib/spring-boot-jarmode-layertools-2.3.3.RELEASE.jar BOOT-INF/classpath.idx BOOT-INF/layers.idx 输出显示一个名为 spring-boot-jarmode-layertools 的附加 JAR 和一个 layersfle.idx 文件。分层功能由这个附加 JAR 提供，如下一节所述。\n取不同层中的依赖关系 要查看并从分层 JAR 中提取层，我们使用系统属性 -Djarmode=layertools 来启动 spring-boot-jarmode-layertools JAR 而不是应用程序：\njava -Djarmode=layertools -jar target/usersignup-0.0.1-SNAPSHOT.jar 运行此命令会生成包含可用命令选项的输出：\nUsage: java -Djarmode=layertools -jar usersignup-0.0.1-SNAPSHOT.jar Available commands: list List layers from the jar that can be extracted extract Extracts layers from the jar for image creation help Help about any command 输出显示命令 list 、 extract 和 help ，其中 help 是默认命令。让我们使用 list 选项运行命令：\njava -Djarmode=layertools -jar target/usersignup-0.0.1-SNAPSHOT.jar list dependencies spring-boot-loader snapshot-dependencies application 我们可以看到可以作为层添加的依赖项列表。\n默认层是：\n图层名称 内容 dependencies 版本不包含 SNAPSHOT 的任何依赖项 spring-boot-loader JAR 加载器类 snapshot-dependencies 版本包含 SNAPSHOT 的任何依赖项 application 应用程序类和资源 这些层按照应添加到 Docker 映像的顺序在 layers.idx 文件中定义。这些层在第一次拉取后会缓存在主机中，因为它们不会更改。仅将更新的应用程序层下载到主机，由于大小减小，速度更快。\n使用在单独层中提取的依赖项构建图像 我们将使用称为多阶段构建的方法分两个阶段构建最终图像。在第一阶段，我们将提取依赖项，在第二阶段，我们将提取的依赖项复制到最终映像。\n让我们修改 Docker 文件以进行多阶段构建：\n# the first stage of our build will extract the layers FROM adoptopenjdk:14-jre-hotspot as builder WORKDIR application ARG JAR_FILE=target/*.jar COPY ${JAR_FILE} application.jar RUN java -Djarmode=layertools -jar application.jar extract # the second stage of our build will copy the extracted layers FROM adoptopenjdk:14-jre-hotspot WORKDIR application COPY --from=builder application/dependencies/ ./ COPY --from=builder application/spring-boot-loader/ ./ COPY --from=builder application/snapshot-dependencies/ ./ COPY --from=builder application/application/ ./ ENTRYPOINT [\"java\", \"org.springframework.boot.loader.JarLauncher\"] 我们将此配置保存在单独的文件中 - Dockerfile2 。\n我们使用以下命令构建 Docker 镜像：\ndocker build -f Dockerfile2 -t usersignup:v1 . 运行此命令后，我们得到以下输出：\nSending build context to Docker daemon 20.41MB Step 1/12 : FROM adoptopenjdk:14-jre-hotspot as builder 14-jre-hotspot: Pulling from library/adoptopenjdk . . Successfully built a9ebf6970841 Successfully tagged userssignup:v1 我们可以看到 Docker 镜像是使用镜像 ID 创建的，然后被标记的。\n最后，我们像以前一样运行 Dive 命令来检查生成的 Docker 镜像内的层。我们可以指定图像 ID 或标签作为 Dive 命令的输入：\ndive userssignup:v1 正如我们在输出中看到的，包含应用程序的层现在只有 11 kB，依赖项缓存在单独的层中。\n提取不同层中的内部依赖关系 我们可以通过在单独的层中提取任何自定义依赖项来进一步减小应用程序层的大小，而不是通过在名为 layers.idx 的 yml 类似文件中声明它们来将它们与应用程序一起打包：\n- \"dependencies\": - \"BOOT-INF/lib/\" - \"spring-boot-loader\": - \"org/\" - \"snapshot-dependencies\": - \"custom-dependencies\": - \"io/myorg/\" - \"application\": - \"BOOT-INF/classes/\" - \"BOOT-INF/classpath.idx\" - \"BOOT-INF/layers.idx\" - \"META-INF/\" 在此文件中 - layers.idx 我们添加了一个名为 io.myorg 的自定义依赖项，其中包含从共享存储库中提取的组织依赖项。\n结论 在本文中，我们研究了使用云原生 Buildpack 直接从源代码创建容器映像。这是使用 Docker 构建容器映像的传统方式的替代方案，首先构建 fat 可执行 JAR，然后通过在 Dockerfile 中指定指令将其打包到容器映像中。\n我们还考虑通过启用分层功能来优化我们的容器，该功能提取缓存在主机中的单独层中的依赖项，并在容器运行时引擎的调度期间下载应用程序的薄层。\n文章中使用的所有源码可以参考Github上的。\n命令参考 以下是我们在本文中使用的命令摘要，以供快速参考。\n清洁我们的环境：\ndocker system prune -a 使用 Docker 文件构建容器镜像：\ndocker build -f -t . 从源代码构建容器镜像（没有 Dockerfile）：\nmvn spring-boot:build-image 查看依赖关系层。在构建应用程序 JAR 之前，确保在 spring-boot-maven-plugin 中启用分层功能：\njava -Djarmode=layertools -jar application.jar list 提取依赖层。在构建应用程序 JAR 之前，确保在 spring-boot-maven-plugin 中启用分层功能：\njava -Djarmode=layertools -jar application.jar extract 查看容器镜像列表\ndocker images 查看容器镜像内的层（确保已安装 dive tool 工具）：\ndive 原文链接：https://reflectoring.io/spring-boot-docker/\n","wordCount":"3712","inLanguage":"en","datePublished":"2023-08-16T14:00:00+08:00","dateModified":"2023-08-16T14:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.com/posts/2023/08/16/spring-boot-docker/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.com/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.com/categories/ideas title=周报><span>周报</span></a></li><li><a href=https://blog.chensoul.com/categories/notes title=编程><span>编程</span></a></li><li><a href=https://blog.chensoul.com/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.com/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[译]为 Spring Boot 应用程序创建优化的 Docker 映像</h1><div class=post-meta><span title='2023-08-16 14:00:00 +0800 +0800'>2023-08-16</span>&nbsp;·&nbsp;chensoul</div></header><div class=post-content><p>容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。</p><p>本文着眼于容器化 Spring Boot 应用程序的不同方法：</p><ul><li>使用 Docker 文件构建 Docker 镜像，</li><li>使用 Cloud-Native Buildpack 从源代码构建 OCI 映像，</li><li>通过使用分层工具将 JAR 的各个部分拆分为不同的层，在运行时优化映像。</li></ul><h2 id=示例代码>示例代码<a hidden class=anchor aria-hidden=true href=#示例代码>#</a></h2><p>本文附有 <a href=https://github.com/thombergs/code-examples/tree/master/spring-boot/spring-boot-docker>GitHub</a> 上的工作代码示例。</p><h2 id=容器术语>容器术语<a hidden class=anchor aria-hidden=true href=#容器术语>#</a></h2><p>我们将从整篇文章中使用的容器术语开始：</p><ul><li><strong>Container image</strong>: 具有特定格式的文件。我们通过运行构建工具将应用程序转换为容器映像。</li><li><strong>Container</strong>: 容器镜像的运行时实例。</li><li><strong>Container engine</strong>: t负责运行Container的守护进程。</li><li><strong>Container host</strong>: 容器引擎运行的主机。</li><li><strong>Container registry</strong>: 用于发布和分发容器映像的共享位置。</li><li><strong>OCI Standard</strong>: 开放容器倡议 (OCI) 是在 Linux 基金会下形成的一个轻量级、开放的治理结构。 OCI 镜像规范定义了容器镜像格式和运行时的行业标准，以确保所有容器引擎都可以运行任何构建工具生成的容器镜像。</li></ul><p>为了容器化应用程序，我们将应用程序封装在容器映像中，并将该映像发布到共享注册表。容器运行时从注册表中提取该映像，解压该映像，然后在其中运行应用程序。</p><p>Spring Boot 2.3 版本提供了用于构建 OCI 映像的插件。</p><p>Docker 恰好是最常用的容器实现，并且我们在示例中使用 Docker，因此本文中所有后续对容器的引用都将指 Docker。</p><h2 id=以传统方式构建容器镜像>以传统方式构建容器镜像<a hidden class=anchor aria-hidden=true href=#以传统方式构建容器镜像>#</a></h2><p>通过向 Docker 文件添加一些指令，可以非常轻松地创建 Spring Boot 应用程序的 Docker 镜像。</p><p>我们首先构建一个可执行 JAR，并作为 Docker 文件指令的一部分，在应用必要的自定义后将可执行 JAR 复制到基本 JRE 映像上。</p><p>让我们从 Spring Initializr 创建带有 <code>web</code> 、 <code>lombok</code> 和 <code>actuator</code> 依赖项的 Spring Boot 应用程序。我们还添加了一个休息控制器来使用 <code>GET</code> 方法公开 API。</p><h3 id=创建-docker-文件>创建 Docker 文件<a hidden class=anchor aria-hidden=true href=#创建-docker-文件>#</a></h3><p>接下来，我们通过添加 <code>Dockerfile</code> 来容器化该应用程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> adoptopenjdk:11-jre-hotspot</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> <span class=nv>JAR_FILE</span><span class=o>=</span>target/*.jar<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> <span class=si>${</span><span class=nv>JAR_FILE</span><span class=si>}</span> application.jar<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 8080</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;java&#34;</span><span class=p>,</span><span class=s2>&#34;-jar&#34;</span><span class=p>,</span><span class=s2>&#34;/application.jar&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>我们的 Docker 文件包含来自 <code>adoptopenjdk</code> 的基本映像，我们在该映像上复制 JAR 文件，然后公开将侦听请求的端口 <code>8080</code> 。</p><h3 id=构建应用程序>构建应用程序<a hidden class=anchor aria-hidden=true href=#构建应用程序>#</a></h3><p>我们首先使用 Maven 或 Gradle 构建应用程序。我们在这里使用 Maven：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn clean package
</span></span></code></pre></div><p>这将创建应用程序的可执行 JAR。我们需要将这个可执行 JAR 转换为 Docker 映像，以便在 Docker 引擎中运行。</p><h3 id=构建容器镜像>构建容器镜像<a hidden class=anchor aria-hidden=true href=#构建容器镜像>#</a></h3><p>接下来，我们通过从包含之前创建的 Docker 文件的根项目目录运行 <code>docker build</code> 命令，将此可执行 JAR 放入 Docker 映像中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build  -t usersignup:v1 .
</span></span></code></pre></div><p>我们可以看到使用以下命令列出的图像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>docker images 
</span></span></code></pre></div><p>上述命令的输出包括我们的映像 <code>usersignup</code> 以及 Docker 文件中指定的基础映像 <code>adoptopenjdk</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>REPOSITORY          TAG                 SIZE
</span></span><span class=line><span class=cl>usersignup          v1                  249MB
</span></span><span class=line><span class=cl>adoptopenjdk        11-jre-hotspot      229MB
</span></span></code></pre></div><h3 id=查看容器镜像内的层>查看容器镜像内的层<a hidden class=anchor aria-hidden=true href=#查看容器镜像内的层>#</a></h3><p>让我们看看图像内的图层堆栈。我们将使用 <a href=https://github.com/wagoodman/dive>dive tool</a> 来查看这些图层：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>dive usersignup:v1
</span></span></code></pre></div><p>以下是运行 Dive 命令的部分输出：</p><p><img loading=lazy src=https://reflectoring.io/images/posts/springboot-docker-image/dive1_hubcbf0cf5b8016db6aaa4ee18f24f07bd_217954_995x0_resize_box_3.png alt="dive screenshot"></p><p>正如我们所看到的，应用层构成了图像大小的重要组成部分。作为优化的一部分，我们的目标是在以下部分中减小该层的大小。</p><h2 id=使用-buildpack-构建容器镜像>使用 Buildpack 构建容器镜像<a hidden class=anchor aria-hidden=true href=#使用-buildpack-构建容器镜像>#</a></h2><p>Buildpacks 是各种平台即服务 (PAAS) 产品使用的通用术语，用于从源代码构建容器映像。它由 Heroku 于 2011 年发起，此后已被 Cloud Foundry、Google App Engine、Gitlab、Knative 等采用。</p><p><img loading=lazy src=https://reflectoring.io/images/posts/springboot-docker-image/Docker_buildpack_hub141f56b152735f30f93b4dac67d723e_39179_522x0_resize_box_3.png alt="dive screenshot"></p><h3 id=云原生-buildpack-的优势>云原生 Buildpack 的优势<a hidden class=anchor aria-hidden=true href=#云原生-buildpack-的优势>#</a></h3><p>使用 Buildpack 构建映像的一个主要优点是，可以在集中位置（构建器）管理对映像配置的更改，并将其传播到使用该构建器的所有应用程序。</p><p>Buildpack 与平台紧密耦合。云原生 Buildpack 通过支持 OCI 映像格式实现跨平台标准化，确保映像可以由 Docker 引擎运行。</p><h3 id=使用-spring-boot-插件>使用 Spring Boot 插件<a hidden class=anchor aria-hidden=true href=#使用-spring-boot-插件>#</a></h3><p>Spring Boot 插件使用 Buildpack 从源代码创建 OCI 映像。映像是使用 <code>bootBuildImage</code> 任务 (Gradle) 或 <code>spring-boot:build-image</code> 目标 (Maven) 和本地 Docker 安装构建的。</p><p>我们可以通过在 <code>image tag</code> 中指定名称来自定义推送到 Docker 注册表所需的镜像名称：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;plugin&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;groupId&gt;</span>org.springframework.boot<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;configuration&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;image&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nt>&lt;name&gt;</span>docker.io/pratikdas/${project.artifactId}:v1<span class=nt>&lt;/name&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/image&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/configuration&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/plugin&gt;</span>
</span></span></code></pre></div><p>让我们使用 Maven 运行 <code>build-image</code> 目标来构建应用程序并创建容器映像。我们现在没有使用任何 Docker 文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mvn spring-boot:build-image
</span></span></code></pre></div><p>运行此命令将产生类似于以下内容的输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> --- spring-boot-maven-plugin:2.3.3.RELEASE:build-image <span class=o>(</span>default-cli<span class=o>)</span> @ usersignup ---
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> Building image <span class=s1>&#39;docker.io/pratikdas/usersignup:v1&#39;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span>  &gt; Pulling builder image <span class=s1>&#39;gcr.io/paketo-buildpacks/builder:base-platform-api-0.3&#39;</span> 0%
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>.. <span class=o>[</span>creator<span class=o>]</span>     Adding label <span class=s1>&#39;org.springframework.boot.version&#39;</span>
</span></span><span class=line><span class=cl>.. <span class=o>[</span>creator<span class=o>]</span>     *** Images <span class=o>(</span>c311fe74ec73<span class=o>)</span>:
</span></span><span class=line><span class=cl>.. <span class=o>[</span>creator<span class=o>]</span>           docker.io/pratikdas/usersignup:v1
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> Successfully built image <span class=s1>&#39;docker.io/pratikdas/usersignup:v1&#39;</span>
</span></span></code></pre></div><p>从输出中，我们可以看到 <code>paketo Cloud-Native buildpack</code> 被用来构建可运行的 OCI 映像。正如我们之前所做的那样，我们可以通过运行以下命令来查看列为 Docker 映像的映像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker images 
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>REPOSITORY                             SIZE
</span></span><span class=line><span class=cl>paketobuildpacks/run                  84.3MB
</span></span><span class=line><span class=cl>gcr.io/paketo-buildpacks/builder      652MB
</span></span><span class=line><span class=cl>pratikdas/usersignup                  257MB
</span></span></code></pre></div><h2 id=使用-jib-构建容器镜像>使用 Jib 构建容器镜像<a hidden class=anchor aria-hidden=true href=#使用-jib-构建容器镜像>#</a></h2><p>Jib 是 Google 的一个镜像构建器插件，提供了一种从源代码构建容器镜像的替代方法。</p><p>我们在pom.xml中配置 <code>jib-maven-plugin</code> ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl>      <span class=nt>&lt;plugin&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;groupId&gt;</span>com.google.cloud.tools<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;artifactId&gt;</span>jib-maven-plugin<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;version&gt;</span>2.5.2<span class=nt>&lt;/version&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nt>&lt;/plugin&gt;</span>
</span></span></code></pre></div><p>接下来，我们使用 Maven 命令触发 Jib 插件来构建应用程序并创建容器映像。和以前一样，我们在这里没有使用任何 Docker 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mvn compile jib:build -Dimage<span class=o>=</span>&lt;docker registry name&gt;/usersignup:v1
</span></span></code></pre></div><p>运行上述 Maven 命令后，我们得到以下输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> Containerizing application to pratikdas/usersignup:v1...
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> Container entrypoint <span class=nb>set</span> to <span class=o>[</span>java, -cp, /app/resources:/app/classes:/app/libs/*, io.pratik.users.UsersignupApplication<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> Built and pushed image as pratikdas/usersignup:v1
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> Executing tasks:
</span></span><span class=line><span class=cl><span class=o>[</span>INFO<span class=o>]</span> <span class=o>[==============================]</span> 100.0% <span class=nb>complete</span>
</span></span></code></pre></div><p>输出显示容器映像已构建并推送到注册表。</p><h2 id=构建优化镜像的动机和技术>构建优化镜像的动机和技术<a hidden class=anchor aria-hidden=true href=#构建优化镜像的动机和技术>#</a></h2><p>我们优化的主要动机有两个：</p><ul><li>性能：在容器编排系统中，容器镜像从镜像仓库拉取到运行容器引擎的主机上。这个过程称为调度。从注册表中提取大型映像会导致容器编排系统中的调度时间较长以及 CI 管道中的构建时间较长。</li><li>安全性：大尺寸图像也有更大的漏洞表面积。</li></ul><p>Docker 镜像由一堆层组成，每个层代表 Dockerfile 中的一条指令。每一层都是底层变化的增量。当我们从注册中心拉取Docker镜像时，它是被分层拉取并缓存在主机中的。</p><p>Spring Boot 使用“fat JAR”作为其默认打包格式。当我们检查 fat JAR 时，我们可以看到该应用程序只占整个 JAR 的很小一部分。这是变化最频繁的部分。其余部分由 Spring 框架依赖项组成。</p><p>优化公式的核心是将应用程序与 Spring 框架依赖项隔离到一个单独的层中。</p><p>构成 fat JAR 大部分的依赖项层仅下载一次并缓存在主机系统中。</p><p>在应用程序更新和容器调度期间，仅拉取应用程序的薄层，如下图所示：</p><p><img loading=lazy src=https://reflectoring.io/images/posts/springboot-docker-image/Docker_optimized_hu7e3f87c1ee5c9089319f5b74bf96dc0e_337860_521x0_resize_box_3.png alt="dive screenshot"></p><p>让我们在接下来的部分中了解如何为 Spring Boot 应用程序构建这些优化的映像。</p><h2 id=使用-buildpack-为-spring-boot-应用程序构建优化的容器映像>使用 Buildpack 为 Spring Boot 应用程序构建优化的容器映像<a hidden class=anchor aria-hidden=true href=#使用-buildpack-为-spring-boot-应用程序构建优化的容器映像>#</a></h2><p>Spring Boot 2.3 通过将 fat JAR 的各个部分提取到单独的层中来支持分层。分层功能默认关闭，需要使用 Spring Boot Maven 插件显式启用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;plugin&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;groupId&gt;</span>org.springframework.boot<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;configuration&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;layers&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nt>&lt;enabled&gt;</span>true<span class=nt>&lt;/enabled&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/layers&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/configuration&gt;</span> 
</span></span><span class=line><span class=cl><span class=nt>&lt;/plugin&gt;</span>
</span></span></code></pre></div><p>我们将使用此配置首先使用 Buildpack 生成容器映像，然后在以下部分中使用 Docker 生成容器映像。</p><p>让我们运行 Maven <code>build-image</code> 目标来创建容器映像：images/stock/-1200x628-branded.jpg</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mvn spring-boot:build-image
</span></span></code></pre></div><p>如果我们运行 Dive 来查看生成图像中的各层，我们可以看到应用程序层（以红色圈出）在千字节范围内比我们使用 fat JAR 格式获得的要小得多：</p><p><img loading=lazy src=https://reflectoring.io/images/posts/springboot-docker-image/dive-buildpack-layer_hue5f4a8721d8f8ee948ce4b161834cbfd_180286_774x0_resize_box_3.png alt="dive screenshot"></p><h2 id=使用-docker-为-spring-boot-应用程序构建优化的容器映像>使用 Docker 为 Spring Boot 应用程序构建优化的容器映像<a hidden class=anchor aria-hidden=true href=#使用-docker-为-spring-boot-应用程序构建优化的容器映像>#</a></h2><p>我们还可以使用 Docker 文件创建分层的 JAR Docker 镜像，而不是使用 Maven 或 Gradle 插件。</p><p>当我们使用 Docker 时，我们需要执行两个额外的步骤来提取层并将其复制到最终映像中。</p><p>使用 Maven 构建并启用分层功能后，生成的 JAR 内容将如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>META-INF/
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>BOOT-INF/lib/
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>BOOT-INF/lib/spring-boot-jarmode-layertools-2.3.3.RELEASE.jar
</span></span><span class=line><span class=cl>BOOT-INF/classpath.idx
</span></span><span class=line><span class=cl>BOOT-INF/layers.idx
</span></span></code></pre></div><p>输出显示一个名为 <code>spring-boot-jarmode-layertools</code> 的附加 JAR 和一个 <code>layersfle.idx</code> 文件。分层功能由这个附加 JAR 提供，如下一节所述。</p><h3 id=取不同层中的依赖关系>取不同层中的依赖关系<a hidden class=anchor aria-hidden=true href=#取不同层中的依赖关系>#</a></h3><p>要查看并从分层 JAR 中提取层，我们使用系统属性 <code>-Djarmode=layertools</code> 来启动 <code>spring-boot-jarmode-layertools</code> JAR 而不是应用程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>java -Djarmode<span class=o>=</span>layertools -jar target/usersignup-0.0.1-SNAPSHOT.jar
</span></span></code></pre></div><p>运行此命令会生成包含可用命令选项的输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Usage:
</span></span><span class=line><span class=cl>  java -Djarmode<span class=o>=</span>layertools -jar usersignup-0.0.1-SNAPSHOT.jar
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Available commands:
</span></span><span class=line><span class=cl>  list     List layers from the jar that can be extracted
</span></span><span class=line><span class=cl>  extract  Extracts layers from the jar <span class=k>for</span> image creation
</span></span><span class=line><span class=cl>  <span class=nb>help</span>     Help about any <span class=nb>command</span>
</span></span></code></pre></div><p>输出显示命令 <code>list</code> 、 <code>extract</code> 和 <code>help</code> ，其中 <code>help</code> 是默认命令。让我们使用 <code>list</code> 选项运行命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>java -Djarmode<span class=o>=</span>layertools -jar target/usersignup-0.0.1-SNAPSHOT.jar list
</span></span><span class=line><span class=cl>dependencies
</span></span><span class=line><span class=cl>spring-boot-loader
</span></span><span class=line><span class=cl>snapshot-dependencies
</span></span><span class=line><span class=cl>application
</span></span></code></pre></div><p>我们可以看到可以作为层添加的依赖项列表。</p><p>默认层是：</p><table><thead><tr><th style=text-align:left>图层名称</th><th style=text-align:left>内容</th></tr></thead><tbody><tr><td style=text-align:left><code>dependencies</code></td><td style=text-align:left>版本不包含 SNAPSHOT 的任何依赖项</td></tr><tr><td style=text-align:left><code>spring-boot-loader</code></td><td style=text-align:left>JAR 加载器类</td></tr><tr><td style=text-align:left><code>snapshot-dependencies</code></td><td style=text-align:left>版本包含 SNAPSHOT 的任何依赖项</td></tr><tr><td style=text-align:left><code>application</code></td><td style=text-align:left>应用程序类和资源</td></tr></tbody></table><p>这些层按照应添加到 Docker 映像的顺序在 <code>layers.idx</code> 文件中定义。这些层在第一次拉取后会缓存在主机中，因为它们不会更改。仅将更新的应用程序层下载到主机，由于大小减小，速度更快。</p><h3 id=使用在单独层中提取的依赖项构建图像>使用在单独层中提取的依赖项构建图像<a hidden class=anchor aria-hidden=true href=#使用在单独层中提取的依赖项构建图像>#</a></h3><p>我们将使用称为多阶段构建的方法分两个阶段构建最终图像。在第一阶段，我们将提取依赖项，在第二阶段，我们将提取的依赖项复制到最终映像。</p><p>让我们修改 Docker 文件以进行多阶段构建：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># the first stage of our build will extract the layers</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> adoptopenjdk:14-jre-hotspot as builder</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> application</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> <span class=nv>JAR_FILE</span><span class=o>=</span>target/*.jar<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> <span class=si>${</span><span class=nv>JAR_FILE</span><span class=si>}</span> application.jar<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> java -Djarmode<span class=o>=</span>layertools -jar application.jar extract<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># the second stage of our build will copy the extracted layers</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> adoptopenjdk:14-jre-hotspot</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> application</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder application/dependencies/ ./<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder application/spring-boot-loader/ ./<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder application/snapshot-dependencies/ ./<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder application/application/ ./<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;java&#34;</span><span class=p>,</span> <span class=s2>&#34;org.springframework.boot.loader.JarLauncher&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>我们将此配置保存在单独的文件中 - <code>Dockerfile2</code> 。</p><p>我们使用以下命令构建 Docker 镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>docker build -f Dockerfile2 -t usersignup:v1 .
</span></span></code></pre></div><p>运行此命令后，我们得到以下输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Sending build context to Docker daemon  20.41MB
</span></span><span class=line><span class=cl>Step 1/12 : FROM adoptopenjdk:14-jre-hotspot as builder
</span></span><span class=line><span class=cl>14-jre-hotspot: Pulling from library/adoptopenjdk
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>Successfully built a9ebf6970841
</span></span><span class=line><span class=cl>Successfully tagged userssignup:v1
</span></span></code></pre></div><p>我们可以看到 Docker 镜像是使用镜像 ID 创建的，然后被标记的。</p><p>最后，我们像以前一样运行 Dive 命令来检查生成的 Docker 镜像内的层。我们可以指定图像 ID 或标签作为 Dive 命令的输入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>dive userssignup:v1
</span></span></code></pre></div><p>正如我们在输出中看到的，包含应用程序的层现在只有 11 kB，依赖项缓存在单独的层中。</p><p><img loading=lazy src=https://reflectoring.io/images/posts/springboot-docker-image/dive2_hu3bbff09746513aa7b18660495606ffa4_412354_816x0_resize_box_3.png alt="dive screenshot"></p><h3 id=提取不同层中的内部依赖关系>提取不同层中的内部依赖关系<a hidden class=anchor aria-hidden=true href=#提取不同层中的内部依赖关系>#</a></h3><p>我们可以通过在单独的层中提取任何自定义依赖项来进一步减小应用程序层的大小，而不是通过在名为 <code>layers.idx</code> 的 <code>yml</code> 类似文件中声明它们来将它们与应用程序一起打包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>- &#34;dependencies&#34;:
</span></span><span class=line><span class=cl>  - &#34;BOOT-INF/lib/&#34;
</span></span><span class=line><span class=cl>- &#34;spring-boot-loader&#34;:
</span></span><span class=line><span class=cl>  - &#34;org/&#34;
</span></span><span class=line><span class=cl>- &#34;snapshot-dependencies&#34;:
</span></span><span class=line><span class=cl>- &#34;custom-dependencies&#34;:
</span></span><span class=line><span class=cl>  - &#34;io/myorg/&#34;
</span></span><span class=line><span class=cl>- &#34;application&#34;:
</span></span><span class=line><span class=cl>  - &#34;BOOT-INF/classes/&#34;
</span></span><span class=line><span class=cl>  - &#34;BOOT-INF/classpath.idx&#34;
</span></span><span class=line><span class=cl>  - &#34;BOOT-INF/layers.idx&#34;
</span></span><span class=line><span class=cl>  - &#34;META-INF/&#34;
</span></span></code></pre></div><p>在此文件中 - <code>layers.idx</code> 我们添加了一个名为 <code>io.myorg</code> 的自定义依赖项，其中包含从共享存储库中提取的组织依赖项。</p><h2 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h2><p>在本文中，我们研究了使用云原生 Buildpack 直接从源代码创建容器映像。这是使用 Docker 构建容器映像的传统方式的替代方案，首先构建 fat 可执行 JAR，然后通过在 Dockerfile 中指定指令将其打包到容器映像中。</p><p>我们还考虑通过启用分层功能来优化我们的容器，该功能提取缓存在主机中的单独层中的依赖项，并在容器运行时引擎的调度期间下载应用程序的薄层。</p><p>文章中使用的所有源码可以参考<a href=https://github.com/thombergs/code-examples/tree/master/spring-boot/spring-boot-docker>Github</a>上的。</p><h2 id=命令参考>命令参考<a hidden class=anchor aria-hidden=true href=#命令参考>#</a></h2><p>以下是我们在本文中使用的命令摘要，以供快速参考。</p><p>清洁我们的环境：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>docker system prune -a
</span></span></code></pre></div><p>使用 Docker 文件构建容器镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>docker build -f &lt;Docker file name&gt; -t &lt;tag&gt; .
</span></span></code></pre></div><p>从源代码构建容器镜像（没有 Dockerfile）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>mvn spring-boot:build-image
</span></span></code></pre></div><p>查看依赖关系层。在构建应用程序 JAR 之前，确保在 spring-boot-maven-plugin 中启用分层功能：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>java -Djarmode=layertools -jar application.jar list
</span></span></code></pre></div><p>提取依赖层。在构建应用程序 JAR 之前，确保在 spring-boot-maven-plugin 中启用分层功能：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> java -Djarmode=layertools -jar application.jar extract
</span></span></code></pre></div><p>查看容器镜像列表</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>docker images
</span></span></code></pre></div><p>查看容器镜像内的层（确保已安装 dive tool 工具）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>dive &lt;image ID or image tag&gt;
</span></span></code></pre></div><p>原文链接：<a href=https://reflectoring.io/spring-boot-docker/>https://reflectoring.io/spring-boot-docker/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.com/tags/java/>java</a></li><li><a href=https://blog.chensoul.com/tags/spring-boot/>spring boot</a></li><li><a href=https://blog.chensoul.com/tags/spring/>spring</a></li><li><a href=https://blog.chensoul.com/tags/docker/>docker</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.chensoul.com/>ChenSoul</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script async src=https://umami.chensoul.com/script.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>