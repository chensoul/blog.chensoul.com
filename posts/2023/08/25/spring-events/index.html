<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]Spring Events | ChenSoul</title>
<meta name=keywords content="java,spring"><meta name=description content='1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。
事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。
有一些简单的准则需要遵循：
如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。
2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。
在本例中，事件类保存一条字符串消息：
public class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。
要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：
@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System.out.println("Publishing custom event. "); CustomSpringEvent customSpringEvent = new CustomSpringEvent(this, message); applicationEventPublisher.publishEvent(customSpringEvent); } } 或者，发布者类可以实现 ApplicationEventPublisherAware 接口，这也将在应用程序启动时注入事件发布者。通常，使用 @Autowire 注入发布者会更简单。'><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/08/25/spring-events/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/08/25/spring-events/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="[译]Spring Events"><meta property="og:description" content='1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。
事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。
有一些简单的准则需要遵循：
如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。
2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。
在本例中，事件类保存一条字符串消息：
public class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。
要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：
@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System.out.println("Publishing custom event. "); CustomSpringEvent customSpringEvent = new CustomSpringEvent(this, message); applicationEventPublisher.publishEvent(customSpringEvent); } } 或者，发布者类可以实现 ApplicationEventPublisherAware 接口，这也将在应用程序启动时注入事件发布者。通常，使用 @Autowire 注入发布者会更简单。'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/08/25/spring-events/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-25T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-25T00:00:00+00:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]Spring Events"><meta name=twitter:description content='1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。
事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。
有一些简单的准则需要遵循：
如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。
2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。
在本例中，事件类保存一条字符串消息：
public class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。
要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：
@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System.out.println("Publishing custom event. "); CustomSpringEvent customSpringEvent = new CustomSpringEvent(this, message); applicationEventPublisher.publishEvent(customSpringEvent); } } 或者，发布者类可以实现 ApplicationEventPublisherAware 接口，这也将在应用程序启动时注入事件发布者。通常，使用 @Autowire 注入发布者会更简单。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]Spring Events","item":"https://blog.chensoul.cc/posts/2023/08/25/spring-events/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]Spring Events","name":"[译]Spring Events","description":"1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。\n事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。\n有一些简单的准则需要遵循：\n如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。\n2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。\n在本例中，事件类保存一条字符串消息：\npublic class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。\n要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：\n@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System.out.println(\u0026#34;Publishing custom event. \u0026#34;); CustomSpringEvent customSpringEvent = new CustomSpringEvent(this, message); applicationEventPublisher.publishEvent(customSpringEvent); } } 或者，发布者类可以实现 ApplicationEventPublisherAware 接口，这也将在应用程序启动时注入事件发布者。通常，使用 @Autowire 注入发布者会更简单。","keywords":["java","spring"],"articleBody":"1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。\n事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。\n有一些简单的准则需要遵循：\n如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。\n2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。\n在本例中，事件类保存一条字符串消息：\npublic class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。\n要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：\n@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System.out.println(\"Publishing custom event. \"); CustomSpringEvent customSpringEvent = new CustomSpringEvent(this, message); applicationEventPublisher.publishEvent(customSpringEvent); } } 或者，发布者类可以实现 ApplicationEventPublisherAware 接口，这也将在应用程序启动时注入事件发布者。通常，使用 @Autowire 注入发布者会更简单。\n从 Spring Framework 4.2 开始，ApplicationEventPublisher 接口为publishEvent(Object event) 方法提供了新的重载，该方法接受任何对象作为事件。因此，Spring 事件不再需要扩展ApplicationEvent 类。\n2.3.监听者 最后，让我们创建监听器。\n监听器的唯一要求是是一个 bean 并实现 ApplicationListener 接口：\n@Component public class CustomSpringEventListener implements ApplicationListener\u003cCustomSpringEvent\u003e { @Override public void onApplicationEvent(CustomSpringEvent event) { System.out.println(\"Received spring custom event - \" + event.getMessage()); } } 请注意我们的自定义侦听器如何使用自定义事件的通用类型进行参数化，这使得 onApplicationEvent() 方法类型安全。这也避免了必须检查对象是否是特定事件类的实例并转换它。\n而且，正如已经讨论过的（默认情况下 Spring 事件是同步的）， doStuffAndPublishAnEvent() 方法会阻塞，直到所有侦听器完成对事件的处理。\n3. 创建异步事件 在某些情况下，同步发布事件并不是我们真正想要的——我们可能需要异步处理事件。\n我们可以通过创建带有执行器的 ApplicationEventMulticaster bean 在配置中打开它。\n出于我们的目的，SimpleAsyncTaskExecutor 效果很好：\n@Configuration public class AsynchronousSpringEventsConfig { @Bean(name = \"applicationEventMulticaster\") public ApplicationEventMulticaster simpleApplicationEventMulticaster() { SimpleApplicationEventMulticaster eventMulticaster = new SimpleApplicationEventMulticaster(); eventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor()); return eventMulticaster; } } 事件、发布者和侦听器实现与以前相同，但现在侦听器将在单独的线程中异步处理事件。\n4.现有框架事件 Spring 本身发布了各种开箱即用的事件。例如，ApplicationContext 将触发各种框架事件：ContextRefreshedEvent、ContextStartedEvent、RequestHandledEvent 等。\n这些事件为应用程序开发人员提供了一个选项，可以挂钩应用程序和上下文的生命周期，并在需要时添加自己的自定义逻辑。\n下面是侦听器侦听上下文刷新的简单示例：\npublic class ContextRefreshedListener implements ApplicationListener\u003cContextRefreshedEvent\u003e { @Override public void onApplicationEvent(ContextRefreshedEvent cse) { System.out.println(\"Handling context re-freshed event. \"); } } 5. 注解驱动的事件监听器 从 Spring 4.2 开始，事件侦听器不需要是实现 ApplicationListener 接口的 bean — 它可以通过 @EventListener 注释在托管 bean 的任何公共方法上注册：\n@Component public class AnnotationDrivenEventListener { @EventListener public void handleContextStart(ContextStartedEvent cse) { System.out.println(\"Handling context started event.\"); } } 和以前一样，方法签名声明它消耗的事件类型。\n默认情况下，监听器是同步调用的。但是，我们可以通过添加 @Async 注解轻松使其异步。我们只需要记住在应用程序中启用异步支持即可。\n6. 泛型支持 还可以使用事件类型中的泛型信息来调度事件。\n6.1.通用应用程序事件 让我们创建一个通用事件类型。\n在我们的示例中，事件类包含任何内容和成功状态指示器：\npublic class GenericSpringEvent\u003cT\u003e { private T what; protected boolean success; public GenericSpringEvent(T what, boolean success) { this.what = what; this.success = success; } // ... standard getters } 请注意 GenericSpringEvent 和 CustomSpringEvent 之间的区别。我们现在可以灵活地发布任何任意事件，并且不再需要从 ApplicationEvent 进行扩展。\n6.2.监听者 现在让我们创建该事件的侦听器。\n我们可以像以前一样通过实现 ApplicationListener 接口来定义监听器：\n@Component public class GenericSpringEventListener implements ApplicationListener\u003cGenericSpringEvent\u003cString\u003e\u003e { @Override public void onApplicationEvent(@NonNull GenericSpringEvent\u003cString\u003e event) { System.out.println(\"Received spring generic event - \" + event.getWhat()); } } 但不幸的是这个定义要求我们从 ApplicationEvent 类继承 GenericSpringEvent。因此，在本教程中，我们将使用前面讨论的注释驱动事件侦听器。\n还可以通过在 @EventListener 注释上定义布尔 SpEL 表达式来使事件侦听器成为有条件的。\n在这种情况下，只有成功的 String GenericSpringEvent 才会调用事件处理程序：\n@Component public class AnnotationDrivenEventListener { @EventListener(condition = \"#event.success\") public void handleSuccessful(GenericSpringEvent\u003cString\u003e event) { System.out.println(\"Handling generic event (conditional).\"); } } Spring 表达式语言 (SpEL) 是一种功能强大的表达式语言，在另一个教程中详细介绍了它。\n6.3.发布者 事件发布者与上面描述的类似。但由于类型擦除，我们需要发布一个事件来解析我们要过滤的泛型参数，例如，class GenericStringSpringEvent extends GenericSpringEvent。\n此外，还有另一种发布事件的方式。如果我们从使用 @EventListener 注释的方法返回一个非空值作为结果，Spring Framework 会将该结果作为新事件发送给我们。此外，我们可以通过将多个新事件作为事件处理的结果返回到集合中来发布它们。\n7. 交易绑定事件 本节介绍如何使用 @TransactionalEventListener 注释。要了解有关事务管理的更多信息，请查看 Transactions With Spring and JPA。\n从 Spring 4.2 开始，框架提供了一个新的 @TransactionalEventListener 注解，它是@EventListener 的扩展，允许将事件的监听器绑定到事务的某个阶段。\n可以对以下交易阶段进行绑定：\nAFTER_COMMIT（默认）用于在事务成功完成时触发该事件。 AFTER_ROLLBACK – 如果事务已回滚 AFTER_COMPLETION – 如果事务已完成（AFTER_COMMIT 和 AFTER_ROLLBACK 的别名） BEFORE_COMMIT – 用于在事务提交之前触发该事件。 这是事务事件侦听器的一个简单示例：\n@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT) public void handleCustom(CustomSpringEvent event) { System.out.println(\"Handling event inside a transaction BEFORE COMMIT.\"); } 仅当事件生成器正在运行且即将提交的事务中时，才会调用此侦听器。\n如果没有事务正在运行，则根本不会发送事件，除非我们通过将 FallbackExecution 属性设置为 true 来覆盖它。\n8. 结论 在这篇简短的文章中，我们回顾了在 Spring 中处理事件的基础知识，包括创建一个简单的自定义事件、发布它，然后在侦听器中处理它。\n我们还简要了解了如何在配置中启用事件的异步处理。\n然后我们了解了 Spring 4.2 中引入的改进，例如注释驱动的侦听器、更好的泛型支持以及绑定到事务阶段的事件。\n与往常一样，本文中提供的代码可以在 GitHub 上获取。这是一个基于 Maven 的项目，因此应该很容易导入并按原样运行。\n原文链接：https://www.baeldung.com/spring-events\n","wordCount":"431","inLanguage":"en","datePublished":"2023-08-25T00:00:00Z","dateModified":"2023-08-25T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/08/25/spring-events/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[译]Spring Events</h1><div class=post-meta><span title='2023-08-25 00:00:00 +0000 UTC'>2023-08-25</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;431 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e6%a6%82%e8%bf%b0 aria-label="1. 概述">1. 概述</a></li><li><a href=#2-%e8%87%aa%e5%ae%9a%e4%b9%89%e4%ba%8b%e4%bb%b6 aria-label="2. 自定义事件">2. 自定义事件</a><ul><li><a href=#21%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%ba%8b%e4%bb%b6 aria-label=2.1.一个简单的应用程序事件>2.1.一个简单的应用程序事件</a></li><li><a href=#22%e5%8f%91%e5%b8%83%e8%80%85 aria-label=2.2.发布者>2.2.发布者</a></li><li><a href=#23%e7%9b%91%e5%90%ac%e8%80%85 aria-label=2.3.监听者>2.3.监听者</a></li></ul></li><li><a href=#3-%e5%88%9b%e5%bb%ba%e5%bc%82%e6%ad%a5%e4%ba%8b%e4%bb%b6 aria-label="3. 创建异步事件">3. 创建异步事件</a></li><li><a href=#4%e7%8e%b0%e6%9c%89%e6%a1%86%e6%9e%b6%e4%ba%8b%e4%bb%b6 aria-label=4.现有框架事件>4.现有框架事件</a></li><li><a href=#5-%e6%b3%a8%e8%a7%a3%e9%a9%b1%e5%8a%a8%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8 aria-label="5. 注解驱动的事件监听器">5. 注解驱动的事件监听器</a></li><li><a href=#6-%e6%b3%9b%e5%9e%8b%e6%94%af%e6%8c%81 aria-label="6. 泛型支持">6. 泛型支持</a><ul><li><a href=#61%e9%80%9a%e7%94%a8%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%ba%8b%e4%bb%b6 aria-label=6.1.通用应用程序事件>6.1.通用应用程序事件</a></li><li><a href=#62%e7%9b%91%e5%90%ac%e8%80%85 aria-label=6.2.监听者>6.2.监听者</a></li><li><a href=#63%e5%8f%91%e5%b8%83%e8%80%85 aria-label=6.3.发布者>6.3.发布者</a></li></ul></li><li><a href=#7-%e4%ba%a4%e6%98%93%e7%bb%91%e5%ae%9a%e4%ba%8b%e4%bb%b6 aria-label="7. 交易绑定事件">7. 交易绑定事件</a></li><li><a href=#8-%e7%bb%93%e8%ae%ba aria-label="8. 结论">8. 结论</a></li></ul></div></details></div><div class=post-content><h2 id=1-概述><strong>1. 概述</strong><a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h2><p>在本教程中，我们将讨论如何在 Spring 中使用事件。</p><p>事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 <code>ApplicationContext</code> 提供的功能之一。</p><p>有一些简单的准则需要遵循：</p><ul><li>如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 <code>ApplicationEvent</code>。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。</li><li>发布者应该注入一个 <code>ApplicationEventPublisher</code> 对象。</li><li>监听器应该实现 <code>ApplicationListener</code> 接口。</li></ul><h2 id=2-自定义事件><strong>2. 自定义事件</strong><a hidden class=anchor aria-hidden=true href=#2-自定义事件>#</a></h2><p>Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。</p><h3 id=21一个简单的应用程序事件><strong>2.1.一个简单的应用程序事件</strong><a hidden class=anchor aria-hidden=true href=#21一个简单的应用程序事件>#</a></h3><p>让我们创建一个简单的事件类——只是一个存储事件数据的占位符。</p><p>在本例中，事件类保存一条字符串消息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CustomSpringEvent</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>ApplicationEvent</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>CustomSpringEvent</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>source</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>super</span><span class=p>(</span><span class=n>source</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>message</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>getMessage</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>message</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=22发布者>2.2.发布者<a hidden class=anchor aria-hidden=true href=#22发布者>#</a></h3><p>现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。</p><p>要发布事件，发布者只需注入 <code>ApplicationEventPublisher</code> 并使用 <code>publishEvent() </code>API：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CustomSpringEventPublisher</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>ApplicationEventPublisher</span><span class=w> </span><span class=n>applicationEventPublisher</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>publishCustomEvent</span><span class=p>(</span><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Publishing custom event. &#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>CustomSpringEvent</span><span class=w> </span><span class=n>customSpringEvent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CustomSpringEvent</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=n>message</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>applicationEventPublisher</span><span class=p>.</span><span class=na>publishEvent</span><span class=p>(</span><span class=n>customSpringEvent</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>或者，发布者类可以实现 <code>ApplicationEventPublisherAware</code> 接口，这也将在应用程序启动时注入事件发布者。通常，使用 <code>@Autowire</code> 注入发布者会更简单。</p><p>从 Spring Framework 4.2 开始，<code>ApplicationEventPublisher</code> 接口为<code>publishEvent(Object event) </code>方法提供了新的重载，该方法接受任何对象作为事件。因此，Spring 事件不再需要扩展<code>ApplicationEvent</code> 类。</p><h3 id=23监听者>2.3.监听者<a hidden class=anchor aria-hidden=true href=#23监听者>#</a></h3><p>最后，让我们创建监听器。</p><p>监听器的唯一要求是是一个 bean 并实现 <code>ApplicationListener</code> 接口：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CustomSpringEventListener</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>ApplicationListener</span><span class=o>&lt;</span><span class=n>CustomSpringEvent</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>onApplicationEvent</span><span class=p>(</span><span class=n>CustomSpringEvent</span><span class=w> </span><span class=n>event</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Received spring custom event - &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>event</span><span class=p>.</span><span class=na>getMessage</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>请注意我们的自定义侦听器如何使用自定义事件的通用类型进行参数化，这使得 <code>onApplicationEvent() </code>方法类型安全。这也避免了必须检查对象是否是特定事件类的实例并转换它。</p><p>而且，正如已经讨论过的（默认情况下 Spring 事件是同步的）， <code>doStuffAndPublishAnEvent()</code> 方法会阻塞，直到所有侦听器完成对事件的处理。</p><h2 id=3-创建异步事件>3. 创建异步事件<a hidden class=anchor aria-hidden=true href=#3-创建异步事件>#</a></h2><p>在某些情况下，同步发布事件并不是我们真正想要的——我们可能需要异步处理事件。</p><p>我们可以通过创建带有执行器的 <code>ApplicationEventMulticaster</code> bean 在配置中打开它。</p><p>出于我们的目的，<code>SimpleAsyncTaskExecutor</code> 效果很好：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AsynchronousSpringEventsConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;applicationEventMulticaster&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>ApplicationEventMulticaster</span><span class=w> </span><span class=nf>simpleApplicationEventMulticaster</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SimpleApplicationEventMulticaster</span><span class=w> </span><span class=n>eventMulticaster</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>new</span><span class=w> </span><span class=n>SimpleApplicationEventMulticaster</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>eventMulticaster</span><span class=p>.</span><span class=na>setTaskExecutor</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>SimpleAsyncTaskExecutor</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>eventMulticaster</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>事件、发布者和侦听器实现与以前相同，但现在侦听器将在单独的线程中异步处理事件。</p><h2 id=4现有框架事件>4.现有框架事件<a hidden class=anchor aria-hidden=true href=#4现有框架事件>#</a></h2><p>Spring 本身发布了各种开箱即用的事件。例如，<code>ApplicationContext</code> 将触发各种框架事件：<code>ContextRefreshedEvent</code>、<code>ContextStartedEvent</code>、<code>RequestHandledEvent</code> 等。</p><p>这些事件为应用程序开发人员提供了一个选项，可以挂钩应用程序和上下文的生命周期，并在需要时添加自己的自定义逻辑。</p><p>下面是侦听器侦听上下文刷新的简单示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ContextRefreshedListener</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>implements</span><span class=w> </span><span class=n>ApplicationListener</span><span class=o>&lt;</span><span class=n>ContextRefreshedEvent</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>onApplicationEvent</span><span class=p>(</span><span class=n>ContextRefreshedEvent</span><span class=w> </span><span class=n>cse</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Handling context re-freshed event. &#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=5-注解驱动的事件监听器>5. 注解驱动的事件监听器<a hidden class=anchor aria-hidden=true href=#5-注解驱动的事件监听器>#</a></h2><p>从 Spring 4.2 开始，事件侦听器不需要是实现 <code>ApplicationListener</code> 接口的 bean — 它可以通过 <code>@EventListener</code> 注释在托管 bean 的任何公共方法上注册：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AnnotationDrivenEventListener</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@EventListener</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>handleContextStart</span><span class=p>(</span><span class=n>ContextStartedEvent</span><span class=w> </span><span class=n>cse</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Handling context started event.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>和以前一样，方法签名声明它消耗的事件类型。</p><p>默认情况下，监听器是同步调用的。但是，我们可以通过添加 @Async 注解轻松使其异步。我们只需要记住在应用程序中启用异步支持即可。</p><h2 id=6-泛型支持>6. 泛型支持<a hidden class=anchor aria-hidden=true href=#6-泛型支持>#</a></h2><p>还可以使用事件类型中的泛型信息来调度事件。</p><h3 id=61通用应用程序事件>6.1.通用应用程序事件<a hidden class=anchor aria-hidden=true href=#61通用应用程序事件>#</a></h3><p>让我们创建一个通用事件类型。</p><p>在我们的示例中，事件类包含任何内容和成功状态指示器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>GenericSpringEvent</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=n>what</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>protected</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>success</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>GenericSpringEvent</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>what</span><span class=p>,</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>success</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>what</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>what</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>success</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>success</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... standard getters</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>请注意 <code>GenericSpringEvent</code> 和 <code>CustomSpringEvent</code> 之间的区别。我们现在可以灵活地发布任何任意事件，并且不再需要从 <code>ApplicationEvent</code> 进行扩展。</p><h3 id=62监听者>6.2.监听者<a hidden class=anchor aria-hidden=true href=#62监听者>#</a></h3><p>现在让我们创建该事件的侦听器。</p><p>我们可以像以前一样通过实现 <code>ApplicationListener</code> 接口来定义监听器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>GenericSpringEventListener</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>implements</span><span class=w> </span><span class=n>ApplicationListener</span><span class=o>&lt;</span><span class=n>GenericSpringEvent</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>onApplicationEvent</span><span class=p>(</span><span class=nd>@NonNull</span><span class=w> </span><span class=n>GenericSpringEvent</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>event</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Received spring generic event - &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>event</span><span class=p>.</span><span class=na>getWhat</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>但不幸的是这个定义要求我们从 <code>ApplicationEvent</code> 类继承 <code>GenericSpringEvent</code>。因此，在本教程中，我们将使用前面讨论的注释驱动事件侦听器。</p><p>还可以通过在 <code>@EventListener</code> 注释上定义布尔 SpEL 表达式来使事件侦听器成为有条件的。</p><p>在这种情况下，只有成功的 String <code>GenericSpringEvent</code> 才会调用事件处理程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AnnotationDrivenEventListener</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@EventListener</span><span class=p>(</span><span class=n>condition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;#event.success&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>handleSuccessful</span><span class=p>(</span><span class=n>GenericSpringEvent</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>event</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Handling generic event (conditional).&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Spring 表达式语言 (SpEL) 是一种功能强大的表达式语言，在另一个教程中详细介绍了它。</p><h3 id=63发布者>6.3.发布者<a hidden class=anchor aria-hidden=true href=#63发布者>#</a></h3><p>事件发布者与上面描述的类似。但由于类型擦除，我们需要发布一个事件来解析我们要过滤的泛型参数，例如，<code>class GenericStringSpringEvent extends GenericSpringEvent</code>。</p><p>此外，还有另一种发布事件的方式。如果我们从使用 <code>@EventListener</code> 注释的方法返回一个非空值作为结果，Spring Framework 会将该结果作为新事件发送给我们。此外，我们可以通过将多个新事件作为事件处理的结果返回到集合中来发布它们。</p><h2 id=7-交易绑定事件>7. 交易绑定事件<a hidden class=anchor aria-hidden=true href=#7-交易绑定事件>#</a></h2><p>本节介绍如何使用 <code>@TransactionalEventListener</code> 注释。要了解有关事务管理的更多信息，请查看 <a href=https://www.baeldung.com/transaction-configuration-with-jpa-and-spring>Transactions With Spring and JPA</a>。</p><p>从 Spring 4.2 开始，框架提供了一个新的 <code>@TransactionalEventListener</code> 注解，它是<code>@EventListener</code> 的扩展，允许将事件的监听器绑定到事务的某个阶段。</p><p>可以对以下交易阶段进行绑定：</p><ul><li><em><code>AFTER_COMMIT</code></em>（默认）用于在事务成功完成时触发该事件。</li><li><em><code>AFTER_ROLLBACK</code></em> – 如果事务已回滚</li><li><em><code>AFTER_COMPLETION</code></em> – 如果事务已完成（<code>AFTER_COMMIT</code> 和 <code>AFTER_ROLLBACK</code> 的别名）</li><li><em><code>BEFORE_COMMIT</code></em> – 用于在事务提交之前触发该事件。</li></ul><p>这是事务事件侦听器的一个简单示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@TransactionalEventListener</span><span class=p>(</span><span class=n>phase</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TransactionPhase</span><span class=p>.</span><span class=na>BEFORE_COMMIT</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>handleCustom</span><span class=p>(</span><span class=n>CustomSpringEvent</span><span class=w> </span><span class=n>event</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Handling event inside a transaction BEFORE COMMIT.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>仅当事件生成器正在运行且即将提交的事务中时，才会调用此侦听器。</p><p>如果没有事务正在运行，则根本不会发送事件，除非我们通过将 <code>FallbackExecution</code> 属性设置为 true 来覆盖它。</p><h2 id=8-结论>8. 结论<a hidden class=anchor aria-hidden=true href=#8-结论>#</a></h2><p>在这篇简短的文章中，我们回顾了在 Spring 中处理事件的基础知识，包括创建一个简单的自定义事件、发布它，然后在侦听器中处理它。</p><p>我们还简要了解了如何在配置中启用事件的异步处理。</p><p>然后我们了解了 Spring 4.2 中引入的改进，例如注释驱动的侦听器、更好的泛型支持以及绑定到事务阶段的事件。</p><p>与往常一样，本文中提供的代码可以在 <a href=https://github.com/eugenp/tutorials/tree/master/spring-core-2>GitHub</a> 上获取。这是一个基于 Maven 的项目，因此应该很容易导入并按原样运行。</p><p>原文链接：<a href=https://www.baeldung.com/spring-events>https://www.baeldung.com/spring-events</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/java/>Java</a></li><li><a href=https://blog.chensoul.cc/tags/spring/>Spring</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/08/25/global-error-handler-in-a-spring-rest-api/><span class=title>« Prev</span><br><span>[译]REST API 的自定义错误消息处理</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/08/25/spring-security-async-principal-propagation/><span class=title>Next »</span><br><span>[译]使用@Async进行Spring Security上下文传播</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Events on x" href="https://x.com/intent/tweet/?text=%5b%e8%af%91%5dSpring%20Events&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f25%2fspring-events%2f&amp;hashtags=java%2cspring"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Events on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f25%2fspring-events%2f&amp;title=%5b%e8%af%91%5dSpring%20Events&amp;summary=%5b%e8%af%91%5dSpring%20Events&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f25%2fspring-events%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Events on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f25%2fspring-events%2f&title=%5b%e8%af%91%5dSpring%20Events"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Events on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f25%2fspring-events%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Events on whatsapp" href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5dSpring%20Events%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f25%2fspring-events%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Events on telegram" href="https://telegram.me/share/url?text=%5b%e8%af%91%5dSpring%20Events&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f25%2fspring-events%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Events on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%e8%af%91%5dSpring%20Events&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f25%2fspring-events%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>