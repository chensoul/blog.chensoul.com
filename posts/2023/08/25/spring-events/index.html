<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]Spring Events | ChenSoul</title><meta name=keywords content="java,spring"><meta name=description content="1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。
事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。
有一些简单的准则需要遵循：
如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。
2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。
在本例中，事件类保存一条字符串消息：
public class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。
要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：
@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System."><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.com/posts/2023/08/25/spring-events/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c0bdcf61a84b821409b092c03af60edc8ea542c6d2dc20cff93150bcfd67d65d.css integrity="sha256-wL3PYahLghQJsJLAOvYO3I6lQsbS3CDP+TFQvP1n1l0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.com/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.com/apple-touch-icon.png><meta name=twitter:title content="[译]Spring Events | ChenSoul"><meta name=twitter:description content="1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。
事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。
有一些简单的准则需要遵循：
如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。
2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。
在本例中，事件类保存一条字符串消息：
public class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。
要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：
@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System."><meta property="og:title" content="[译]Spring Events | ChenSoul"><meta property="og:description" content="1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。
事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。
有一些简单的准则需要遵循：
如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。
2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。
在本例中，事件类保存一条字符串消息：
public class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。
要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：
@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.com/posts/2023/08/25/spring-events/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-25T07:00:00+08:00"><meta property="article:modified_time" content="2023-08-25T07:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.com/posts/"},{"@type":"ListItem","position":2,"name":"[译]Spring Events","item":"https://blog.chensoul.com/posts/2023/08/25/spring-events/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]Spring Events | ChenSoul","name":"[译]Spring Events","description":"1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。\n事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。\n有一些简单的准则需要遵循：\n如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。\n2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。\n在本例中，事件类保存一条字符串消息：\npublic class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。\n要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：\n@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System.","keywords":["java","spring"],"wordCount":"431","inLanguage":"en","datePublished":"2023-08-25T07:00:00+08:00","dateModified":"2023-08-25T07:00:00+08:00","author":[{"@type":"Person","name":"chensoul"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.com/posts/2023/08/25/spring-events/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.com/favicon.ico"}}}</script><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.com/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.com/categories/weekly/ title=周报>周报</a></li><li><a href=https://blog.chensoul.com/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.com/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>[译]Spring Events</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-08-25</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.com/tags/java/>java</a><a href=https://blog.chensoul.com/tags/spring/>spring</a></span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>3 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e6%a6%82%e8%bf%b0 aria-label="1. 概述"><strong>1. 概述</strong></a></li><li><a href=#2-%e8%87%aa%e5%ae%9a%e4%b9%89%e4%ba%8b%e4%bb%b6 aria-label="2. 自定义事件"><strong>2. 自定义事件</strong></a><ul><li><a href=#21%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%ba%8b%e4%bb%b6 aria-label=2.1.一个简单的应用程序事件><strong>2.1.一个简单的应用程序事件</strong></a></li><li><a href=#22%e5%8f%91%e5%b8%83%e8%80%85 aria-label=2.2.发布者>2.2.发布者</a></li><li><a href=#23%e7%9b%91%e5%90%ac%e8%80%85 aria-label=2.3.监听者>2.3.监听者</a></li></ul></li><li><a href=#3-%e5%88%9b%e5%bb%ba%e5%bc%82%e6%ad%a5%e4%ba%8b%e4%bb%b6 aria-label="3. 创建异步事件">3. 创建异步事件</a></li><li><a href=#4%e7%8e%b0%e6%9c%89%e6%a1%86%e6%9e%b6%e4%ba%8b%e4%bb%b6 aria-label=4.现有框架事件>4.现有框架事件</a></li><li><a href=#5-%e6%b3%a8%e8%a7%a3%e9%a9%b1%e5%8a%a8%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8 aria-label="5. 注解驱动的事件监听器">5. 注解驱动的事件监听器</a></li><li><a href=#6-%e6%b3%9b%e5%9e%8b%e6%94%af%e6%8c%81 aria-label="6. 泛型支持">6. 泛型支持</a><ul><li><a href=#61%e9%80%9a%e7%94%a8%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%ba%8b%e4%bb%b6 aria-label=6.1.通用应用程序事件>6.1.通用应用程序事件</a></li><li><a href=#62%e7%9b%91%e5%90%ac%e8%80%85 aria-label=6.2.监听者>6.2.监听者</a></li><li><a href=#63%e5%8f%91%e5%b8%83%e8%80%85 aria-label=6.3.发布者>6.3.发布者</a></li></ul></li><li><a href=#7-%e4%ba%a4%e6%98%93%e7%bb%91%e5%ae%9a%e4%ba%8b%e4%bb%b6 aria-label="7. 交易绑定事件">7. 交易绑定事件</a></li><li><a href=#8-%e7%bb%93%e8%ae%ba aria-label="8. 结论">8. 结论</a></li></ul></div></details></div><div class=post-content><h2 id=1-概述><strong>1. 概述</strong></h2><p>在本教程中，我们将讨论如何在 Spring 中使用事件。</p><p>事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 <code>ApplicationContext</code> 提供的功能之一。</p><p>有一些简单的准则需要遵循：</p><ul><li>如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 <code>ApplicationEvent</code>。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。</li><li>发布者应该注入一个 <code>ApplicationEventPublisher</code> 对象。</li><li>监听器应该实现 <code>ApplicationListener</code> 接口。</li></ul><h2 id=2-自定义事件><strong>2. 自定义事件</strong></h2><p>Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。</p><h3 id=21一个简单的应用程序事件><strong>2.1.一个简单的应用程序事件</strong></h3><p>让我们创建一个简单的事件类——只是一个存储事件数据的占位符。</p><p>在本例中，事件类保存一条字符串消息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CustomSpringEvent</span> <span class=kd>extends</span> <span class=n>ApplicationEvent</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>message</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>CustomSpringEvent</span><span class=o>(</span><span class=n>Object</span> <span class=n>source</span><span class=o>,</span> <span class=n>String</span> <span class=n>message</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>super</span><span class=o>(</span><span class=n>source</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>message</span> <span class=o>=</span> <span class=n>message</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>getMessage</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>message</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=22发布者>2.2.发布者</h3><p>现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。</p><p>要发布事件，发布者只需注入 <code>ApplicationEventPublisher</code> 并使用 <code>publishEvent() </code>API：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CustomSpringEventPublisher</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Autowired</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>ApplicationEventPublisher</span> <span class=n>applicationEventPublisher</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>publishCustomEvent</span><span class=o>(</span><span class=kd>final</span> <span class=n>String</span> <span class=n>message</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Publishing custom event. &#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CustomSpringEvent</span> <span class=n>customSpringEvent</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CustomSpringEvent</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>message</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>applicationEventPublisher</span><span class=o>.</span><span class=na>publishEvent</span><span class=o>(</span><span class=n>customSpringEvent</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>或者，发布者类可以实现 <code>ApplicationEventPublisherAware</code> 接口，这也将在应用程序启动时注入事件发布者。通常，使用 <code>@Autowire</code> 注入发布者会更简单。</p><p>从 Spring Framework 4.2 开始，<code>ApplicationEventPublisher</code> 接口为<code>publishEvent(Object event) </code>方法提供了新的重载，该方法接受任何对象作为事件。因此，Spring 事件不再需要扩展<code>ApplicationEvent</code> 类。</p><h3 id=23监听者>2.3.监听者</h3><p>最后，让我们创建监听器。</p><p>监听器的唯一要求是是一个 bean 并实现 <code>ApplicationListener</code> 接口：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CustomSpringEventListener</span> <span class=kd>implements</span> <span class=n>ApplicationListener</span><span class=o>&lt;</span><span class=n>CustomSpringEvent</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onApplicationEvent</span><span class=o>(</span><span class=n>CustomSpringEvent</span> <span class=n>event</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Received spring custom event - &#34;</span> <span class=o>+</span> <span class=n>event</span><span class=o>.</span><span class=na>getMessage</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>请注意我们的自定义侦听器如何使用自定义事件的通用类型进行参数化，这使得 <code>onApplicationEvent() </code>方法类型安全。这也避免了必须检查对象是否是特定事件类的实例并转换它。</p><p>而且，正如已经讨论过的（默认情况下 Spring 事件是同步的）， <code>doStuffAndPublishAnEvent()</code> 方法会阻塞，直到所有侦听器完成对事件的处理。</p><h2 id=3-创建异步事件>3. 创建异步事件</h2><p>在某些情况下，同步发布事件并不是我们真正想要的——我们可能需要异步处理事件。</p><p>我们可以通过创建带有执行器的 <code>ApplicationEventMulticaster</code> bean 在配置中打开它。</p><p>出于我们的目的，<code>SimpleAsyncTaskExecutor</code> 效果很好：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>AsynchronousSpringEventsConfig</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Bean</span><span class=o>(</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;applicationEventMulticaster&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>ApplicationEventMulticaster</span> <span class=nf>simpleApplicationEventMulticaster</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>SimpleApplicationEventMulticaster</span> <span class=n>eventMulticaster</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=k>new</span> <span class=n>SimpleApplicationEventMulticaster</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>eventMulticaster</span><span class=o>.</span><span class=na>setTaskExecutor</span><span class=o>(</span><span class=k>new</span> <span class=n>SimpleAsyncTaskExecutor</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>eventMulticaster</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>事件、发布者和侦听器实现与以前相同，但现在侦听器将在单独的线程中异步处理事件。</p><h2 id=4现有框架事件>4.现有框架事件</h2><p>Spring 本身发布了各种开箱即用的事件。例如，<code>ApplicationContext</code> 将触发各种框架事件：<code>ContextRefreshedEvent</code>、<code>ContextStartedEvent</code>、<code>RequestHandledEvent</code> 等。</p><p>这些事件为应用程序开发人员提供了一个选项，可以挂钩应用程序和上下文的生命周期，并在需要时添加自己的自定义逻辑。</p><p>下面是侦听器侦听上下文刷新的简单示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ContextRefreshedListener</span>
</span></span><span class=line><span class=cl>  <span class=kd>implements</span> <span class=n>ApplicationListener</span><span class=o>&lt;</span><span class=n>ContextRefreshedEvent</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onApplicationEvent</span><span class=o>(</span><span class=n>ContextRefreshedEvent</span> <span class=n>cse</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Handling context re-freshed event. &#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=5-注解驱动的事件监听器>5. 注解驱动的事件监听器</h2><p>从 Spring 4.2 开始，事件侦听器不需要是实现 <code>ApplicationListener</code> 接口的 bean — 它可以通过 <code>@EventListener</code> 注释在托管 bean 的任何公共方法上注册：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>AnnotationDrivenEventListener</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@EventListener</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>handleContextStart</span><span class=o>(</span><span class=n>ContextStartedEvent</span> <span class=n>cse</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Handling context started event.&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>和以前一样，方法签名声明它消耗的事件类型。</p><p>默认情况下，监听器是同步调用的。但是，我们可以通过添加 @Async 注解轻松使其异步。我们只需要记住在应用程序中启用异步支持即可。</p><h2 id=6-泛型支持>6. 泛型支持</h2><p>还可以使用事件类型中的泛型信息来调度事件。</p><h3 id=61通用应用程序事件>6.1.通用应用程序事件</h3><p>让我们创建一个通用事件类型。</p><p>在我们的示例中，事件类包含任何内容和成功状态指示器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>GenericSpringEvent</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>T</span> <span class=n>what</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>protected</span> <span class=kt>boolean</span> <span class=n>success</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>GenericSpringEvent</span><span class=o>(</span><span class=n>T</span> <span class=n>what</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>success</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>what</span> <span class=o>=</span> <span class=n>what</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>success</span> <span class=o>=</span> <span class=n>success</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... standard getters
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></div><p>请注意 <code>GenericSpringEvent</code> 和 <code>CustomSpringEvent</code> 之间的区别。我们现在可以灵活地发布任何任意事件，并且不再需要从 <code>ApplicationEvent</code> 进行扩展。</p><h3 id=62监听者>6.2.监听者</h3><p>现在让我们创建该事件的侦听器。</p><p>我们可以像以前一样通过实现 <code>ApplicationListener</code> 接口来定义监听器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>GenericSpringEventListener</span>
</span></span><span class=line><span class=cl>  <span class=kd>implements</span> <span class=n>ApplicationListener</span><span class=o>&lt;</span><span class=n>GenericSpringEvent</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onApplicationEvent</span><span class=o>(</span><span class=nd>@NonNull</span> <span class=n>GenericSpringEvent</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>event</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Received spring generic event - &#34;</span> <span class=o>+</span> <span class=n>event</span><span class=o>.</span><span class=na>getWhat</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>但不幸的是这个定义要求我们从 <code>ApplicationEvent</code> 类继承 <code>GenericSpringEvent</code>。因此，在本教程中，我们将使用前面讨论的注释驱动事件侦听器。</p><p>还可以通过在 <code>@EventListener</code> 注释上定义布尔 SpEL 表达式来使事件侦听器成为有条件的。</p><p>在这种情况下，只有成功的 String <code>GenericSpringEvent</code> 才会调用事件处理程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>AnnotationDrivenEventListener</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@EventListener</span><span class=o>(</span><span class=n>condition</span> <span class=o>=</span> <span class=s>&#34;#event.success&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>handleSuccessful</span><span class=o>(</span><span class=n>GenericSpringEvent</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>event</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Handling generic event (conditional).&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Spring 表达式语言 (SpEL) 是一种功能强大的表达式语言，在另一个教程中详细介绍了它。</p><h3 id=63发布者>6.3.发布者</h3><p>事件发布者与上面描述的类似。但由于类型擦除，我们需要发布一个事件来解析我们要过滤的泛型参数，例如，<code>class GenericStringSpringEvent extends GenericSpringEvent</code>。</p><p>此外，还有另一种发布事件的方式。如果我们从使用 <code>@EventListener</code> 注释的方法返回一个非空值作为结果，Spring Framework 会将该结果作为新事件发送给我们。此外，我们可以通过将多个新事件作为事件处理的结果返回到集合中来发布它们。</p><h2 id=7-交易绑定事件>7. 交易绑定事件</h2><p>本节介绍如何使用 <code>@TransactionalEventListener</code> 注释。要了解有关事务管理的更多信息，请查看 <a href=https://www.baeldung.com/transaction-configuration-with-jpa-and-spring>Transactions With Spring and JPA</a>。</p><p>从 Spring 4.2 开始，框架提供了一个新的 <code>@TransactionalEventListener</code> 注解，它是<code>@EventListener</code> 的扩展，允许将事件的监听器绑定到事务的某个阶段。</p><p>可以对以下交易阶段进行绑定：</p><ul><li><em><code>AFTER_COMMIT</code></em>（默认）用于在事务成功完成时触发该事件。</li><li><em><code>AFTER_ROLLBACK</code></em> – 如果事务已回滚</li><li><em><code>AFTER_COMPLETION</code></em> – 如果事务已完成（<code>AFTER_COMMIT</code> 和 <code>AFTER_ROLLBACK</code> 的别名）</li><li><em><code>BEFORE_COMMIT</code></em> – 用于在事务提交之前触发该事件。</li></ul><p>这是事务事件侦听器的一个简单示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@TransactionalEventListener</span><span class=o>(</span><span class=n>phase</span> <span class=o>=</span> <span class=n>TransactionPhase</span><span class=o>.</span><span class=na>BEFORE_COMMIT</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>handleCustom</span><span class=o>(</span><span class=n>CustomSpringEvent</span> <span class=n>event</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Handling event inside a transaction BEFORE COMMIT.&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>仅当事件生成器正在运行且即将提交的事务中时，才会调用此侦听器。</p><p>如果没有事务正在运行，则根本不会发送事件，除非我们通过将 <code>FallbackExecution</code> 属性设置为 true 来覆盖它。</p><h2 id=8-结论>8. 结论</h2><p>在这篇简短的文章中，我们回顾了在 Spring 中处理事件的基础知识，包括创建一个简单的自定义事件、发布它，然后在侦听器中处理它。</p><p>我们还简要了解了如何在配置中启用事件的异步处理。</p><p>然后我们了解了 Spring 4.2 中引入的改进，例如注释驱动的侦听器、更好的泛型支持以及绑定到事务阶段的事件。</p><p>与往常一样，本文中提供的代码可以在 <a href=https://github.com/eugenp/tutorials/tree/master/spring-core-2>GitHub</a> 上获取。这是一个基于 Maven 的项目，因此应该很容易导入并按原样运行。</p><p>原文链接：<a href=https://www.baeldung.com/spring-events>https://www.baeldung.com/spring-events</a></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://blog.chensoul.com/posts/2023/08/25/spring-security-async-principal-propagation/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>[译]使用@Async进行Spring Security上下文传播</span></a>
<a class=next href=https://blog.chensoul.com/posts/2023/08/25/spring-async/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>[译]如何在Spring中执行@Async</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.chensoul.com/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a></span>
<span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script async src=https://umami.chensoul.com/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script>
<script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script><script>mediumZoom(".entry-cover img"),mediumZoom(".post-content img:not([no-zoom])")</script><script src=/js/instantclick.min.js data-no-instant></script>
<script data-no-instant>InstantClick.init()</script></body></html>