<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]Spring Security 面试问题 | ChenSoul</title>
<meta name=keywords content="java,spring security"><meta name=description content="本面试准备指南将讨论一些常见的 Spring Security 面试问题。无论您是准备面试还是只是想增强对 Spring Security 的了解，这些问题都将帮助您理解关键概念并指导您设计常见安全问题的解决方案。
1. Spring Security 的核心特性是什么？ Spring Security 提供的两个最突出的功能是身份验证和授权。这些功能在确保应用程序的安全性方面发挥着至关重要的作用。然而，Spring Security 超越了身份验证和授权，还提供了额外的功能来防止漏洞利用并与其他框架集成。
1.1.验证 身份验证是验证尝试访问应用程序的用户身份的过程。 Spring Security 提供多种身份验证方法（基于表单的身份验证、HTTP 基本身份验证、OAuth2、Siteminder、OpenID Connect、LDAP、JDBC 等），允许应用程序使用各种方法对用户进行身份验证。
它还支持自定义，当默认选项不满足要求时，可以实现自定义的身份验证机制。
1.2.授权 授权是向经过身份验证的用户或实体授予许可或权利的过程。用户或实体成功通过身份验证后，授权将决定他们可以在应用程序中访问哪些操作或资源。 Spring Security 为开发人员提供了多种方法来实现授权并控制用户对应用程序不同部分的访问。以下是一些常见的方法：
基于 Web URL 的授权：可以根据特定的 URL 或 URL 模式实施访问控制，规范哪些用户可以访问某些资源。 方法级授权：如果需要，甚至可以对 Java Bean 中的方法进行访问控制，从而在方法级提供细粒度的授权。 域实例级授权：Spring Security 提供了控制对特定域实例的访问的能力，允许基于某些实体的所有权或关联进行授权。 1.3.防止漏洞利用 Spring Security 提供了多种功能来防范常见的 Web 应用程序安全漏洞。一些显着的功能包括：
跨站请求伪造 (CSRF) 保护：Spring Security 会自动将 CSRF 令牌添加到表单和 AJAX 请求中，从而防止 CSRF 攻击。 跨站脚本 (XSS) 保护：Spring Security 支持输出编码，并提供实用程序通过清理用户输入来防止 XSS 攻击。 点击劫持保护：Spring Security 包括 X-Frame-Options 支持，以防止点击劫持攻击。 1.4.集成 Spring Security 与其他框架和库无缝集成，以增强应用程序的安全性。一些关键的集成是：
Spring MVC：Spring Security 与 Spring MVC 集成，为 Web 应用程序提供无缝的安全功能。它可以安全地处理请求、身份验证、授权并防止常见的 Web 漏洞。 Spring Data：Spring Security 与 Spring Data 集成，以便在查询中引用当前用户。这种集成确保可以根据身份验证和授权规则轻松访问和过滤用户特定的数据。 Jackson：Jackson 的支持可以实现 Spring Security 相关类的高效序列化和反序列化，特别是在使用分布式会话或 Spring Session 等框架时，从而提高效率和可扩展性。 密码学：Spring Security 与各种密码库和算法集成，以提供敏感信息的安全存储和传输。这种集成包括密码散列、加密和安全通信协议等功能，以保护数据的机密性和完整性。 有关 Spring Security 功能的更详细信息，请参阅官方文档。"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="[译]Spring Security 面试问题"><meta property="og:description" content="本面试准备指南将讨论一些常见的 Spring Security 面试问题。无论您是准备面试还是只是想增强对 Spring Security 的了解，这些问题都将帮助您理解关键概念并指导您设计常见安全问题的解决方案。
1. Spring Security 的核心特性是什么？ Spring Security 提供的两个最突出的功能是身份验证和授权。这些功能在确保应用程序的安全性方面发挥着至关重要的作用。然而，Spring Security 超越了身份验证和授权，还提供了额外的功能来防止漏洞利用并与其他框架集成。
1.1.验证 身份验证是验证尝试访问应用程序的用户身份的过程。 Spring Security 提供多种身份验证方法（基于表单的身份验证、HTTP 基本身份验证、OAuth2、Siteminder、OpenID Connect、LDAP、JDBC 等），允许应用程序使用各种方法对用户进行身份验证。
它还支持自定义，当默认选项不满足要求时，可以实现自定义的身份验证机制。
1.2.授权 授权是向经过身份验证的用户或实体授予许可或权利的过程。用户或实体成功通过身份验证后，授权将决定他们可以在应用程序中访问哪些操作或资源。 Spring Security 为开发人员提供了多种方法来实现授权并控制用户对应用程序不同部分的访问。以下是一些常见的方法：
基于 Web URL 的授权：可以根据特定的 URL 或 URL 模式实施访问控制，规范哪些用户可以访问某些资源。 方法级授权：如果需要，甚至可以对 Java Bean 中的方法进行访问控制，从而在方法级提供细粒度的授权。 域实例级授权：Spring Security 提供了控制对特定域实例的访问的能力，允许基于某些实体的所有权或关联进行授权。 1.3.防止漏洞利用 Spring Security 提供了多种功能来防范常见的 Web 应用程序安全漏洞。一些显着的功能包括：
跨站请求伪造 (CSRF) 保护：Spring Security 会自动将 CSRF 令牌添加到表单和 AJAX 请求中，从而防止 CSRF 攻击。 跨站脚本 (XSS) 保护：Spring Security 支持输出编码，并提供实用程序通过清理用户输入来防止 XSS 攻击。 点击劫持保护：Spring Security 包括 X-Frame-Options 支持，以防止点击劫持攻击。 1.4.集成 Spring Security 与其他框架和库无缝集成，以增强应用程序的安全性。一些关键的集成是：
Spring MVC：Spring Security 与 Spring MVC 集成，为 Web 应用程序提供无缝的安全功能。它可以安全地处理请求、身份验证、授权并防止常见的 Web 漏洞。 Spring Data：Spring Security 与 Spring Data 集成，以便在查询中引用当前用户。这种集成确保可以根据身份验证和授权规则轻松访问和过滤用户特定的数据。 Jackson：Jackson 的支持可以实现 Spring Security 相关类的高效序列化和反序列化，特别是在使用分布式会话或 Spring Session 等框架时，从而提高效率和可扩展性。 密码学：Spring Security 与各种密码库和算法集成，以提供敏感信息的安全存储和传输。这种集成包括密码散列、加密和安全通信协议等功能，以保护数据的机密性和完整性。 有关 Spring Security 功能的更详细信息，请参阅官方文档。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-12T00:00:00+00:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]Spring Security 面试问题"><meta name=twitter:description content="本面试准备指南将讨论一些常见的 Spring Security 面试问题。无论您是准备面试还是只是想增强对 Spring Security 的了解，这些问题都将帮助您理解关键概念并指导您设计常见安全问题的解决方案。
1. Spring Security 的核心特性是什么？ Spring Security 提供的两个最突出的功能是身份验证和授权。这些功能在确保应用程序的安全性方面发挥着至关重要的作用。然而，Spring Security 超越了身份验证和授权，还提供了额外的功能来防止漏洞利用并与其他框架集成。
1.1.验证 身份验证是验证尝试访问应用程序的用户身份的过程。 Spring Security 提供多种身份验证方法（基于表单的身份验证、HTTP 基本身份验证、OAuth2、Siteminder、OpenID Connect、LDAP、JDBC 等），允许应用程序使用各种方法对用户进行身份验证。
它还支持自定义，当默认选项不满足要求时，可以实现自定义的身份验证机制。
1.2.授权 授权是向经过身份验证的用户或实体授予许可或权利的过程。用户或实体成功通过身份验证后，授权将决定他们可以在应用程序中访问哪些操作或资源。 Spring Security 为开发人员提供了多种方法来实现授权并控制用户对应用程序不同部分的访问。以下是一些常见的方法：
基于 Web URL 的授权：可以根据特定的 URL 或 URL 模式实施访问控制，规范哪些用户可以访问某些资源。 方法级授权：如果需要，甚至可以对 Java Bean 中的方法进行访问控制，从而在方法级提供细粒度的授权。 域实例级授权：Spring Security 提供了控制对特定域实例的访问的能力，允许基于某些实体的所有权或关联进行授权。 1.3.防止漏洞利用 Spring Security 提供了多种功能来防范常见的 Web 应用程序安全漏洞。一些显着的功能包括：
跨站请求伪造 (CSRF) 保护：Spring Security 会自动将 CSRF 令牌添加到表单和 AJAX 请求中，从而防止 CSRF 攻击。 跨站脚本 (XSS) 保护：Spring Security 支持输出编码，并提供实用程序通过清理用户输入来防止 XSS 攻击。 点击劫持保护：Spring Security 包括 X-Frame-Options 支持，以防止点击劫持攻击。 1.4.集成 Spring Security 与其他框架和库无缝集成，以增强应用程序的安全性。一些关键的集成是：
Spring MVC：Spring Security 与 Spring MVC 集成，为 Web 应用程序提供无缝的安全功能。它可以安全地处理请求、身份验证、授权并防止常见的 Web 漏洞。 Spring Data：Spring Security 与 Spring Data 集成，以便在查询中引用当前用户。这种集成确保可以根据身份验证和授权规则轻松访问和过滤用户特定的数据。 Jackson：Jackson 的支持可以实现 Spring Security 相关类的高效序列化和反序列化，特别是在使用分布式会话或 Spring Session 等框架时，从而提高效率和可扩展性。 密码学：Spring Security 与各种密码库和算法集成，以提供敏感信息的安全存储和传输。这种集成包括密码散列、加密和安全通信协议等功能，以保护数据的机密性和完整性。 有关 Spring Security 功能的更详细信息，请参阅官方文档。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]Spring Security 面试问题","item":"https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]Spring Security 面试问题","name":"[译]Spring Security 面试问题","description":"本面试准备指南将讨论一些常见的 Spring Security 面试问题。无论您是准备面试还是只是想增强对 Spring Security 的了解，这些问题都将帮助您理解关键概念并指导您设计常见安全问题的解决方案。\n1. Spring Security 的核心特性是什么？ Spring Security 提供的两个最突出的功能是身份验证和授权。这些功能在确保应用程序的安全性方面发挥着至关重要的作用。然而，Spring Security 超越了身份验证和授权，还提供了额外的功能来防止漏洞利用并与其他框架集成。\n1.1.验证 身份验证是验证尝试访问应用程序的用户身份的过程。 Spring Security 提供多种身份验证方法（基于表单的身份验证、HTTP 基本身份验证、OAuth2、Siteminder、OpenID Connect、LDAP、JDBC 等），允许应用程序使用各种方法对用户进行身份验证。\n它还支持自定义，当默认选项不满足要求时，可以实现自定义的身份验证机制。\n1.2.授权 授权是向经过身份验证的用户或实体授予许可或权利的过程。用户或实体成功通过身份验证后，授权将决定他们可以在应用程序中访问哪些操作或资源。 Spring Security 为开发人员提供了多种方法来实现授权并控制用户对应用程序不同部分的访问。以下是一些常见的方法：\n基于 Web URL 的授权：可以根据特定的 URL 或 URL 模式实施访问控制，规范哪些用户可以访问某些资源。 方法级授权：如果需要，甚至可以对 Java Bean 中的方法进行访问控制，从而在方法级提供细粒度的授权。 域实例级授权：Spring Security 提供了控制对特定域实例的访问的能力，允许基于某些实体的所有权或关联进行授权。 1.3.防止漏洞利用 Spring Security 提供了多种功能来防范常见的 Web 应用程序安全漏洞。一些显着的功能包括：\n跨站请求伪造 (CSRF) 保护：Spring Security 会自动将 CSRF 令牌添加到表单和 AJAX 请求中，从而防止 CSRF 攻击。 跨站脚本 (XSS) 保护：Spring Security 支持输出编码，并提供实用程序通过清理用户输入来防止 XSS 攻击。 点击劫持保护：Spring Security 包括 X-Frame-Options 支持，以防止点击劫持攻击。 1.4.集成 Spring Security 与其他框架和库无缝集成，以增强应用程序的安全性。一些关键的集成是：\nSpring MVC：Spring Security 与 Spring MVC 集成，为 Web 应用程序提供无缝的安全功能。它可以安全地处理请求、身份验证、授权并防止常见的 Web 漏洞。 Spring Data：Spring Security 与 Spring Data 集成，以便在查询中引用当前用户。这种集成确保可以根据身份验证和授权规则轻松访问和过滤用户特定的数据。 Jackson：Jackson 的支持可以实现 Spring Security 相关类的高效序列化和反序列化，特别是在使用分布式会话或 Spring Session 等框架时，从而提高效率和可扩展性。 密码学：Spring Security 与各种密码库和算法集成，以提供敏感信息的安全存储和传输。这种集成包括密码散列、加密和安全通信协议等功能，以保护数据的机密性和完整性。 有关 Spring Security 功能的更详细信息，请参阅官方文档。","keywords":["java","spring security"],"articleBody":"本面试准备指南将讨论一些常见的 Spring Security 面试问题。无论您是准备面试还是只是想增强对 Spring Security 的了解，这些问题都将帮助您理解关键概念并指导您设计常见安全问题的解决方案。\n1. Spring Security 的核心特性是什么？ Spring Security 提供的两个最突出的功能是身份验证和授权。这些功能在确保应用程序的安全性方面发挥着至关重要的作用。然而，Spring Security 超越了身份验证和授权，还提供了额外的功能来防止漏洞利用并与其他框架集成。\n1.1.验证 身份验证是验证尝试访问应用程序的用户身份的过程。 Spring Security 提供多种身份验证方法（基于表单的身份验证、HTTP 基本身份验证、OAuth2、Siteminder、OpenID Connect、LDAP、JDBC 等），允许应用程序使用各种方法对用户进行身份验证。\n它还支持自定义，当默认选项不满足要求时，可以实现自定义的身份验证机制。\n1.2.授权 授权是向经过身份验证的用户或实体授予许可或权利的过程。用户或实体成功通过身份验证后，授权将决定他们可以在应用程序中访问哪些操作或资源。 Spring Security 为开发人员提供了多种方法来实现授权并控制用户对应用程序不同部分的访问。以下是一些常见的方法：\n基于 Web URL 的授权：可以根据特定的 URL 或 URL 模式实施访问控制，规范哪些用户可以访问某些资源。 方法级授权：如果需要，甚至可以对 Java Bean 中的方法进行访问控制，从而在方法级提供细粒度的授权。 域实例级授权：Spring Security 提供了控制对特定域实例的访问的能力，允许基于某些实体的所有权或关联进行授权。 1.3.防止漏洞利用 Spring Security 提供了多种功能来防范常见的 Web 应用程序安全漏洞。一些显着的功能包括：\n跨站请求伪造 (CSRF) 保护：Spring Security 会自动将 CSRF 令牌添加到表单和 AJAX 请求中，从而防止 CSRF 攻击。 跨站脚本 (XSS) 保护：Spring Security 支持输出编码，并提供实用程序通过清理用户输入来防止 XSS 攻击。 点击劫持保护：Spring Security 包括 X-Frame-Options 支持，以防止点击劫持攻击。 1.4.集成 Spring Security 与其他框架和库无缝集成，以增强应用程序的安全性。一些关键的集成是：\nSpring MVC：Spring Security 与 Spring MVC 集成，为 Web 应用程序提供无缝的安全功能。它可以安全地处理请求、身份验证、授权并防止常见的 Web 漏洞。 Spring Data：Spring Security 与 Spring Data 集成，以便在查询中引用当前用户。这种集成确保可以根据身份验证和授权规则轻松访问和过滤用户特定的数据。 Jackson：Jackson 的支持可以实现 Spring Security 相关类的高效序列化和反序列化，特别是在使用分布式会话或 Spring Session 等框架时，从而提高效率和可扩展性。 密码学：Spring Security 与各种密码库和算法集成，以提供敏感信息的安全存储和传输。这种集成包括密码散列、加密和安全通信协议等功能，以保护数据的机密性和完整性。 有关 Spring Security 功能的更详细信息，请参阅官方文档。\n2.解释一下 Spring Security 的核心组件？ 当谈到 Spring Security 时，几个核心组件在为 Java 应用程序提供安全功能方面发挥着至关重要的作用。这些组件协同工作以确保强大的身份验证、授权和其他安全功能。\n2.1.委托过滤代理 DelegatingFilterProxy是 Spring 框架提供的一个特殊的 Servlet Filter。它充当处理安全相关请求的入口点。当收到请求时，DelegatingFilterProxy 将请求委托给 Spring FilterChainProxy bean 进行进一步处理（springSecurityFilterChain bean）。 FilterChainProxy 利用SecurityFilterChain 来确定为当前请求调用的适当的过滤器集。\n2.2.过滤器链代理 FilterChainProxy 根据传入请求的 URL 模式和定义的安全配置确定要应用哪些过滤器。它根据配置的安全规则评估请求并选择适当的过滤器链（使用@EnableWebSecurity， FilterChainProxy 自动创建为 bean。它包装实际的安全过滤器链并充当处理请求的委托）。\n2.3.安全过滤链 当收到请求时，FilterChainProxy 会找到相应的 SecurityFilterChain 并执行该链中的过滤器列表。每个过滤器根据应用程序的安全配置执行其指定的任务。过滤器可以修改请求、执行身份验证检查、验证权限或处理与会话相关的操作。\nSpring Security 中的一些重要安全过滤器包括：\nUsernamePasswordAuthenticationFilter：此过滤器通过拦截登录请求并根据用户提供的凭据对用户进行身份验证来处理基于表单的身份验证。 BasicAuthenticationFilter：此过滤器处理基本身份验证，用户在 HTTP 标头中以用户名和密码的形式提供凭据。 RememberMeAuthenticationFilter：此过滤器启用 Remember-Me 功能，允许用户使用存储在 cookie 中的持久令牌自动登录。 LogoutFilter：此过滤器处理注销过程、使用户会话无效、清除身份验证详细信息以及执行其他操作（例如重定向到特定注销页面）。 ExceptionTranslationFilter：此过滤器捕获请求处理期间引发的任何身份验证或访问相关的异常，并将其转换为有意义的响应，例如重定向到登录页面或返回禁止的响应。 一旦请求到达SecurityFilterChain内注册的过滤器，相应的过滤器就会将请求委托给其他 bean 来执行相应的任务。例如，AuthenticationProcessingFilter 准备 Authentication 实例并将其委托给 AuthenticationManager 进行身份验证流程。\n2.4.认证管理器 AuthenticationManager 负责对用户进行身份验证。它有一个名为 authenticate () 的方法，该方法将 Authentication 实例作为参数。 authenticate () 方法负责验证所提供的凭据（在 AuthenticationProvider 的适当实现的帮助下），并在身份验证成功时返回经过身份验证的 Authentication 对象。\n默认情况下，Spring Security 提供了一个名为 ProviderManager 的 AuthenticationManager 接口的实现。 ProviderManager 将身份验证过程委托给 AuthenticationProvider 实例列表。\n2.5.认证提供者 AuthenticationProvider 负责验证特定类型的凭证或身份验证机制。它定义了针对特定源（例如用户数据库、外部身份验证服务或任何其他自定义身份验证机制）执行身份验证的合同。\n当应用程序中使用多种身份验证机制时，可以配置多个 AuthenticationProvider 实例来单独处理每种机制。\n更多信息请参考官方文档。\n3. Spring Security 如何处理用户认证？ 在较高级别上，Spring Security 通过一系列步骤处理用户身份验证。大多数步骤对于各种身份验证都是通用的，但很少有身份验证流程需要特定步骤。\n以下步骤演示了基于表单登录的身份验证，其中用户在请求中输入用户名/密码组合。\n用户尝试访问受保护的资源或发起登录请求，该请求被 Spring Security 拦截，并将我们重定向到登录页面。 身份验证过滤器 UsernamePasswordAuthenticationFilter 负责从请求中捕获用户的凭据（通常为每个对 /login 发出的请求调用 UsernamePasswordAuthenticationFilter ）。 UsernamePasswordAuthenticationFilter 提取用户名和密码并创建一个 Authentication 对象（来自 UsernamePasswordAuthenticationToken 的实例）。 然后将 Authentication 对象传递给 AuthenticationManager。 AuthenticationManager 将身份验证过程委托给一个或多个 AuthenticationProvider。 AuthenticationProvider 使用具有方法 loadUserByUsername(username) 的 UserDetailsS​​ervice bean 验证凭据。它返回包含用户数据的 UserDetails 对象。如果没有找到具有给定用户名的用户，则抛出 UsernameNotFoundException 。 如果身份验证成功，则将包含经过身份验证的用户信息的 Authentication 对象返回到 AuthenticationManager。 AuthenticationManager 将经过身份验证的 Authentication 对象存储在 SecurityContext 中。 安全上下文通常存储在线程局部变量中，使其可以在整个应用程序中访问。 用户经过身份验证后，Spring Security 允许用户访问请求的资源或继续执行请求的操作。 4. AuthenticationManager 如何确定合适的 AuthenticationProvider？ 在身份验证过程中，AuthenticationManager 接收代表用户凭据的 Authentication 对象。 AuthenticationManager 循环访问每个 AuthenticationProvider 并调用它们的 supports(Class\u003c?\u003e authentication) 方法来确定提供程序是否支持特定类型的 Authentication 对象。每个 AuthenticationProvider 都实现此方法，并且通常检查提供程序是否可以根据身份验证对象的类处理身份验证请求。\n这是 ProviderManager 源代码中的代码片段，它是 AuthenticationManager 的默认实现：\npublic Authentication authenticate(Authentication authentication) throws AuthenticationException { Class\u003c? extends Authentication\u003e toTest = authentication.getClass(); // ....... for (AuthenticationProvider provider : getProviders()) { if (!provider.supports(toTest)) { continue; } // ...... } 一旦找到支持给定身份验证对象的 AuthenticationProvider，AuthenticationManager 就会调用提供程序的 authenticate(Authentication authentication) 方法。此方法执行特定于该提供程序的身份验证逻辑，例如根据用户数据库或外部身份验证服务验证凭据。\n5. Spring Security 如何处理用户授权？ 在较高的层面上，Spring Security 通过一个涉及多个组件协同工作的过程来处理用户授权。\n以下是该过程的概述。\n一旦请求通过身份验证，就会进入授权阶段。 FilterChainProxy 调用过滤器链中适当的授权过滤器。 AuthorizationFilter 从 SecurityContextHolder 检索 Authentication 对象。然后，它将授权过程委托给 AuthorizationManager，后者负责根据配置的访问控制规则和权限做出最终的授权决策。 AuthorizationManager 取代 AccessDecisionManager 和 AccessDecisionVoter。 AuthorizationFilter 使用 Authentication 对象和 HTTP 请求构造Supplier 对象。然后将此供应商传递给RequestMatcherDelegatingAuthorizationManager 的 check () 方法，这是 Spring Security 使用的默认AuthorizationManager。 RequestMatcherDelegatingAuthorizationManager 根据配置的 RequestMatcher 实例评估提供的 Supplier ，以确定请求的资源是否与任何指定的访问控制规则匹配。 RequestMatcherDelegatingAuthorizationManager 的 check 方法返回一个 AuthorizationDecision 对象。如果授权决策是 false ，表示访问被拒绝，则会抛出异常（通常是 403 Access Denied 异常）。 另一方面，如果授权决策是 true ，表示授予访问权限，则过滤器链将继续执行，直到到达 DispatcherServlet。链中的每个过滤器执行其指定的任务，例如请求预处理、安全检查或任何其他自定义功能。 6.什么是密码编码器？默认编码器是什么？ PasswordEncoder 是一个用于使用 encode() 和 matches() 方法对密码进行编码和验证的接口。它负责获取用户的密码，应用单向哈希算法，并安全地存储哈希密码。当用户尝试登录时，输入的密码会使用相同的算法再次进行哈希处理，并将生成的哈希值与存储的哈希密码进行比较以进行身份 ​​ 验证。\n默认密码编码器是 BCryptPasswordEncoder。 BCrypt 是一种广泛使用的安全哈希算法，它结合了加盐和成本因素，以防止各种类型的攻击，包括暴力攻击。 BCryptPasswordEncoder 是密码存储的不错选择，因为它提供了高级别的安全性。\n@Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } 对于自定义要求，我们还可以配置自定义密码编码器。\n实现 PasswordEncoder 接口 创建一个实现 PasswordEncoder 接口的类。此类将提供编码和验证密码的实现。\npublic class CustomPasswordEncoder implements PasswordEncoder { @Override public String encode(CharSequence rawPassword) // Implement your password encoding logic here // Return the encoded password as a String } @Override public boolean matches(CharSequence rawPassword, String encodedPassword) { // Implement your password verification logic here // Compare the rawPassword with the encodedPassword and return true or false } } 配置自定义密码编码器 在 Spring Security 配置中，我们可以通过定义 PasswordEncoder bean 来指定自定义密码编码器的使用。 Spring Security 将使用这个 bean 进行密码编码和验证。\n@Configuration @EnableWebSecurity public class SecurityConfig { @Bean public PasswordEncoder passwordEncoder() { return new CustomPasswordEncoder(); } // Other security configuration code } 7. 如何在非 Spring boot 应用程序中启用 Spring 安全性？ 当谈到在非 Spring Boot 应用程序中启用 Spring Security 时，我们可以采取几种方法。让我们探讨两种标准方法：\n基于 Java 的配置 基于 XML 的配置 使用 AbstractSecurityWebApplicationInitializer 进行基于 Java 的配置 在 Java 配置中，我们可以通过扩展 AbstractSecurityWebApplicationInitializer 类并选择性地重写其方法来配置 DelegatingFilterProxy 并将其与 springSecurityFilterChain bean 关联来启用 Spring Security。它避免在 web.xml 文件中写入 servlet-filter 配置。\n我们可以在 SecurityConfig.java 中定义自定义安全 bean。\npublic class SpringSecurityInitializer extends AbstractSecurityWebApplicationInitializer { public SpringSecurityInitializer() { super(SecurityConfig.class); } } 基于 XML 的配置 在 XML 配置中，我们需要显式定义 DelegatingFilterProxy bean 并使用过滤器名称将其映射到 springSecurityFilterChain bean。此链接通常在 web.xml 文件中完成：\nspringSecurityFilterChain org.springframework.web.filter.DelegatingFilterProxy springSecurityFilterChain /* ERROR REQUEST 8. 如何在 Spring boot 应用程序中启用 Spring 安全性？ 如果我们使用 Spring Boot，启用 Spring Security 就非常简单。我们需要做的就是将 Spring Security starter 添加到项目的依赖项中，默认情况下自动配置将可用。这是因为当 Spring Security 位于类路径中时，WebSecurityEnablerConfiguration 会自动为我们激活 @EnableWebSecurity 注解。\norg.springframework.boot spring-boot-starter-security 9. Spring Security 中@EnableWebSecurity 的用途是什么？ @EnableWebSecurity 注解用于启用应用程序的 Web 安全性。当此注释添加到配置类时，表示该类将提供必要的配置和设置来保护 Web 应用程序。\n在非 Spring boot 应用程序中，@EnableWebSecurity 注释除了提供开发人员编写的自定义配置 bean 之外，还会隐式执行以下任务。\n创建 Spring Security 过滤器链：它初始化并配置负责处理传入请求和应用安全措施的过滤器链。 配置安全上下文：它设置用于处理身份验证和授权的安全上下文。安全上下文保存有关当前经过身份验证的用户及其授予的权限的信息。 在 Spring boot 应用程序中，使用 @EnableWebSecurity 注释是可选的。 Spring boot 安全自动配置提供了与使用@EnableWebSecurity 注释几乎相同的功能。\n当在 Spring boot 应用程序中使用 @EnableWebSecurity 时，默认的自动配置会后退，并提供的配置优先。\n@Configuration @EnableWebSecurity public class SecurityConfig { @Bean public WebSecurityCustomizer webSecurityCustomizer() { return (web) -\u003e web.ignoring() .requestMatchers(\"/resources/**\"); } @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests() .requestMatchers(\"/public/**\").permitAll() .anyRequest().hasRole(\"USER\") .and() .formLogin().permitAll(); return http.build(); } // Possibly more bean methods ... } 10. Spring Security 中的角色和权限有什么区别？ 在 Spring Security 中，角色和权限都用于定义和管理用户权限。然而，两者之间有一个微妙的区别：\n角色：角色代表广泛的权限类别或权限组。它通常用于将相关权限分组在一起。可以将角色分配给用户，并且用户可以拥有多个角色。例如，角色可以是“管理员”、“用户”或“管理员”。角色通常用于高级访问控制决策。 权限：权限也称为权限或特权，表示用户可以拥有的特定权限。它定义了细粒度的访问控制级别。权限直接或通过角色授予用户。例如，权限可以是“READ_DATA”、“WRITE_DATA”或“DELETE_DATA”。权威机构用于精确的访问控制决策。 11.如何使用注解实现方法安全？ 除了 URL 级别的安全性之外，Spring Security 还支持方法级别的安全性。要在 Spring Security 中使用注解实现方法级安全性，我们可以使用@EnableMethodSecurity 注解任何@Configuration 类。\n@Configuration @EnableWebSecurity @EnableMethodSecurity public class SecurityConfig { //.. } 现在我们可以通过@Secured、@PreAuthorize、@PostAuthorize、@PreFilter 和@PostFilter 注解来授权方法调用，包括输入参数和返回值。\n在以下示例中， deleteProduct 方法使用 @PreAuthorize 注释进行保护，表达式 hasRole('ADMIN') 确保只有具有“ADMIN”角色的用户才能调用此方法。\n@PreAuthorize(\"hasRole('ADMIN')\") public void deleteProduct(Long productId) { // Method logic for deleting a product } 默认情况下，Spring boot 中方法安全性是禁用的。\n12.什么是基本身份验证？如何实施？ 基本身份验证是一种简单的身份验证机制，其中客户端在每个请求的 HTTP 标头中包含用户名和密码（凭据以“ username:password ”格式发送，然后在包含之前进行 Base64 编码在 Authorization 标头中）。然后，服务器验证凭据，如果正确，则授予对所请求资源的访问权限。\n为了在 Spring Security 中启用基本身份验证，我们使用 *httpBasic*() 方法。\n@Bean public SecurityFilterChain securityFilterChain (HttpSecurity http) throws Exception { http.authorizeHttpRequests() .anyRequest().authenticated() .and() .httpBasic(); return http.build(); } 13.什么是 JWT 认证？如何实施？ JWT（JSON Web Token）身份验证是一种流行的身份验证机制，它使用基于 JSON 的令牌在各方之间安全地传输身份验证和授权信息。它支持无状态身份验证，并且无需在服务器端存储会话。\n要在 Spring Security 中实现 JWT 身份验证，我们可以按照以下步骤操作：\n包含必要的依赖项： spring-security-jwt 和用于 JWT 处理的库（例如 jjwt ）。 实现 JWT 令牌提供程序：创建一个负责生成 JWT 令牌的类。此类应包含用于创建和签署 JWT、设置声明以及指定过期时间的方法。 实现 JWT 身份验证过滤器：创建自定义过滤器来拦截传入请求，从请求标头中提取 JWT 令牌并对其进行验证。此过滤器应使用 JWT 令牌提供程序来验证令牌的签名并提取必要的用户详细信息。 使用 Spring Security 配置 JWT 身份验证过滤器：我们应该配置 JWT 身份验证过滤器以用于处理身份验证请求 实现用户详细信息服务：创建一个用户详细信息服务，根据 JWT 令牌中存储的信息检索用户的详细信息。该服务负责从用户存储库或任何其他数据源获取用户详细信息。 有关实现细节的更多信息，请阅读 Spring Security 中的 JWT 身份验证一文。\n14. 如何实现 OAuth2 安全性？ OAuth2 是一个授权框架，允许应用程序获得对用户帐户的有限访问权限。它涉及多个组件，包括授权服务器和资源服务器。授权服务器处理身份验证并颁发访问令牌，而资源服务器托管受保护的资源并验证访问令牌。\n要实现 OAuth2 安全性，您需要配置授权服务器和资源服务器。\n授权服务器 授权服务器负责对用户进行身份验证并颁发访问令牌。在 Spring Security 中，我们可以使用 AuthorizationServerConfigurerAdapter 类来配置授权服务器。\n以下类设置授权服务器，定义安全约束，并配置可以访问服务器的客户端以获取访问令牌以进行身份 ​​ 验证和授权。\n@Configuration @EnableAuthorizationServer public class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Autowired private BCryptPasswordEncoder passwordEncoder; @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security .tokenKeyAccess(\"permitAll()\") .checkTokenAccess(\"isAuthenticated()\"); .allowFormAuthenticationForClients(); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\"client-id\") .secret(\"client-secret\") .authorizedGrantTypes(\"authorization_code\", \"password\", \"refresh_token\") .scopes(\"read\", \"write\") .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(86400); } } 资源服务器 资源服务器托管受保护的资源并验证访问令牌。在 Spring Security 中，我们可以使用 ResourceServerConfigurerAdapter 类来配置资源服务器。\n在以下示例中，OAuth2ResourceServerConfig 通过指定不同 API 端点的访问规则来配置资源服务器。它允许不受限制地访问公共资源，同时要求对私人访问进行身份验证。\n@Configuration @EnableResourceServer public class OAuth2ResourceServerConfig extends ResourceServerConfigurerAdapter { @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/api/public/**\").permitAll() .antMatchers(\"/api/private/**\").authenticated(); } } 资源服务器需要验证访问令牌，以确保它是由受信任的授权服务器颁发的，并且没有过期或被篡改。\n一种常见的方法是使用 Spring Security 提供的 RemoteTokenServices 类。资源服务器向授权服务器的 /oauth/check_token 端点发出请求，并将访问令牌作为参数传递。\n@Bean public ResourceServerTokenServices tokenService() { RemoteTokenServices tokenServices = new RemoteTokenServices(); tokenServices.setClientId(\"client-id\"); tokenServices.setClientSecret(\"client-secret\"); tokenServices.setCheckTokenEndpointUrl(\"http://localhost:8080/oauth/check_token\"); return tokenServices; } 15. Spring Security 中的 CSRF 保护是什么？如何实施？ CSRF（跨站点请求伪造）保护是一种安全机制，可防止攻击者利用用户和网站之间的信任。它可以防范 CSRF 攻击，即攻击者在用户不知情或未同意的情况下诱骗用户的浏览器在网站上执行不需要的操作。\n要在 Spring Security 中实现 CSRF 保护，我们可以按照以下步骤操作：\n在客户端代码（通常采用 HTML 表单）中，向应用程序端点发出请求时，将 CSRF 令牌作为隐藏字段或请求标头包含在内。 在服务器端，配置 Spring Security 以期望并验证传入请求中的 CSRF 令牌。 默认情况下，Spring Security 自动启用 CSRF 保护。它将 CSRF 令牌添加到表单中并将其包含在后续请求中。\n我们可以使用 csrf() 方法在 Spring Security 中配置/自定义 CSRF 保护。\n@Configuration public class SecurityWithCsrfCookieConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .csrf() .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()); return http.build(); } } 在上面的示例中，我们将 CSRF 保护配置为使用 CookieCsrfTokenRepository 并通过设置 withHttpOnlyFalse() 确保 JavaScript 可以访问 CSRF 令牌。我们可以根据我们的需求选择不同的 CsrfTokenRepository 实现。\n16. 什么是 CORS 以及 Spring Security 中如何处理它？ CORS（跨源资源共享）是 Web 浏览器强制执行的一种安全机制，用于限制跨源 HTTP 请求。它允许服务器指定允许哪些源（域）访问其资源。\n在 Spring Security 中，有两种方法可以在我们的应用程序中配置 CORS：\n全局配置 我们可以通过创建 CorsConfigurationSource 类的 bean 来全局配置 CORS 支持。在此示例中，我们将 CORS 策略配置为允许来自指定源（本例中为 http://localhost:8081 ）的跨源请求。\n@Bean public CorsConfigurationSource corsConfigurationSource() { CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedHeader(\"*\"); config.addAllowedMethod(\"*\"); config.addAllowedOrigin(\"http://localhost:8081\"); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\"/**\", config); return source; } 处理程序方法特定的配置 如果我们只需要特定端点的 CORS，我们可以在方法级别使用 @CrossOrigin 注释。这允许我们指定允许的源、HTTP 方法和其他配置。\n在此示例中， /api/resource 端点仅允许使用指定 HTTP 方法来自 http://example.com 的跨源请求。\n@RestController public class MyController { @GetMapping(\"/api/resource\") @CrossOrigin(origins = \"http://example.com\", methods = {RequestMethod.GET, RequestMethod.POST}) public String getResource() { //... } } 17.解释一下基于会话的身份验证？ 基于会话的身份验证是 Web 应用程序中管理用户身份验证的常用方法。它涉及使用会话和 cookie 来维护身份验证状态并识别经过身份验证的用户。\n基于会话的身份验证的工作原理如下：\n用户身份验证：当用户使用有效凭据登录应用程序时，服务器会验证凭据并为用户创建新会话。会话通常由唯一的会话 ID 组成。 会话创建：服务器将用户的会话 ID 存储在会话存储（例如内存或数据库）中，并将其与用户的身份验证详细信息和任何相关会话数据（例如用户角色、权限）相关联。 会话 ID 存储：服务器将会话 ID 作为 cookie 或响应负载的一部分发送回客户端。客户端的 Web 浏览器存储此会话 ID。 后续请求：客户端的 Web 浏览器自动将会话 ID 包含在后续请求的请求标头（通常作为 cookie）中。这允许服务器识别用户的会话并检索相关的身份验证详细信息。 会话验证：服务器收到请求后，会验证会话 ID，以确保其真实性和完整性。它检查会话是否存在并且仍然有效（例如，未过期或无效）。如果会话有效，服务器将认为用户已通过身份验证并继续处理请求。 会话过期：会话通常有一个过期时间，以确保安全性和管理服务器资源。一旦会话过期，用户需要通过重新登录来重新进行身份验证。 注销：当用户注销时，服务器会通过将会话从会话存储中删除来使其无效。客户端的 Web 浏览器还会删除会话 ID cookie。 18. 如何防止暴力破解？ 防止暴力攻击涉及实施一些措施，使攻击者难以通过重复登录尝试猜测有效凭据。\n以下是我们可以用来降低暴力攻击风险的一些策略：\n帐户锁定：实施帐户锁定机制，在一定次数的登录尝试失败后临时锁定用户帐户。这可以阻止攻击者不断猜测密码。帐户被锁定后，用户可以收到通知或获得安全解锁帐户的方法，例如通过密码重置过程或联系客户支持。 速率限制：应用速率限制技术来限制特定时间范围内的登录尝试次数。这可以防止攻击者快速连续发出多个登录请求。实施速率限制可以减慢攻击过程并降低其效率，从而帮助减轻暴力攻击。 CAPTCHA 或 reCAPTCHA：将 CAPTCHA（区分计算机和人类的完全自动化公共图灵测试）或 reCAPTCHA 挑战集成到您的登录表单中。这些挑战要求用户解决谜题或输入扭曲图像中显示的字符，这有助于确保登录尝试是由人类用户而不是自动脚本进行的。 双因素身份验证 (2FA)：实施双因素身份验证以添加额外的安全层。使用 2FA，除了用户名和密码之外，用户还需要提供第二种形式的身份验证，例如发送到其移动设备的唯一代码。即使攻击者设法获得有效凭据，这也大大降低了暴力攻击成功的风险。 19. Spring Security 中如何处理注销？ 在基于会话的身份验证中，注销涉及销毁会话对象并删除用户浏览器中的会话 cookie。这可以通过配置 HttpSecurity 来实现，如下所示：\nhttp // Other security configurations... .logout() .invalidateHttpSession(true) // Invalidate the user's HttpSession .deleteCookies(\"JSESSIONID\") // Remove the session cookie .logoutSuccessUrl(\"/login?logout\") // Redirect to the logout success URL .permitAll(); // Allow anyone to access the logout URL 20. 迁移过程中如何支持多个密码编码器？ 要在 Spring Security 迁移期间支持多个密码编码器，您可以使用 Spring Security 提供的 DelegatingPasswordEncoder。 DelegatingPasswordEncoder 允许您配置多个密码编码器，并将每个编码器与标识符或“id”相关联。\n@Bean public PasswordEncoder passwordEncoder() { Map\u003cString, PasswordEncoder\u003e encoders = new HashMap\u003c\u003e(); encoders.put(\"bcrypt\", new BCryptPasswordEncoder()); encoders.put(\"custom\", new CustomPasswordEncoder()); // Replace with your custom encoder return new DelegatingPasswordEncoder(\"bcrypt\", encoders); } 在上面的例子中，我们配置了两个密码编码器：\nBCryptPasswordEncoder CustomPasswordEncoder DelegatingPasswordEncoder 使用默认编码器 ID（“bcrypt”）和编码器映射进行初始化。在身份验证过程中，Spring Security 将根据编码密码的前缀或提供的编码器 ID 确定适当的编码器。\n21.保护 REST-API 的最佳实践？ 实施 REST API 安全性涉及多种注意事项，以保护 API 免受未经授权的访问并确保数据完整性。\n身份验证：实施安全的身份验证机制来验证发出 API 请求的客户端的身份。常见方法包括基于令牌的身份验证（例如 JWT）、OAuth 2.0 或 API 密钥。选择适合应用程序要求的身份验证方法并将其集成到 API 端点中。 授权：定义访问控制规则以确定每个经过身份验证的客户端可以访问哪些操作或资源。使用基于角色或基于权限的授权机制对 API 端点实施限制。 Spring Security 提供了诸如 @PreAuthorize 或 @RolesAllowed 之类的注释来在方法或端点级别配置授权规则。 安全传输层：通过强制执行 HTTPS 确保客户端和 API 服务器之间的安全通信。这对客户端和服务器之间交换的数据进行加密，防止其被窃听和篡改。配置您的服务器以使用 SSL/TLS 证书并为所有 API 端点启用 HTTPS。 输入验证：验证和清理用户输入，以防止常见的安全漏洞，例如 SQL 注入、跨站点脚本 (XSS) 或其他注入攻击。应用输入验证技术和框架来清理和验证用户提供的数据，以降低安全漏洞的风险。 速率限制：实施速率限制机制以防止滥用并确保 API 资源的公平使用。定义特定时间段内每个客户端或每个 API 端点允许的请求数量的限制。这有助于防止 DoS（拒绝服务）攻击并确保 API 的可用性和性能。 日志记录和监控：当我们必须解决不明显且难以重现的问题时，日志记录和监控有助于在雨天进行调试。 22. Spring Security 如何与 Mobile App Security 配合使用？ Spring Security 能够与移动应用程序安全性无缝集成，提供强大的身份验证和授权功能。\n一种流行的方法是基于令牌的安全性，其中移动应用程序向服务器发送身份验证请求并获取令牌（例如 JWT）作为响应。随后，该令牌将包含在所有后续 API 请求中，以用作授权机制。\n结论 这本常见 Spring Security 面试问题和答案的综合指南探讨了身份验证、授权和 Spring Security 的各种组件等关键概念。我们深入研究了密码编码、请求匹配、方法安全注释以及与其他框架的集成等主题。通过熟悉这些面试问题及其答案，您可以在面试期间自信地处理 Spring Security 相关的讨论。\n快乐学习！\n原文链接：Spring Security Interview Questions\n","wordCount":"1336","inLanguage":"en","datePublished":"2023-10-12T00:00:00Z","dateModified":"2023-10-12T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[译]Spring Security 面试问题</h1><div class=post-meta><span title='2023-10-12 00:00:00 +0000 UTC'>2023-10-12</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1336 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-spring-security-%e7%9a%84%e6%a0%b8%e5%bf%83%e7%89%b9%e6%80%a7%e6%98%af%e4%bb%80%e4%b9%88 aria-label="1. Spring Security 的核心特性是什么？">1. Spring Security 的核心特性是什么？</a><ul><li><a href=#11%e9%aa%8c%e8%af%81 aria-label=1.1.验证>1.1.验证</a></li><li><a href=#12%e6%8e%88%e6%9d%83 aria-label=1.2.授权>1.2.授权</a></li><li><a href=#13%e9%98%b2%e6%ad%a2%e6%bc%8f%e6%b4%9e%e5%88%a9%e7%94%a8 aria-label=1.3.防止漏洞利用>1.3.防止漏洞利用</a></li><li><a href=#14%e9%9b%86%e6%88%90 aria-label=1.4.集成>1.4.集成</a></li></ul></li><li><a href=#2%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b-spring-security-%e7%9a%84%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6 aria-label="2.解释一下 Spring Security 的核心组件？">2.解释一下 Spring Security 的核心组件？</a><ul><li><a href=#21%e5%a7%94%e6%89%98%e8%bf%87%e6%bb%a4%e4%bb%a3%e7%90%86 aria-label=2.1.委托过滤代理>2.1.委托过滤代理</a></li><li><a href=#22%e8%bf%87%e6%bb%a4%e5%99%a8%e9%93%be%e4%bb%a3%e7%90%86 aria-label=2.2.过滤器链代理>2.2.过滤器链代理</a></li><li><a href=#23%e5%ae%89%e5%85%a8%e8%bf%87%e6%bb%a4%e9%93%be aria-label=2.3.安全过滤链>2.3.安全过滤链</a></li><li><a href=#24%e8%ae%a4%e8%af%81%e7%ae%a1%e7%90%86%e5%99%a8 aria-label=2.4.认证管理器>2.4.认证管理器</a></li><li><a href=#25%e8%ae%a4%e8%af%81%e6%8f%90%e4%be%9b%e8%80%85 aria-label=2.5.认证提供者>2.5.认证提供者</a></li></ul></li><li><a href=#3-spring-security-%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e7%94%a8%e6%88%b7%e8%ae%a4%e8%af%81 aria-label="3. Spring Security 如何处理用户认证？">3. Spring Security 如何处理用户认证？</a></li><li><a href=#4-authenticationmanager-%e5%a6%82%e4%bd%95%e7%a1%ae%e5%ae%9a%e5%90%88%e9%80%82%e7%9a%84-authenticationprovider aria-label="4. AuthenticationManager 如何确定合适的 AuthenticationProvider？">4. AuthenticationManager 如何确定合适的 AuthenticationProvider？</a></li><li><a href=#5-spring-security-%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e7%94%a8%e6%88%b7%e6%8e%88%e6%9d%83 aria-label="5. Spring Security 如何处理用户授权？">5. Spring Security 如何处理用户授权？</a></li><li><a href=#6%e4%bb%80%e4%b9%88%e6%98%af%e5%af%86%e7%a0%81%e7%bc%96%e7%a0%81%e5%99%a8%e9%bb%98%e8%ae%a4%e7%bc%96%e7%a0%81%e5%99%a8%e6%98%af%e4%bb%80%e4%b9%88 aria-label=6.什么是密码编码器？默认编码器是什么？>6.什么是密码编码器？默认编码器是什么？</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0-passwordencoder-%e6%8e%a5%e5%8f%a3 aria-label="实现 PasswordEncoder 接口">实现 PasswordEncoder 接口</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e8%87%aa%e5%ae%9a%e4%b9%89%e5%af%86%e7%a0%81%e7%bc%96%e7%a0%81%e5%99%a8 aria-label=配置自定义密码编码器>配置自定义密码编码器</a></li></ul></li><li><a href=#7-%e5%a6%82%e4%bd%95%e5%9c%a8%e9%9d%9e-spring-boot-%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%ad%e5%90%af%e7%94%a8-spring-%e5%ae%89%e5%85%a8%e6%80%a7 aria-label="7. 如何在非 Spring boot 应用程序中启用 Spring 安全性？">7. 如何在非 Spring boot 应用程序中启用 Spring 安全性？</a><ul><li><a href=#%e4%bd%bf%e7%94%a8-abstractsecuritywebapplicationinitializer-%e8%bf%9b%e8%a1%8c%e5%9f%ba%e4%ba%8e-java-%e7%9a%84%e9%85%8d%e7%bd%ae aria-label="使用 AbstractSecurityWebApplicationInitializer 进行基于 Java 的配置">使用 AbstractSecurityWebApplicationInitializer 进行基于 Java 的配置</a></li><li><a href=#%e5%9f%ba%e4%ba%8e-xml-%e7%9a%84%e9%85%8d%e7%bd%ae aria-label="基于 XML 的配置">基于 XML 的配置</a></li></ul></li><li><a href=#8-%e5%a6%82%e4%bd%95%e5%9c%a8-spring-boot-%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%ad%e5%90%af%e7%94%a8-spring-%e5%ae%89%e5%85%a8%e6%80%a7 aria-label="8. 如何在 Spring boot 应用程序中启用 Spring 安全性？">8. 如何在 Spring boot 应用程序中启用 Spring 安全性？</a></li><li><a href=#9-spring-security-%e4%b8%adenablewebsecurity-%e7%9a%84%e7%94%a8%e9%80%94%e6%98%af%e4%bb%80%e4%b9%88 aria-label="9. Spring Security 中@EnableWebSecurity 的用途是什么？">9. Spring Security 中@EnableWebSecurity 的用途是什么？</a></li><li><a href=#10-spring-security-%e4%b8%ad%e7%9a%84%e8%a7%92%e8%89%b2%e5%92%8c%e6%9d%83%e9%99%90%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="10. Spring Security 中的角色和权限有什么区别？">10. Spring Security 中的角色和权限有什么区别？</a></li><li><a href=#11%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e6%b3%a8%e8%a7%a3%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95%e5%ae%89%e5%85%a8 aria-label=11.如何使用注解实现方法安全？>11.如何使用注解实现方法安全？</a></li><li><a href=#12%e4%bb%80%e4%b9%88%e6%98%af%e5%9f%ba%e6%9c%ac%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e5%a6%82%e4%bd%95%e5%ae%9e%e6%96%bd aria-label=12.什么是基本身份验证？如何实施？>12.什么是基本身份验证？如何实施？</a></li><li><a href=#13%e4%bb%80%e4%b9%88%e6%98%af-jwt-%e8%ae%a4%e8%af%81%e5%a6%82%e4%bd%95%e5%ae%9e%e6%96%bd aria-label="13.什么是 JWT 认证？如何实施？">13.什么是 JWT 认证？如何实施？</a></li><li><a href=#14-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-oauth2-%e5%ae%89%e5%85%a8%e6%80%a7 aria-label="14. 如何实现 OAuth2 安全性？">14. 如何实现 OAuth2 安全性？</a><ul><li><a href=#%e6%8e%88%e6%9d%83%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label=授权服务器>授权服务器</a></li><li><a href=#%e8%b5%84%e6%ba%90%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label=资源服务器>资源服务器</a></li></ul></li><li><a href=#15-spring-security-%e4%b8%ad%e7%9a%84-csrf-%e4%bf%9d%e6%8a%a4%e6%98%af%e4%bb%80%e4%b9%88%e5%a6%82%e4%bd%95%e5%ae%9e%e6%96%bd aria-label="15. Spring Security 中的 CSRF 保护是什么？如何实施？">15. Spring Security 中的 CSRF 保护是什么？如何实施？</a></li><li><a href=#16-%e4%bb%80%e4%b9%88%e6%98%af-cors-%e4%bb%a5%e5%8f%8a-spring-security-%e4%b8%ad%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e5%ae%83 aria-label="16. 什么是 CORS 以及 Spring Security 中如何处理它？">16. 什么是 CORS 以及 Spring Security 中如何处理它？</a><ul><li><a href=#%e5%85%a8%e5%b1%80%e9%85%8d%e7%bd%ae aria-label=全局配置>全局配置</a></li><li><a href=#%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f%e6%96%b9%e6%b3%95%e7%89%b9%e5%ae%9a%e7%9a%84%e9%85%8d%e7%bd%ae aria-label=处理程序方法特定的配置>处理程序方法特定的配置</a></li></ul></li><li><a href=#17%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b%e5%9f%ba%e4%ba%8e%e4%bc%9a%e8%af%9d%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81 aria-label=17.解释一下基于会话的身份验证？>17.解释一下基于会话的身份验证？</a></li><li><a href=#18-%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e6%9a%b4%e5%8a%9b%e7%a0%b4%e8%a7%a3 aria-label="18. 如何防止暴力破解？">18. 如何防止暴力破解？</a></li><li><a href=#19-spring-security-%e4%b8%ad%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e6%b3%a8%e9%94%80 aria-label="19. Spring Security 中如何处理注销？">19. Spring Security 中如何处理注销？</a></li><li><a href=#20-%e8%bf%81%e7%a7%bb%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%a6%82%e4%bd%95%e6%94%af%e6%8c%81%e5%a4%9a%e4%b8%aa%e5%af%86%e7%a0%81%e7%bc%96%e7%a0%81%e5%99%a8 aria-label="20. 迁移过程中如何支持多个密码编码器？">20. 迁移过程中如何支持多个密码编码器？</a></li><li><a href=#21%e4%bf%9d%e6%8a%a4-rest-api-%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5 aria-label="21.保护 REST-API 的最佳实践？">21.保护 REST-API 的最佳实践？</a></li><li><a href=#22-spring-security-%e5%a6%82%e4%bd%95%e4%b8%8e-mobile-app-security-%e9%85%8d%e5%90%88%e4%bd%bf%e7%94%a8 aria-label="22. Spring Security 如何与 Mobile App Security 配合使用？">22. Spring Security 如何与 Mobile App Security 配合使用？</a></li><li><a href=#%e7%bb%93%e8%ae%ba aria-label=结论>结论</a></li></ul></div></details></div><div class=post-content><p>本面试准备指南将讨论一些常见的 Spring Security 面试问题。无论您是准备面试还是只是想增强对 Spring Security 的了解，这些问题都将帮助您理解关键概念并指导您设计常见安全问题的解决方案。</p><h2 id=1-spring-security-的核心特性是什么>1. Spring Security 的核心特性是什么？<a hidden class=anchor aria-hidden=true href=#1-spring-security-的核心特性是什么>#</a></h2><p>Spring Security 提供的两个最突出的功能是身份验证和授权。这些功能在确保应用程序的安全性方面发挥着至关重要的作用。然而，Spring Security 超越了身份验证和授权，还提供了额外的功能来防止漏洞利用并与其他框架集成。</p><h3 id=11验证>1.1.验证<a hidden class=anchor aria-hidden=true href=#11验证>#</a></h3><p>身份验证是验证尝试访问应用程序的用户身份的过程。 Spring Security 提供多种身份验证方法（基于表单的身份验证、HTTP 基本身份验证、OAuth2、Siteminder、OpenID Connect、LDAP、JDBC 等），允许应用程序使用各种方法对用户进行身份验证。</p><p>它还支持自定义，当默认选项不满足要求时，可以实现自定义的身份验证机制。</p><h3 id=12授权>1.2.授权<a hidden class=anchor aria-hidden=true href=#12授权>#</a></h3><p>授权是向经过身份验证的用户或实体授予许可或权利的过程。用户或实体成功通过身份验证后，授权将决定他们可以在应用程序中访问哪些操作或资源。 Spring Security 为开发人员提供了多种方法来实现授权并控制用户对应用程序不同部分的访问。以下是一些常见的方法：</p><ul><li><strong>基于 Web URL 的授权</strong>：可以根据特定的 URL 或 URL 模式实施访问控制，规范哪些用户可以访问某些资源。</li><li><strong>方法级授权</strong>：如果需要，甚至可以对 Java Bean 中的方法进行访问控制，从而在方法级提供细粒度的授权。</li><li><strong>域实例级授权</strong>：Spring Security 提供了控制对特定域实例的访问的能力，允许基于某些实体的所有权或关联进行授权。</li></ul><h3 id=13防止漏洞利用>1.3.防止漏洞利用<a hidden class=anchor aria-hidden=true href=#13防止漏洞利用>#</a></h3><p>Spring Security 提供了多种功能来防范常见的 Web 应用程序安全漏洞。一些显着的功能包括：</p><ul><li><strong>跨站请求伪造 (CSRF) 保护</strong>：Spring Security 会自动将 CSRF 令牌添加到表单和 AJAX 请求中，从而防止 CSRF 攻击。</li><li><strong>跨站脚本 (XSS) 保护</strong>：Spring Security 支持输出编码，并提供实用程序通过清理用户输入来防止 XSS 攻击。</li><li><strong>点击劫持保护</strong>：Spring Security 包括 X-Frame-Options 支持，以防止点击劫持攻击。</li></ul><h3 id=14集成>1.4.集成<a hidden class=anchor aria-hidden=true href=#14集成>#</a></h3><p>Spring Security 与其他框架和库无缝集成，以增强应用程序的安全性。一些关键的集成是：</p><ul><li><strong>Spring MVC</strong>：Spring Security 与 Spring MVC 集成，为 Web 应用程序提供无缝的安全功能。它可以安全地处理请求、身份验证、授权并防止常见的 Web 漏洞。</li><li><strong>Spring Data</strong>：Spring Security 与 Spring Data 集成，以便在查询中引用当前用户。这种集成确保可以根据身份验证和授权规则轻松访问和过滤用户特定的数据。</li><li><strong>Jackson</strong>：Jackson 的支持可以实现 Spring Security 相关类的高效序列化和反序列化，特别是在使用分布式会话或 Spring Session 等框架时，从而提高效率和可扩展性。</li><li><strong>密码学</strong>：Spring Security 与各种密码库和算法集成，以提供敏感信息的安全存储和传输。这种集成包括密码散列、加密和安全通信协议等功能，以保护数据的机密性和完整性。</li></ul><p>有关 Spring Security 功能的更详细信息，请参阅<a href=https://docs.spring.io/spring-security/reference/features/index.html>官方文档</a>。</p><h2 id=2解释一下-spring-security-的核心组件>2.解释一下 Spring Security 的核心组件？<a hidden class=anchor aria-hidden=true href=#2解释一下-spring-security-的核心组件>#</a></h2><p>当谈到 Spring Security 时，几个核心组件在为 Java 应用程序提供安全功能方面发挥着至关重要的作用。这些组件协同工作以确保强大的身份验证、授权和其他安全功能。</p><p><img loading=lazy src=https://howtodoinjava.com/wp-content/uploads/2023/05/Spring-Security-Architechture.svg alt=Spring-Security-Architechture></p><h3 id=21委托过滤代理>2.1.委托过滤代理<a hidden class=anchor aria-hidden=true href=#21委托过滤代理>#</a></h3><p><code>DelegatingFilterProxy</code>是 Spring 框架提供的一个特殊的 Servlet Filter。它充当处理安全相关请求的入口点。当收到请求时，<code>DelegatingFilterProxy</code> 将请求委托给 Spring FilterChainProxy bean 进行进一步处理（<code>springSecurityFilterChain</code> bean）。 <code>FilterChainProxy</code> 利用<code>SecurityFilterChain</code> 来确定为当前请求调用的适当的过滤器集。</p><h3 id=22过滤器链代理>2.2.过滤器链代理<a hidden class=anchor aria-hidden=true href=#22过滤器链代理>#</a></h3><p><code>FilterChainProxy</code> 根据传入请求的 URL 模式和定义的安全配置确定要应用哪些过滤器。它根据配置的安全规则评估请求并选择适当的过滤器链（使用<code>@EnableWebSecurity</code>， <code>FilterChainProxy</code> 自动创建为 bean。它包装实际的安全过滤器链并充当处理请求的委托）。</p><h3 id=23安全过滤链>2.3.安全过滤链<a hidden class=anchor aria-hidden=true href=#23安全过滤链>#</a></h3><p>当收到请求时，<code>FilterChainProxy</code> 会找到相应的 <code>SecurityFilterChain</code> 并执行该链中的过滤器列表。每个过滤器根据应用程序的安全配置执行其指定的任务。过滤器可以修改请求、执行身份验证检查、验证权限或处理与会话相关的操作。</p><p>Spring Security 中的一些重要安全过滤器包括：</p><ul><li><code>UsernamePasswordAuthenticationFilter</code>：此过滤器通过拦截登录请求并根据用户提供的凭据对用户进行身份验证来处理基于表单的身份验证。</li><li><code>BasicAuthenticationFilter</code>：此过滤器处理基本身份验证，用户在 HTTP 标头中以用户名和密码的形式提供凭据。</li><li><code>RememberMeAuthenticationFilter</code>：此过滤器启用 <code>Remember-Me</code> 功能，允许用户使用存储在 cookie 中的持久令牌自动登录。</li><li><code>LogoutFilter</code>：此过滤器处理注销过程、使用户会话无效、清除身份验证详细信息以及执行其他操作（例如重定向到特定注销页面）。</li><li><code>ExceptionTranslationFilter</code>：此过滤器捕获请求处理期间引发的任何身份验证或访问相关的异常，并将其转换为有意义的响应，例如重定向到登录页面或返回禁止的响应。</li></ul><p>一旦请求到达<code>SecurityFilterChain</code>内注册的过滤器，相应的过滤器就会将请求委托给其他 bean 来执行相应的任务。例如，<code>AuthenticationProcessingFilter</code> 准备 <code>Authentication</code> 实例并将其委托给 <code>AuthenticationManager</code> 进行身份验证流程。</p><p><img loading=lazy src=https://howtodoinjava.com/wp-content/uploads/2022/05/Custom-Authentication-Flow-1024x551.jpg alt=img></p><h3 id=24认证管理器>2.4.认证管理器<a hidden class=anchor aria-hidden=true href=#24认证管理器>#</a></h3><p><code>AuthenticationManager</code> 负责对用户进行身份验证。它有一个名为 <code>authenticate</code> () 的方法，该方法将 <code>Authentication</code> 实例作为参数。 <code>authenticate</code> () 方法负责验证所提供的凭据（在 <code>AuthenticationProvider</code> 的适当实现的帮助下），并在身份验证成功时返回经过身份验证的 <code>Authentication</code> 对象。</p><p>默认情况下，Spring Security 提供了一个名为 <code>ProviderManager</code> 的 <code>AuthenticationManager</code> 接口的实现。 <code>ProviderManager</code> 将身份验证过程委托给 <code>AuthenticationProvider</code> 实例列表。</p><h3 id=25认证提供者>2.5.认证提供者<a hidden class=anchor aria-hidden=true href=#25认证提供者>#</a></h3><p><code>AuthenticationProvider</code> 负责验证特定类型的凭证或身份验证机制。它定义了针对特定源（例如用户数据库、外部身份验证服务或任何其他自定义身份验证机制）执行身份验证的合同。</p><p>当应用程序中使用多种身份验证机制时，可以配置多个 <code>AuthenticationProvider</code> 实例来单独处理每种机制。</p><p>更多信息请参考<a href=https://docs.spring.io/spring-security/reference/servlet/architecture.html>官方文档</a>。</p><h2 id=3-spring-security-如何处理用户认证>3. Spring Security 如何处理用户认证？<a hidden class=anchor aria-hidden=true href=#3-spring-security-如何处理用户认证>#</a></h2><p>在较高级别上，Spring Security 通过一系列步骤处理用户身份验证。大多数步骤对于各种身份验证都是通用的，但很少有身份验证流程需要特定步骤。</p><p>以下步骤演示了基于表单登录的身份验证，其中用户在请求中输入用户名/密码组合。</p><p><img loading=lazy src=https://howtodoinjava.com/wp-content/uploads/2023/05/Login-WorkFlow-1-1024x572.png alt=img></p><ul><li>用户尝试访问受保护的资源或发起登录请求，该请求被 Spring Security 拦截，并将我们重定向到登录页面。</li><li>身份验证过滤器 <code>UsernamePasswordAuthenticationFilter</code> 负责从请求中捕获用户的凭据（通常为每个对 /login 发出的请求调用 <code>UsernamePasswordAuthenticationFilter</code> ）。</li><li><code>UsernamePasswordAuthenticationFilter</code> 提取用户名和密码并创建一个 Authentication 对象（来自 <code>UsernamePasswordAuthenticationToken</code> 的实例）。</li><li>然后将 <code>Authentication</code> 对象传递给 <code>AuthenticationManager</code>。</li><li><code>AuthenticationManager</code> 将身份验证过程委托给一个或多个 <code>AuthenticationProvider</code>。</li><li><code>AuthenticationProvider</code> 使用具有方法 <code>loadUserByUsername(username)</code> 的 <code>UserDetailsS</code>​​ervice bean 验证凭据。它返回包含用户数据的 <code>UserDetails</code> 对象。如果没有找到具有给定用户名的用户，则抛出 <code>UsernameNotFoundException</code> 。</li><li>如果身份验证成功，则将包含经过身份验证的用户信息的 <code>Authentication</code> 对象返回到 <code>AuthenticationManager</code>。</li><li><code>AuthenticationManager</code> 将经过身份验证的 <code>Authentication</code> 对象存储在 <code>SecurityContext</code> 中。</li><li>安全上下文通常存储在线程局部变量中，使其可以在整个应用程序中访问。</li><li>用户经过身份验证后，Spring Security 允许用户访问请求的资源或继续执行请求的操作。</li></ul><h2 id=4-authenticationmanager-如何确定合适的-authenticationprovider>4. AuthenticationManager 如何确定合适的 AuthenticationProvider？<a hidden class=anchor aria-hidden=true href=#4-authenticationmanager-如何确定合适的-authenticationprovider>#</a></h2><p>在身份验证过程中，<code>AuthenticationManager</code> 接收代表用户凭据的 <code>Authentication</code> 对象。 <code>AuthenticationManager</code> 循环访问每个 <code>AuthenticationProvider</code> 并调用它们的 <code>supports(Class&lt;?> authentication)</code> 方法来确定提供程序是否支持特定类型的 <code>Authentication</code> 对象。每个 <code>AuthenticationProvider</code> 都实现此方法，并且通常检查提供程序是否可以根据身份验证对象的类处理身份验证请求。</p><p>这是 <code>ProviderManager</code> 源代码中的代码片段，它是 <code>AuthenticationManager</code> 的默认实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=n>Authentication</span><span class=w> </span><span class=nf>authenticate</span><span class=p>(</span><span class=n>Authentication</span><span class=w> </span><span class=n>authentication</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>AuthenticationException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>Class</span><span class=o>&lt;?</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Authentication</span><span class=o>&gt;</span><span class=w> </span><span class=n>toTest</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>authentication</span><span class=p>.</span><span class=na>getClass</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// .......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>AuthenticationProvider</span><span class=w> </span><span class=n>provider</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>getProviders</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>provider</span><span class=p>.</span><span class=na>supports</span><span class=p>(</span><span class=n>toTest</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>               </span><span class=c1>// ......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>一旦找到支持给定身份验证对象的 <code>AuthenticationProvider</code>，<code>AuthenticationManager</code> 就会调用提供程序的 <code>authenticate(Authentication authentication)</code> 方法。此方法执行特定于该提供程序的身份验证逻辑，例如根据用户数据库或外部身份验证服务验证凭据。</p><h2 id=5-spring-security-如何处理用户授权>5. Spring Security 如何处理用户授权？<a hidden class=anchor aria-hidden=true href=#5-spring-security-如何处理用户授权>#</a></h2><p>在较高的层面上，Spring Security 通过一个涉及多个组件协同工作的过程来处理用户授权。</p><p><img loading=lazy src=https://howtodoinjava.com/wp-content/uploads/2023/05/Auth-WorkFlow-1-1024x647.png alt=img></p><p>以下是该过程的概述。</p><ul><li>一旦请求通过身份验证，就会进入授权阶段。 <code>FilterChainProxy</code> 调用过滤器链中适当的授权过滤器。</li><li><code>AuthorizationFilter</code> 从 <code>SecurityContextHolder</code> 检索 <code>Authentication</code> 对象。然后，它将授权过程委托给 <code>AuthorizationManager</code>，后者负责根据配置的访问控制规则和权限做出最终的授权决策。 <code>AuthorizationManager</code> 取代 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code>。</li><li><code>AuthorizationFilter</code> 使用 <code>Authentication</code> 对象和 HTTP 请求构造<code>Supplier</code> 对象。然后将此供应商传递给<code>RequestMatcherDelegatingAuthorizationManager</code> 的 <code>check</code> () 方法，这是 Spring Security 使用的默认<code>AuthorizationManager</code>。</li><li><code>RequestMatcherDelegatingAuthorizationManager</code> 根据配置的 <code>RequestMatcher</code> 实例评估提供的 <code>Supplier</code> ，以确定请求的资源是否与任何指定的访问控制规则匹配。</li><li><code>RequestMatcherDelegatingAuthorizationManager</code> 的 <code>check</code> 方法返回一个 <code>AuthorizationDecision</code> 对象。如果授权决策是 <code>false</code> ，表示访问被拒绝，则会抛出异常（通常是 <code>403 Access Denied</code> 异常）。</li><li>另一方面，如果授权决策是 <code>true</code> ，表示授予访问权限，则过滤器链将继续执行，直到到达 <code>DispatcherServlet</code>。链中的每个过滤器执行其指定的任务，例如请求预处理、安全检查或任何其他自定义功能。</li></ul><h2 id=6什么是密码编码器默认编码器是什么>6.什么是密码编码器？默认编码器是什么？<a hidden class=anchor aria-hidden=true href=#6什么是密码编码器默认编码器是什么>#</a></h2><p><code>PasswordEncoder</code> 是一个用于使用 <code>encode()</code> 和 <code>matches() </code>方法对密码进行编码和验证的接口。它负责获取用户的密码，应用单向哈希算法，并安全地存储哈希密码。当用户尝试登录时，输入的密码会使用相同的算法再次进行哈希处理，并将生成的哈希值与存储的哈希密码进行比较以进行身份 ​​ 验证。</p><p>默认密码编码器是 <code>BCryptPasswordEncoder</code>。 BCrypt 是一种广泛使用的安全哈希算法，它结合了加盐和成本因素，以防止各种类型的攻击，包括暴力攻击。 <code>BCryptPasswordEncoder</code> 是密码存储的不错选择，因为它提供了高级别的安全性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>PasswordEncoder</span><span class=w> </span><span class=nf>passwordEncoder</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>BCryptPasswordEncoder</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>对于自定义要求，我们还可以配置自定义密码编码器。</p><h3 id=实现-passwordencoder-接口>实现 PasswordEncoder 接口<a hidden class=anchor aria-hidden=true href=#实现-passwordencoder-接口>#</a></h3><p>创建一个实现 <code>PasswordEncoder</code> 接口的类。此类将提供编码和验证密码的实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CustomPasswordEncoder</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>PasswordEncoder</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>encode</span><span class=p>(</span><span class=n>CharSequence</span><span class=w> </span><span class=n>rawPassword</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Implement your password encoding logic here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Return the encoded password as a String</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>matches</span><span class=p>(</span><span class=n>CharSequence</span><span class=w> </span><span class=n>rawPassword</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>encodedPassword</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Implement your password verification logic here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Compare the rawPassword with the encodedPassword and return true or false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=配置自定义密码编码器>配置自定义密码编码器<a hidden class=anchor aria-hidden=true href=#配置自定义密码编码器>#</a></h3><p>在 Spring Security 配置中，我们可以通过定义 <code>PasswordEncoder</code> bean 来指定自定义密码编码器的使用。 Spring Security 将使用这个 bean 进行密码编码和验证。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@EnableWebSecurity</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SecurityConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>PasswordEncoder</span><span class=w> </span><span class=nf>passwordEncoder</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CustomPasswordEncoder</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Other security configuration code</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=7-如何在非-spring-boot-应用程序中启用-spring-安全性>7. 如何在非 Spring boot 应用程序中启用 Spring 安全性？<a hidden class=anchor aria-hidden=true href=#7-如何在非-spring-boot-应用程序中启用-spring-安全性>#</a></h2><p>当谈到在非 Spring Boot 应用程序中启用 Spring Security 时，我们可以采取几种方法。让我们探讨两种标准方法：</p><ul><li>基于 Java 的配置</li><li>基于 XML 的配置</li></ul><h3 id=使用-abstractsecuritywebapplicationinitializer-进行基于-java-的配置>使用 AbstractSecurityWebApplicationInitializer 进行基于 Java 的配置<a hidden class=anchor aria-hidden=true href=#使用-abstractsecuritywebapplicationinitializer-进行基于-java-的配置>#</a></h3><p>在 Java 配置中，我们可以通过扩展 <code>AbstractSecurityWebApplicationInitializer</code> 类并选择性地重写其方法来配置 <code>DelegatingFilterProxy</code> 并将其与 <code>springSecurityFilterChain</code> bean 关联来启用 Spring Security。它避免在 <code>web.xml</code> 文件中写入 servlet-filter 配置。</p><p>我们可以在 SecurityConfig.java 中定义自定义安全 bean。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SpringSecurityInitializer</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>AbstractSecurityWebApplicationInitializer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=nf>SpringSecurityInitializer</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=kd>super</span><span class=p>(</span><span class=n>SecurityConfig</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=基于-xml-的配置>基于 XML 的配置<a hidden class=anchor aria-hidden=true href=#基于-xml-的配置>#</a></h3><p>在 XML 配置中，我们需要显式定义 <code>DelegatingFilterProxy</code> bean 并使用过滤器名称将其映射到 <code>springSecurityFilterChain</code> bean。此链接通常在 web.xml 文件中完成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;filter&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;filter-name&gt;</span>springSecurityFilterChain<span class=nt>&lt;/filter-name&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;filter-class&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class=nt>&lt;/filter-class&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/filter&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;filter-mapping&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;filter-name&gt;</span>springSecurityFilterChain<span class=nt>&lt;/filter-name&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;url-pattern&gt;</span>/*<span class=nt>&lt;/url-pattern&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;dispatcher&gt;</span>ERROR<span class=nt>&lt;/dispatcher&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;dispatcher&gt;</span>REQUEST<span class=nt>&lt;/dispatcher&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/filter-mapping&gt;</span>
</span></span></code></pre></div><h2 id=8-如何在-spring-boot-应用程序中启用-spring-安全性>8. 如何在 Spring boot 应用程序中启用 Spring 安全性？<a hidden class=anchor aria-hidden=true href=#8-如何在-spring-boot-应用程序中启用-spring-安全性>#</a></h2><p>如果我们使用 Spring Boot，启用 Spring Security 就非常简单。我们需要做的就是将 Spring Security starter 添加到项目的依赖项中，默认情况下自动配置将可用。这是因为当 Spring Security 位于类路径中时，<code>WebSecurityEnablerConfiguration</code> 会自动为我们激活 @EnableWebSecurity 注解。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;dependency&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;groupId&gt;</span>org.springframework.boot<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;artifactId&gt;</span>spring-boot-starter-security<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/dependency&gt;</span>
</span></span></code></pre></div><h2 id=9-spring-security-中enablewebsecurity-的用途是什么>9. Spring Security 中@EnableWebSecurity 的用途是什么？<a hidden class=anchor aria-hidden=true href=#9-spring-security-中enablewebsecurity-的用途是什么>#</a></h2><p><code>@EnableWebSecurity</code> 注解用于启用应用程序的 Web 安全性。当此注释添加到配置类时，表示该类将提供必要的配置和设置来保护 Web 应用程序。</p><p>在非 Spring boot 应用程序中，@EnableWebSecurity 注释除了提供开发人员编写的自定义配置 bean 之外，还会隐式执行以下任务。</p><ul><li>创建 Spring Security 过滤器链：它初始化并配置负责处理传入请求和应用安全措施的过滤器链。</li><li>配置安全上下文：它设置用于处理身份验证和授权的安全上下文。安全上下文保存有关当前经过身份验证的用户及其授予的权限的信息。</li></ul><p>在 Spring boot 应用程序中，使用 @EnableWebSecurity 注释是可选的。 Spring boot 安全自动配置提供了与使用@EnableWebSecurity 注释几乎相同的功能。</p><p>当在 Spring boot 应用程序中使用 @EnableWebSecurity 时，默认的自动配置会后退，并提供的配置优先。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@EnableWebSecurity</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SecurityConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>WebSecurityCustomizer</span><span class=w> </span><span class=nf>webSecurityCustomizer</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=n>web</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>web</span><span class=p>.</span><span class=na>ignoring</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>requestMatchers</span><span class=p>(</span><span class=s>&#34;/resources/**&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>SecurityFilterChain</span><span class=w> </span><span class=nf>securityFilterChain</span><span class=p>(</span><span class=n>HttpSecurity</span><span class=w> </span><span class=n>http</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>http</span><span class=p>.</span><span class=na>authorizeHttpRequests</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>requestMatchers</span><span class=p>(</span><span class=s>&#34;/public/**&#34;</span><span class=p>).</span><span class=na>permitAll</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>anyRequest</span><span class=p>().</span><span class=na>hasRole</span><span class=p>(</span><span class=s>&#34;USER&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>and</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>formLogin</span><span class=p>().</span><span class=na>permitAll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>http</span><span class=p>.</span><span class=na>build</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Possibly more bean methods ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=10-spring-security-中的角色和权限有什么区别>10. Spring Security 中的角色和权限有什么区别？<a hidden class=anchor aria-hidden=true href=#10-spring-security-中的角色和权限有什么区别>#</a></h2><p>在 Spring Security 中，角色和权限都用于定义和管理用户权限。然而，两者之间有一个微妙的区别：</p><ul><li><strong>角色</strong>：角色代表广泛的权限类别或权限组。它通常用于将相关权限分组在一起。可以将角色分配给用户，并且用户可以拥有多个角色。例如，角色可以是“管理员”、“用户”或“管理员”。角色通常用于高级访问控制决策。</li><li><strong>权限</strong>：权限也称为权限或特权，表示用户可以拥有的特定权限。它定义了细粒度的访问控制级别。权限直接或通过角色授予用户。例如，权限可以是“READ_DATA”、“WRITE_DATA”或“DELETE_DATA”。权威机构用于精确的访问控制决策。</li></ul><h2 id=11如何使用注解实现方法安全>11.如何使用注解实现方法安全？<a hidden class=anchor aria-hidden=true href=#11如何使用注解实现方法安全>#</a></h2><p>除了 URL 级别的安全性之外，Spring Security 还支持方法级别的安全性。要在 Spring Security 中使用注解实现方法级安全性，我们可以使用@EnableMethodSecurity 注解任何@Configuration 类。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@EnableWebSecurity</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@EnableMethodSecurity</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SecurityConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//..</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>现在我们可以通过@Secured、@PreAuthorize、@PostAuthorize、@PreFilter 和@PostFilter 注解来授权方法调用，包括输入参数和返回值。</p><p>在以下示例中， <code>deleteProduct</code> 方法使用 @PreAuthorize 注释进行保护，表达式 <code>hasRole('ADMIN')</code> 确保只有具有“ADMIN”角色的用户才能调用此方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@PreAuthorize</span><span class=p>(</span><span class=s>&#34;hasRole(&#39;ADMIN&#39;)&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>deleteProduct</span><span class=p>(</span><span class=n>Long</span><span class=w> </span><span class=n>productId</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Method logic for deleting a product</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>默认情况下，Spring boot 中方法安全性是禁用的。</p><h2 id=12什么是基本身份验证如何实施>12.什么是基本身份验证？如何实施？<a hidden class=anchor aria-hidden=true href=#12什么是基本身份验证如何实施>#</a></h2><p>基本身份验证是一种简单的身份验证机制，其中客户端在每个请求的 HTTP 标头中包含用户名和密码（凭据以“ <code>username:password</code> ”格式发送，然后在包含之前进行 Base64 编码在 <code>Authorization</code> 标头中）。然后，服务器验证凭据，如果正确，则授予对所请求资源的访问权限。</p><p>为了在 Spring Security 中启用基本身份验证，我们使用 <code>*httpBasic*()</code> 方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>SecurityFilterChain</span><span class=w> </span><span class=nf>securityFilterChain</span><span class=w> </span><span class=p>(</span><span class=n>HttpSecurity</span><span class=w> </span><span class=n>http</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>http</span><span class=p>.</span><span class=na>authorizeHttpRequests</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>anyRequest</span><span class=p>().</span><span class=na>authenticated</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>and</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=na>httpBasic</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>http</span><span class=p>.</span><span class=na>build</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=13什么是-jwt-认证如何实施>13.什么是 JWT 认证？如何实施？<a hidden class=anchor aria-hidden=true href=#13什么是-jwt-认证如何实施>#</a></h2><p>JWT（JSON Web Token）身份验证是一种流行的身份验证机制，它使用基于 JSON 的令牌在各方之间安全地传输身份验证和授权信息。它支持无状态身份验证，并且无需在服务器端存储会话。</p><p><img loading=lazy src=https://howtodoinjava.com/wp-content/uploads/2023/05/Jwt-Workflow-1024x448.png alt=img></p><p>要在 Spring Security 中实现 JWT 身份验证，我们可以按照以下步骤操作：</p><ul><li><strong>包含必要的依赖项</strong>： <code>spring-security-jwt</code> 和用于 JWT 处理的库（例如 <code>jjwt</code> ）。</li><li><strong>实现 JWT 令牌提供程序</strong>：创建一个负责生成 JWT 令牌的类。此类应包含用于创建和签署 JWT、设置声明以及指定过期时间的方法。</li><li><strong>实现 JWT 身份验证过滤器</strong>：创建自定义过滤器来拦截传入请求，从请求标头中提取 JWT 令牌并对其进行验证。此过滤器应使用 JWT 令牌提供程序来验证令牌的签名并提取必要的用户详细信息。</li><li><strong>使用 Spring Security 配置 JWT 身份验证过滤器</strong>：我们应该配置 JWT 身份验证过滤器以用于处理身份验证请求</li><li><strong>实现用户详细信息服务</strong>：创建一个用户详细信息服务，根据 JWT 令牌中存储的信息检索用户的详细信息。该服务负责从用户存储库或任何其他数据源获取用户详细信息。</li></ul><p>有关实现细节的更多信息，请阅读 <a href=https://howtodoinjava.com/spring-security/jwt-auth-vuejs-spring-boot-security/>Spring Security 中的 JWT 身份验证</a>一文。</p><h2 id=14-如何实现-oauth2-安全性>14. 如何实现 OAuth2 安全性？<a hidden class=anchor aria-hidden=true href=#14-如何实现-oauth2-安全性>#</a></h2><p>OAuth2 是一个授权框架，允许应用程序获得对用户帐户的有限访问权限。它涉及多个组件，包括授权服务器和资源服务器。授权服务器处理身份验证并颁发访问令牌，而资源服务器托管受保护的资源并验证访问令牌。</p><p>要<a href=https://howtodoinjava.com/spring-security/oauth2-login-with-spring-boot-security/>实现 OAuth2 安全性</a>，您需要<a href=https://howtodoinjava.com/spring-boot2/oauth2-auth-server/>配置授权服务器和资源服务器</a>。</p><h3 id=授权服务器>授权服务器<a hidden class=anchor aria-hidden=true href=#授权服务器>#</a></h3><p>授权服务器负责对用户进行身份验证并颁发访问令牌。在 Spring Security 中，我们可以使用 AuthorizationServerConfigurerAdapter 类来配置授权服务器。</p><p>以下类设置授权服务器，定义安全约束，并配置可以访问服务器的客户端以获取访问令牌以进行身份 ​​ 验证和授权。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@EnableAuthorizationServer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>OAuth2AuthorizationServer</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>AuthorizationServerConfigurerAdapter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>BCryptPasswordEncoder</span><span class=w> </span><span class=n>passwordEncoder</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>configure</span><span class=p>(</span><span class=n>AuthorizationServerSecurityConfigurer</span><span class=w> </span><span class=n>security</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>security</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>tokenKeyAccess</span><span class=p>(</span><span class=s>&#34;permitAll()&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>checkTokenAccess</span><span class=p>(</span><span class=s>&#34;isAuthenticated()&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>allowFormAuthenticationForClients</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>configure</span><span class=p>(</span><span class=n>ClientDetailsServiceConfigurer</span><span class=w> </span><span class=n>clients</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>clients</span><span class=p>.</span><span class=na>inMemory</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>withClient</span><span class=p>(</span><span class=s>&#34;client-id&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>secret</span><span class=p>(</span><span class=s>&#34;client-secret&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>authorizedGrantTypes</span><span class=p>(</span><span class=s>&#34;authorization_code&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;password&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;refresh_token&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>scopes</span><span class=p>(</span><span class=s>&#34;read&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;write&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>accessTokenValiditySeconds</span><span class=p>(</span><span class=n>3600</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>refreshTokenValiditySeconds</span><span class=p>(</span><span class=n>86400</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=资源服务器>资源服务器<a hidden class=anchor aria-hidden=true href=#资源服务器>#</a></h3><p>资源服务器托管受保护的资源并验证访问令牌。在 Spring Security 中，我们可以使用 ResourceServerConfigurerAdapter 类来配置资源服务器。</p><p>在以下示例中，OAuth2ResourceServerConfig 通过指定不同 API 端点的访问规则来配置资源服务器。它允许不受限制地访问公共资源，同时要求对私人访问进行身份验证。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@EnableResourceServer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>OAuth2ResourceServerConfig</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>ResourceServerConfigurerAdapter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>configure</span><span class=p>(</span><span class=n>HttpSecurity</span><span class=w> </span><span class=n>http</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>http</span><span class=p>.</span><span class=na>authorizeRequests</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>antMatchers</span><span class=p>(</span><span class=s>&#34;/api/public/**&#34;</span><span class=p>).</span><span class=na>permitAll</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>antMatchers</span><span class=p>(</span><span class=s>&#34;/api/private/**&#34;</span><span class=p>).</span><span class=na>authenticated</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>资源服务器需要验证访问令牌，以确保它是由受信任的授权服务器颁发的，并且没有过期或被篡改。</p><p>一种常见的方法是使用 Spring Security 提供的 <code>RemoteTokenServices</code> 类。资源服务器向授权服务器的 <code>/oauth/check_token</code> 端点发出请求，并将访问令牌作为参数传递。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>ResourceServerTokenServices</span><span class=w> </span><span class=nf>tokenService</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>RemoteTokenServices</span><span class=w> </span><span class=n>tokenServices</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RemoteTokenServices</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>tokenServices</span><span class=p>.</span><span class=na>setClientId</span><span class=p>(</span><span class=s>&#34;client-id&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>tokenServices</span><span class=p>.</span><span class=na>setClientSecret</span><span class=p>(</span><span class=s>&#34;client-secret&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>tokenServices</span><span class=p>.</span><span class=na>setCheckTokenEndpointUrl</span><span class=p>(</span><span class=s>&#34;http://localhost:8080/oauth/check_token&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>return</span><span class=w> </span><span class=n>tokenServices</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=15-spring-security-中的-csrf-保护是什么如何实施>15. Spring Security 中的 CSRF 保护是什么？如何实施？<a hidden class=anchor aria-hidden=true href=#15-spring-security-中的-csrf-保护是什么如何实施>#</a></h2><p>CSRF（跨站点请求伪造）保护是一种安全机制，可防止攻击者利用用户和网站之间的信任。它可以防范 CSRF 攻击，即攻击者在用户不知情或未同意的情况下诱骗用户的浏览器在网站上执行不需要的操作。</p><p>要在 Spring Security 中实现 CSRF 保护，我们可以按照以下步骤操作：</p><ul><li>在客户端代码（通常采用 HTML 表单）中，向应用程序端点发出请求时，将 CSRF 令牌作为隐藏字段或请求标头包含在内。</li><li>在服务器端，配置 Spring Security 以期望并验证传入请求中的 CSRF 令牌。</li></ul><p>默认情况下，Spring Security 自动启用 CSRF 保护。它将 CSRF 令牌添加到表单中并将其包含在后续请求中。</p><p>我们可以使用 <code>csrf()</code> 方法在 Spring Security 中配置/自定义 CSRF 保护。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SecurityWithCsrfCookieConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>SecurityFilterChain</span><span class=w> </span><span class=nf>filterChain</span><span class=p>(</span><span class=n>HttpSecurity</span><span class=w> </span><span class=n>http</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>.</span><span class=na>csrf</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>.</span><span class=na>csrfTokenRepository</span><span class=p>(</span><span class=n>CookieCsrfTokenRepository</span><span class=p>.</span><span class=na>withHttpOnlyFalse</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>http</span><span class=p>.</span><span class=na>build</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上面的示例中，我们将 CSRF 保护配置为使用 CookieCsrfTokenRepository 并通过设置 <code>withHttpOnlyFalse()</code> 确保 JavaScript 可以访问 CSRF 令牌。我们可以根据我们的需求选择不同的 <code>CsrfTokenRepository</code> 实现。</p><h2 id=16-什么是-cors-以及-spring-security-中如何处理它>16. 什么是 CORS 以及 Spring Security 中如何处理它？<a hidden class=anchor aria-hidden=true href=#16-什么是-cors-以及-spring-security-中如何处理它>#</a></h2><p>CORS（跨源资源共享）是 Web 浏览器强制执行的一种安全机制，用于限制跨源 HTTP 请求。它允许服务器指定允许哪些源（域）访问其资源。</p><p>在 Spring Security 中，有两种方法可以在我们的应用程序中配置 CORS：</p><h3 id=全局配置>全局配置<a hidden class=anchor aria-hidden=true href=#全局配置>#</a></h3><p>我们可以通过创建 CorsConfigurationSource 类的 bean 来全局配置 CORS 支持。在此示例中，我们将 CORS 策略配置为允许来自指定源（本例中为 <code>http://localhost:8081</code> ）的跨源请求。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>CorsConfigurationSource</span><span class=w> </span><span class=nf>corsConfigurationSource</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>CorsConfiguration</span><span class=w> </span><span class=n>config</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CorsConfiguration</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>config</span><span class=p>.</span><span class=na>setAllowCredentials</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>config</span><span class=p>.</span><span class=na>addAllowedHeader</span><span class=p>(</span><span class=s>&#34;*&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>config</span><span class=p>.</span><span class=na>addAllowedMethod</span><span class=p>(</span><span class=s>&#34;*&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>config</span><span class=p>.</span><span class=na>addAllowedOrigin</span><span class=p>(</span><span class=s>&#34;http://localhost:8081&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>UrlBasedCorsConfigurationSource</span><span class=w> </span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>UrlBasedCorsConfigurationSource</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>source</span><span class=p>.</span><span class=na>registerCorsConfiguration</span><span class=p>(</span><span class=s>&#34;/**&#34;</span><span class=p>,</span><span class=w> </span><span class=n>config</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>source</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=处理程序方法特定的配置>处理程序方法特定的配置<a hidden class=anchor aria-hidden=true href=#处理程序方法特定的配置>#</a></h3><p>如果我们只需要特定端点的 CORS，我们可以在方法级别使用 <code>@CrossOrigin</code> 注释。这允许我们指定允许的源、HTTP 方法和其他配置。</p><p>在此示例中， <code>/api/resource</code> 端点仅允许使用指定 HTTP 方法来自 <code>http://example.com</code> 的跨源请求。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GetMapping</span><span class=p>(</span><span class=s>&#34;/api/resource&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@CrossOrigin</span><span class=p>(</span><span class=n>origins</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;http://example.com&#34;</span><span class=p>,</span><span class=w> </span><span class=n>methods</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=n>RequestMethod</span><span class=p>.</span><span class=na>GET</span><span class=p>,</span><span class=w> </span><span class=n>RequestMethod</span><span class=p>.</span><span class=na>POST</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>getResource</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=17解释一下基于会话的身份验证>17.解释一下基于会话的身份验证？<a hidden class=anchor aria-hidden=true href=#17解释一下基于会话的身份验证>#</a></h2><p>基于会话的身份验证是 Web 应用程序中管理用户身份验证的常用方法。它涉及使用会话和 cookie 来维护身份验证状态并识别经过身份验证的用户。</p><p><img loading=lazy src=https://howtodoinjava.com/wp-content/uploads/2023/05/session-based-auth-1024x545.png alt=img></p><p>基于会话的身份验证的工作原理如下：</p><ul><li><strong>用户身份验证</strong>：当用户使用有效凭据登录应用程序时，服务器会验证凭据并为用户创建新会话。会话通常由唯一的会话 ID 组成。</li><li><strong>会话创建</strong>：服务器将用户的会话 ID 存储在会话存储（例如内存或数据库）中，并将其与用户的身份验证详细信息和任何相关会话数据（例如用户角色、权限）相关联。</li><li><strong>会话 ID 存储</strong>：服务器将会话 ID 作为 cookie 或响应负载的一部分发送回客户端。客户端的 Web 浏览器存储此会话 ID。</li><li><strong>后续请求</strong>：客户端的 Web 浏览器自动将会话 ID 包含在后续请求的请求标头（通常作为 cookie）中。这允许服务器识别用户的会话并检索相关的身份验证详细信息。</li><li><strong>会话验证</strong>：服务器收到请求后，会验证会话 ID，以确保其真实性和完整性。它检查会话是否存在并且仍然有效（例如，未过期或无效）。如果会话有效，服务器将认为用户已通过身份验证并继续处理请求。</li><li><strong>会话过期</strong>：会话通常有一个过期时间，以确保安全性和管理服务器资源。一旦会话过期，用户需要通过重新登录来重新进行身份验证。</li><li><strong>注销</strong>：当用户注销时，服务器会通过将会话从会话存储中删除来使其无效。客户端的 Web 浏览器还会删除会话 ID cookie。</li></ul><h2 id=18-如何防止暴力破解>18. 如何防止暴力破解？<a hidden class=anchor aria-hidden=true href=#18-如何防止暴力破解>#</a></h2><p>防止暴力攻击涉及实施一些措施，使攻击者难以通过重复登录尝试猜测有效凭据。</p><p>以下是我们可以用来降低暴力攻击风险的一些策略：</p><ul><li><strong>帐户锁定</strong>：实施帐户锁定机制，在一定次数的登录尝试失败后临时锁定用户帐户。这可以阻止攻击者不断猜测密码。帐户被锁定后，用户可以收到通知或获得安全解锁帐户的方法，例如通过密码重置过程或联系客户支持。</li><li><strong>速率限制</strong>：应用速率限制技术来限制特定时间范围内的登录尝试次数。这可以防止攻击者快速连续发出多个登录请求。实施速率限制可以减慢攻击过程并降低其效率，从而帮助减轻暴力攻击。</li><li><strong>CAPTCHA 或 reCAPTCHA</strong>：将 CAPTCHA（区分计算机和人类的完全自动化公共图灵测试）或 reCAPTCHA 挑战集成到您的登录表单中。这些挑战要求用户解决谜题或输入扭曲图像中显示的字符，这有助于确保登录尝试是由人类用户而不是自动脚本进行的。</li><li><strong>双因素身份验证 (2FA)</strong>：实施双因素身份验证以添加额外的安全层。使用 2FA，除了用户名和密码之外，用户还需要提供第二种形式的身份验证，例如发送到其移动设备的唯一代码。即使攻击者设法获得有效凭据，这也大大降低了暴力攻击成功的风险。</li></ul><h2 id=19-spring-security-中如何处理注销>19. Spring Security 中如何处理注销？<a hidden class=anchor aria-hidden=true href=#19-spring-security-中如何处理注销>#</a></h2><p>在基于会话的身份验证中，注销涉及销毁会话对象并删除用户浏览器中的会话 cookie。这可以通过配置 <code>HttpSecurity</code> 来实现，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Other security configurations...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=na>logout</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>invalidateHttpSession</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=c1>// Invalidate the user&#39;s HttpSession</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>deleteCookies</span><span class=p>(</span><span class=s>&#34;JSESSIONID&#34;</span><span class=p>)</span><span class=w> </span><span class=c1>// Remove the session cookie</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>logoutSuccessUrl</span><span class=p>(</span><span class=s>&#34;/login?logout&#34;</span><span class=p>)</span><span class=w> </span><span class=c1>// Redirect to the logout success URL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>permitAll</span><span class=p>();</span><span class=w> </span><span class=c1>// Allow anyone to access the logout URL</span><span class=w>
</span></span></span></code></pre></div><h2 id=20-迁移过程中如何支持多个密码编码器>20. 迁移过程中如何支持多个密码编码器？<a hidden class=anchor aria-hidden=true href=#20-迁移过程中如何支持多个密码编码器>#</a></h2><p>要在 Spring Security 迁移期间支持多个密码编码器，您可以使用 Spring Security 提供的 DelegatingPasswordEncoder。 DelegatingPasswordEncoder 允许您配置多个密码编码器，并将每个编码器与标识符或“id”相关联。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>PasswordEncoder</span><span class=w> </span><span class=nf>passwordEncoder</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>PasswordEncoder</span><span class=o>&gt;</span><span class=w> </span><span class=n>encoders</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>encoders</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;bcrypt&#34;</span><span class=p>,</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>BCryptPasswordEncoder</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>encoders</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;custom&#34;</span><span class=p>,</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CustomPasswordEncoder</span><span class=p>());</span><span class=w> </span><span class=c1>// Replace with your custom encoder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DelegatingPasswordEncoder</span><span class=p>(</span><span class=s>&#34;bcrypt&#34;</span><span class=p>,</span><span class=w> </span><span class=n>encoders</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上面的例子中，我们配置了两个密码编码器：</p><ul><li><code>BCryptPasswordEncoder</code></li><li><code>CustomPasswordEncoder</code></li></ul><p><code>DelegatingPasswordEncoder</code> 使用默认编码器 ID（“bcrypt”）和编码器映射进行初始化。在身份验证过程中，Spring Security 将根据编码密码的前缀或提供的编码器 ID 确定适当的编码器。</p><h2 id=21保护-rest-api-的最佳实践>21.保护 REST-API 的最佳实践？<a hidden class=anchor aria-hidden=true href=#21保护-rest-api-的最佳实践>#</a></h2><p>实施 REST API 安全性涉及多种注意事项，以保护 API 免受未经授权的访问并确保数据完整性。</p><ul><li><code>身份验证</code>：实施安全的身份验证机制来验证发出 API 请求的客户端的身份。常见方法包括基于令牌的身份验证（例如 JWT）、OAuth 2.0 或 API 密钥。选择适合应用程序要求的身份验证方法并将其集成到 API 端点中。</li><li><code>授权</code>：定义访问控制规则以确定每个经过身份验证的客户端可以访问哪些操作或资源。使用基于角色或基于权限的授权机制对 API 端点实施限制。 Spring Security 提供了诸如 <code>@PreAuthorize</code> 或 <code>@RolesAllowed</code> 之类的注释来在方法或端点级别配置授权规则。</li><li><code>安全传输层</code>：通过强制执行 HTTPS 确保客户端和 API 服务器之间的安全通信。这对客户端和服务器之间交换的数据进行加密，防止其被窃听和篡改。配置您的服务器以使用 SSL/TLS 证书并为所有 API 端点启用 HTTPS。</li><li><code>输入验证</code>：验证和清理用户输入，以防止常见的安全漏洞，例如 SQL 注入、跨站点脚本 (XSS) 或其他注入攻击。应用输入验证技术和框架来清理和验证用户提供的数据，以降低安全漏洞的风险。</li><li><code>速率限制</code>：实施速率限制机制以防止滥用并确保 API 资源的公平使用。定义特定时间段内每个客户端或每个 API 端点允许的请求数量的限制。这有助于防止 DoS（拒绝服务）攻击并确保 API 的可用性和性能。</li><li><code>日志记录和监控</code>：当我们必须解决不明显且难以重现的问题时，日志记录和监控有助于在雨天进行调试。</li></ul><h2 id=22-spring-security-如何与-mobile-app-security-配合使用>22. Spring Security 如何与 Mobile App Security 配合使用？<a hidden class=anchor aria-hidden=true href=#22-spring-security-如何与-mobile-app-security-配合使用>#</a></h2><p>Spring Security 能够与移动应用程序安全性无缝集成，提供强大的身份验证和授权功能。</p><p>一种流行的方法是基于令牌的安全性，其中移动应用程序向服务器发送身份验证请求并获取令牌（例如 JWT）作为响应。随后，该令牌将包含在所有后续 API 请求中，以用作授权机制。</p><h2 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h2><p>这本常见 Spring Security 面试问题和答案的综合指南探讨了身份验证、授权和 Spring Security 的各种组件等关键概念。我们深入研究了密码编码、请求匹配、方法安全注释以及与其他框架的集成等主题。通过熟悉这些面试问题及其答案，您可以在面试期间自信地处理 Spring Security 相关的讨论。</p><p>快乐学习！</p><p>原文链接：<a href=https://howtodoinjava.com/interview-questions/spring-security-interview-questions/>Spring Security Interview Questions</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/java/>Java</a></li><li><a href=https://blog.chensoul.cc/tags/spring-security/>Spring-Security</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/10/12/git-interview-questions/><span class=title>« Prev</span><br><span>[译]DevOps 和测试人员的 Git 面试问题</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/10/12/http-in-depth/><span class=title>Next »</span><br><span>[译]关于 HTTP 您需要了解的一切</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Security 面试问题 on x" href="https://x.com/intent/tweet/?text=%5b%e8%af%91%5dSpring%20Security%20%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f12%2fspring-security-interview-questions%2f&amp;hashtags=java%2cspringsecurity"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Security 面试问题 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f12%2fspring-security-interview-questions%2f&amp;title=%5b%e8%af%91%5dSpring%20Security%20%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98&amp;summary=%5b%e8%af%91%5dSpring%20Security%20%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f12%2fspring-security-interview-questions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Security 面试问题 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f12%2fspring-security-interview-questions%2f&title=%5b%e8%af%91%5dSpring%20Security%20%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Security 面试问题 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f12%2fspring-security-interview-questions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Security 面试问题 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5dSpring%20Security%20%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f12%2fspring-security-interview-questions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Security 面试问题 on telegram" href="https://telegram.me/share/url?text=%5b%e8%af%91%5dSpring%20Security%20%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f12%2fspring-security-interview-questions%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]Spring Security 面试问题 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%e8%af%91%5dSpring%20Security%20%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f12%2fspring-security-interview-questions%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>