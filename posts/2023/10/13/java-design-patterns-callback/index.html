<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="本文主要介绍 Callback 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。"><title>Java设计模式：Callback | ChenSoul</title>
<link rel=canonical href=https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/raw-images/favicon.jpg"><meta name=twitter:title content="Java设计模式：Callback"><meta name=twitter:description content="本文主要介绍 Callback 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="Java设计模式：Callback"><meta property="og:description" content="本文主要介绍 Callback 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-13T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-13T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="og:image" content="https://blog.chensoul.cc/raw-images/favicon.jpg"><meta itemprop=name content="Java设计模式：Callback"><meta itemprop=description content="本文主要介绍 Callback 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。"><meta itemprop=datePublished content="2023-10-13T00:00:00+00:00"><meta itemprop=dateModified content="2023-10-13T00:00:00+00:00"><meta itemprop=wordCount content="300"><meta itemprop=image content="https://blog.chensoul.cc/raw-images/favicon.jpg"><meta itemprop=keywords content="Java"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"Java设计模式：Callback","headline":"Java设计模式：Callback","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/","description":"\u003cp\u003e本文主要介绍 \u003ca href=\"https://java-design-patterns.com/zh/patterns/callback/\" target=\"_blank\"\u003eCallback\u003c/a\u003e 模式，在 \u003ca href=\"https://java-design-patterns.com/\" target=\"_blank\"\u003eJava Design Patterns\u003c/a\u003e 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。\u003c/p\u003e","wordCount":"300","keywords":["java"],"datePublished":"2023-10-13T00:00:00Z","dateModified":"2023-10-13T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://twitter.com/","https://github.com/chensoul","https://www.linkedin.com/in/"]}]}</script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/ rel=bookmark title=Java设计模式：Callback>Java设计模式：Callback</a></h2><hr><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2023-10-13T00:00:00>2023-10-13
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/java/ title=java>java</a></span></div></header><div class=entry-content><p>本文主要介绍 <a href=https://java-design-patterns.com/zh/patterns/callback/ target=_blank>Callback</a> 模式，在 <a href=https://java-design-patterns.com/ target=_blank>Java Design Patterns</a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。</p><h2 id=介绍>介绍</h2><p>回调（Callback）是一种设计模式，在这种模式中，一个可执行的代码被作为参数传递给其他代码，接收方的代码可以在适当的时候调用它。</p><p>在真实世界的例子中，当我们需要在任务完成时被通知时，我们可以将一个回调方法传递给调用者，并等待它调用以通知我们。简单地说，回调是一个传递给调用者的方法，在定义的时刻被调用。</p><p>维基百科说</p><blockquote><p>在计算机编程中，回调又被称为“稍后调用”函数，可以是任何可执行的代码用来作为参数传递给其他代码；其它代码被期望在给定时间内调用回调方法。</p></blockquote><h2 id=代码>代码</h2><p>回调是一个只有一个方法的简单接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Callback</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>call</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面我们定义一个任务它将在任务执行完成后执行回调。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Task</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>executeWith</span>(Callback callback) {
</span></span><span style=display:flex><span>    execute();
</span></span><span style=display:flex><span>    Optional.<span style=color:#a6e22e>ofNullable</span>(callback).<span style=color:#a6e22e>ifPresent</span>(Callback::call);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SimpleTask</span> <span style=color:#66d9ef>extends</span> Task {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Logger LOGGER <span style=color:#f92672>=</span> getLogger(SimpleTask.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>() {
</span></span><span style=display:flex><span>    LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Perform some important activity and after call the callback method.&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后这里是我们如何执行一个任务然后接收一个回调当它完成时。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>var</span> task <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SimpleTask();
</span></span><span style=display:flex><span>task.<span style=color:#a6e22e>executeWith</span>(() <span style=color:#f92672>-&gt;</span> LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;I&#39;m done now.&#34;</span>));
</span></span></code></pre></div><h2 id=类图>类图</h2><p><img src=https://java-design-patterns.com/assets/callback-a632b2a4.png alt="alt text"></p><h2 id=适用场景>适用场景</h2><p>回调模式适用于以下场景：</p><ol><li>异步操作：当需要在异步操作完成后执行某些操作时，可以使用回调模式。例如，在网络请求中，可以传递一个回调函数，在请求完成后调用该函数处理响应数据。</li><li>事件处理：当需要对事件进行响应和处理时，可以使用回调模式。例如，在图形界面开发中，可以注册某个控件的回调函数，以便在用户触发事件时执行相应的操作。</li><li>插件扩展：当需要为应用程序提供扩展性，允许第三方插件在特定事件发生时进行自定义操作时，可以使用回调模式。例如，游戏引擎中的事件系统允许开发者注册回调函数以响应游戏中的特定事件。</li><li>回调链：当需要按特定顺序执行多个回调函数，并将前一个回调函数的结果传递给下一个回调函数时，可以使用回调模式。这种情况下，回调函数形成了一个回调链。</li><li>模板方法模式：回调模式常与模板方法模式结合使用。模板方法模式定义了一个算法的骨架，而具体的步骤由子类实现。可以使用回调模式将子类中的具体步骤作为回调函数传递给模板方法。</li></ol><p>总的来说，回调模式适用于需要在特定事件发生后执行某些操作的情况，以及需要实现解耦和灵活性的场景。它提供了一种在代码间通信的方式，使得代码可以更加模块化和可复用。</p><h2 id=java-例子>Java 例子</h2><ul><li><a href=http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html target=_blank>CyclicBarrier</a> 构造函数可以接受回调，该回调将在每次障碍被触发时触发。</li></ul><h2 id=faq>FAQ</h2><h3 id=回调模式如何实现解耦和灵活性>回调模式如何实现解耦和灵活性？</h3><p>回调模式通过将一个可执行的代码块（回调函数）作为参数传递给其他代码，实现了解耦和灵活性。</p><ul><li><p>解耦性：回调模式可以将调用方与被调用方解耦，使它们之间的关系更加松散。调用方只需要知道回调函数的接口，而不需要了解具体的实现细节。被调用方在特定的时机调用回调函数，而不需要知道调用方的具体实现。这种解耦性使得系统中的不同部分可以独立地进行修改和扩展，而不会对彼此产生过多的依赖。</p></li><li><p>灵活性：回调模式提供了一种灵活的扩展机制。通过传递不同的回调函数，可以改变程序的行为或逻辑，而不需要修改原有的代码。这种灵活性使得系统可以适应不同的需求和变化，而不需要进行大规模的修改或重构。同时，回调模式也允许在运行时动态地修改回调函数，从而实现更高级的动态行为。</p></li></ul><p>通过使用回调模式，系统的不同部分可以相互独立地演化和扩展，而不会引入过多的紧耦合关系。这使得代码更加模块化、可复用和可维护。此外，回调模式还可以提高代码的可测试性，因为可以使用模拟或替代的回调函数来进行单元测试。</p><p>总而言之，回调模式通过解耦和灵活性的特性，帮助提高了代码的可维护性、可扩展性和可测试性，使系统更加灵活和适应变化。</p><h3 id=回调模式和事件驱动模式有什么区别>回调模式和事件驱动模式有什么区别？</h3><p>回调模式和事件驱动模式是两种常见的设计模式，它们在某些方面有相似之处，但也存在一些区别。</p><p>回调模式：</p><ul><li>在回调模式中，一个可执行的代码块（回调函数）被传递给其他代码，以便在特定事件发生时被调用。</li><li>回调函数通常由调用方提供，用于定义在特定事件发生时应该执行的操作。</li><li>回调模式用于实现解耦和灵活性，允许不同模块之间通过回调函数进行通信，但不依赖于具体的实现细节。</li></ul><p>事件驱动模式：</p><ul><li>事件驱动模式是一种编程范式，其中系统的行为和控制是由事件的发生和处理驱动的。</li><li>在事件驱动模式中，组件（如控件、对象等）可以产生事件，并将其发送到事件处理程序进行处理。</li><li>事件处理程序是事先定义好的，用于响应特定类型的事件。</li><li>事件驱动模式通常涉及事件的发布、订阅和分发机制，以便将事件路由到正确的处理程序。</li></ul><p>区别：</p><ol><li>角色和通信方式：在回调模式中，回调函数是被调用方提供给调用方的，通过函数参数进行传递。而在事件驱动模式中，组件产生事件并将其发送给事件处理程序进行处理。</li><li>控制流：在回调模式中，调用方主动调用回调函数来传递控制权，以响应特定事件。而在事件驱动模式中，控制流是由事件的发生和处理驱动的，事件处理程序被动地等待事件的发生。</li><li>灵活性和扩展性：回调模式更加灵活，因为可以将不同的回调函数传递给相同的调用方，从而改变其行为。而事件驱动模式更加适用于大型系统，因为可以通过添加、移除或替换事件处理程序来扩展系统的功能。</li><li>通信机制：回调模式通常使用函数参数进行通信，而事件驱动模式通常使用发布-订阅或观察者模式来实现事件的传递和处理。</li></ol><p>需要注意的是，回调模式和事件驱动模式并不是互斥的，它们可以同时存在于一个系统中，相互配合使用来实现不同的需求。</p><h3 id=回调模式和观察者模式有什么区别>回调模式和观察者模式有什么区别？</h3><p>回调模式和观察者模式是两种常见的设计模式，它们在某些方面有相似之处，但也存在一些区别。</p><p>回调模式：</p><ul><li>在回调模式中，一个可执行的代码块（回调函数）被传递给其他代码，以便在特定事件发生时被调用。</li><li>回调函数通常由调用方提供，用于定义在特定事件发生时应该执行的操作。</li><li>回调模式用于实现解耦和灵活性，允许不同模块之间通过回调函数进行通信，但不依赖于具体的实现细节。</li></ul><p>观察者模式：</p><ul><li>观察者模式是一种发布-订阅模式，用于在对象之间建立一对多的依赖关系。当一个对象的状态发生变化时，它会通知所有依赖于它的观察者对象。</li><li>观察者模式通常由一个主题（被观察者）和多个观察者组成。主题维护观察者列表，并在状态变化时通知观察者。</li><li>观察者模式用于实现对象之间的松耦合，使得主题和观察者可以独立变化，而不会相互影响。</li></ul><p>区别：</p><ol><li>角色和通信方式：在回调模式中，回调函数是被调用方提供给调用方的，通过函数参数进行传递。而在观察者模式中，主题通常维护观察者列表，并通过通知方法将状态变化信息传递给观察者。</li><li>控制流：在回调模式中，调用方主动调用回调函数来传递控制权，以响应特定事件。而在观察者模式中，主题对象在状态变化时被动地通知观察者，并由观察者决定如何处理通知。</li><li>关注点：回调模式更关注于事件发生后的回调操作。观察者模式更关注于主题和观察者之间的状态变化通知和处理。</li><li>依赖关系：在回调模式中，调用方和被调用方之间存在直接依赖关系，因为回调函数是由调用方提供的。而在观察者模式中，主题和观察者之间松耦合，它们只通过接口进行通信，不直接依赖于具体的实现。</li></ol><p>需要注意的是，回调模式和观察者模式可以根据具体的应用场景进行选择和组合使用。在某些情况下，它们可以互为补充，实现更灵活和可扩展的系统设计。</p><h3 id=使用回调模式会存在内存泄露吗>使用回调模式，会存在内存泄露吗？</h3><p>在 Java 中使用回调模式时，也存在潜在的内存泄漏问题。内存泄漏可能发生在以下情况下：</p><ol><li>长期持有回调对象：如果一个对象持有一个回调对象的引用，并且该回调对象的生命周期比持有对象更长，那么即使持有对象不再使用，回调对象仍然保持对其的引用，从而导致内存泄漏。</li><li>匿名内部类回调：当使用匿名内部类作为回调对象时，如果匿名内部类引用了外部类的实例，且该实例的生命周期比回调对象更长，那么即使外部类实例不再需要，回调对象仍然保持对其的引用，导致内存泄漏。</li></ol><h3 id=使用回调模式如何避免内存泄露>使用回调模式，如何避免内存泄露？</h3><p>以下是一些常见的方法来避免内存泄漏：</p><ol><li>及时释放对象引用：确保在不再需要对象时，显式地将其引用设置为 null。这样可以使垃圾回收器能够回收对象所占用的内存。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SomeObject obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SomeObject();
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用obj对象...</span>
</span></span><span style=display:flex><span>obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// 不再需要obj对象时，将其引用设置为null</span>
</span></span></code></pre></div><ol start=2><li>避免长期持有对象引用：当一个对象持有另一个对象的引用时，确保持有引用的对象的生命周期不比被引用对象更长。在不再需要持有对象时，及时将其引用设置为 null。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SomeClass</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Callback callback;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setCallback</span>(Callback callback) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>callback</span> <span style=color:#f92672>=</span> callback;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSomething</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用callback对象...</span>
</span></span><span style=display:flex><span>        callback <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// 不再需要callback对象时，将其引用设置为null</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>使用弱引用或软引用：对于某些情况下，当对象不再被强引用引用时，希望能够被垃圾回收，可以使用弱引用（WeakReference）或软引用（SoftReference）来持有对象。这样，在内存不足时，垃圾回收器可以回收这些对象。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SomeObject obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SomeObject();
</span></span><span style=display:flex><span>WeakReference<span style=color:#f92672>&lt;</span>SomeObject<span style=color:#f92672>&gt;</span> weakRef <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WeakReference<span style=color:#f92672>&lt;&gt;</span>(obj);
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用weakRef对象...</span>
</span></span><span style=display:flex><span>obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// 不再需要obj对象时，将其引用设置为null</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在适当的时机，检查弱引用是否还持有对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (weakRef.<span style=color:#a6e22e>get</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对象已被垃圾回收</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>避免匿名内部类引用外部对象：在使用匿名内部类时，避免在内部类中引用外部类的实例，或者使用静态内部类来避免该问题。如果匿名内部类引用了外部类实例，并且外部类实例的生命周期比内部类更长，就会导致内存泄漏。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SomeClass</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSomething</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> SomeObject obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SomeObject();
</span></span><span style=display:flex><span>        Runnable runnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 使用obj对象...</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用runnable对象...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上述示例中，匿名内部类引用了外部类的<code>SomeObject</code>实例<code>obj</code>。如果在<code>run()</code>方法中持续引用了<code>obj</code>，那么即使<code>doSomething()</code>方法执行完毕，<code>obj</code>仍然无法被垃圾回收。为避免该问题，可以将<code>SomeObject</code>声明为<code>final</code>，或者使用静态内部类。</p><blockquote><ul><li><p>1、在 Java 中，将<code>SomeObject</code>声明为<code>final</code>可以帮助避免匿名内部类引起的内存泄漏问题。</p><p>当内部类引用外部类的实例时，如果外部类的实例不再需要，但内部类仍然持有对外部类实例的引用，就可能导致内存泄漏。</p><p>当将<code>SomeObject</code>声明为<code>final</code>时，编译器会确保在匿名内部类中使用的外部类实例不可变。这意味着在编译时，编译器会将对外部类实例的引用复制给内部类的成员变量，并且该引用在整个内部类的生命周期中保持不变。</p><p>由于引用是不可变的，因此不会出现外部类实例被内部类持有，从而导致外部类实例无法被垃圾回收的情况。一旦外部类实例不再被引用，即使匿名内部类仍然存在，外部类实例也可以被垃圾回收器回收。</p><p>通过将<code>SomeObject</code>声明为<code>final</code>，可以确保在匿名内部类中对外部类实例的引用是安全的，不会导致内存泄漏问题。这是因为编译器在编译时会生成正确的代码，确保内部类不会持有外部类实例的引用超过其生命周期。</p><p>需要注意的是，虽然使用<code>final</code>修饰外部类引用可以帮助避免内存泄漏问题，但这并不是解决所有可能导致内存泄漏的情况的通用解决方案。在处理回调或内部类时，还需要仔细考虑对象引用的生命周期，并采取适当的措施来避免潜在的内存泄漏。</p></li><li><p>2、使用静态内部类可以帮助避免内部类引起的内存泄漏问题。</p><p>静态内部类与外部类之间的引用是相互独立的，这意味着静态内部类不会隐式地持有对外部类实例的引用。</p><p>当内部类是静态内部类时，它不会隐式地持有对外部类实例的引用。这意味着即使外部类实例不再被引用，静态内部类仍然可以独立存在，而不会阻止外部类实例被垃圾回收。</p><p>由于静态内部类不持有对外部类实例的引用，因此在外部类实例不再需要时，可以安全地将其设置为 null，并允许垃圾回收器回收内存。</p><p>以下是使用静态内部类的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SomeClass</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CallbackImpl</span> <span style=color:#66d9ef>implements</span> Callback {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实现回调接口的方法</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSomething</span>() {
</span></span><span style=display:flex><span>        Callback callback <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CallbackImpl();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用callback对象...</span>
</span></span><span style=display:flex><span>        callback <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// 不再需要callback对象时，将其引用设置为null</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上述示例中，<code>CallbackImpl</code>是静态内部类，它实现了<code>Callback</code>接口。在<code>doSomething()</code>方法中，我们创建了<code>CallbackImpl</code>的实例，并使用它进行回调操作。当不再需要<code>callback</code>对象时，将其引用设置为 null，以允许垃圾回收器回收内存。</p><p>使用静态内部类可以有效地避免内存泄漏问题，因为它们不会持有对外部类实例的引用，从而使得外部类实例可以在不再需要时被垃圾回收。这使得静态内部类成为一种常见的处理回调或复杂逻辑的有效方式。</p></li></ul></blockquote></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCallback https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f13%2fjava-design-patterns-callback%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f13%2fjava-design-patterns-callback%2f&title=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCallback" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCallback&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f13%2fjava-design-patterns-callback%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f13%2fjava-design-patterns-callback%2f&title=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCallback" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f13%2fjava-design-patterns-callback%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCallback%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f13%2fjava-design-patterns-callback%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/ rel=next><span class=post-title>[译]Spring Boot3和Spring6中的新特性</span></a></div><div class=nav-next><a href=/posts/2023/10/12/git-interview-questions/ rel=prev><span class=post-title>[译]DevOps 和测试人员的 Git 面试问题</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2023/12/14/all-things-about-microprofile/>All things about MicroProfile</a></li><li><a href=/posts/2023/11/02/jhipster-intro/>JHipster安装和介绍</a></li><li><a href=/posts/2023/10/26/java-design-patterns-circuit-breaker/>Java设计模式：Circuit Breaker</a></li><li><a href=/posts/2023/10/16/java-design-patterns-chain/>Java设计模式：Chain</a></li><li><a href=/posts/2023/09/25/java-design-patterns-cahcing/>Java设计模式：Caching</a></li><li><a href=/posts/2023/09/22/java-design-patterns-bytecode/>Java设计模式：Bytecode</a></li><li><a href=/posts/2023/09/05/java-design-patterns-builder/>Java设计模式：Builder</a></li><li><a href=/posts/2023/09/05/java-design-patterns-business-delegate/>Java设计模式：Business Delegate</a></li><li><a href=/posts/2023/08/28/java-design-patterns-bridge/>Java设计模式：Bridge</a></li><li><a href=/posts/2023/08/25/java-design-patterns-balking/>Java设计模式：Balking</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link><a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a>
Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a>
<a style=margin-left:20px href=/privacy_policy/ target=_blank rel="noopener noreferrer">Privacy Policy</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>