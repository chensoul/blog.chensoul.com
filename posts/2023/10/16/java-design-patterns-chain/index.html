<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="本文主要介绍 Chain 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。"><title>Java设计模式：Chain | ChenSoul</title>
<link rel=canonical href=https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/images/favicon.webp"><meta name=twitter:title content="Java设计模式：Chain"><meta name=twitter:description content="本文主要介绍 Chain 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="Java设计模式：Chain"><meta property="og:description" content="本文主要介绍 Chain 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-16T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-16T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="og:image" content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=name content="Java设计模式：Chain"><meta itemprop=description content="本文主要介绍 Chain 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。"><meta itemprop=datePublished content="2023-10-16T00:00:00+00:00"><meta itemprop=dateModified content="2023-10-16T00:00:00+00:00"><meta itemprop=wordCount content="324"><meta itemprop=image content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=keywords content="Java"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"Java设计模式：Chain","headline":"Java设计模式：Chain","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/","description":"\u003cp\u003e本文主要介绍 \u003ca href=\"https://java-design-patterns.com/zh/patterns/chain/\" target=\"_blank\"\u003eChain\u003c/a\u003e 模式，在 \u003ca href=\"https://java-design-patterns.com/\" target=\"_blank\"\u003eJava Design Patterns\u003c/a\u003e 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。\u003c/p\u003e","wordCount":"324","keywords":["java"],"datePublished":"2023-10-16T00:00:00Z","dateModified":"2023-10-16T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://twitter.com/","https://github.com/chensoul","https://www.linkedin.com/in/"]}]}</script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/ rel=bookmark title=Java设计模式：Chain>Java设计模式：Chain</a></h2><hr><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2023-10-16T00:00:00>2023-10-16
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/java/ title=java>java</a></span></div></header><div style=background-color:#f1f3f5;margin-top:20px><aside style=margin:5px><span style=font-size:20px;font-weight:700>Table of Contents</span><div style=padding-left:30px><nav id=TableOfContents><ul><li><a href=#目的>目的</a></li><li><a href=#介绍>介绍</a></li><li><a href=#适用场景>适用场景</a></li><li><a href=#举例>举例</a></li><li><a href=#java中的例子>Java中的例子</a></li></ul></nav></div></aside></div><div class=entry-content><p>本文主要介绍 <a href=https://java-design-patterns.com/zh/patterns/chain/ target=_blank>Chain</a> 模式，在 <a href=https://java-design-patterns.com/ target=_blank>Java Design Patterns</a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。</p><h2 id=目的>目的</h2><p>通过给多个对象一个处理请求的机会，避免请求的发送者和它的接收者耦合。串联接收对象并在链条中传递请求直到一个对象处理它。</p><h2 id=介绍>介绍</h2><p>责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象按照顺序处理请求，直到其中一个对象能够处理该请求为止。该模式将请求发送者和接收者解耦，使多个对象都有机会处理请求，同时避免请求发送者与接收者之间的直接耦合。</p><p>在责任链模式中，通常会构建一个处理请求的链条，链条上的每个对象都有一个指向下一个对象的引用。当请求到达链条的起点时，它会依次经过链条上的每个对象，直到找到能够处理请求的对象为止。每个对象都可以决定是否处理请求，或者将请求传递给下一个对象。</p><p>以下是责任链模式的几个关键角色：</p><ol><li>抽象处理器（Handler）：定义处理请求的接口，并包含一个指向下一个处理器的引用。通常会提供一个处理请求的方法。</li><li>具体处理器（ConcreteHandler）：实现抽象处理器的接口，具体处理请求的逻辑。如果自己无法处理请求，则将请求传递给下一个处理器。</li><li>客户端（Client）：创建责任链，并将请求发送给链条的起点。</li></ol><p>下面是一个示例，说明如何使用责任链模式处理请求：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 抽象处理器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Handler</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> Handler nextHandler;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setNextHandler</span>(Handler nextHandler) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>nextHandler</span> <span style=color:#f92672>=</span> nextHandler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleRequest</span>(Request request);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 具体处理器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConcreteHandler1</span> <span style=color:#66d9ef>extends</span> Handler {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleRequest</span>(Request request) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (满足处理条件) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 处理请求的逻辑</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (nextHandler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将请求传递给下一个处理器</span>
</span></span><span style=display:flex><span>            nextHandler.<span style=color:#a6e22e>handleRequest</span>(request);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 具体处理器2和具体处理器3的定义与具体处理器1类似</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 客户端</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Client</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Handler handler1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcreteHandler1();
</span></span><span style=display:flex><span>        Handler handler2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcreteHandler2();
</span></span><span style=display:flex><span>        Handler handler3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcreteHandler3();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 构建责任链</span>
</span></span><span style=display:flex><span>        handler1.<span style=color:#a6e22e>setNextHandler</span>(handler2);
</span></span><span style=display:flex><span>        handler2.<span style=color:#a6e22e>setNextHandler</span>(handler3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建请求</span>
</span></span><span style=display:flex><span>        Request request <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Request();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 发送请求给责任链的起点</span>
</span></span><span style=display:flex><span>        handler1.<span style=color:#a6e22e>handleRequest</span>(request);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上述示例中，抽象处理器（Handler）定义了处理请求的接口，并包含一个指向下一个处理器的引用。具体处理器（ConcreteHandler）继承自抽象处理器，实现了处理请求的逻辑，如果自己无法处理请求，则将请求传递给下一个处理器。客户端（Client）创建了具体处理器的实例，并构建了责任链，然后将请求发送给责任链的起点。</p><p>责任链模式的优点包括：</p><ul><li>解耦请求发送者和接收者，让多个对象都有机会处理请求。</li><li>灵活性高，可以动态地改变责任链的结构和顺序。</li><li>可以简化对象之间的交互，每个对象只需要关注自己的处理逻辑。</li></ul><p>然而，责任链模式也有一些注意事项：</p><ul><li>需要注意链条的构建顺序，确保请求可以被正确地处理。</li><li>如果责任链过长或处理逻辑复杂，可能会影响性能。</li><li>请求可能无法被处理，需要在设计中考虑默认处理或异常处理机制。</li></ul><h2 id=适用场景>适用场景</h2><p>责任链模式在以下几种应用场景中经常被使用：</p><ol><li>请求处理链：当一个请求需要经过多个处理器进行处理，并且每个处理器都有可能处理该请求或将其传递给下一个处理器时，可以使用责任链模式。例如，Web开发中的请求处理、日志记录系统中的日志处理等。</li><li>异常处理：在处理异常时，可以使用责任链模式来处理不同类型的异常。每个处理器负责处理一种类型的异常，如果无法处理，则将异常传递给下一个处理器。这样可以实现异常处理的灵活性和可扩展性。</li><li>权限验证：在一个系统中，可以使用责任链模式来进行权限验证。每个处理器可以验证某个特定权限，如果无法验证，则将验证请求传递给下一个处理器。这样可以实现权限验证的灵活组合和动态调整。</li><li>日志记录：在日志记录系统中，可以使用责任链模式来处理不同级别的日志信息。每个处理器负责记录特定级别的日志，如果无法处理，则将日志传递给下一个处理器。这样可以实现日志记录的分级和灵活配置。</li><li>缓存处理：在缓存系统中，可以使用责任链模式来处理缓存读取请求。每个处理器可以根据一定的策略判断是否命中缓存，如果未命中则将请求传递给下一个处理器。这样可以实现缓存的层级和灵活的缓存策略。</li><li>数据验证器（Data Validator）：在数据验证过程中，可以使用责任链模式来对数据进行不同类型的验证。每个验证器负责验证特定的数据规则，如果无法验证，则将验证请求传递给下一个验证器。这样可以实现数据验证的分步处理和灵活的验证规则组合。</li></ol><p>需要注意的是，责任链模式适用于处理请求的场景，其中每个处理器都有可能处理请求或将其传递给下一个处理器。在选择使用责任链模式时，需确保请求能够被正确处理，并且链条的构建顺序是合理的，避免出现死循环或请求无法被处理的情况。</p><h2 id=举例>举例</h2><p>这段代码展示了一个简单的泛型责任链模式实现，其中包括<code>Handler</code>接口和<code>Pipeline</code>类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Handler</span><span style=color:#f92672>&lt;</span>I, O<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    O <span style=color:#a6e22e>process</span>(I input);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Pipeline</span><span style=color:#f92672>&lt;</span>I, O<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Handler<span style=color:#f92672>&lt;</span>I, O<span style=color:#f92672>&gt;</span> currentHandler;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Pipeline</span>(Handler<span style=color:#f92672>&lt;</span>I, O<span style=color:#f92672>&gt;</span> currentHandler) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>currentHandler</span> <span style=color:#f92672>=</span> currentHandler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>K<span style=color:#f92672>&gt;</span> Pipeline<span style=color:#f92672>&lt;</span>I, K<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>addHandler</span>(Handler<span style=color:#f92672>&lt;</span>O, K<span style=color:#f92672>&gt;</span> newHandler) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Pipeline<span style=color:#f92672>&lt;&gt;</span>(input <span style=color:#f92672>-&gt;</span> newHandler.<span style=color:#a6e22e>process</span>(currentHandler.<span style=color:#a6e22e>process</span>(input)));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> O <span style=color:#a6e22e>execute</span>(I input) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> currentHandler.<span style=color:#a6e22e>process</span>(input);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上述代码中，<code>Handler</code>接口定义了一个处理输入类型为<code>I</code>，输出类型为<code>O</code>的操作。它包含一个<code>process</code>方法，用于执行处理逻辑。</p><p><code>Pipeline</code>类是一个泛型类，它接受输入类型<code>I</code>和输出类型<code>O</code>。在构造函数中，通过传入一个初始的<code>currentHandler</code>，创建一个责任链的起点。</p><p><code>Pipeline</code>类提供了<code>addHandler</code>方法，用于添加新的处理器到责任链中。该方法接受一个实现了<code>Handler</code>接口的<code>newHandler</code>，并返回一个新的<code>Pipeline</code>对象，新的责任链包括之前的处理器和新的处理器。</p><p><code>execute</code>方法用于执行整个责任链。它接受输入参数<code>input</code>，并通过调用当前处理器的<code>process</code>方法，依次执行责任链中的每个处理器，并返回最终的输出结果。</p><p>使用这个简单的泛型责任链模式，你可以根据具体的业务需求创建不同类型的处理器，并通过<code>addHandler</code>方法将它们连接在一起，形成一个处理流程。然后，你可以使用<code>execute</code>方法将输入数据传入责任链中，依次经过每个处理器进行处理，最终得到输出结果。</p><p>假设我们有一个处理器链，用于处理字符串的转换操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringToUpperHandler</span> <span style=color:#66d9ef>implements</span> Handler<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>process</span>(String input) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> input.<span style=color:#a6e22e>toUpperCase</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringTrimHandler</span> <span style=color:#66d9ef>implements</span> Handler<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>process</span>(String input) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> input.<span style=color:#a6e22e>trim</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringReverseHandler</span> <span style=color:#66d9ef>implements</span> Handler<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>process</span>(String input) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> StringBuilder(input).<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在，我们可以使用这些处理器来创建一个处理流程，并执行输入字符串的转换操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建处理器和处理流程</span>
</span></span><span style=display:flex><span>        Handler<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> toUpperHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringToUpperHandler();
</span></span><span style=display:flex><span>        Handler<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> trimHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringTrimHandler();
</span></span><span style=display:flex><span>        Handler<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> reverseHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringReverseHandler();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pipeline<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> pipeline <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Pipeline<span style=color:#f92672>&lt;&gt;</span>(toUpperHandler)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>addHandler</span>(trimHandler)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>addHandler</span>(reverseHandler);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行处理流程</span>
</span></span><span style=display:flex><span>        String input <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;  Hello, World!  &#34;</span>;
</span></span><span style=display:flex><span>        String output <span style=color:#f92672>=</span> pipeline.<span style=color:#a6e22e>execute</span>(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Output: &#34;</span> <span style=color:#f92672>+</span> output);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上述示例中，我们创建了三个处理器：<code>StringToUpperHandler</code>、<code>StringTrimHandler</code>和<code>StringReverseHandler</code>，它们分别用于将字符串转换为大写、去除空格和反转字符串。</p><p>然后，我们使用这些处理器创建了一个处理流程，通过调用<code>addHandler</code>方法将它们逐步链接在一起，形成一个处理器链。</p><p>最后，我们执行处理流程，将输入字符串<code>" Hello, World! "</code>传入<code>execute</code>方法中。该输入字符串首先经过<code>toUpperHandler</code>处理器处理，然后传递给<code>trimHandler</code>进行处理，最后传递给<code>reverseHandler</code>进行处理。处理完成后，得到最终的输出结果。</p><p>在本例中，输出结果为<code>"!DLROW ,OLLEH"</code>，这是通过依次应用处理器链中的每个处理器对输入字符串进行转换而得到的。</p><h2 id=java中的例子>Java中的例子</h2><ul><li><a href=http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log target=_blank>java.util.logging.Logger#log()</a></li><li><a href=https://commons.apache.org/proper/commons-chain/index.html target=_blank>Apache Commons Chain</a></li><li><a href=http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain- target=_blank>javax.servlet.Filter#doFilter()</a></li></ul></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aChain https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f16%2fjava-design-patterns-chain%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f16%2fjava-design-patterns-chain%2f&title=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aChain" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aChain&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f16%2fjava-design-patterns-chain%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f16%2fjava-design-patterns-chain%2f&title=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aChain" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f16%2fjava-design-patterns-chain%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aChain%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f16%2fjava-design-patterns-chain%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2023/10/26/java-design-patterns-circuit-breaker/ rel=next><span class=post-title>Java设计模式：Circuit Breaker</span></a></div><div class=nav-next><a href=/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/ rel=prev><span class=post-title>[译]Spring Boot3和Spring6中的新特性</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2023/12/14/all-things-about-microprofile/>All things about MicroProfile</a></li><li><a href=/posts/2023/11/02/jhipster-intro/>JHipster安装和介绍</a></li><li><a href=/posts/2023/10/26/java-design-patterns-circuit-breaker/>Java设计模式：Circuit Breaker</a></li><li><a href=/posts/2023/10/13/java-design-patterns-callback/>Java设计模式：Callback</a></li><li><a href=/posts/2023/09/25/java-design-patterns-cahcing/>Java设计模式：Caching</a></li><li><a href=/posts/2023/09/22/java-design-patterns-bytecode/>Java设计模式：Bytecode</a></li><li><a href=/posts/2023/09/05/java-design-patterns-builder/>Java设计模式：Builder</a></li><li><a href=/posts/2023/09/05/java-design-patterns-business-delegate/>Java设计模式：Business Delegate</a></li><li><a href=/posts/2023/08/28/java-design-patterns-bridge/>Java设计模式：Bridge</a></li><li><a href=/posts/2023/08/25/java-design-patterns-balking/>Java设计模式：Balking</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link><a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a>
Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a>
<a style=margin-left:20px href=/privacy_policy/ target=_blank rel="noopener noreferrer">Privacy Policy</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>