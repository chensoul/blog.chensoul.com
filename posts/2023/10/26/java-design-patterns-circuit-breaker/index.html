<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java设计模式：Circuit Breaker | ChenSoul</title>
<meta name=keywords content="java"><meta name=description content='本文主要介绍 Circuit Breaker 断路器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。
在一个分布式系统中，不可避免地会出现许多外部依赖，如数据库、网络服务等。这些外部依赖可能会发生故障、延迟或不可用的情况。如果没有适当的措施，这些故障可能会导致整个系统的性能下降，甚至系统崩溃。
断路器模式通过在应用程序和外部依赖之间引入一个断路器接口来解决这个问题。断路器接口充当一个中间层，监视对外部依赖的调用。当外部依赖发生故障时，断路器可以迅速地中断对外部依赖的调用，避免资源的浪费和故障的传递。
除了断路器接口之外，断路器模式还涉及以下几个重要的知识点：
故障阈值（Failure Threshold）：断路器模式通过设置故障阈值来判断服务的健康状态。当服务的失败次数达到或超过故障阈值时，断路器会打开，阻止对服务的进一步调用。 回退响应（Fallback Response）：当断路器打开时，可以为调用方提供回退响应。回退响应是一个预定义的响应，用于代替无法正常调用的服务的响应。回退响应可以是事先定义好的静态响应，或者是通过调用备用服务来获取的响应。 断路器状态（Circuit Breaker State）：断路器可以处于不同的状态，如关闭（Closed）、打开（Open）和半开（Half-Open）。初始状态通常是关闭状态，表示服务正常可用。当服务的失败次数达到故障阈值时，断路器会打开，阻止对服务的进一步调用。在一定时间后，断路器会进入半开状态，允许发起一次测试调用。如果测试调用成功，断路器将重新关闭；如果测试调用仍然失败，断路器将重新打开。 断路器的自动恢复（Automatic Recovery）：断路器模式通常具有自动恢复功能。在断路器打开的状态下，一段时间过去后，断路器会尝试重新关闭，以允许对服务的正常调用。自动恢复可以防止长时间的服务中断，提供给服务一个机会来恢复正常运行。 健康检查（Health Check）：断路器模式可以通过定期的健康检查来监控服务的状态。健康检查可以是定期发送心跳请求或执行一些特定的健康检查操作。通过健康检查，可以及时发现服务的故障或不可用状态，并相应地打开断路器。 示例 首先，您需要创建一个监控服务类，它将使用断路器来包装远程服务的调用。以下是一个示例监控服务类的代码：
public class MonitoringService { private final CircuitBreaker delayedService; private final CircuitBreaker quickService; public MonitoringService(CircuitBreaker delayedService, CircuitBreaker quickService) { this.delayedService = delayedService; this.quickService = quickService; } public String localResourceResponse() { return "Local Service is working"; } public String delayedServiceResponse() { try { return this.delayedService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } public String quickServiceResponse() { try { return this.quickService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } } 在上述代码中，MonitoringService 类接受两个断路器对象作为参数，分别用于包装延迟服务和快速服务的远程调用。它还包含一个用于获取本地资源的方法。'><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Java设计模式：Circuit Breaker"><meta property="og:description" content='本文主要介绍 Circuit Breaker 断路器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。
在一个分布式系统中，不可避免地会出现许多外部依赖，如数据库、网络服务等。这些外部依赖可能会发生故障、延迟或不可用的情况。如果没有适当的措施，这些故障可能会导致整个系统的性能下降，甚至系统崩溃。
断路器模式通过在应用程序和外部依赖之间引入一个断路器接口来解决这个问题。断路器接口充当一个中间层，监视对外部依赖的调用。当外部依赖发生故障时，断路器可以迅速地中断对外部依赖的调用，避免资源的浪费和故障的传递。
除了断路器接口之外，断路器模式还涉及以下几个重要的知识点：
故障阈值（Failure Threshold）：断路器模式通过设置故障阈值来判断服务的健康状态。当服务的失败次数达到或超过故障阈值时，断路器会打开，阻止对服务的进一步调用。 回退响应（Fallback Response）：当断路器打开时，可以为调用方提供回退响应。回退响应是一个预定义的响应，用于代替无法正常调用的服务的响应。回退响应可以是事先定义好的静态响应，或者是通过调用备用服务来获取的响应。 断路器状态（Circuit Breaker State）：断路器可以处于不同的状态，如关闭（Closed）、打开（Open）和半开（Half-Open）。初始状态通常是关闭状态，表示服务正常可用。当服务的失败次数达到故障阈值时，断路器会打开，阻止对服务的进一步调用。在一定时间后，断路器会进入半开状态，允许发起一次测试调用。如果测试调用成功，断路器将重新关闭；如果测试调用仍然失败，断路器将重新打开。 断路器的自动恢复（Automatic Recovery）：断路器模式通常具有自动恢复功能。在断路器打开的状态下，一段时间过去后，断路器会尝试重新关闭，以允许对服务的正常调用。自动恢复可以防止长时间的服务中断，提供给服务一个机会来恢复正常运行。 健康检查（Health Check）：断路器模式可以通过定期的健康检查来监控服务的状态。健康检查可以是定期发送心跳请求或执行一些特定的健康检查操作。通过健康检查，可以及时发现服务的故障或不可用状态，并相应地打开断路器。 示例 首先，您需要创建一个监控服务类，它将使用断路器来包装远程服务的调用。以下是一个示例监控服务类的代码：
public class MonitoringService { private final CircuitBreaker delayedService; private final CircuitBreaker quickService; public MonitoringService(CircuitBreaker delayedService, CircuitBreaker quickService) { this.delayedService = delayedService; this.quickService = quickService; } public String localResourceResponse() { return "Local Service is working"; } public String delayedServiceResponse() { try { return this.delayedService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } public String quickServiceResponse() { try { return this.quickService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } } 在上述代码中，MonitoringService 类接受两个断路器对象作为参数，分别用于包装延迟服务和快速服务的远程调用。它还包含一个用于获取本地资源的方法。'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-26T00:00:00+08:00"><meta property="article:modified_time" content="2023-10-26T00:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java设计模式：Circuit Breaker"><meta name=twitter:description content='本文主要介绍 Circuit Breaker 断路器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。
在一个分布式系统中，不可避免地会出现许多外部依赖，如数据库、网络服务等。这些外部依赖可能会发生故障、延迟或不可用的情况。如果没有适当的措施，这些故障可能会导致整个系统的性能下降，甚至系统崩溃。
断路器模式通过在应用程序和外部依赖之间引入一个断路器接口来解决这个问题。断路器接口充当一个中间层，监视对外部依赖的调用。当外部依赖发生故障时，断路器可以迅速地中断对外部依赖的调用，避免资源的浪费和故障的传递。
除了断路器接口之外，断路器模式还涉及以下几个重要的知识点：
故障阈值（Failure Threshold）：断路器模式通过设置故障阈值来判断服务的健康状态。当服务的失败次数达到或超过故障阈值时，断路器会打开，阻止对服务的进一步调用。 回退响应（Fallback Response）：当断路器打开时，可以为调用方提供回退响应。回退响应是一个预定义的响应，用于代替无法正常调用的服务的响应。回退响应可以是事先定义好的静态响应，或者是通过调用备用服务来获取的响应。 断路器状态（Circuit Breaker State）：断路器可以处于不同的状态，如关闭（Closed）、打开（Open）和半开（Half-Open）。初始状态通常是关闭状态，表示服务正常可用。当服务的失败次数达到故障阈值时，断路器会打开，阻止对服务的进一步调用。在一定时间后，断路器会进入半开状态，允许发起一次测试调用。如果测试调用成功，断路器将重新关闭；如果测试调用仍然失败，断路器将重新打开。 断路器的自动恢复（Automatic Recovery）：断路器模式通常具有自动恢复功能。在断路器打开的状态下，一段时间过去后，断路器会尝试重新关闭，以允许对服务的正常调用。自动恢复可以防止长时间的服务中断，提供给服务一个机会来恢复正常运行。 健康检查（Health Check）：断路器模式可以通过定期的健康检查来监控服务的状态。健康检查可以是定期发送心跳请求或执行一些特定的健康检查操作。通过健康检查，可以及时发现服务的故障或不可用状态，并相应地打开断路器。 示例 首先，您需要创建一个监控服务类，它将使用断路器来包装远程服务的调用。以下是一个示例监控服务类的代码：
public class MonitoringService { private final CircuitBreaker delayedService; private final CircuitBreaker quickService; public MonitoringService(CircuitBreaker delayedService, CircuitBreaker quickService) { this.delayedService = delayedService; this.quickService = quickService; } public String localResourceResponse() { return "Local Service is working"; } public String delayedServiceResponse() { try { return this.delayedService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } public String quickServiceResponse() { try { return this.quickService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } } 在上述代码中，MonitoringService 类接受两个断路器对象作为参数，分别用于包装延迟服务和快速服务的远程调用。它还包含一个用于获取本地资源的方法。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"Java设计模式：Circuit Breaker","item":"https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java设计模式：Circuit Breaker","name":"Java设计模式：Circuit Breaker","description":"本文主要介绍 Circuit Breaker 断路器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。\n介绍 断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。\n在一个分布式系统中，不可避免地会出现许多外部依赖，如数据库、网络服务等。这些外部依赖可能会发生故障、延迟或不可用的情况。如果没有适当的措施，这些故障可能会导致整个系统的性能下降，甚至系统崩溃。\n断路器模式通过在应用程序和外部依赖之间引入一个断路器接口来解决这个问题。断路器接口充当一个中间层，监视对外部依赖的调用。当外部依赖发生故障时，断路器可以迅速地中断对外部依赖的调用，避免资源的浪费和故障的传递。\n除了断路器接口之外，断路器模式还涉及以下几个重要的知识点：\n故障阈值（Failure Threshold）：断路器模式通过设置故障阈值来判断服务的健康状态。当服务的失败次数达到或超过故障阈值时，断路器会打开，阻止对服务的进一步调用。 回退响应（Fallback Response）：当断路器打开时，可以为调用方提供回退响应。回退响应是一个预定义的响应，用于代替无法正常调用的服务的响应。回退响应可以是事先定义好的静态响应，或者是通过调用备用服务来获取的响应。 断路器状态（Circuit Breaker State）：断路器可以处于不同的状态，如关闭（Closed）、打开（Open）和半开（Half-Open）。初始状态通常是关闭状态，表示服务正常可用。当服务的失败次数达到故障阈值时，断路器会打开，阻止对服务的进一步调用。在一定时间后，断路器会进入半开状态，允许发起一次测试调用。如果测试调用成功，断路器将重新关闭；如果测试调用仍然失败，断路器将重新打开。 断路器的自动恢复（Automatic Recovery）：断路器模式通常具有自动恢复功能。在断路器打开的状态下，一段时间过去后，断路器会尝试重新关闭，以允许对服务的正常调用。自动恢复可以防止长时间的服务中断，提供给服务一个机会来恢复正常运行。 健康检查（Health Check）：断路器模式可以通过定期的健康检查来监控服务的状态。健康检查可以是定期发送心跳请求或执行一些特定的健康检查操作。通过健康检查，可以及时发现服务的故障或不可用状态，并相应地打开断路器。 示例 首先，您需要创建一个监控服务类，它将使用断路器来包装远程服务的调用。以下是一个示例监控服务类的代码：\npublic class MonitoringService { private final CircuitBreaker delayedService; private final CircuitBreaker quickService; public MonitoringService(CircuitBreaker delayedService, CircuitBreaker quickService) { this.delayedService = delayedService; this.quickService = quickService; } public String localResourceResponse() { return \u0026#34;Local Service is working\u0026#34;; } public String delayedServiceResponse() { try { return this.delayedService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } public String quickServiceResponse() { try { return this.quickService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } } 在上述代码中，MonitoringService 类接受两个断路器对象作为参数，分别用于包装延迟服务和快速服务的远程调用。它还包含一个用于获取本地资源的方法。","keywords":["java"],"articleBody":"本文主要介绍 Circuit Breaker 断路器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。\n介绍 断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。\n在一个分布式系统中，不可避免地会出现许多外部依赖，如数据库、网络服务等。这些外部依赖可能会发生故障、延迟或不可用的情况。如果没有适当的措施，这些故障可能会导致整个系统的性能下降，甚至系统崩溃。\n断路器模式通过在应用程序和外部依赖之间引入一个断路器接口来解决这个问题。断路器接口充当一个中间层，监视对外部依赖的调用。当外部依赖发生故障时，断路器可以迅速地中断对外部依赖的调用，避免资源的浪费和故障的传递。\n除了断路器接口之外，断路器模式还涉及以下几个重要的知识点：\n故障阈值（Failure Threshold）：断路器模式通过设置故障阈值来判断服务的健康状态。当服务的失败次数达到或超过故障阈值时，断路器会打开，阻止对服务的进一步调用。 回退响应（Fallback Response）：当断路器打开时，可以为调用方提供回退响应。回退响应是一个预定义的响应，用于代替无法正常调用的服务的响应。回退响应可以是事先定义好的静态响应，或者是通过调用备用服务来获取的响应。 断路器状态（Circuit Breaker State）：断路器可以处于不同的状态，如关闭（Closed）、打开（Open）和半开（Half-Open）。初始状态通常是关闭状态，表示服务正常可用。当服务的失败次数达到故障阈值时，断路器会打开，阻止对服务的进一步调用。在一定时间后，断路器会进入半开状态，允许发起一次测试调用。如果测试调用成功，断路器将重新关闭；如果测试调用仍然失败，断路器将重新打开。 断路器的自动恢复（Automatic Recovery）：断路器模式通常具有自动恢复功能。在断路器打开的状态下，一段时间过去后，断路器会尝试重新关闭，以允许对服务的正常调用。自动恢复可以防止长时间的服务中断，提供给服务一个机会来恢复正常运行。 健康检查（Health Check）：断路器模式可以通过定期的健康检查来监控服务的状态。健康检查可以是定期发送心跳请求或执行一些特定的健康检查操作。通过健康检查，可以及时发现服务的故障或不可用状态，并相应地打开断路器。 示例 首先，您需要创建一个监控服务类，它将使用断路器来包装远程服务的调用。以下是一个示例监控服务类的代码：\npublic class MonitoringService { private final CircuitBreaker delayedService; private final CircuitBreaker quickService; public MonitoringService(CircuitBreaker delayedService, CircuitBreaker quickService) { this.delayedService = delayedService; this.quickService = quickService; } public String localResourceResponse() { return \"Local Service is working\"; } public String delayedServiceResponse() { try { return this.delayedService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } public String quickServiceResponse() { try { return this.quickService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } } 在上述代码中，MonitoringService 类接受两个断路器对象作为参数，分别用于包装延迟服务和快速服务的远程调用。它还包含一个用于获取本地资源的方法。\n接下来，您需要创建一个默认的断路器实现类，实现 CircuitBreaker 接口，并根据需要自定义逻辑。\npublic interface CircuitBreaker { void recordSuccess(); void recordFailure(String response); void evaluateState(); } CircuitBreaker接口定义了三个方法：\nrecordSuccess(): 当依赖的服务调用成功时调用该方法，用于记录成功的事件。 recordFailure(String response): 当依赖的服务调用失败时调用该方法，用于记录失败的事件。方法接受一个响应字符串作为参数。 evaluateState(): 该方法用于评估当前断路器的状态。根据预定义的条件，如故障阈值、故障计数和最后故障时间等，判断是否需要改变断路器的状态。 以下是一个示例的默认断路器实现类的代码：\npublic class DefaultCircuitBreaker implements CircuitBreaker { private final long timeout; private final long retryTimePeriod; private final RemoteService service; private long lastFailureTime; private String lastFailureResponse; private int failureCount; private final int failureThreshold; private State state; private final long futureTime = 1000 * 1000 * 1000 * 1000; public DefaultCircuitBreaker(RemoteService serviceToCall, long timeout, int failureThreshold, long retryTimePeriod) { this.service = serviceToCall; this.state = State.CLOSED; this.failureThreshold = failureThreshold; this.timeout = timeout; this.retryTimePeriod = retryTimePeriod; this.lastFailureTime = System.nanoTime() + futureTime; this.failureCount = 0; } @Override public void recordSuccess() { this.failureCount = 0; this.lastFailureTime = System.nanoTime() + futureTime; this.state = State.CLOSED; } @Override public void recordFailure(String response) { failureCount = failureCount + 1; this.lastFailureTime = System.nanoTime(); this.lastFailureResponse = response; } protected void evaluateState() { if (failureCount \u003e= failureThreshold) { if ((System.nanoTime() - lastFailureTime) \u003e retryTimePeriod) { state = State.HALF_OPEN; } else { state = State.OPEN; } } else { state = State.CLOSED; } } @Override public String getState() { evaluateState(); return state.name(); } @Override public void setState(State state) { this.state = state; switch (state) { case OPEN: this.failureCount = failureThreshold; break; case HALF_OPEN: this.failureCount = 0; break; case CLOSED: this.failureCount = 0; this.lastFailureTime = System.nanoTime() + futureTime; break; } } @Override public String attemptRequest() throws RemoteServiceException { if (state == State.OPEN) { return lastFailureResponse; } try { // Simulate the remote service call return service.call(); } catch (RemoteServiceException e) { recordFailure(e.getMessage()); throw e; } } } 上述代码中的 DefaultCircuitBreaker 类是一个默认的断路器实现类。它包含了记录成功和失败的方法，评估当前状态的方法，获取当前状态的方法，以及尝试发起请求的方法。根据状态，它可以控制是否允许请求通过或返回上一次的失败响应。\n最后，您可以使用以下代码示例来演示如何使用断路器：\n@Slf4j public class App { private static final Logger LOGGER = LoggerFactory.getLogger(App.class); /** * Program entry point. * * @param args command line args */ public static void main(String[] args) { var serverStartTime = System.nanoTime(); var delayedService = new DelayedRemoteService(serverStartTime, 5); var delayedServiceCircuitBreaker = new DefaultCircuitBreaker(delayedService, 3000, 2, 2000 * 1000 * 1000); var quickService = new QuickRemoteService(); var quickServiceCircuitBreaker = new DefaultCircuitBreaker(quickService, 3000, 2, 2000 * 1000 * 1000); // 创建一个可以进行本地和远程调用的监控服务对象 var monitoringService = new MonitoringService(delayedServiceCircuitBreaker, quickServiceCircuitBreaker); // 获取本地资源 LOGGER.info(monitoringService.localResourceResponse()); // 从延迟服务中获取响应 2 次，以满足失败阈值 LOGGER.info(monitoringService.delayedServiceResponse()); LOGGER.info(monitoringService.delayedServiceResponse()); // 在超过故障阈值限制后获取延迟服务断路器的当前状态 // 现在是打开状态 LOGGER.info(delayedServiceCircuitBreaker.getState()); // 同时，延迟服务宕机，从健康快速服务获取响应 LOGGER.info(monitoringService.quickServiceResponse()); LOGGER.info(quickServiceCircuitBreaker.getState()); // 等待延迟的服务响应 try { LOGGER.info(\"Waiting for delayed service to become responsive\"); Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } // 检查延时断路器的状态，应该是HALF_OPEN LOGGER.info(delayedServiceCircuitBreaker.getState()); // 从延迟服务中获取响应，现在应该是健康的 LOGGER.info(monitoringService.delayedServiceResponse()); // 获取成功响应后，它的状态应该是关闭。 LOGGER.info(delayedServiceCircuitBreaker.getState()); } } 类图 适用场景 断路器模式在分布式系统和微服务架构中有许多常见的应用场景。以下是一些常见的应用场景：\n外部依赖调用：在使用外部服务或资源时，例如数据库、网络服务、API调用等，断路器模式可以用来处理外部依赖的故障。它可以防止故障的传递，减少对故障依赖的调用，并提供故障处理机制。 限流和熔断：断路器模式可以用于实现限流和熔断机制，以保护系统免受外部依赖的过载或故障。它可以监控请求的频率和响应时间，并在达到阈值时阻止对外部依赖的调用，以避免系统崩溃。 降级和容错：在面对外部依赖故障时，断路器模式可以提供降级和容错机制。它可以切换到备用逻辑或服务，以提供基本的功能或默认值，保持系统的部分可用性。 重试和恢复：断路器模式可以用于实现故障重试和恢复机制。当外部依赖发生故障时，断路器可以尝试重新连接或重新调用依赖，以尽快恢复正常操作。 监控和报告：断路器模式通常与监控和报告机制结合使用，以提供对系统状态和故障的可视化和警报。它可以记录故障信息、请求统计、错误率等指标，帮助开发人员和运维团队监控系统健康状况。 总之，断路器模式适用于任何可能遇到外部依赖故障的场景。它可以提供故障隔离、弹性和自愈能力，提高系统的可用性、可靠性和性能。\nFAQ 再提供一个使用断路器模式的例子？ 当涉及到使用断路器模式的例子时，一个常见的应用场景是在微服务架构中保护对其他服务的调用。以下是一个简单的示例：\n假设我们有一个电子商务应用程序，它包含订单服务和库存服务。订单服务负责处理用户的订单，而库存服务则负责管理产品的库存信息。为了保护订单服务对库存服务的调用，我们可以使用断路器模式。\npublic class OrderService { private CircuitBreaker circuitBreaker; private InventoryService inventoryService; public OrderService() { // 初始化断路器 circuitBreaker = new CircuitBreaker(); // 初始化库存服务 inventoryService = new InventoryService(); } public void placeOrder(Order order) { try { // 检查断路器状态 if (circuitBreaker.isClosed()) { // 调用库存服务检查库存 boolean hasStock = inventoryService.checkStock(order.getProduct()); if (hasStock) { // 执行订单处理逻辑 // ... // 订单处理成功，记录成功事件 circuitBreaker.recordSuccess(); } else { // 库存不足，记录失败事件 circuitBreaker.recordFailure(\"Insufficient stock\"); throw new RuntimeException(\"Insufficient stock\"); } } else { // 断路器打开，执行回退逻辑 throw new RuntimeException(\"Order service is currently unavailable. Please try again later.\"); } } catch (Exception e) { // 处理异常情况，记录失败事件 circuitBreaker.recordFailure(e.getMessage()); throw e; } } } 在上述例子中，OrderService类是订单服务的实现。它通过使用CircuitBreaker类来保护对库存服务的调用。在placeOrder()方法中，首先检查断路器的状态。如果断路器处于关闭状态（即可用状态），则调用库存服务的checkStock()方法来检查产品的库存情况。如果库存足够，订单处理成功，并记录成功事件；如果库存不足，订单处理失败，并记录失败事件。\n如果断路器处于打开状态，说明库存服务不可用，此时将执行回退逻辑，抛出异常或提供相应的回退响应。无论是执行回退逻辑还是处理异常情况，都需要记录失败事件。\n通过使用断路器模式，我们可以保护订单服务免受库存服务故障的影响。断路器会监控库存服务的健康状态，并在故障发生时打开断路器，阻止对库存服务的进一步调用。这样，即使库存服务不可用，订单服务仍然能够提供恰当的响应，并避免因连锁故障而导致整个系统崩溃。\n如何优化断路器模式的代码？ 当编写断路器模式的代码时，可以进行一些优化和改进。以下是一些可能的优化方法：\n使用现有的库或框架：断路器模式是一个常见的设计模式，许多流行的Java库和框架已经提供了断路器实现，例如 Netflix的Hystrix、Resilience4j等。使用这些库可以减少您自己编写和维护断路器代码的工作量，并且它们通常具有更多的功能和配置选项。 超时设置：在断路器模式中，设置适当的超时时间非常重要。您可以使用Java的Future、CompletableFuture或第三方库来实现调用的超时控制。确保在超过超时时间后，取消或中断正在进行的请求，并记录为失败。 错误计数器和重置策略：根据失败计数器和重置策略，您可以更准确地确定何时打开、关闭或半开断路器。考虑使用滑动窗口或滑动时间窗口来计算错误计数，并根据预定义的规则进行状态转换。 熔断指标和监控：在大型应用程序中，了解断路器的使用情况和性能指标非常重要。您可以使用指标收集库（例如Micrometer）和监控系统（例如Prometheus、Grafana）来收集和可视化断路器的指标数据，以便进行监控和故障排除。 异步支持：如果您的应用程序需要进行大量的并发请求，考虑使用异步编程模型（例如Java的CompletableFuture、响应式编程库等）。这样可以更好地利用资源，并提高应用程序的吞吐量和性能。 你能推荐一些常用的断路器模式的Java库吗？ 当涉及到断路器模式的Java库时，以下是一些常用的选择：\nNetflix Hystrix：Hystrix是一个广泛使用的断路器库，为分布式系统提供故障容错和弹性功能。它具有自适应的断路器逻辑、请求超时、线程池隔离、回退逻辑等功能。然而，请注意，Netflix宣布停止Hystrix的维护和开发，推荐使用Resilience4j或其他替代库。 Resilience4j：Resilience4j是一个轻量级的断路器和弹性库，专为Java 8+应用程序设计。它提供了断路器、限流、重试、超时等功能，并与Java函数式编程风格很好地配合。Resilience4j还与Spring Boot集成得很好，可以轻松地在Spring应用程序中使用。 Sentinel：Sentinel是阿里巴巴开源的一款弹性流控框架，它提供了断路器、流量控制、熔断降级等功能。Sentinel支持针对流量实时监控和规则配置，可以帮助您保护应用程序免受异常流量和故障的影响。 Akka Circuit Breaker：Akka是一个用于构建高并发和分布式应用程序的工具包，其中包含了一个名为Circuit Breaker的模块。Akka的Circuit Breaker模块提供了断路器功能，并与Akka的Actor模型和消息传递机制集成得很好。 Spring Cloud Circuit Breaker：Spring Cloud Circuit Breaker是Spring Cloud生态系统的一部分，它提供了与多个断路器实现（如Hystrix、Resilience4j、Sentinel等）的集成。因此，您可以根据需要选择合适的断路器实现，并在Spring应用程序中使用它们。 Spring Cloud Circuit Breaker如何实现断路器模式？ Spring Cloud Circuit Breaker是Spring Cloud提供的一个模块，用于实现断路器模式。它基于抽象的CircuitBreaker接口，并提供了与不同断路器实现的集成。\nSpring Cloud Circuit Breaker通过与各种断路器实现（如Netflix Hystrix、Resilience4j、Sentinel等）的整合，为开发人员提供了一致的编程模型和API，以便在微服务架构中实现断路器模式。\n以下是使用Spring Cloud Circuit Breaker实现断路器模式的一般步骤：\n添加依赖：在项目的构建文件中，添加Spring Cloud Circuit Breaker相应的依赖，例如使用Netflix Hystrix： org.springframework.cloud spring-cloud-starter-circuitbreaker-hystrix 创建断路器方法：在需要保护的方法上，使用@CircuitBreaker注解标记该方法，指定断路器的名称。例如： import org.springframework.cloud.circuitbreaker.annotation.CircuitBreaker; @CircuitBreaker(name = \"myCircuitBreaker\") public String performRemoteCall() { // 远程服务调用逻辑 // ... } 配置断路器属性：可以通过配置文件（如application.properties或application.yml）来设置断路器的属性，如超时时间、故障阈值等。例如： spring: cloud: circuitbreaker: enabled: true default-config: timeout: 1000 circuit-breaker: request-volume-threshold: 10 failure-ratio: 0.5 wait-duration-in-open-state: 5000 处理回退逻辑：可以通过在方法上定义一个备用方法（fallback method）来指定在断路器打开时执行的回退逻辑。可以使用@Fallback注解标记该备用方法。例如： import org.springframework.cloud.circuitbreaker.annotation.Fallback; @Fallback(fallbackMethod = \"fallbackMethod\") public String performRemoteCall() { // 远程服务调用逻辑 // ... } public String fallbackMethod(Exception e) { // 回退逻辑 // ... } 通过上述步骤，Spring Cloud Circuit Breaker会根据断路器的配置和状态来保护被@CircuitBreaker注解标记的方法。当方法调用发生故障或超过阈值时，断路器将打开，并执行备用方法。备用方法可以提供一个预定义的响应或执行一些回退逻辑，以确保系统的稳定性。\n需要注意的是，具体的配置和用法可能因使用的断路器实现（如Hystrix、Resilience4j等）而有所差异。因此，建议参考Spring Cloud Circuit Breaker的官方文档和相关示例，以了解更多关于特定断路器实现的详细信息和用法。\nSpring Cloud Circuit Breaker和常规的断路器实现的区别？ Spring Cloud Circuit Breaker 是基于 Spring Cloud 的断路器模块，提供了对断路器模式的支持。它与常规的断路器实现（如 Hystrix、Resilience4j 等）相比，有以下几个区别：\n统一的抽象接口：Spring Cloud Circuit Breaker 提供了一个统一的抽象接口，即 CircuitBreaker 接口，用于定义断路器的行为和状态。这个接口使得可以在不同的断路器实现之间进行切换和替换，而不需要更改应用程序的代码。\n以下是 CircuitBreaker 接口的定义：\npublic interface CircuitBreaker { String getId(); \u003cT\u003e T run(Supplier\u003cT\u003e toRun); \u003cT\u003e T runCallable(Callable\u003cT\u003e toRun) throws Exception; void reset(); CircuitBreaker.State getState(); default boolean isOpen() { return getState() == CircuitBreaker.State.OPEN; } default boolean isClosed() { return getState() == CircuitBreaker.State.CLOSED; } default boolean isHalfOpen() { return getState() == CircuitBreaker.State.HALF_OPEN; } enum State { CLOSED, OPEN, HALF_OPEN } } CircuitBreaker 接口定义了以下方法：\ngetId()：获取断路器的唯一标识符。 run(Supplier toRun)：运行一个带有返回值的操作（通过 Supplier 提供），并返回操作的结果。如果断路器处于打开状态，将会触发断路器打开的逻辑。 runCallable(Callable toRun)：运行一个带有返回值的操作（通过 Callable 提供），并返回操作的结果。与 run(Supplier toRun) 类似，如果断路器处于打开状态，将会触发断路器打开的逻辑。 reset()：重置断路器的状态。将断路器状态重置为关闭状态。 getState()：获取断路器的当前状态，返回一个 CircuitBreaker.State 枚举值，表示关闭状态、打开状态或半开状态。 isOpen()、isClosed()、isHalfOpen()：这些方法是对状态的便捷判断方法，用于判断断路器当前的状态。 多个断路器实现的支持：Spring Cloud Circuit Breaker 支持多个断路器实现，如 Hystrix、Resilience4j、Sentinel 等。这样，开发人员可以根据实际需求和偏好选择适合的断路器实现。\n与 Spring Cloud 整合：Spring Cloud Circuit Breaker 与 Spring Cloud 生态系统无缝集成，可以与其他 Spring Cloud 组件（如服务注册与发现、负载均衡等）一起使用。它可以通过注解或编程方式与 Spring Boot 应用程序集成，简化了断路器的配置和使用。\n可插拔的实现：Spring Cloud Circuit Breaker 的设计允许开发人员进行自定义的断路器实现。通过实现 CircuitBreakerFactory 接口，可以创建自定义的断路器实例，并将其集成到 Spring Cloud Circuit Breaker 中。\n总的来说，Spring Cloud Circuit Breaker 提供了一种更灵活、可扩展和与 Spring Cloud 集成的方式来实现断路器模式。它使得开发人员可以选择适合自己项目需求的断路器实现，并能够与其他 Spring Cloud 组件无缝协作。\n参考资料 Understanding Circuit Breaker Patter Martin Fowler on Circuit Breaker Fault tolerance in a high volume, distributed system Circuit Breaker pattern ","wordCount":"884","inLanguage":"en","datePublished":"2023-10-26T00:00:00+08:00","dateModified":"2023-10-26T00:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Java设计模式：Circuit Breaker</h1><div class=post-meta><span title='2023-10-26 00:00:00 +0800 CST'>2023-10-26</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;884 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a></li><li><a href=#%e7%a4%ba%e4%be%8b aria-label=示例>示例</a></li><li><a href=#%e7%b1%bb%e5%9b%be aria-label=类图>类图</a></li><li><a href=#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af aria-label=适用场景>适用场景</a></li><li><a href=#faq aria-label=FAQ>FAQ</a><ul><li><a href=#%e5%86%8d%e6%8f%90%e4%be%9b%e4%b8%80%e4%b8%aa%e4%bd%bf%e7%94%a8%e6%96%ad%e8%b7%af%e5%99%a8%e6%a8%a1%e5%bc%8f%e7%9a%84%e4%be%8b%e5%ad%90 aria-label=再提供一个使用断路器模式的例子？>再提供一个使用断路器模式的例子？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96%e6%96%ad%e8%b7%af%e5%99%a8%e6%a8%a1%e5%bc%8f%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=如何优化断路器模式的代码？>如何优化断路器模式的代码？</a></li><li><a href=#%e4%bd%a0%e8%83%bd%e6%8e%a8%e8%8d%90%e4%b8%80%e4%ba%9b%e5%b8%b8%e7%94%a8%e7%9a%84%e6%96%ad%e8%b7%af%e5%99%a8%e6%a8%a1%e5%bc%8f%e7%9a%84java%e5%ba%93%e5%90%97 aria-label=你能推荐一些常用的断路器模式的Java库吗？>你能推荐一些常用的断路器模式的Java库吗？</a></li><li><a href=#spring-cloud-circuit-breaker%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%96%ad%e8%b7%af%e5%99%a8%e6%a8%a1%e5%bc%8f aria-label="Spring Cloud Circuit Breaker如何实现断路器模式？">Spring Cloud Circuit Breaker如何实现断路器模式？</a></li><li><a href=#spring-cloud-circuit-breaker%e5%92%8c%e5%b8%b8%e8%a7%84%e7%9a%84%e6%96%ad%e8%b7%af%e5%99%a8%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="Spring Cloud Circuit Breaker和常规的断路器实现的区别？">Spring Cloud Circuit Breaker和常规的断路器实现的区别？</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><p>本文主要介绍 <a href=https://java-design-patterns.com/zh/patterns/circuit-breaker/>Circuit Breaker</a> 断路器模式，在 <a href=https://java-design-patterns.com/>Java Design Patterns</a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。</p><h2 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h2><p>断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。</p><p>在一个分布式系统中，不可避免地会出现许多外部依赖，如数据库、网络服务等。这些外部依赖可能会发生故障、延迟或不可用的情况。如果没有适当的措施，这些故障可能会导致整个系统的性能下降，甚至系统崩溃。</p><p>断路器模式通过在应用程序和外部依赖之间引入一个断路器接口来解决这个问题。断路器接口充当一个中间层，监视对外部依赖的调用。当外部依赖发生故障时，断路器可以迅速地中断对外部依赖的调用，避免资源的浪费和故障的传递。</p><p>除了断路器接口之外，断路器模式还涉及以下几个重要的知识点：</p><ol><li><strong>故障阈值（Failure Threshold）</strong>：断路器模式通过设置故障阈值来判断服务的健康状态。当服务的失败次数达到或超过故障阈值时，断路器会打开，阻止对服务的进一步调用。</li><li><strong>回退响应（Fallback Response）</strong>：当断路器打开时，可以为调用方提供回退响应。回退响应是一个预定义的响应，用于代替无法正常调用的服务的响应。回退响应可以是事先定义好的静态响应，或者是通过调用备用服务来获取的响应。</li><li><strong>断路器状态（Circuit Breaker State）</strong>：断路器可以处于不同的状态，如关闭（Closed）、打开（Open）和半开（Half-Open）。初始状态通常是关闭状态，表示服务正常可用。当服务的失败次数达到故障阈值时，断路器会打开，阻止对服务的进一步调用。在一定时间后，断路器会进入半开状态，允许发起一次测试调用。如果测试调用成功，断路器将重新关闭；如果测试调用仍然失败，断路器将重新打开。</li><li><strong>断路器的自动恢复（Automatic Recovery）</strong>：断路器模式通常具有自动恢复功能。在断路器打开的状态下，一段时间过去后，断路器会尝试重新关闭，以允许对服务的正常调用。自动恢复可以防止长时间的服务中断，提供给服务一个机会来恢复正常运行。</li><li><strong>健康检查（Health Check）</strong>：断路器模式可以通过定期的健康检查来监控服务的状态。健康检查可以是定期发送心跳请求或执行一些特定的健康检查操作。通过健康检查，可以及时发现服务的故障或不可用状态，并相应地打开断路器。</li></ol><h2 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h2><p>首先，您需要创建一个监控服务类，它将使用断路器来包装远程服务的调用。以下是一个示例监控服务类的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MonitoringService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>CircuitBreaker</span><span class=w> </span><span class=n>delayedService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>CircuitBreaker</span><span class=w> </span><span class=n>quickService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=nf>MonitoringService</span><span class=p>(</span><span class=n>CircuitBreaker</span><span class=w> </span><span class=n>delayedService</span><span class=p>,</span><span class=w> </span><span class=n>CircuitBreaker</span><span class=w> </span><span class=n>quickService</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>delayedService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>delayedService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>quickService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>quickService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>localResourceResponse</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=s>&#34;Local Service is working&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>delayedServiceResponse</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>delayedService</span><span class=p>.</span><span class=na>attemptRequest</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>RemoteServiceException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>getMessage</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>quickServiceResponse</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>quickService</span><span class=p>.</span><span class=na>attemptRequest</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>RemoteServiceException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>getMessage</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上述代码中，<code>MonitoringService</code> 类接受两个断路器对象作为参数，分别用于包装延迟服务和快速服务的远程调用。它还包含一个用于获取本地资源的方法。</p><p>接下来，您需要创建一个默认的断路器实现类，实现 <code>CircuitBreaker</code> 接口，并根据需要自定义逻辑。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>CircuitBreaker</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>recordSuccess</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>recordFailure</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>response</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>evaluateState</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>CircuitBreaker接口定义了三个方法：</p><ol><li><code>recordSuccess()</code>: 当依赖的服务调用成功时调用该方法，用于记录成功的事件。</li><li><code>recordFailure(String response)</code>: 当依赖的服务调用失败时调用该方法，用于记录失败的事件。方法接受一个响应字符串作为参数。</li><li><code>evaluateState()</code>: 该方法用于评估当前断路器的状态。根据预定义的条件，如故障阈值、故障计数和最后故障时间等，判断是否需要改变断路器的状态。</li></ol><p>以下是一个示例的默认断路器实现类的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DefaultCircuitBreaker</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>CircuitBreaker</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>timeout</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>retryTimePeriod</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>RemoteService</span><span class=w> </span><span class=n>service</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>lastFailureTime</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>lastFailureResponse</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>failureCount</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>failureThreshold</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=n>State</span><span class=w> </span><span class=n>state</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>futureTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1000</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1000</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1000</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=nf>DefaultCircuitBreaker</span><span class=p>(</span><span class=n>RemoteService</span><span class=w> </span><span class=n>serviceToCall</span><span class=p>,</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>timeout</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>failureThreshold</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                              </span><span class=kt>long</span><span class=w> </span><span class=n>retryTimePeriod</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>service</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>serviceToCall</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State</span><span class=p>.</span><span class=na>CLOSED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>failureThreshold</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>failureThreshold</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>timeout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>timeout</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>retryTimePeriod</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>retryTimePeriod</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>lastFailureTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>nanoTime</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>futureTime</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>failureCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>recordSuccess</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>failureCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>lastFailureTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>nanoTime</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>futureTime</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State</span><span class=p>.</span><span class=na>CLOSED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>recordFailure</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>response</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>failureCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>failureCount</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>lastFailureTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>nanoTime</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>lastFailureResponse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>response</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>evaluateState</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>failureCount</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>failureThreshold</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>System</span><span class=p>.</span><span class=na>nanoTime</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>lastFailureTime</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>retryTimePeriod</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State</span><span class=p>.</span><span class=na>HALF_OPEN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State</span><span class=p>.</span><span class=na>OPEN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State</span><span class=p>.</span><span class=na>CLOSED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>getState</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>evaluateState</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=n>state</span><span class=p>.</span><span class=na>name</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setState</span><span class=p>(</span><span class=n>State</span><span class=w> </span><span class=n>state</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>state</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>switch</span><span class=w> </span><span class=p>(</span><span class=n>state</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>case</span><span class=w> </span><span class=n>OPEN</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=k>this</span><span class=p>.</span><span class=na>failureCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>failureThreshold</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>case</span><span class=w> </span><span class=n>HALF_OPEN</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=k>this</span><span class=p>.</span><span class=na>failureCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>case</span><span class=w> </span><span class=n>CLOSED</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=k>this</span><span class=p>.</span><span class=na>failureCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=k>this</span><span class=p>.</span><span class=na>lastFailureTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>nanoTime</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>futureTime</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>attemptRequest</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>RemoteServiceException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>state</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>State</span><span class=p>.</span><span class=na>OPEN</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>return</span><span class=w> </span><span class=n>lastFailureResponse</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=c1>// Simulate the remote service call</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>return</span><span class=w> </span><span class=n>service</span><span class=p>.</span><span class=na>call</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>RemoteServiceException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=n>recordFailure</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=na>getMessage</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>throw</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>上述代码中的 <code>DefaultCircuitBreaker</code> 类是一个默认的断路器实现类。它包含了记录成功和失败的方法，评估当前状态的方法，获取当前状态的方法，以及尝试发起请求的方法。根据状态，它可以控制是否允许请求通过或返回上一次的失败响应。</p><p>最后，您可以使用以下代码示例来演示如何使用断路器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>App</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=n>LOGGER</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LoggerFactory</span><span class=p>.</span><span class=na>getLogger</span><span class=p>(</span><span class=n>App</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Program entry point.
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * @param args command line args
</span></span></span><span class=line><span class=cl><span class=cm>   */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=n>serverStartTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>nanoTime</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=n>delayedService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DelayedRemoteService</span><span class=p>(</span><span class=n>serverStartTime</span><span class=p>,</span><span class=w> </span><span class=n>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=n>delayedServiceCircuitBreaker</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DefaultCircuitBreaker</span><span class=p>(</span><span class=n>delayedService</span><span class=p>,</span><span class=w> </span><span class=n>3000</span><span class=p>,</span><span class=w> </span><span class=n>2</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>2000</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1000</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=n>quickService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>QuickRemoteService</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=n>quickServiceCircuitBreaker</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DefaultCircuitBreaker</span><span class=p>(</span><span class=n>quickService</span><span class=p>,</span><span class=w> </span><span class=n>3000</span><span class=p>,</span><span class=w> </span><span class=n>2</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>2000</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1000</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 创建一个可以进行本地和远程调用的监控服务对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=n>monitoringService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>MonitoringService</span><span class=p>(</span><span class=n>delayedServiceCircuitBreaker</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>quickServiceCircuitBreaker</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 获取本地资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=n>monitoringService</span><span class=p>.</span><span class=na>localResourceResponse</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 从延迟服务中获取响应 2 次，以满足失败阈值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=n>monitoringService</span><span class=p>.</span><span class=na>delayedServiceResponse</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=n>monitoringService</span><span class=p>.</span><span class=na>delayedServiceResponse</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 在超过故障阈值限制后获取延迟服务断路器的当前状态</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 现在是打开状态</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=n>delayedServiceCircuitBreaker</span><span class=p>.</span><span class=na>getState</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=c1>// 同时，延迟服务宕机，从健康快速服务获取响应</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=n>monitoringService</span><span class=p>.</span><span class=na>quickServiceResponse</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=n>quickServiceCircuitBreaker</span><span class=p>.</span><span class=na>getState</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 等待延迟的服务响应</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;Waiting for delayed service to become responsive&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Thread</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>5000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>InterruptedException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 检查延时断路器的状态，应该是HALF_OPEN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=n>delayedServiceCircuitBreaker</span><span class=p>.</span><span class=na>getState</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 从延迟服务中获取响应，现在应该是健康的</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=n>monitoringService</span><span class=p>.</span><span class=na>delayedServiceResponse</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 获取成功响应后，它的状态应该是关闭。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOGGER</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=n>delayedServiceCircuitBreaker</span><span class=p>.</span><span class=na>getState</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=类图>类图<a hidden class=anchor aria-hidden=true href=#类图>#</a></h2><p><img loading=lazy src=https://java-design-patterns.com/assets/circuit-breaker.urm-153d25ce.png alt="alt text"></p><h2 id=适用场景>适用场景<a hidden class=anchor aria-hidden=true href=#适用场景>#</a></h2><p>断路器模式在分布式系统和微服务架构中有许多常见的应用场景。以下是一些常见的应用场景：</p><ol><li><strong>外部依赖调用</strong>：在使用外部服务或资源时，例如数据库、网络服务、API调用等，断路器模式可以用来处理外部依赖的故障。它可以防止故障的传递，减少对故障依赖的调用，并提供故障处理机制。</li><li><strong>限流和熔断</strong>：断路器模式可以用于实现限流和熔断机制，以保护系统免受外部依赖的过载或故障。它可以监控请求的频率和响应时间，并在达到阈值时阻止对外部依赖的调用，以避免系统崩溃。</li><li><strong>降级和容错</strong>：在面对外部依赖故障时，断路器模式可以提供降级和容错机制。它可以切换到备用逻辑或服务，以提供基本的功能或默认值，保持系统的部分可用性。</li><li><strong>重试和恢复</strong>：断路器模式可以用于实现故障重试和恢复机制。当外部依赖发生故障时，断路器可以尝试重新连接或重新调用依赖，以尽快恢复正常操作。</li><li><strong>监控和报告</strong>：断路器模式通常与监控和报告机制结合使用，以提供对系统状态和故障的可视化和警报。它可以记录故障信息、请求统计、错误率等指标，帮助开发人员和运维团队监控系统健康状况。</li></ol><p>总之，断路器模式适用于任何可能遇到外部依赖故障的场景。它可以提供故障隔离、弹性和自愈能力，提高系统的可用性、可靠性和性能。</p><h2 id=faq>FAQ<a hidden class=anchor aria-hidden=true href=#faq>#</a></h2><h3 id=再提供一个使用断路器模式的例子>再提供一个使用断路器模式的例子？<a hidden class=anchor aria-hidden=true href=#再提供一个使用断路器模式的例子>#</a></h3><p>当涉及到使用断路器模式的例子时，一个常见的应用场景是在微服务架构中保护对其他服务的调用。以下是一个简单的示例：</p><p>假设我们有一个电子商务应用程序，它包含订单服务和库存服务。订单服务负责处理用户的订单，而库存服务则负责管理产品的库存信息。为了保护订单服务对库存服务的调用，我们可以使用断路器模式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>OrderService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>CircuitBreaker</span><span class=w> </span><span class=n>circuitBreaker</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>InventoryService</span><span class=w> </span><span class=n>inventoryService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>OrderService</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 初始化断路器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>circuitBreaker</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CircuitBreaker</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 初始化库存服务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>inventoryService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>InventoryService</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>placeOrder</span><span class=p>(</span><span class=n>Order</span><span class=w> </span><span class=n>order</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 检查断路器状态</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>circuitBreaker</span><span class=p>.</span><span class=na>isClosed</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 调用库存服务检查库存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>boolean</span><span class=w> </span><span class=n>hasStock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>inventoryService</span><span class=p>.</span><span class=na>checkStock</span><span class=p>(</span><span class=n>order</span><span class=p>.</span><span class=na>getProduct</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hasStock</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// 执行订单处理逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// 订单处理成功，记录成功事件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>circuitBreaker</span><span class=p>.</span><span class=na>recordSuccess</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// 库存不足，记录失败事件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>circuitBreaker</span><span class=p>.</span><span class=na>recordFailure</span><span class=p>(</span><span class=s>&#34;Insufficient stock&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=s>&#34;Insufficient stock&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 断路器打开，执行回退逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=s>&#34;Order service is currently unavailable. Please try again later.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 处理异常情况，记录失败事件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>circuitBreaker</span><span class=p>.</span><span class=na>recordFailure</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=na>getMessage</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>throw</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上述例子中，<code>OrderService</code>类是订单服务的实现。它通过使用<code>CircuitBreaker</code>类来保护对库存服务的调用。在<code>placeOrder()</code>方法中，首先检查断路器的状态。如果断路器处于关闭状态（即可用状态），则调用库存服务的<code>checkStock()</code>方法来检查产品的库存情况。如果库存足够，订单处理成功，并记录成功事件；如果库存不足，订单处理失败，并记录失败事件。</p><p>如果断路器处于打开状态，说明库存服务不可用，此时将执行回退逻辑，抛出异常或提供相应的回退响应。无论是执行回退逻辑还是处理异常情况，都需要记录失败事件。</p><p>通过使用断路器模式，我们可以保护订单服务免受库存服务故障的影响。断路器会监控库存服务的健康状态，并在故障发生时打开断路器，阻止对库存服务的进一步调用。这样，即使库存服务不可用，订单服务仍然能够提供恰当的响应，并避免因连锁故障而导致整个系统崩溃。</p><h3 id=如何优化断路器模式的代码>如何优化断路器模式的代码？<a hidden class=anchor aria-hidden=true href=#如何优化断路器模式的代码>#</a></h3><p>当编写断路器模式的代码时，可以进行一些优化和改进。以下是一些可能的优化方法：</p><ol><li><strong>使用现有的库或框架</strong>：断路器模式是一个常见的设计模式，许多流行的Java库和框架已经提供了断路器实现，例如 Netflix的Hystrix、Resilience4j等。使用这些库可以减少您自己编写和维护断路器代码的工作量，并且它们通常具有更多的功能和配置选项。</li><li><strong>超时设置</strong>：在断路器模式中，设置适当的超时时间非常重要。您可以使用Java的<code>Future</code>、<code>CompletableFuture</code>或第三方库来实现调用的超时控制。确保在超过超时时间后，取消或中断正在进行的请求，并记录为失败。</li><li><strong>错误计数器和重置策略</strong>：根据失败计数器和重置策略，您可以更准确地确定何时打开、关闭或半开断路器。考虑使用滑动窗口或滑动时间窗口来计算错误计数，并根据预定义的规则进行状态转换。</li><li><strong>熔断指标和监控</strong>：在大型应用程序中，了解断路器的使用情况和性能指标非常重要。您可以使用指标收集库（例如Micrometer）和监控系统（例如Prometheus、Grafana）来收集和可视化断路器的指标数据，以便进行监控和故障排除。</li><li><strong>异步支持</strong>：如果您的应用程序需要进行大量的并发请求，考虑使用异步编程模型（例如Java的<code>CompletableFuture</code>、响应式编程库等）。这样可以更好地利用资源，并提高应用程序的吞吐量和性能。</li></ol><h3 id=你能推荐一些常用的断路器模式的java库吗>你能推荐一些常用的断路器模式的Java库吗？<a hidden class=anchor aria-hidden=true href=#你能推荐一些常用的断路器模式的java库吗>#</a></h3><p>当涉及到断路器模式的Java库时，以下是一些常用的选择：</p><ol><li><strong>Netflix Hystrix</strong>：Hystrix是一个广泛使用的断路器库，为分布式系统提供故障容错和弹性功能。它具有自适应的断路器逻辑、请求超时、线程池隔离、回退逻辑等功能。然而，请注意，Netflix宣布停止Hystrix的维护和开发，推荐使用Resilience4j或其他替代库。</li><li><strong>Resilience4j</strong>：Resilience4j是一个轻量级的断路器和弹性库，专为Java 8+应用程序设计。它提供了断路器、限流、重试、超时等功能，并与Java函数式编程风格很好地配合。Resilience4j还与Spring Boot集成得很好，可以轻松地在Spring应用程序中使用。</li><li><strong>Sentinel</strong>：Sentinel是阿里巴巴开源的一款弹性流控框架，它提供了断路器、流量控制、熔断降级等功能。Sentinel支持针对流量实时监控和规则配置，可以帮助您保护应用程序免受异常流量和故障的影响。</li><li><strong>Akka Circuit Breaker</strong>：Akka是一个用于构建高并发和分布式应用程序的工具包，其中包含了一个名为Circuit Breaker的模块。Akka的Circuit Breaker模块提供了断路器功能，并与Akka的Actor模型和消息传递机制集成得很好。</li><li><a href=https://spring.io/projects/spring-cloud-circuitbreaker>Spring Cloud Circuit Breaker</a>：Spring Cloud Circuit Breaker是Spring Cloud生态系统的一部分，它提供了与多个断路器实现（如Hystrix、Resilience4j、Sentinel等）的集成。因此，您可以根据需要选择合适的断路器实现，并在Spring应用程序中使用它们。</li></ol><h3 id=spring-cloud-circuit-breaker如何实现断路器模式>Spring Cloud Circuit Breaker如何实现断路器模式？<a hidden class=anchor aria-hidden=true href=#spring-cloud-circuit-breaker如何实现断路器模式>#</a></h3><p>Spring Cloud Circuit Breaker是Spring Cloud提供的一个模块，用于实现断路器模式。它基于抽象的<code>CircuitBreaker</code>接口，并提供了与不同断路器实现的集成。</p><p>Spring Cloud Circuit Breaker通过与各种断路器实现（如Netflix Hystrix、Resilience4j、Sentinel等）的整合，为开发人员提供了一致的编程模型和API，以便在微服务架构中实现断路器模式。</p><p>以下是使用Spring Cloud Circuit Breaker实现断路器模式的一般步骤：</p><ol><li>添加依赖：在项目的构建文件中，添加Spring Cloud Circuit Breaker相应的依赖，例如使用Netflix Hystrix：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;dependency&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;groupId&gt;</span>org.springframework.cloud<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;artifactId&gt;</span>spring-cloud-starter-circuitbreaker-hystrix<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/dependency&gt;</span>
</span></span></code></pre></div><ol start=2><li>创建断路器方法：在需要保护的方法上，使用<code>@CircuitBreaker</code>注解标记该方法，指定断路器的名称。例如：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>org.springframework.cloud.circuitbreaker.annotation.CircuitBreaker</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@CircuitBreaker</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;myCircuitBreaker&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>performRemoteCall</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 远程服务调用逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol start=3><li>配置断路器属性：可以通过配置文件（如<code>application.properties</code>或<code>application.yml</code>）来设置断路器的属性，如超时时间、故障阈值等。例如：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spring</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>cloud</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>circuitbreaker</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>default-config</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>timeout</span><span class=p>:</span><span class=w> </span><span class=m>1000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>circuit-breaker</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>request-volume-threshold</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>failure-ratio</span><span class=p>:</span><span class=w> </span><span class=m>0.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>wait-duration-in-open-state</span><span class=p>:</span><span class=w> </span><span class=m>5000</span><span class=w>
</span></span></span></code></pre></div><ol start=4><li>处理回退逻辑：可以通过在方法上定义一个备用方法（fallback method）来指定在断路器打开时执行的回退逻辑。可以使用<code>@Fallback</code>注解标记该备用方法。例如：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>org.springframework.cloud.circuitbreaker.annotation.Fallback</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Fallback</span><span class=p>(</span><span class=n>fallbackMethod</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;fallbackMethod&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>performRemoteCall</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 远程服务调用逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>fallbackMethod</span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 回退逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>通过上述步骤，Spring Cloud Circuit Breaker会根据断路器的配置和状态来保护被<code>@CircuitBreaker</code>注解标记的方法。当方法调用发生故障或超过阈值时，断路器将打开，并执行备用方法。备用方法可以提供一个预定义的响应或执行一些回退逻辑，以确保系统的稳定性。</p><p>需要注意的是，具体的配置和用法可能因使用的断路器实现（如Hystrix、Resilience4j等）而有所差异。因此，建议参考Spring Cloud Circuit Breaker的官方文档和相关示例，以了解更多关于特定断路器实现的详细信息和用法。</p><h3 id=spring-cloud-circuit-breaker和常规的断路器实现的区别>Spring Cloud Circuit Breaker和常规的断路器实现的区别？<a hidden class=anchor aria-hidden=true href=#spring-cloud-circuit-breaker和常规的断路器实现的区别>#</a></h3><p>Spring Cloud Circuit Breaker 是基于 Spring Cloud 的断路器模块，提供了对断路器模式的支持。它与常规的断路器实现（如 Hystrix、Resilience4j 等）相比，有以下几个区别：</p><ol><li><p>统一的抽象接口：Spring Cloud Circuit Breaker 提供了一个统一的抽象接口，即 <code>CircuitBreaker</code> 接口，用于定义断路器的行为和状态。这个接口使得可以在不同的断路器实现之间进行切换和替换，而不需要更改应用程序的代码。</p><blockquote><p>以下是 <code>CircuitBreaker</code> 接口的定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>CircuitBreaker</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=nf>getId</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=nf>run</span><span class=p>(</span><span class=n>Supplier</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>toRun</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=nf>runCallable</span><span class=p>(</span><span class=n>Callable</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>toRun</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>reset</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>CircuitBreaker</span><span class=p>.</span><span class=na>State</span><span class=w> </span><span class=nf>getState</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>default</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>isOpen</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>getState</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>CircuitBreaker</span><span class=p>.</span><span class=na>State</span><span class=p>.</span><span class=na>OPEN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>default</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>isClosed</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>getState</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>CircuitBreaker</span><span class=p>.</span><span class=na>State</span><span class=p>.</span><span class=na>CLOSED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>default</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>isHalfOpen</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>getState</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>CircuitBreaker</span><span class=p>.</span><span class=na>State</span><span class=p>.</span><span class=na>HALF_OPEN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>enum</span><span class=w> </span><span class=n>State</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>CLOSED</span><span class=p>,</span><span class=w> </span><span class=n>OPEN</span><span class=p>,</span><span class=w> </span><span class=n>HALF_OPEN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>CircuitBreaker</code> 接口定义了以下方法：</p><ul><li><code>getId()</code>：获取断路器的唯一标识符。</li><li><code>run(Supplier&lt;T> toRun)</code>：运行一个带有返回值的操作（通过 <code>Supplier</code> 提供），并返回操作的结果。如果断路器处于打开状态，将会触发断路器打开的逻辑。</li><li><code>runCallable(Callable&lt;T> toRun)</code>：运行一个带有返回值的操作（通过 <code>Callable</code> 提供），并返回操作的结果。与 <code>run(Supplier&lt;T> toRun)</code> 类似，如果断路器处于打开状态，将会触发断路器打开的逻辑。</li><li><code>reset()</code>：重置断路器的状态。将断路器状态重置为关闭状态。</li><li><code>getState()</code>：获取断路器的当前状态，返回一个 <code>CircuitBreaker.State</code> 枚举值，表示关闭状态、打开状态或半开状态。</li><li><code>isOpen()</code>、<code>isClosed()</code>、<code>isHalfOpen()</code>：这些方法是对状态的便捷判断方法，用于判断断路器当前的状态。</li></ul></blockquote></li><li><p>多个断路器实现的支持：Spring Cloud Circuit Breaker 支持多个断路器实现，如 Hystrix、Resilience4j、Sentinel 等。这样，开发人员可以根据实际需求和偏好选择适合的断路器实现。</p></li><li><p>与 Spring Cloud 整合：Spring Cloud Circuit Breaker 与 Spring Cloud 生态系统无缝集成，可以与其他 Spring Cloud 组件（如服务注册与发现、负载均衡等）一起使用。它可以通过注解或编程方式与 Spring Boot 应用程序集成，简化了断路器的配置和使用。</p></li><li><p>可插拔的实现：Spring Cloud Circuit Breaker 的设计允许开发人员进行自定义的断路器实现。通过实现 <code>CircuitBreakerFactory</code> 接口，可以创建自定义的断路器实例，并将其集成到 Spring Cloud Circuit Breaker 中。</p></li></ol><p>总的来说，Spring Cloud Circuit Breaker 提供了一种更灵活、可扩展和与 Spring Cloud 集成的方式来实现断路器模式。它使得开发人员可以选择适合自己项目需求的断路器实现，并能够与其他 Spring Cloud 组件无缝协作。</p><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://itnext.io/understand-circuitbreaker-design-pattern-with-simple-practical-example-92a752615b42>Understanding Circuit Breaker Patter</a></li><li><a href=https://martinfowler.com/bliki/CircuitBreaker.html>Martin Fowler on Circuit Breaker</a></li><li><a href=https://medium.com/netflix-techblog/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a>Fault tolerance in a high volume, distributed system</a></li><li><a href=https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker>Circuit Breaker pattern</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/><span class=title>« Prev</span><br><span>JHipster安装和介绍</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/><span class=title>Next »</span><br><span>Java设计模式：Chain</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Circuit Breaker on x" href="https://x.com/intent/tweet/?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCircuit%20Breaker&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f26%2fjava-design-patterns-circuit-breaker%2f&amp;hashtags=java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Circuit Breaker on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f26%2fjava-design-patterns-circuit-breaker%2f&amp;title=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCircuit%20Breaker&amp;summary=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCircuit%20Breaker&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f26%2fjava-design-patterns-circuit-breaker%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Circuit Breaker on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f26%2fjava-design-patterns-circuit-breaker%2f&title=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCircuit%20Breaker"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Circuit Breaker on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f26%2fjava-design-patterns-circuit-breaker%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Circuit Breaker on whatsapp" href="https://api.whatsapp.com/send?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCircuit%20Breaker%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f26%2fjava-design-patterns-circuit-breaker%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Circuit Breaker on telegram" href="https://telegram.me/share/url?text=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCircuit%20Breaker&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f26%2fjava-design-patterns-circuit-breaker%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java设计模式：Circuit Breaker on ycombinator" href="https://news.ycombinator.com/submitlink?t=Java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9aCircuit%20Breaker&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f10%2f26%2fjava-design-patterns-circuit-breaker%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>