<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]《Grokking the System Design Interview》域名系统 | ChenSoul</title>
<meta name=keywords content="architecture"><meta name=description content="这是一篇双语翻译的文章，原文出自《Grokking the System Design Interview》教程的 Domain Name System 这篇章节。
Introduction to Domain Name System (DNS) 域名系统 (DNS) 简介
The origins of DNS DNS 的起源
Let’s consider the example of a mobile phone where a unique number is associated with each user. To make calls to friends, we can initially try to memorize some of the phone numbers. However, as the number of contacts grows, we’ll have to use a phone book to keep track of all our contacts. This way, whenever we need to make a call, we’ll refer to the phone book and dial the number we need.
让我们考虑一个移动电话的示例，其中每个用户都有一个唯一的号码。为了给朋友打电话，我们首先可以尝试记住一些电话号码。然而，随着联系人数量的增加，我们将不得不使用电话簿来跟踪所有联系人。这样，每当我们需要打电话时，我们都会查阅电话簿并拨打我们需要的号码。"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/11/17/dns/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/11/17/dns/><meta name=twitter:title content="[译]《Grokking the System Design Interview》域名系统 | ChenSoul"><meta name=twitter:description content="这是一篇双语翻译的文章，原文出自《Grokking the System Design Interview》教程的 Domain Name System 这篇章节。
Introduction to Domain Name System (DNS) 域名系统 (DNS) 简介
The origins of DNS DNS 的起源
Let’s consider the example of a mobile phone where a unique number is associated with each user. To make calls to friends, we can initially try to memorize some of the phone numbers. However, as the number of contacts grows, we’ll have to use a phone book to keep track of all our contacts. This way, whenever we need to make a call, we’ll refer to the phone book and dial the number we need.
让我们考虑一个移动电话的示例，其中每个用户都有一个唯一的号码。为了给朋友打电话，我们首先可以尝试记住一些电话号码。然而，随着联系人数量的增加，我们将不得不使用电话簿来跟踪所有联系人。这样，每当我们需要打电话时，我们都会查阅电话簿并拨打我们需要的号码。"><meta property="og:title" content="[译]《Grokking the System Design Interview》域名系统 | ChenSoul"><meta property="og:description" content="这是一篇双语翻译的文章，原文出自《Grokking the System Design Interview》教程的 Domain Name System 这篇章节。
Introduction to Domain Name System (DNS) 域名系统 (DNS) 简介
The origins of DNS DNS 的起源
Let’s consider the example of a mobile phone where a unique number is associated with each user. To make calls to friends, we can initially try to memorize some of the phone numbers. However, as the number of contacts grows, we’ll have to use a phone book to keep track of all our contacts. This way, whenever we need to make a call, we’ll refer to the phone book and dial the number we need.
让我们考虑一个移动电话的示例，其中每个用户都有一个唯一的号码。为了给朋友打电话，我们首先可以尝试记住一些电话号码。然而，随着联系人数量的增加，我们将不得不使用电话簿来跟踪所有联系人。这样，每当我们需要打电话时，我们都会查阅电话簿并拨打我们需要的号码。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/11/17/dns/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-17T17:00:00+08:00"><meta property="article:modified_time" content="2023-11-17T17:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]《Grokking the System Design Interview》域名系统","item":"https://blog.chensoul.cc/posts/2023/11/17/dns/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]《Grokking the System Design Interview》域名系统 | ChenSoul","name":"[译]《Grokking the System Design Interview》域名系统","description":"这是一篇双语翻译的文章，原文出自《Grokking the System Design Interview》教程的 Domain Name System 这篇章节。\nIntroduction to Domain Name System (DNS) 域名系统 (DNS) 简介\nThe origins of DNS DNS 的起源\nLet’s consider the example of a mobile phone where a unique number is associated with each user. To make calls to friends, we can initially try to memorize some of the phone numbers. However, as the number of contacts grows, we’ll have to use a phone book to keep track of all our contacts. This way, whenever we need to make a call, we’ll refer to the phone book and dial the number we need.\n让我们考虑一个移动电话的示例，其中每个用户都有一个唯一的号码。为了给朋友打电话，我们首先可以尝试记住一些电话号码。然而，随着联系人数量的增加，我们将不得不使用电话簿来跟踪所有联系人。这样，每当我们需要打电话时，我们都会查阅电话簿并拨打我们需要的号码。","keywords":["architecture"],"wordCount":"2809","inLanguage":"en","datePublished":"2023-11-17T17:00:00+08:00","dateModified":"2023-11-17T17:00:00+08:00","author":[{"@type":"Person","name":"chensoul"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/11/17/dns/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>[译]《Grokking the System Design Interview》域名系统</h1><div class=post-meta><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-11-17</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/architecture/>Architecture</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>14 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction-to-domain-name-system-dns aria-label="Introduction to Domain Name System (DNS)">Introduction to Domain Name System (DNS)</a></li><li><a href=#the-origins-of-dns aria-label="The origins of DNS">The origins of DNS</a><ul><li><a href=#what-is-dns aria-label="What is DNS?">What is DNS?</a></li><li><a href=#important-details aria-label="Important details">Important details</a></li><li><a href=#common-types-of-resource-records aria-label="Common Types of Resource Records">Common Types of Resource Records</a></li></ul></li><li><a href=#how-the-domain-name-system-works aria-label="How the Domain Name System Works">How the Domain Name System Works</a><ul><li><a href=#dns-hierarchy aria-label="DNS hierarchy">DNS hierarchy</a><ul><li><a href=#iterative-versus-recursive-query-resolution aria-label="Iterative versus recursive query resolution">Iterative versus recursive query resolution</a></li></ul></li><li><a href=#caching aria-label=Caching>Caching</a></li><li><a href=#dns-as-a-distributed-system aria-label="DNS as a distributed system">DNS as a distributed system</a><ul><li><a href=#highly-scalable aria-label="Highly scalable">Highly scalable</a></li><li><a href=#reliable aria-label=Reliable>Reliable</a></li><li><a href=#consistent aria-label=Consistent>Consistent</a></li></ul></li><li><a href=#test-it-out aria-label="Test it out">Test it out</a><ul><li><a href=#the-nslookup-output aria-label="The nslookup output">The <code>nslookup</code> output</a></li><li><a href=#the-dig-output aria-label="The dig output">The <code>dig</code> output</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>这是一篇双语翻译的文章，原文出自《Grokking the System Design Interview》教程的 <a href=https://www.educative.io/courses/grokking-modern-system-design-interview-for-engineers-managers/introduction-to-domain-name-system-dns>Domain Name System</a> 这篇章节。</p><hr><h1 id=introduction-to-domain-name-system-dns>Introduction to Domain Name System (DNS)</h1><blockquote><p>域名系统 (DNS) 简介</p></blockquote><h1 id=the-origins-of-dns>The origins of DNS</h1><blockquote><p>DNS 的起源</p></blockquote><p>Let’s consider the example of a mobile phone where a unique number is associated with each user. To make calls to friends, we can initially try to memorize some of the phone numbers. However, as the number of contacts grows, we’ll have to use a phone book to keep track of all our contacts. This way, whenever we need to make a call, we’ll refer to the phone book and dial the number we need.</p><blockquote><p>让我们考虑一个移动电话的示例，其中每个用户都有一个唯一的号码。为了给朋友打电话，我们首先可以尝试记住一些电话号码。然而，随着联系人数量的增加，我们将不得不使用电话簿来跟踪所有联系人。这样，每当我们需要打电话时，我们都会查阅电话簿并拨打我们需要的号码。</p></blockquote><p>Similarly, computers are uniquely identified by IP addresses—for example, <code>104.18.2.119</code> is an IP address. We use IP addresses to visit a website hosted on a machine. Since humans cannot easily remember IP addresses to visit domain names (an example domain name being <a href=http://educative.io/>educative.io</a>), we need a phone book-like repository that can maintain all mappings of domain names to IP addresses. In this chapter, we’ll see how DNS serves as the Internet’s phone book.</p><blockquote><p>同样，计算机由 IP 地址唯一标识，例如， <code>104.18.2.119</code> 是一个 IP 地址。我们使用 IP 地址来访问计算机上托管的网站。由于人类无法轻易记住 IP 地址来访问域名（例如域名 eduducative.io），因此我们需要一个类似电话簿的存储库来维护域名到 IP 地址的所有映射。在本章中，我们将了解 DNS 如何充当互联网的电话簿。</p></blockquote><img src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/educative-dns-06.png alt=educative-dns-06 style=width:75%><h2 id=what-is-dns>What is DNS?</h2><blockquote><p>什么是 DNS？</p></blockquote><p>The <strong>domain name system (DNS)</strong> is the Internet’s naming service that maps human-friendly domain names to machine-readable IP addresses. The service of DNS is transparent to users. When a user enters a domain name in the browser, the browser has to translate the domain name to IP address by asking the DNS infrastructure. Once the desired IP address is obtained, the user’s request is forwarded to the destination web server.</p><blockquote><p>域名系统 (DNS) 是互联网的命名服务，它将人类友好的域名映射到机器可读的 IP 地址。 DNS服务对用户是透明的。当用户在浏览器中输入域名时，浏览器必须通过询问 DNS 基础设施将域名转换为 IP 地址。一旦获得所需的 IP 地址，用户的请求就会转发到目标 Web 服务器。</p></blockquote><p>The slides below show the high-level flow of the working of DNS:</p><blockquote><p>下面的幻灯片显示了 DNS 工作的高级流程：</p></blockquote><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/educative-dns-07.png alt=educative-dns-07></p><p>The entire operation is performed very quickly. Therefore, the end user experiences minimum delay. We’ll also see how browsers save some of the frequently used mappings for later use in the next lesson.</p><blockquote><p>整个操作进行得非常快。因此，最终用户体验到的延迟最小。我们还将了解浏览器如何保存一些常用的映射以供下一课稍后使用。</p></blockquote><h2 id=important-details>Important details</h2><blockquote><p>重要细节</p></blockquote><p>Let’s highlight some of the important details about DNS, some of which we’ll cover in the next lesson:</p><blockquote><p>让我们重点介绍有关 DNS 的一些重要细节，其中一些我们将在下一课中介绍：</p></blockquote><ul><li><p><strong>Name servers:</strong> It’s important to understand that the DNS isn’t a single server. It’s a complete infrastructure with numerous servers. DNS servers that respond to users’ queries are called <strong>name servers</strong>.</p><blockquote><p>名称服务器：重要的是要了解 DNS 不是单个服务器。它是一个拥有大量服务器的完整基础设施。响应用户查询的 DNS 服务器称为名称服务器。</p></blockquote></li><li><p><strong>Resource records:</strong> The DNS database stores domain name to IP address mappings in the form of resource records (RR). The RR is the smallest unit of information that users request from the name servers. There are different types of RRs. The table below describes common RRs. The three important pieces of information are <em>type</em>, <em>name</em>, and <em>value</em>. The <em>name</em> and <em>value</em> change depending upon the <em>type</em> of the RR.</p><blockquote><p>资源记录：DNS 数据库以资源记录 (RR) 的形式存储域名到 IP 地址的映射。 RR 是用户从名称服务器请求的最小信息单元。 RR 有不同类型。下表描述了常见的 RR。三个重要的信息是类型、名称和值。名称和值根据 RR 的类型而变化。</p></blockquote></li></ul><h2 id=common-types-of-resource-records>Common Types of Resource Records</h2><blockquote><p>资源记录的常见类型</p></blockquote><table><thead><tr><th>**Type **</th><th>**Description **</th><th>**Name **</th><th><strong>Value</strong></th><th>**Example (Type, Name, Value) **</th></tr></thead><tbody><tr><td>A</td><td>Provides the hostname to IP address mapping</td><td>Hostname</td><td>IP address</td><td>(A, relay1.main.educative.io,104.18.2.119)</td></tr><tr><td>NS</td><td>Provides the hostname that is the authoritative DNS for a domain name</td><td>Domain name</td><td>Hostname</td><td>(NS, educative.io, dns.educative.io)</td></tr><tr><td>CNAME</td><td>Provides the mapping from alias to canonical hostname</td><td>Hostname</td><td>Canonical name</td><td>(CNAME, educative.io, server1.primary.educative.io)</td></tr><tr><td>MX</td><td>Provides the mapping of mail server from alias to canonical hostname</td><td>Hostname</td><td>Canonical name</td><td>(MX, mail.educative.io, mailserver1.backup.educative.io)</td></tr></tbody></table><ul><li><p><strong>Caching:</strong> DNS uses caching at different layers to reduce request latency for the user. Caching plays an important role in reducing the burden on DNS infrastructure because it has to cater to the queries of the entire Internet.</p><blockquote><p>缓存：DNS 使用不同层的缓存来减少用户的请求延迟。缓存在减轻 DNS 基础设施的负担方面发挥着重要作用，因为它必须满足整个互联网的查询。</p></blockquote></li><li><p><strong>Hierarchy:</strong> DNS name servers are in a hierarchical form. The hierarchical structure allows DNS to be highly scalable because of its increasing size and query load. In the next lesson, we’ll look at how a tree-like structure is used to manage the entire DNS database.</p><blockquote><p>层次结构：DNS 名称服务器采用层次结构形式。由于其规模和查询负载不断增加，分层结构使 DNS 具有高度可扩展性。在下一课中，我们将了解如何使用树状结构来管理整个 DNS 数据库。</p></blockquote></li></ul><p>Let’s explore more details of the above points in the next lesson to get more clarity.</p><blockquote><p>让我们在下一课中探讨上述要点的更多细节，以便更加清晰。</p></blockquote><h1 id=how-the-domain-name-system-works>How the Domain Name System Works</h1><blockquote><p>域名系统如何运作</p></blockquote><p>Through this lesson, we’ll answer the following questions:</p><blockquote><p>通过本课，我们将回答以下问题：</p></blockquote><ul><li><p>How is the DNS hierarchy formed using various types of DNS name servers?</p><blockquote><p>如何使用各种类型的 DNS 名称服务器形成 DNS 层次结构？</p></blockquote></li><li><p>How is caching performed at different levels of the Internet to reduce the querying burden over the DNS infrastructure?</p><blockquote><p>如何在互联网的不同级别执行缓存以减轻 DNS 基础设施的查询负担？</p></blockquote></li><li><p>How does the distributed nature of the DNS infrastructure help its robustness?</p><blockquote><p>DNS 基础设施的分布式特性如何有助于其稳健性？</p></blockquote></li></ul><p>Let’s get started.</p><blockquote><p>让我们开始吧。</p></blockquote><h2 id=dns-hierarchy>DNS hierarchy</h2><blockquote><p>DNS层次结构</p></blockquote><p>As stated before, the DNS isn’t a single server that accepts requests and responds to user queries. It’s a complete infrastructure with name servers at different hierarchies.</p><blockquote><p>如前所述，DNS 不是接受请求并响应用户查询的单个服务器。它是一个完整的基础设施，具有不同层次结构的名称服务器。</p></blockquote><p>There are mainly four types of servers in the DNS hierarchy:</p><blockquote><p>DNS 层次结构中主要有四种类型的服务器：</p></blockquote><ol><li><p><strong>DNS resolver:</strong> Resolvers initiate the querying sequence and forward requests to the other DNS name servers. Typically, DNS resolvers lie within the premise of the user’s network. However, DNS resolvers can also cater to users’ DNS queries through caching techniques, as we will see shortly. These servers can also be called local or default servers.</p><blockquote><p>DNS 解析器：解析器启动查询序列并将请求转发到其他 DNS 名称服务器。通常，DNS 解析器位于用户网络的内部。然而，DNS 解析器还可以通过缓存技术来满足用户的 DNS 查询，我们很快就会看到。这些服务器也可以称为本地或默认服务器。</p></blockquote></li><li><p><strong>Root-level name servers:</strong> These servers receive requests from local servers. Root name servers maintain name servers based on top-level domain names, such as <code>.com</code>, <code>.edu</code>, <code>.us</code>, and so on. For instance, when a user requests the IP address of <a href=http://educative.io/>educative.io</a>, root-level name servers will return a list of top-level domain (TLD) servers that hold the IP addresses of the <code>.io</code> domain.</p><blockquote><p>根级名称服务器：这些服务器接收来自本地服务器的请求。根名称服务器维护基于顶级域名的名称服务器，例如 <code>.com</code> 、 <code>.edu</code> 、 <code>.us</code> 等。例如，当用户请求 educative.io 的 IP 地址时，根级名称服务器将返回保存 <code>.io</code> 域的 IP 地址的顶级域 (TLD) 服务器列表。</p></blockquote></li><li><p><strong>Top-level domain (TLD) name servers:</strong> These servers hold the IP addresses of authoritative name servers. The querying party will get a list of IP addresses that belong to the authoritative servers of the organization.</p><blockquote><p>顶级域名 (TLD) 名称服务器：这些服务器保存权威名称服务器的 IP 地址。查询方将获得属于该组织的权威服务器的IP地址列表。</p></blockquote></li><li><p><strong>Authoritative name servers:</strong> These are the organization’s DNS name servers that provide the IP addresses of the web or application servers.</p><blockquote><p>权威名称服务器：这些是组织的 DNS 名称服务器，提供 Web 或应用程序服务器的 IP 地址。</p></blockquote></li></ol><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/educative-dns-01.png alt=image-20231117165436915></p><blockquote><p><strong>Question</strong></p><blockquote><p>问题</p></blockquote><p>How are DNS names processed? For example, will <a href=http://educative.io/>educative.io</a> be processed from left to right or right to left?</p><blockquote><p>DNS 名称是如何处理的？例如，educative.io 是从左到右还是从右到左处理？</p></blockquote><p>Unlike UNIX files, which are processed from left to right, DNS names are processed from right to left. In the case of <a href=http://educative.io/>educative.io</a>, the resolvers will first resolve the <code>.io</code> part, then <code>educative</code>, and so on.</p><blockquote><p>与从左到右处理的 UNIX 文件不同，DNS 名称是从右到左处理的。对于 educative.io，解析器将首先解析 <code>.io</code> 部分，然后解析 <code>educative</code> ，依此类推。</p></blockquote><p>Visually, however, the DNS hierarchy can be viewed as a tree.</p><blockquote><p>然而，从视觉上看，DNS 层次结构可以视为一棵树。</p></blockquote></blockquote><h3 id=iterative-versus-recursive-query-resolution>Iterative versus recursive query resolution</h3><blockquote><p>迭代与递归查询解析</p></blockquote><p>There are two ways to perform a DNS query:</p><blockquote><p>有两种方法可以执行 DNS 查询：</p></blockquote><ol><li><p><strong>Iterative:</strong> The local server requests the root, TLD, and the authoritative servers for the IP address.</p><blockquote><p>迭代：本地服务器向根服务器、TLD 和权威服务器请求 IP 地址。</p></blockquote></li><li><p><strong>Recursive:</strong> The end user requests the local server. The local server further requests the root DNS name servers. The root name servers forward the requests to other name servers.</p><blockquote><p>递归：最终用户请求本地服务器。本地服务器进一步请求根 DNS 名称服务器。根名称服务器将请求转发到其他名称服务器。</p></blockquote></li></ol><p>In the following illustration (on the left), DNS query resolution is iterative from the perspective of the local/ISP server:</p><blockquote><p>在下图中（左），从本地/ISP服务器的角度来看，DNS查询解析是迭代的：</p></blockquote><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/educative-dns-02.png alt=educative-dns-02></p><p><strong>Note:</strong> Typically, an iterative query is preferred to reduce query load on DNS infrastructure.</p><blockquote><p>注意：通常，首选迭代查询来减少 DNS 基础设施上的查询负载。</p></blockquote><p>These days, we’ll find many third-party public DNS resolvers offered by Google, Cloudflare, OpenDNS, and many more. The interesting fact is that these public DNS servers may provide quicker responses than the local ISP DNS facilities.</p><blockquote><p>如今，我们会发现 Google、Cloudflare、OpenDNS 等提供的许多第三方公共 DNS 解析器。有趣的是，这些公共 DNS 服务器可能比本地 ISP DNS 设施提供更快的响应。</p></blockquote><h2 id=caching>Caching</h2><blockquote><p>缓存</p></blockquote><p><strong>Caching</strong> refers to the temporary storage of frequently requested <a href=https://www.educative.io/edpresso/what-is-the-difference-between-dns-a-record-and-cname>resource records</a>. A record is a data unit within the DNS database that shows a name-to-value binding. Caching reduces response time to the user and decreases network traffic. When we use caching at different hierarchies, it can reduce a lot of querying burden on the DNS infrastructure. Caching can be implemented in the browser, operating systems, local name server within the user’s network, or the ISP’s DNS resolvers.</p><blockquote><p>缓存是指临时存储经常请求的资源记录。 记录是 DNS 数据库中的一个数据单元，显示名称到值的绑定。缓存减少了用户的响应时间并减少了网络流量。当我们在不同的层次结构中使用缓存时，它可以减轻 DNS 基础设施的大量查询负担。缓存可以在浏览器、操作系统、用户网络内的本地名称服务器或 ISP 的 DNS 解析器中实现。</p></blockquote><p>The slideshow below demonstrates the power of caching in the DNS:</p><blockquote><p>下面的幻灯片展示了 DNS 中缓存的强大功能：</p></blockquote><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/educative-dns-03.png alt=educative-dns-03></p><p><strong>Note:</strong> Even if there is no cache available to resolve a user’s query and it’s imperative to visit the DNS infrastructure, caching can still be beneficial. The local server or ISP DNS resolver can cache the IP addresses of TLD servers or authoritative servers and avoid requesting the root-level server.</p><blockquote><p>注意：即使没有可用的缓存来解析用户的查询并且必须访问 DNS 基础设施，缓存仍然是有益的。本地服务器或ISP DNS解析器可以缓存TLD服务器或权威服务器的IP地址，并避免请求根级服务器。</p></blockquote><h2 id=dns-as-a-distributed-system>DNS as a distributed system</h2><blockquote><p>DNS 作为分布式系统</p></blockquote><p>Although the DNS hierarchy facilitates the distributed Internet that we know today, it’s a distributed system itself. The distributed nature of DNS has the following advantages:</p><blockquote><p>尽管 DNS 层次结构促进了我们今天所知的分布式互联网，但它本身就是一个分布式系统。 DNS的分布式特性具有以下优点：</p></blockquote><ul><li><p>It avoids becoming a single point of failure (SPOF).</p><blockquote><p>它避免成为单点故障 (SPOF)。</p></blockquote></li><li><p>It achieves low query latency so users can get responses from nearby servers.</p><blockquote><p>它实现了低查询延迟，因此用户可以从附近的服务器获得响应。</p></blockquote></li><li><p>It gets a higher degree of flexibility during maintenance and updates or upgrades. For example, if one DNS server is down or overburdened, another DNS server can respond to user queries.</p><blockquote><p>它在维护和更新或升级过程中获得更高程度的灵活性。例如，如果一台 DNS 服务器发生故障或负载过重，另一台 DNS 服务器可以响应用户查询。</p></blockquote></li></ul><p>There are 13 logical root name servers (named letter <strong>A</strong> through <strong>M</strong>) with many instances spread throughout the globe. These servers are managed by 12 different organizations.</p><blockquote><p>有 13 个逻辑根名称服务器（命名为字母 A 到 M），其中许多实例遍布全球。这些服务器由 12 个不同的组织管理。</p></blockquote><p>Let’s now go over how DNS is scalable, reliable, and consistent.</p><blockquote><p>现在让我们回顾一下 DNS 如何实现可扩展、可靠和一致。</p></blockquote><h3 id=highly-scalable>Highly scalable</h3><blockquote><p>高度可扩展</p></blockquote><p>Due to its hierarchical nature, DNS is a highly scalable system. Roughly 1,000 replicated instances of 13 root-level servers are spread throughout the world strategically to handle user queries. The working labor is divided among TLD and root servers to handle a query and, finally, the authoritative servers that are managed by the organizations themselves to make the entire system work. As shown in the DNS hierarchy tree above, different services handle different portions of the tree enabling scalability and manageability of the system.</p><blockquote><p>由于其分层性质，DNS 是一个高度可扩展的系统。 13 台根级服务器的大约 1,000 个复制实例战略性地分布在世界各地，以处理用户查询。工作劳力被分配到 TLD 和根服务器来处理查询，最后分配到由组织自己管理的权威服务器以使整个系统正常运行。如上面的 DNS 层次结构树所示，不同的服务处理树的不同部分，从而实现系统的可扩展性和可管理性。</p></blockquote><h3 id=reliable>Reliable</h3><blockquote><p>可靠性</p></blockquote><p>Three main reasons make the DNS a reliable system:</p><blockquote><p>DNS 成为可靠系统的三个主要原因：</p></blockquote><ol><li><p><strong>Caching:</strong> The caching is done in the browser, the operating system, and the local name server, and the ISP DNS resolvers also maintain a rich cache of frequently visited services. Even if some DNS servers are temporarily down, cached records can be served to make DNS a reliable system.</p><blockquote><p>缓存：缓存是在浏览器、操作系统和本地名称服务器中完成的，ISP DNS 解析器还维护着经常访问的服务的丰富缓存。即使某些 DNS 服务器暂时关闭，也可以提供缓存记录，使 DNS 成为一个可靠的系统。</p></blockquote></li><li><p><strong>Server replication:</strong> DNS has replicated copies of each logical server spread systematically across the globe to entertain user requests at low latency. The redundant servers improve the reliability of the overall system.</p><blockquote><p>服务器复制：DNS 系统地复制了遍布全球的每个逻辑服务器的副本，以低延迟处理用户请求。冗余服务器提高了整个系统的可靠性。</p></blockquote></li><li><p><strong>Protocol:</strong> Although many clients rely on the unreliable User Datagram Protocol (UDP) to request and receive DNS responses, it is important to acknowledge that UDP also offers distinct advantages. UDP is much faster and, therefore, improves DNS performance. Furthermore, Internet service’s reliability has improved since its inception, so UDP is usually favored over TCP. A DNS resolver can resend the UDP request if it didn’t get a reply to a previous one. This request-response needs just one round trip, which provides a shorter delay as compared to TCP, which needs a three-way handshake before data exchange.</p><blockquote><p>协议：尽管许多客户端依赖不可靠的用户数据报协议 (UDP) 来请求和接收 DNS 响应，但重要的是要承认 UDP 也提供了独特的优势。 UDP 速度更快，因此可以提高 DNS 性能。此外，自诞生以来，互联网服务的可靠性已得到提高，因此 UDP 通常比 TCP 更受青睐。如果 DNS 解析器没有收到前一个请求的回复，则可以重新发送 UDP 请求。这种请求-响应仅需要一次往返，与在数据交换之前需要三次握手的 TCP 相比，延迟更短。</p></blockquote></li></ol><blockquote><p><strong>Question</strong></p><blockquote><p>问题</p></blockquote><p>What happens if a network is congested? Should DNS continue using UDP?</p><blockquote><p>如果网络拥塞会发生什么？ DNS 是否应该继续使用 UDP？</p></blockquote><p>Typically, DNS uses UDP. However, DNS can use TCP when its message size exceeds the original packet size of 512 Bytes. This is because large-size packets are more prone to be damaged in congested networks. DNS always uses TCP for zone transfers.</p><blockquote><p>通常，DNS 使用 UDP。但是，当 DNS 的消息大小超过原始数据包大小 512 字节时，DNS 可以使用 TCP。这是因为大尺寸数据包在拥塞的网络中更容易被损坏。 DNS 始终使用 TCP 进行区域传输。</p></blockquote><p>Some clients prefer DNS over TCP to employ transport layer security for privacy reasons.</p><blockquote><p>出于隐私原因，某些客户端更喜欢使用 DNS 而不是 TCP 来采用传输层安全性。</p></blockquote></blockquote><h3 id=consistent>Consistent</h3><blockquote><p>一致性</p></blockquote><p>DNS uses various protocols to update and transfer information among replicated servers in a hierarchy. DNS compromises on strong consistency to achieve high performance because data is read frequently from DNS databases as compared to writing. However, DNS provides eventual consistency and updates records on replicated servers lazily. Typically, it can take from a few seconds up to three days to update records on the DNS servers across the Internet. The time it takes to propagate information among different DNS clusters depends on the DNS infrastructure, the size of the update, and which part of the DNS tree is being updated.</p><blockquote><p>DNS 使用各种协议在层次结构中的复制服务器之间更新和传输信息。 DNS 会在强一致性方面做出妥协以实现高性能，因为与写入相比，从 DNS 数据库中读取数据的频率更高。然而，DNS 提供最终一致性并延迟更新复制服务器上的记录。通常，更新 Internet 上 DNS 服务器上的记录可能需要几秒钟到三天的时间。在不同 DNS 集群之间传播信息所需的时间取决于 DNS 基础设施、更新的大小以及正在更新 DNS 树的哪一部分。</p></blockquote><p>Consistency can suffer because of caching too. Since authoritative servers are located within the organization, it may be possible that certain resource records are updated on the authoritative servers in case of server failures at the organization. Therefore, cached records at the default/local and ISP servers may be outdated. To mitigate this issue, each cached record comes with an expiration time called <strong>time-to-live (TTL)</strong>.</p><blockquote><p>由于缓存，一致性也会受到影响。由于权威服务器位于组织内，因此在组织中的服务器发生故障的情况下，权威服务器上的某些资源记录可能会被更新。因此，默认/本地和 ISP 服务器上的缓存记录可能会过时。为了缓解此问题，每个缓存记录都带有一个称为生存时间 (TTL) 的过期时间。</p></blockquote><blockquote><p><strong>Question</strong></p><blockquote><p>问题</p></blockquote><p>To maintain high availability, should the TTL value be large or small?</p><blockquote><p>为了保持高可用性，TTL值应该大还是小？</p></blockquote><p>To maintain high availability, the TTL value should be small. This is because if any server or cluster fails, the organization can update the resource records right away. Users will experience non-availability only for the time the TTL isn’t expired. However, if the TTL is large, the organization will update its resource records, whereas users will keep pinging the outdated server that would have crashed long ago. Companies that long for high availability maintain a TTL value as low as 120 seconds. Therefore, even in case of a failure, the maximum downtime is a few minutes.</p><blockquote><p>为了保持高可用性，TTL值应该很小。这是因为如果任何服务器或集群发生故障，组织可以立即更新资源记录。仅在 TTL 未过期期间，用户才会遇到不可用的情况。然而，如果 TTL 很大，组织将更新其资源记录，而用户将继续 ping 早就崩溃的过时服务器。渴望高可用性的公司将 TTL 值维持在低至 120 秒。因此，即使发生故障，最长停机时间也只有几分钟。</p></blockquote></blockquote><h2 id=test-it-out>Test it out</h2><blockquote><p>测试一下</p></blockquote><p>Let’s run a couple of commands. Click on the terminal to execute the following commands. Copy the following commands in the terminal to run them. Study the output of the commands:</p><blockquote><p>让我们运行几个命令。单击终端以执行以下命令。在终端中复制以下命令来运行它们。研究命令的输出：</p></blockquote><ol><li><code>nslookup www.google.com</code></li><li><code>dig www.google.com</code></li></ol><p>The following slide deck highlights some important aspects of <code>nslookup</code> and <code>dig</code> output.</p><blockquote><p>以下幻灯片重点介绍了 <code>nslookup</code> 和 <code>dig</code> 输出的一些重要方面。</p></blockquote><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/educative-dns-04.png alt=educative-dns-04></p><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/educative-dns-05.png alt=educative-dns-05></p><p>Let’s go through the meaning of the output:</p><blockquote><p>我们来看看输出的含义：</p></blockquote><h3 id=the-nslookup-output>The <code>nslookup</code> output</h3><blockquote><p><code>nslookup</code> 输出</p></blockquote><ul><li><p>The <code>Non-authoritative answer</code>, as the name suggests, is the answer provided by a server that is not the authoritative server of Google. It isn’t in the list of authoritative nameservers that Google maintains. So, where does the answer come from? The answer is provided by second, third, and fourth-hand name servers configured to reply to our DNS query—for example, our university or office DNS resolver, our ISP nameserver, our ISP’s ISP nameserver, and so on. In short, it can be considered as a cached version of Google’s authoritative nameservers response. If we try multiple domain names, we’ll realize that we receive a cached response most of the time.</p><blockquote><p><code>Non-authoritative answer</code> ，顾名思义，是由非 Google 权威服务器提供的答案。它不在 Google 维护的权威域名服务器列表中。那么，答案从何而来？答案由配置为回复我们的 DNS 查询的第二手、第三手和第四手名称服务器提供，例如，我们的大学或办公室 DNS 解析器、我们的 ISP 名称服务器、我们 ISP 的 ISP 名称服务器等。简而言之，它可以被视为 Google 权威域名服务器响应的缓存版本。如果我们尝试多个域名，我们会发现大多数时候我们都会收到缓存的响应。</p></blockquote></li><li><p>If we run the same command multiple times, we’ll receive the same IP addresses list but in a different order each time. The reason for that is DNS is indirectly performing <a href=https://www.educative.io/collection/page/10370001/4941429335392256/4521972679049216>load balancing</a>. It’s an important term that we’ll gain familiarity with in the coming lessons.</p><blockquote><p>如果我们多次运行相同的命令，我们将收到相同的 IP 地址列表，但每次的顺序不同。原因是 DNS 间接执行负载平衡。这是一个重要的术语，我们将在接下来的课程中熟悉它。</p></blockquote></li></ul><h3 id=the-dig-output>The <code>dig</code> output</h3><blockquote><p><code>dig</code> 输出</p></blockquote><ul><li><p>The <code>Query time: 4 msec</code> represents the time it takes to get a response from the DNS server. For various reasons, these numbers may be different in our case.</p><blockquote><p><code>Query time: 4 msec</code> 表示从 DNS 服务器获取响应所需的时间。由于各种原因，这些数字在我们的案例中可能有所不同。</p></blockquote></li><li><p>The <code>300</code> value in the <em><code>ANSWER SECTION</code></em> represents the number of seconds the cache is maintained in the DNS resolver. This means that Google’s ADNS keeps a TTL value of five minutes (300/60 <em>sec</em>).</p><blockquote><p><code>ANSWER SECTION</code> 中的 <code>300</code> 值表示 DNS 解析器中维护缓存的秒数。这意味着 Google 的 ADNS 将 TTL 值保持为五分钟（300/60 秒）。</p></blockquote></li></ul><p><strong>Note:</strong> We invite you to test different services for their TTL and query times to strengthen your understanding. You may use the above terminal for this purpose.</p><blockquote><p>注意：我们邀请您测试不同服务的 TTL 和查询时间，以加深您的理解。您可以使用上述终端来实现此目的。</p></blockquote><blockquote><p><strong>Question</strong></p><blockquote><p>问题</p></blockquote><p>If we need DNS to tell us which IP to reach a website or service, how will we know the DNS resolver’s IP address? (It seems like a chicken-and-egg problem!)</p><blockquote><p>如果我们需要 DNS 告诉我们哪个 IP 可以访问网站或服务，我们如何知道 DNS 解析器的 IP 地址？ （这似乎是一个先有鸡还是先有蛋的问题！）</p></blockquote><p>End users’ operating systems have configuration files (<code>/etc/resolv.conf</code> in Linux) with the DNS resolvers’ IP addresses, which in turn obtain all information for them. (Often, DHCP provides the default DNS resolver IP address along with other configurations.) The end-systems request DNS resolves for any DNS queries. DNS resolvers have special software installed to resolve queries through the DNS infrastructure. The root server’s IP addresses are within the special software. Typically, the Berkeley Internet Name Domain (BIND) software is used on DNS resolvers. The <a href=https://www.internic.net/domain/named.root>InterNIC</a> maintains the updated list of 13 root servers.</p><blockquote><p>最终用户的操作系统具有包含 DNS 解析器 IP 地址的配置文件（Linux 中为 <code>/etc/resolv.conf</code> ），而 DNS 解析器又会获取其所有信息。 （通常，DHCP 提供默认 DNS 解析器 IP 地址以及其他配置。）终端系统请求 DNS 解析任何 DNS 查询。 DNS 解析器安装了特殊软件来通过 DNS 基础设施解析查询。根服务器的IP地址位于特殊软件内。通常，伯克利互联网名称域 (BIND) 软件用于 DNS 解析器。 InterNIC 维护着 13 个根服务器的更新列表。</p></blockquote><p>So, we break the chicken-and-egg problem by seeding each resolver with prior knowledge of root DNS servers (whose IPs rarely change).</p><blockquote><p>因此，我们通过为每个解析器提供根 DNS 服务器（其 IP 很少更改）的先验知识来解决先有鸡还是先有蛋的问题。</p></blockquote></blockquote></div><footer class=post-footer><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/11/24/designing-pastebin/><span class=title><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>[译]《Grokking the System Design Interview》设计Pastebin</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/11/17/designing-a-url-shortening-service/><span class=title>Next Page&nbsp;<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>如何设计一个短网址服务</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script><script>mediumZoom(".entry-cover img"),mediumZoom(".post-content img:not([no-zoom])")</script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>