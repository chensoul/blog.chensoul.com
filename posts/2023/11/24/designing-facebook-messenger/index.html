<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]《Grokking the System Design Interview》设计Facebook Messenger | ChenSoul</title>
<meta name=keywords content="architecture"><meta name=description content="这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Facebook Messenger》设计 Facebook Messenger。 Let’s design an instant messaging service like Facebook Messenger where users can send text messages to each other through web and mobile interfaces. 让我们设计一个像 Facebook Messenger 这样的即时消息"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/11/24/designing-facebook-messenger/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.899d9a536396b9b03c9eae0c99cc6ec954a90da94036f5390d131eb8071bb417.css integrity="sha256-iZ2aU2OWubA8nq4MmcxuyVSpDalANvU5DRMeuAcbtBc=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/11/24/designing-facebook-messenger/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="[译]《Grokking the System Design Interview》设计Facebook Messenger"><meta property="og:description" content="这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Facebook Messenger》设计 Facebook Messenger。 Let’s design an instant messaging service like Facebook Messenger where users can send text messages to each other through web and mobile interfaces. 让我们设计一个像 Facebook Messenger 这样的即时消息"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/11/24/designing-facebook-messenger/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-24T00:00:00+08:00"><meta property="article:modified_time" content="2023-11-24T00:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]《Grokking the System Design Interview》设计Facebook Messenger"><meta name=twitter:description content="这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Facebook Messenger》设计 Facebook Messenger。 Let’s design an instant messaging service like Facebook Messenger where users can send text messages to each other through web and mobile interfaces. 让我们设计一个像 Facebook Messenger 这样的即时消息"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]《Grokking the System Design Interview》设计Facebook Messenger","item":"https://blog.chensoul.cc/posts/2023/11/24/designing-facebook-messenger/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]《Grokking the System Design Interview》设计Facebook Messenger","name":"[译]《Grokking the System Design Interview》设计Facebook Messenger","description":"这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Facebook Messenger》设计 Facebook Messenger。 Let’s design an instant messaging service like Facebook Messenger where users can send text messages to each other through web and mobile interfaces. 让我们设计一个像 Facebook Messenger 这样的即时消息","keywords":["architecture"],"articleBody":"这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Facebook Messenger》设计 Facebook Messenger。\nLet’s design an instant messaging service like Facebook Messenger where users can send text messages to each other through web and mobile interfaces. 让我们设计一个像 Facebook Messenger 这样的即时消息服务，用户可以通过网络和移动界面互相发送短信。\n1. What is Facebook Messenger? 1.什么是 Facebook Messenger？\nFacebook Messenger is a software application which provides text-based instant messaging services to its users. Messenger users can chat with their Facebook friends both from cell-phones and Facebook’s website.\nFacebook Messenger 是一款为其用户提供基于文本的即时消息服务的软件应用程序。 Messenger 用户可以通过手机和 Facebook 网站与 Facebook 好友聊天。\n2. Requirements and Goals of the System 系统的要求和目标 Our Messenger should meet the following requirements:\n我们的 Messenger 应满足以下要求：\nFunctional Requirements:\n功能要求：\nMessenger should support one-on-one conversations between users.\nMessenger 应支持用户之间的一对一对话。\nMessenger should keep track of the online/offline statuses of its users.\nMessenger 应跟踪用户的在线/离线状态。\nMessenger should support persistent storage of chat history.\nMessenger应该支持聊天记录的持久存储。\nNon-functional Requirements:\n非功能性要求：\nUsers should have real-time chat experience with minimum latency.\n用户应该获得延迟最小的实时聊天体验。\nOur system should be highly consistent; users should be able to see the same chat history on all their devices.\n我们的系统应该高度一致；用户应该能够在所有内容上看到相同的聊天记录他们的设备。\nMessenger’s high availability is desirable; we can tolerate lower availability in the interest of consistency.\nMessenger 的高可用性是可取的；为了以下目的，我们可以容忍较低的可用性一致性。\nExtended Requirements:\n扩展要求：\nGroup Chats: Messenger should support multiple people talking to each other in a group.\n群组聊天：Messenger 应支持多人在群组中相互交谈。\nPush notifications: Messenger should be able to notify users of new messages when they are offline.\n推送通知：Messenger 应该能够在用户有新消息时通知他们离线。\n3. Capacity Estimation and Constraints 容量估计和约束 Let’s assume that we have 500 million daily active users and on average each user sends 40 messages daily; this gives us 20 billion messages per day.\n假设我们有 5 亿日活跃用户，平均每个用户每天发送 40 条消息；这每天给我们带来 200 亿条消息。\nStorage Estimation: Let’s assume that on average a message is 100 bytes, so to store all the messages for one day we would need 2TB of storage.\n存储估算：假设一条消息平均为 100 字节，因此要存储一天的所有消息，我们需要 2TB 的存储空间。\n20 billion messages * 100 bytes =\u003e 2 TB/day\n200 亿条消息 * 100 字节 =\u003e 2 TB/天\nTo store five years of chat history, we would need 3.6 petabytes of storage.\n要存储五年的聊天历史记录，我们需要 3.6 PB 的存储空间。\n2 TB * 365 days * 5 years ~= 3.6 PB\nOther than the chat messages, we would also need to store users’ information, messages’ metadata (ID, Timestamp, etc.). Not to mention, the above calculation doesn’t take data compression and replication in consideration.\n除了聊天消息之外，我们还需要存储用户信息、消息元数据（ID、时间戳等）。更不用说，上述计算没有考虑数据压缩和复制。\nBandwidth Estimation: If our service is getting 2TB of data every day, this will give us 25MB of incoming data for each second.\n带宽估计：如果我们的服务每天获取 2TB 的数据，那么每秒将为我们提供 25MB 的传入数据。\n2 TB / 86400 sec ~= 25 MB/s\nSince each incoming message needs to go out to another user, we will need the same amount of bandwidth 25MB/s for both upload and download.\n由于每条传入消息都需要发送给另一个用户，因此我们需要相同的带宽 25MB/s 来进行上传和下载。\nHigh level estimates:\n高水平估计：\nTotal messages 20 billion per day Storage for each day 2TB Storage for 5 years 3.6PB Incomming data 25MB/s Outgoing data 25MB/s\n消息总数 每天 200 亿条 每天存储 2TB 存储 5 年 3.6PB 传入数据 25MB/s 传出数据 25MB/s\n4. High Level Design 高层设计 At a high-level, we will need a chat server that will be the central piece, orchestrating all the communications between users. When a user wants to send a message to another user, they will connect to the chat server and send the message to the server; the server then passes that message to the other user and also stores it in the database.\n在高层，我们需要一个聊天服务器作为核心部分，协调用户之间的所有通信。当一个用户想要向另一个用户发送消息时，他们会连接到聊天服务器并将消息发送到服务器；然后，服务器将该消息传递给其他用户并将其存储在数据库中。\nThe detailed workflow would look like this:\n详细的工作流程如下所示：\nUser-A sends a message to User-B through the chat server.\n用户 A 通过聊天服务器向用户 B 发送消息。\nThe server receives the message and sends an acknowledgment to User-A.\n服务器接收消息并向用户 A 发送确认。\nThe server stores the message in its database and sends the message to User-B.\n服务器将消息存储在其数据库中并将消息发送给用户\nUser-B receives the message and sends the acknowledgment to the server.\n用户B 接收消息并向服务器发送确认。\nThe server notifies User-A that the message has been delivered successfully to User-B.\n服务器通知用户 A 消息已成功传递给用户 B。\n5. Detailed Component Design 详细组件设计 Let’s try to build a simple solution first where everything runs on one server. At the high level our system needs to handle the following use cases:\n让我们首先尝试构建一个简单的解决方案，其中所有内容都在一台服务器上运行。在高层，我们的系统需要处理以下用例：\nReceive incoming messages and deliver outgoing messages.\n接收传入消息并传递传出消息。\nStore and retrieve messages from the database.\n在数据库中存储和检索消息。\nKeep a record of which user is online or has gone offline, and notify all the relevant users about these status changes.\n记录哪些用户在线或离线，并通知所有相关用户这些状态变化。\nLet’s talk about these scenarios one by one:\n我们来一一谈谈这些场景：\na. Messages Handling\na.消息处理\nHow would we efficiently send/receive messages? To send messages, a user needs to connect to the server and post messages for the other users. To get a message from the server, the user has two options:\n我们如何有效地发送/接收消息？要发送消息，用户需要连接到服务器并为其他用户发布消息。要从服务器获取消息，用户有两种选择：\nPull model: Users can periodically ask the server if there are any new messages for them.\nPull模型：用户可以定期向服务器询问是否有新消息。\nPush model: Users can keep a connection open with the server and can depend upon the server to notify them whenever there are new messages.\n推送模型：用户可以与服务器保持开放的连接，并且可以依赖服务器每当有新消息时通知他们。\nIf we go with our first approach, then the server needs to keep track of messages that are still waiting to be delivered, and as soon as the receiving user connects to the server to ask for any new message, the server can return all the pending messages. To minimize latency for the user, they have to check the server quite frequently, and most of the time they will be getting an empty response if there are no pending message. This will waste a lot of resources and does not look like an efficient solution.\n如果我们采用第一种方法，那么服务器需要跟踪仍在等待传递的消息，并且一旦接收用户连接到服务器以请求任何新消息，服务器就可以返回所有待处理的消息消息。为了最大限度地减少用户的延迟，他们必须经常检查服务器，并且大多数时候，如果没有待处理的消息，他们将得到空响应。这会浪费大量资源，而且看起来并不是一个有效的解决方案。\nIf we go with our second approach, where all the active users keep a connection open with the server, then as soon as the server receives a message it can immediately pass the message to the intended user. This way, the server does not need to keep track of the pending messages, and we will have minimum latency, as the messages are delivered instantly on the opened connection.\n如果我们采用第二种方法，即所有活动用户与服务器保持打开的连接，那么一旦服务器收到消息，它就可以立即将消息传递给目标用户。这样，服务器不需要跟踪待处理的消息，并且我们将具有最小的延迟，因为消息是在打开的连接上立即传递的。\nHow will clients maintain an open connection with the server? We can use HTTP Long Polling or WebSockets. In long polling, clients can request information from the server with the expectation that the server may not respond immediately. If the server has no new data for the client when the poll is received, instead of sending an empty response, the server holds the request open and waits for\n客户端如何与服务器保持开放连接？我们可以使用 HTTP 长轮询或 WebSockets。在长轮询中，客户端可以向服务器请求信息，但期望服务器可能不会立即响应。如果服务器在收到轮询时没有为客户端提供新数据，则服务器不会发送空响应，而是保持请求打开并等待\nresponse information to become available. Once it does have new information, the server immediately sends the response to the client, completing the open request. Upon receipt of the server response, the client can immediately issue another server request for future updates. This gives a lot of improvements in latencies, throughputs, and performance. The long polling request can timeout or can receive a disconnect from the server, in that case, the client has to open a new request.\n响应信息变得可用。一旦有新信息，服务器立即将响应发送给客户端，完成打开请求。收到服务器响应后，客户端可以立即发出另一个服务器请求以进行将来的更新。这在延迟、吞吐量和性能方面带来了很大的改进。长轮询请求可能会超时或可能会收到与服务器的断开连接，在这种情况下，客户端必须打开新的请求。\nHow can the server keep track of all the opened connection to redirect messages to the users efficiently? The server can maintain a hash table, where “key” would be the UserID and “value” would be the connection object. So whenever the server receives a message for a user, it looks up that user in the hash table to find the connection object and sends the message on the open request.\n服务器如何跟踪所有打开的连接以有效地将消息重定向到用户？服务器可以维护一个哈希表，其中“key”是用户ID，“value”是连接对象。因此，每当服务器收到用户的消息时，它都会在哈希表中查找该用户以找到连接对象，并根据打开的请求发送消息。\nWhat will happen when the server receives a message for a user who has gone offline? If the receiver has disconnected, the server can notify the sender about the delivery failure. If it is a temporary disconnect, e.g., the receiver’s long-poll request just timed out, then we should expect a reconnect from the user. In that case, we can ask the sender to retry sending the message. This retry could be embedded in the client’s logic so that users don’t have to retype the message. The server can also store the message for a while and retry sending it once the receiver reconnects.\n当服务器收到用户下线的消息时会发生什么？如果接收方已断开连接，服务器可以通知发送方传送失败。如果是临时断开连接，例如接收者的长轮询请求刚刚超时，那么我们应该期望用户重新连接。在这种情况下，我们可以要求发件人重试发送消息。这种重试可以嵌入到客户端的逻辑中，这样用户就不必重新输入消息。服务器还可以将消息存储一段时间，并在接收者重新连接后重试发送。\nHow many chat servers we need? Let’s plan for 500 million connections at any time. Assuming a modern server can handle 50K concurrent connections at any time, we would need 10K such servers.\n我们需要多少个聊天服务器？随时规划5亿连接。假设现代服务器可以随时处理 50K 并发连接，我们将需要 10K 这样的服务器。\nHow do we know which server holds the connection to which user? We can introduce a software load balancer in front of our chat servers; that can map each UserID to a server to redirect the request.\n我们如何知道哪个服务器拥有与哪个用户的连接？我们可以在聊天服务器前面引入一个软件负载均衡器；它可以将每个 UserID 映射到服务器以重定向请求。\nHow should the server process a ‘deliver message’ request? The server needs to do the following things upon receiving a new message: 1) Store the message in the database 2) Send the message to the receiver and 3) Send an acknowledgment to the sender.\n服务器应该如何处理“传递消息”请求？服务器在收到新消息后需要执行以下操作： 1) 将消息存储在数据库中 2) 将消息发送给接收者 3) 向发送者发送确认。\nThe chat server will first find the server that holds the connection for the receiver and pass the message to that server to send it to the receiver. The chat server can then send the acknowledgment to the sender; we don’t need to wait for storing the message in the database (this can happen in the background). Storing the message is discussed in the next section.\n聊天服务器将首先找到为接收者保留连接的服务器，并将消息传递给该服务器以将其发送给接收者。然后聊天服务器可以将确认发送给发送者；我们不需要等待将消息存储在数据库中（这可以在后台发生）。下一节将讨论存储消息。\nHow does the messenger maintain the sequencing of the messages? We can store a timestamp with each message, which is the time the message is received by the server. This will still not ensure correct ordering of messages for clients. The scenario where the server timestamp cannot determine the exact order of messages would look like this:\n消息传递者如何保持消息的顺序？我们可以为每条消息存储一个时间戳，这是服务器接收消息的时间。这仍然不能确保客户端消息的正确排序。服务器时间戳无法确定消息的确切顺序的情况如下所示：\nUser-1 sends a message M1 to the server for User-2.\nUser-1 向 User-2 的服务器发送消息 M1。\nThe server receives M1 at T1.\n服务器在 T1 接收 M1。\nMeanwhile, User-2 sends a message M2 to the server for User-1.\n同时，User-2向User-1的服务器发送消息M2。\nThe server receives the message M2 at T2, such that T2 \u003e T1.\n服务器在T2接收消息M2，使得T2\u003eT1。\nThe server sends message M1 to User-2 and M2 to User-1.\n服务器将消息 M1 发送到 User-2，将 M2 发送到 User-1。\nSo User-1 will see M1 first and then M2, whereas User-2 will see M2 first and then M1.\n因此，用户 1 将首先看到 M1，然后是 M2，而用户 2 将首先看到 M2，然后是 M1。\nTo resolve this, we need to keep a sequence number with every message for each client. This sequence number will determine the exact ordering of messages for EACH user. With this solution both clients will see a different view of the message sequence, but this view will be consistent for them on all devices.\n为了解决这个问题，我们需要为每个客户端的每条消息保留一个序列号。该序列号将确定每个用户的消息的确切顺序。通过此解决方案，两个客户端都将看到消息序列的不同视图，但此视图在所有设备上都将保持一致。\nb. Storing and retrieving the messages from the database\nb.从数据库中存储和检索消息**\nWhenever the chat server receives a new message, it needs to store it in the database. To do so, we have two options:\n每当聊天服务器收到新消息时，都需要将其存储在数据库中。为此，我们有两个选择：\nStart a separate thread, which will work with the database to store the message. 2. Send an asynchronous request to the database to store the message.\n启动一个单独的线程，该线程将与数据库一起存储消息。 2. 向数据库发送异步请求来存储消息。\nWe have to keep certain things in mind while designing our database:\n在设计数据库时，我们必须记住以下几点：\nHow to efficiently work with the database connection pool.\n如何高效地使用数据库连接池。\nHow to retry failed requests.\n如何重试失败的请求。\nWhere to log those requests that failed even after some retries.\n在哪里记录那些重试后仍失败的请求。\nHow to retry these logged requests (that failed after the retry) when all the issues have resolved.\n当所有问题都解决后，如何重试这些记录的请求（重试后失败）。\nWhich storage system we should use? We need to have a database that can support a very high rate of small updates and also fetch a range of records quickly. This is required because we have a huge number of small messages that need to be inserted in the database and, while querying, a user is mostly interested in sequentially accessing the messages.\n我们应该使用哪种存储系统？我们需要一个能够支持非常高的小更新率并且能够快速获取一系列记录的数据库。这是必需的，因为我们有大量的小消息需要插入到数据库中，并且在查询时，用户最感兴趣的是顺序访问这些消息。\nWe cannot use RDBMS like MySQL or NoSQL like MongoDB because we cannot afford to read/write a row from the database every time a user receives/sends a message. This will not only make the basic operations of our service run with high latency, but also create a huge load on databases.\n我们无法使用 MySQL 等 RDBMS 或 MongoDB 等 NoSQL，因为我们无法在用户每次接收/发送消息时从数据库中读取/写入一行。这不仅会使我们服务的基本操作以高延迟运行，还会对数据库造成巨大的负载。\nBoth of our requirements can be easily met with a wide-column database solution like HBase. HBase is a column-oriented key-value NoSQL database that can store multiple values against one key into multiple columns. HBase is modeled after Google’s BigTable and runs on top of Hadoop Distributed File System (HDFS). HBase groups data together to store new data in a memory buffer and, once the buffer is full, it dumps the data to the disk. This way of storage not only helps storing a lot of small data quickly, but also fetching rows by the key or scanning ranges of rows. HBase is also an efficient database to store variably sized data, which is also required by our service.\n像 HBase 这样的宽列数据库解决方案就可以轻松满足我们的这两个要求。 HBase 是一种面向列的键值 NoSQL 数据库，可以将一个键的多个值存储到多个列中。 HBase 仿照 Google 的 BigTable 建模，并在 Hadoop 分布式文件系统 (HDFS) 之上运行。 HBase 将数据分组在一起，将新数据存储在内存缓冲区中，一旦缓冲区已满，它将数据转储到磁盘。这种存储方式不仅有助于快速存储大量小数据，而且还可以通过键或扫描行范围来获取行。 HBase也是一个高效的数据库，可以存储不同大小的数据，这也是我们的服务所需要的。\nHow should clients efficiently fetch data from the server? Clients should paginate while fetching data from the server. Page size could be different for different clients, e.g., cell phones have smaller screens, so we need a fewer number of message/conversations in the viewport.\n客户端应该如何高效地从服务器获取数据？客户端在从服务器获取数据时应该分页。对于不同的客户端，页面大小可能不同，例如，手机的屏幕较小，因此我们在视口中需要较少数量的消息/对话。\nc. Managing user’s status\nc.管理用户状态\nWe need to keep track of user’s online/offline status and notify all the relevant users whenever a status change happens. Since we are maintaining a connection object on the server for all active users, we can easily figure out the user’s current status from this. With 500M active users at any time, if we have to\n我们需要跟踪用户的在线/离线状态，并在状态发生变化时通知所有相关用户。由于我们在服务器上为所有活动用户维护一个连接对象，因此我们可以轻松地从中找出用户的当前状态。任何时候都有 5 亿活跃用户，如果我们必须的话\nbroadcast each status change to all the relevant active users, it will consume a lot of resources. We can do the following optimization around this:\n将每个状态变化广播给所有相关的活跃用户，会消耗大量资源。围绕这一点我们可以做如下优化：\nWhenever a client starts the app, it can pull the current status of all users in their friends’ list.\n每当客户端启动应用程序时，它都可以提取好友列表中所有用户的当前状态。\nWhenever a user sends a message to another user that has gone offline, we can send a failure to the sender and update the status on the client.\n每当一个用户向另一个离线的用户发送消息时，我们可以向发送者并更新客户端上的状态。\nWhenever a user comes online, the server can always broadcast that status with a delay of a few seconds to see if the user does not go offline immediately.\n每当用户上线时，服务器总是可以延迟几秒广播该状态秒查看用户是否没有立即离线。\nClient’s can pull the status from the server about those users that are being shown on the user’s viewport. This should not be a frequent operation, as the server is broadcasting the online status of users and we can live with the stale offline status of users for a while.\n客户端可以从服务器获取有关用户的状态，这些状态显示在用户的视口。这不应该是一个频繁的操作，因为服务器正在广播在线状态用户的离线状态我们可以忍受一段时间。\nWhenever the client starts a new chat with another user, we can pull the status at that time.\n每当客户端与另一个用户开始新的聊天时，我们就可以提取当时的状态。\nDetailed component design for Facebook messenger\nFacebook Messenger 的详细组件设计\nDesign Summary: Clients will open a connection to the chat server to send a message; the server will then pass it to the requested user. All the active users will keep a connection open with the server to receive messages. Whenever a new message arrives, the chat server will push it to the receiving user on the long poll request. Messages can be stored in HBase, which supports quick small updates, and range\n设计总结：客户端会打开一个到聊天服务器的连接来发送消息；然后服务器会将其传递给请求的用户。所有活动用户都将保持与服务器的连接以接收消息。每当有新消息到达时，聊天服务器都会通过长轮询请求将其推送给接收用户。消息可以存储在HBase中，支持快速小更新和范围\nbased searches. The servers can broadcast the online status of a user to other relevant users. Clients can pull status updates for users who are visible in the client’s viewport on a less frequent basis.\n基于搜索。服务器可以向其他相关用户广播用户的在线状态。客户端可以不频繁地为在客户端视口中可见的用户拉取状态更新。\n6. Data partitioning 数据分区 Since we will be storing a lot of data (3.6PB for five years), we need to distribute it onto multiple database servers. What will be our partitioning scheme?\n由于我们将存储大量数据（五年 3.6PB），因此我们需要将其分发到多个数据库服务器上。我们的分区方案是什么？\nPartitioning based on UserID: Let’s assume we partition based on the hash of the UserID so that we can keep all messages of a user on the same database. If one DB shard is 4TB, we will have “3.6PB/4TB ~= 900” shards for five years. For simplicity, let’s assume we keep 1K shards. So we will find the shard number by “hash(UserID) % 1000” and then store/retrieve the data from there. This partitioning scheme will also be very quick to fetch chat history for any user.\n基于 UserID 的分区：假设我们基于 UserID 的哈希进行分区，以便我们可以将用户的所有消息保存在同一个数据库中。如果一个数据库分片是 4TB，那么五年内我们将拥有“3.6PB/4TB ~= 900”个分片。为了简单起见，我们假设我们保留 1K 分片。因此，我们将通过“hash(UserID) % 1000”找到分片编号，然后从那里存储/检索数据。这种分区方案也可以非常快速地获取任何用户的聊天历史记录。\nIn the beginning, we can start with fewer database servers with multiple shards residing on one physical server. Since we can have multiple database instances on a server, we can easily store multiple partitions on a single server. Our hash function needs to understand this logical partitioning scheme so that it can map multiple logical partitions on one physical server.\n一开始，我们可以从较少的数据库服务器开始，在一台物理服务器上驻留多个分片。由于我们可以在一台服务器上拥有多个数据库实例，因此我们可以轻松地在一台服务器上存储多个分区。我们的哈希函数需要理解这种逻辑分区方案，以便它可以在一台物理服务器上映射多个逻辑分区。\nSince we will store an unlimited history of messages, we can start with a big number of logical partitions, which will be mapped to fewer physical servers, and as our storage demand increases, we can add more physical servers to distribute our logical partitions.\n由于我们将存储无限的消息历史记录，因此我们可以从大量逻辑分区开始，这些逻辑分区将映射到更少的物理服务器，并且随着存储需求的增加，我们可以添加更多物理服务器来分布我们的逻辑分区。\nPartitioning based on MessageID: If we store different messages of a user on separate database shards, fetching a range of messages of a chat would be very slow, so we should not adopt this scheme.\n基于MessageID的分区：如果我们将一个用户的不同消息存储在不同的数据库分片上，那么获取一段聊天的一系列消息会非常慢，所以我们不应该采用这种方案。\n7. Cache 缓存 We can cache a few recent messages (say last 15) in a few recent conversations that are visible in a user’s viewport (say last 5). Since we decided to store all of the user’s messages on one shard, cache for a user should entirely reside on one machine too.\n我们可以在用户视口中可见的一些最近对话（例如最后 5 条）中缓存一些最近的消息（例如最后 15 条）。由于我们决定将所有用户的消息存储在一个分片上，因此用户的缓存也应该完全驻留在一台机器上。\n8. Load balancing 8.负载均衡\nWe will need a load balancer in front of our chat servers; that can map each UserID to a server that holds the connection for the user and then direct the request to that server. Similarly, we would need a load balancer for our cache servers.\n我们需要在聊天服务器前面有一个负载均衡器；它可以将每个 UserID 映射到保存用户连接的服务器，然后将请求定向到该服务器。同样，我们的缓存服务器需要一个负载平衡器。\n9. Fault tolerance and Replication 容错和复制 What will happen when a chat server fails? Our chat servers are holding connections with the users. If a server goes down, should we devise a mechanism to transfer those connections to some other server? It’s extremely hard to failover TCP connections to other servers; an easier approach can be to have clients automatically reconnect if the connection is lost.\n当聊天服务器出现故障时会发生什么？我们的聊天服务器与用户保持连接。如果服务器出现故障，我们是否应该设计一种机制将这些连接转移到其他服务器？将 TCP 连接故障转移到其他服务器非常困难；一种更简单的方法是让客户端在连接丢失时自动重新连接。\nShould we store multiple copies of user messages? We cannot have only one copy of the user’s data, because if the server holding the data crashes or is down permanently, we don’t have any mechanism to\n我们应该存储用户消息的多个副本吗？我们不能只有一份用户数据的副本，因为如果保存数据的服务器崩溃或永久关闭，我们没有任何机制可以\nrecover that data. For this, either we have to store multiple copies of the data on different servers or use techniques like Reed-Solomon encoding to distribute and replicate it.\n恢复该数据。为此，我们要么必须在不同的服务器上存储数据的多个副本，要么使用 Reed-Solomon 编码等技术来分发和复制数据。\n10. Extended Requirements 扩展要求 a. Group chat\na.群聊\nWe can have separate group-chat objects in our system that can be stored on the chat servers. A group- chat object is identified by GroupChatID and will also maintain a list of people who are part of that chat. Our load balancer can direct each group chat message based on GroupChatID and the server handling that group chat can iterate through all the users of the chat to find the server handling the connection of each user to deliver the message.\n我们可以在系统中拥有单独的群聊对象，这些对象可以存储在聊天服务器上。群聊对象由 GroupChatID 标识，并且还将维护属于该聊天的人员列表。我们的负载均衡器可以根据 GroupChatID 引导每个群聊消息，并且处理该群聊的服务器可以迭代所有聊天用户，找到处理每个用户连接的服务器来传递消息。\nIn databases, we can store all the group chats in a separate table partitioned based on GroupChatID.\n在数据库中，我们可以将所有群聊存储在一个根据GroupChatID分区的单独表中。\nb. Push notifications\nb.推送通知\nIn our current design user’s can only send messages to active users and if the receiving user is offline, we send a failure to the sending user. Push notifications will enable our system to send messages to offline users.\n在我们当前的设计中，用户只能向活动用户发送消息，如果接收用户离线，我们会向发送用户发送失败消息。推送通知将使我们的系统能够向离线用户发送消息。\nFor Push notifications, each user can opt-in from their device (or a web browser) to get notifications whenever there is a new message or event. Each manufacturer maintains a set of servers that handles pushing these notifications to the user.\n对于推送通知，每个用户都可以选择从他们的设备（或网络浏览器）接收通知，只要有新消息或事件。每个制造商都维护一组服务器来处理将这些通知推送给用户。\nTo have push notifications in our system, we would need to set up a Notification server, which will take the messages for offline users and send them to the manufacture’s push notification server, which will then send them to the user’s device.\n要在我们的系统中添加推送通知，我们需要设置一个通知服务器，该服务器将获取离线用户的消息并将其发送到制造商的推送通知服务器，然后制造商的推送通知服务器将它们发送到用户的设备。\n","wordCount":"8383","inLanguage":"en","datePublished":"2023-11-24T00:00:00+08:00","dateModified":"2023-11-24T00:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/11/24/designing-facebook-messenger/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[译]《Grokking the System Design Interview》设计Facebook Messenger</h1><div class=post-meta><span title='2023-11-24 00:00:00 +0800 CST'>2023-11-24</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;8383 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-what-is-facebook-messenger aria-label="1. What is Facebook Messenger?">1. What is Facebook Messenger?</a></li><li><a href=#2-requirements-and-goals-of-the-system aria-label="2. Requirements and Goals of the System">2. Requirements and Goals of the System</a></li><li><a href=#3-capacity-estimation-and-constraints aria-label="3. Capacity Estimation and Constraints">3. Capacity Estimation and Constraints</a></li><li><a href=#4-high-level-design aria-label="4. High Level Design">4. High Level Design</a></li><li><a href=#5-detailed-component-design aria-label="5. Detailed Component Design">5. Detailed Component Design</a></li><li><a href=#6-data-partitioning aria-label="6. Data partitioning">6. Data partitioning</a></li><li><a href=#7-cache aria-label="7. Cache">7. Cache</a></li><li><a href=#8-load-balancing aria-label="8. Load balancing">8. Load balancing</a></li><li><a href=#9-fault-tolerance-and-replication aria-label="9. Fault tolerance and Replication">9. Fault tolerance and Replication</a></li><li><a href=#10-extended-requirements aria-label="10. Extended Requirements">10. Extended Requirements</a></li></ul></div></details></div><div class=post-content><p>这是一篇双语翻译的文章，原文出自 <a href=https://github.com/sharanyaa/grok_sdi_educative/blob/master/grok_system_design_interview.pdf target=_blank>grok_system_design_interview.pdf</a> 的一篇文章《Designing Facebook Messenger》设计 Facebook Messenger。</p><hr><p>Let’s design an instant messaging service like Facebook Messenger where users can send text messages to each other through web and mobile interfaces.
让我们设计一个像 Facebook Messenger 这样的即时消息服务，用户可以通过网络和移动界面互相发送短信。</p><h2 id=1-what-is-facebook-messenger>1. What is Facebook Messenger?<a hidden class=anchor aria-hidden=true href=#1-what-is-facebook-messenger>#</a></h2><blockquote><p>1.什么是 Facebook Messenger？</p></blockquote><p>Facebook Messenger is a software application which provides text-based instant messaging services to its users. Messenger users can chat with their Facebook friends both from cell-phones and Facebook’s website.</p><blockquote><p>Facebook Messenger 是一款为其用户提供基于文本的即时消息服务的软件应用程序。 Messenger 用户可以通过手机和 Facebook 网站与 Facebook 好友聊天。</p></blockquote><h2 id=2-requirements-and-goals-of-the-system>2. Requirements and Goals of the System<a hidden class=anchor aria-hidden=true href=#2-requirements-and-goals-of-the-system>#</a></h2><blockquote><ol start=2><li>系统的要求和目标</li></ol></blockquote><p>Our Messenger should meet the following requirements:</p><blockquote><p>我们的 Messenger 应满足以下要求：</p></blockquote><p><strong>Functional Requirements:</strong></p><blockquote><p><strong>功能要求：</strong></p></blockquote><ol><li><p>Messenger should support one-on-one conversations between users.</p><blockquote><p>Messenger 应支持用户之间的一对一对话。</p></blockquote></li><li><p>Messenger should keep track of the online/offline statuses of its users.</p><blockquote><p>Messenger 应跟踪用户的在线/离线状态。</p></blockquote></li><li><p>Messenger should support persistent storage of chat history.</p><blockquote><p>Messenger应该支持聊天记录的持久存储。</p></blockquote></li></ol><p><strong>Non-functional Requirements:</strong></p><blockquote><p><strong>非功能性要求：</strong></p></blockquote><ol><li><p>Users should have real-time chat experience with minimum latency.</p><blockquote><p>用户应该获得延迟最小的实时聊天体验。</p></blockquote></li><li><p>Our system should be highly consistent; users should be able to see the same chat history on all their devices.</p><blockquote><p>我们的系统应该高度一致；用户应该能够在所有内容上看到相同的聊天记录他们的设备。</p></blockquote></li><li><p>Messenger’s high availability is desirable; we can tolerate lower availability in the interest of consistency.</p><blockquote><p>Messenger 的高可用性是可取的；为了以下目的，我们可以容忍较低的可用性一致性。</p></blockquote></li></ol><p><strong>Extended Requirements:</strong></p><blockquote><p><strong>扩展要求：</strong></p></blockquote><ul><li><p>Group Chats: Messenger should support multiple people talking to each other in a group.</p><blockquote><p>群组聊天：Messenger 应支持多人在群组中相互交谈。</p></blockquote></li><li><p>Push notifications: Messenger should be able to notify users of new messages when they are offline.</p><blockquote><p>推送通知：Messenger 应该能够在用户有新消息时通知他们离线。</p></blockquote></li></ul><h2 id=3-capacity-estimation-and-constraints>3. Capacity Estimation and Constraints<a hidden class=anchor aria-hidden=true href=#3-capacity-estimation-and-constraints>#</a></h2><blockquote><ol start=3><li>容量估计和约束</li></ol></blockquote><p>Let’s assume that we have 500 million daily active users and on average each user sends 40 messages daily; this gives us 20 billion messages per day.</p><blockquote><p>假设我们有 5 亿日活跃用户，平均每个用户每天发送 40 条消息；这每天给我们带来 200 亿条消息。</p></blockquote><p><strong>Storage Estimation:</strong> Let’s assume that on average a message is 100 bytes, so to store all the messages for one day we would need 2TB of storage.</p><blockquote><p>存储估算：假设一条消息平均为 100 字节，因此要存储一天的所有消息，我们需要 2TB 的存储空间。</p></blockquote><p>20 billion messages * 100 bytes => 2 TB/day</p><blockquote><p>200 亿条消息 * 100 字节 => 2 TB/天</p></blockquote><p>To store five years of chat history, we would need 3.6 petabytes of storage.</p><blockquote><p>要存储五年的聊天历史记录，我们需要 3.6 PB 的存储空间。</p></blockquote><p>2 TB * 365 days * 5 years ~= 3.6 PB</p><p>Other than the chat messages, we would also need to store users’ information, messages’ metadata (ID, Timestamp, etc.). Not to mention, the above calculation doesn’t take data compression and replication in consideration.</p><blockquote><p>除了聊天消息之外，我们还需要存储用户信息、消息元数据（ID、时间戳等）。更不用说，上述计算没有考虑数据压缩和复制。</p></blockquote><p><strong>Bandwidth Estimation:</strong> If our service is getting 2TB of data every day, this will give us 25MB of incoming data for each second.</p><blockquote><p>带宽估计：如果我们的服务每天获取 2TB 的数据，那么每秒将为我们提供 25MB 的传入数据。</p></blockquote><p>2 TB / 86400 sec ~= 25 MB/s</p><p>Since each incoming message needs to go out to another user, we will need the same amount of bandwidth 25MB/s for both upload and download.</p><blockquote><p>由于每条传入消息都需要发送给另一个用户，因此我们需要相同的带宽 25MB/s 来进行上传和下载。</p></blockquote><p><strong>High level estimates:</strong></p><blockquote><p><strong>高水平估计：</strong></p></blockquote><p>Total messages 20 billion per day Storage for each day 2TB Storage for 5 years 3.6PB Incomming data 25MB/s Outgoing data 25MB/s</p><blockquote><p>消息总数 每天 200 亿条 每天存储 2TB 存储 5 年 3.6PB 传入数据 25MB/s 传出数据 25MB/s</p></blockquote><h2 id=4-high-level-design>4. High Level Design<a hidden class=anchor aria-hidden=true href=#4-high-level-design>#</a></h2><blockquote><ol start=4><li>高层设计</li></ol></blockquote><p>At a high-level, we will need a chat server that will be the central piece, orchestrating all the communications between users. When a user wants to send a message to another user, they will connect to the chat server and send the message to the server; the server then passes that message to the other user and also stores it in the database.</p><blockquote><p>在高层，我们需要一个聊天服务器作为核心部分，协调用户之间的所有通信。当一个用户想要向另一个用户发送消息时，他们会连接到聊天服务器并将消息发送到服务器；然后，服务器将该消息传递给其他用户并将其存储在数据库中。</p></blockquote><p>The detailed workflow would look like this:</p><blockquote><p>详细的工作流程如下所示：</p></blockquote><ol><li><p>User-A sends a message to User-B through the chat server.</p><blockquote><p>用户 A 通过聊天服务器向用户 B 发送消息。</p></blockquote></li><li><p>The server receives the message and sends an acknowledgment to User-A.</p><blockquote><p>服务器接收消息并向用户 A 发送确认。</p></blockquote></li><li><p>The server stores the message in its database and sends the message to User-B.</p><blockquote><p>服务器将消息存储在其数据库中并将消息发送给用户</p></blockquote></li><li><p>User-B receives the message and sends the acknowledgment to the server.</p><blockquote><p>用户B 接收消息并向服务器发送确认。</p></blockquote></li><li><p>The server notifies User-A that the message has been delivered successfully to User-B.</p><blockquote><p>服务器通知用户 A 消息已成功传递给用户 B。</p></blockquote></li></ol><h2 id=5-detailed-component-design>5. Detailed Component Design<a hidden class=anchor aria-hidden=true href=#5-detailed-component-design>#</a></h2><blockquote><ol start=5><li>详细组件设计</li></ol></blockquote><p>Let’s try to build a simple solution first where everything runs on one server. At the high level our system needs to handle the following use cases:</p><blockquote><p>让我们首先尝试构建一个简单的解决方案，其中所有内容都在一台服务器上运行。在高层，我们的系统需要处理以下用例：</p></blockquote><ol><li><p>Receive incoming messages and deliver outgoing messages.</p><blockquote><p>接收传入消息并传递传出消息。</p></blockquote></li><li><p>Store and retrieve messages from the database.</p><blockquote><p>在数据库中存储和检索消息。</p></blockquote></li><li><p>Keep a record of which user is online or has gone offline, and notify all the relevant users about these status changes.</p><blockquote><p>记录哪些用户在线或离线，并通知所有相关用户这些状态变化。</p></blockquote></li></ol><p>Let’s talk about these scenarios one by one:</p><blockquote><p>我们来一一谈谈这些场景：</p></blockquote><p><strong>a. Messages Handling</strong></p><blockquote><p><strong>a.消息处理</strong></p></blockquote><p><strong>How would we efficiently send/receive messages?</strong> To send messages, a user needs to connect to the server and post messages for the other users. To get a message from the server, the user has two options:</p><blockquote><p>我们如何有效地发送/接收消息？要发送消息，用户需要连接到服务器并为其他用户发布消息。要从服务器获取消息，用户有两种选择：</p></blockquote><ol><li><p><strong>Pull model:</strong> Users can periodically ask the server if there are any new messages for them.</p><blockquote><p>Pull模型：用户可以定期向服务器询问是否有新消息。</p></blockquote></li><li><p><strong>Push model:</strong> Users can keep a connection open with the server and can depend upon the server to notify them whenever there are new messages.</p><blockquote><p>推送模型：用户可以与服务器保持开放的连接，并且可以依赖服务器每当有新消息时通知他们。</p></blockquote></li></ol><p>If we go with our first approach, then the server needs to keep track of messages that are still waiting to be delivered, and as soon as the receiving user connects to the server to ask for any new message, the server can return all the pending messages. To minimize latency for the user, they have to check the server quite frequently, and most of the time they will be getting an empty response if there are no pending message. This will waste a lot of resources and does not look like an efficient solution.</p><blockquote><p>如果我们采用第一种方法，那么服务器需要跟踪仍在等待传递的消息，并且一旦接收用户连接到服务器以请求任何新消息，服务器就可以返回所有待处理的消息消息。为了最大限度地减少用户的延迟，他们必须经常检查服务器，并且大多数时候，如果没有待处理的消息，他们将得到空响应。这会浪费大量资源，而且看起来并不是一个有效的解决方案。</p></blockquote><p>If we go with our second approach, where all the active users keep a connection open with the server, then as soon as the server receives a message it can immediately pass the message to the intended user. This way, the server does not need to keep track of the pending messages, and we will have minimum latency, as the messages are delivered instantly on the opened connection.</p><blockquote><p>如果我们采用第二种方法，即所有活动用户与服务器保持打开的连接，那么一旦服务器收到消息，它就可以立即将消息传递给目标用户。这样，服务器不需要跟踪待处理的消息，并且我们将具有最小的延迟，因为消息是在打开的连接上立即传递的。</p></blockquote><p><strong>How will clients maintain an open connection with the server?</strong> We can use HTTP Long Polling or WebSockets. In long polling, clients can request information from the server with the expectation that the server may not respond immediately. If the server has no new data for the client when the poll is received, instead of sending an empty response, the server holds the request open and waits for</p><blockquote><p>客户端如何与服务器保持开放连接？我们可以使用 HTTP 长轮询或 WebSockets。在长轮询中，客户端可以向服务器请求信息，但期望服务器可能不会立即响应。如果服务器在收到轮询时没有为客户端提供新数据，则服务器不会发送空响应，而是保持请求打开并等待</p></blockquote><p>response information to become available. Once it does have new information, the server immediately sends the response to the client, completing the open request. Upon receipt of the server response, the client can immediately issue another server request for future updates. This gives a lot of improvements in latencies, throughputs, and performance. The long polling request can timeout or can receive a disconnect from the server, in that case, the client has to open a new request.</p><blockquote><p>响应信息变得可用。一旦有新信息，服务器立即将响应发送给客户端，完成打开请求。收到服务器响应后，客户端可以立即发出另一个服务器请求以进行将来的更新。这在延迟、吞吐量和性能方面带来了很大的改进。长轮询请求可能会超时或可能会收到与服务器的断开连接，在这种情况下，客户端必须打开新的请求。</p></blockquote><p><strong>How can the server keep track of all the opened connection to redirect messages to the users efficiently?</strong> The server can maintain a hash table, where “key” would be the UserID and “value” would be the connection object. So whenever the server receives a message for a user, it looks up that user in the hash table to find the connection object and sends the message on the open request.</p><blockquote><p>服务器如何跟踪所有打开的连接以有效地将消息重定向到用户？服务器可以维护一个哈希表，其中“key”是用户ID，“value”是连接对象。因此，每当服务器收到用户的消息时，它都会在哈希表中查找该用户以找到连接对象，并根据打开的请求发送消息。</p></blockquote><p><strong>What will happen when the server receives a message for a user who has gone offline?</strong> If the receiver has disconnected, the server can notify the sender about the delivery failure. If it is a temporary disconnect, e.g., the receiver’s long-poll request just timed out, then we should expect a reconnect from the user. In that case, we can ask the sender to retry sending the message. This retry could be embedded in the client’s logic so that users don’t have to retype the message. The server can also store the message for a while and retry sending it once the receiver reconnects.</p><blockquote><p>当服务器收到用户下线的消息时会发生什么？如果接收方已断开连接，服务器可以通知发送方传送失败。如果是临时断开连接，例如接收者的长轮询请求刚刚超时，那么我们应该期望用户重新连接。在这种情况下，我们可以要求发件人重试发送消息。这种重试可以嵌入到客户端的逻辑中，这样用户就不必重新输入消息。服务器还可以将消息存储一段时间，并在接收者重新连接后重试发送。</p></blockquote><p><strong>How many chat servers we need?</strong> Let’s plan for 500 million connections at any time. Assuming a modern server can handle 50K concurrent connections at any time, we would need 10K such servers.</p><blockquote><p>我们需要多少个聊天服务器？随时规划5亿连接。假设现代服务器可以随时处理 50K 并发连接，我们将需要 10K 这样的服务器。</p></blockquote><p><strong>How do we know which server holds the connection to which user?</strong> We can introduce a software load balancer in front of our chat servers; that can map each UserID to a server to redirect the request.</p><blockquote><p>我们如何知道哪个服务器拥有与哪个用户的连接？我们可以在聊天服务器前面引入一个软件负载均衡器；它可以将每个 UserID 映射到服务器以重定向请求。</p></blockquote><p><strong>How should the server process a ‘deliver message’ request?</strong> The server needs to do the following things upon receiving a new message: 1) Store the message in the database 2) Send the message to the receiver and 3) Send an acknowledgment to the sender.</p><blockquote><p>服务器应该如何处理“传递消息”请求？服务器在收到新消息后需要执行以下操作： 1) 将消息存储在数据库中 2) 将消息发送给接收者 3) 向发送者发送确认。</p></blockquote><p>The chat server will first find the server that holds the connection for the receiver and pass the message to that server to send it to the receiver. The chat server can then send the acknowledgment to the sender; we don’t need to wait for storing the message in the database (this can happen in the background). Storing the message is discussed in the next section.</p><blockquote><p>聊天服务器将首先找到为接收者保留连接的服务器，并将消息传递给该服务器以将其发送给接收者。然后聊天服务器可以将确认发送给发送者；我们不需要等待将消息存储在数据库中（这可以在后台发生）。下一节将讨论存储消息。</p></blockquote><p><strong>How does the messenger maintain the sequencing of the messages?</strong> We can store a timestamp with each message, which is the time the message is received by the server. This will still not ensure correct ordering of messages for clients. The scenario where the server timestamp cannot determine the exact order of messages would look like this:</p><blockquote><p>消息传递者如何保持消息的顺序？我们可以为每条消息存储一个时间戳，这是服务器接收消息的时间。这仍然不能确保客户端消息的正确排序。服务器时间戳无法确定消息的确切顺序的情况如下所示：</p></blockquote><ol><li><p>User-1 sends a message M1 to the server for User-2.</p><blockquote><p>User-1 向 User-2 的服务器发送消息 M1。</p></blockquote></li><li><p>The server receives M1 at T1.</p><blockquote><p>服务器在 T1 接收 M1。</p></blockquote></li><li><p>Meanwhile, User-2 sends a message M2 to the server for User-1.</p><blockquote><p>同时，User-2向User-1的服务器发送消息M2。</p></blockquote></li><li><p>The server receives the message M2 at T2, such that T2 > T1.</p><blockquote><p>服务器在T2接收消息M2，使得T2>T1。</p></blockquote></li><li><p>The server sends message M1 to User-2 and M2 to User-1.</p><blockquote><p>服务器将消息 M1 发送到 User-2，将 M2 发送到 User-1。</p></blockquote></li></ol><p>So User-1 will see M1 first and then M2, whereas User-2 will see M2 first and then M1.</p><blockquote><p>因此，用户 1 将首先看到 M1，然后是 M2，而用户 2 将首先看到 M2，然后是 M1。</p></blockquote><p>To resolve this, we need to keep a sequence number with every message for each client. This sequence number will determine the exact ordering of messages for EACH user. With this solution both clients will see a different view of the message sequence, but this view will be consistent for them on all devices.</p><blockquote><p>为了解决这个问题，我们需要为每个客户端的每条消息保留一个序列号。该序列号将确定每个用户的消息的确切顺序。通过此解决方案，两个客户端都将看到消息序列的不同视图，但此视图在所有设备上都将保持一致。</p></blockquote><p><strong>b. Storing and retrieving the messages from the database</strong></p><blockquote><p>b.从数据库中存储和检索消息**</p></blockquote><p>Whenever the chat server receives a new message, it needs to store it in the database. To do so, we have two options:</p><blockquote><p>每当聊天服务器收到新消息时，都需要将其存储在数据库中。为此，我们有两个选择：</p></blockquote><ol><li><p>Start a separate thread, which will work with the database to store the message. 2. Send an asynchronous request to the database to store the message.</p><blockquote><p>启动一个单独的线程，该线程将与数据库一起存储消息。 2. 向数据库发送异步请求来存储消息。</p></blockquote></li></ol><p>We have to keep certain things in mind while designing our database:</p><blockquote><p>在设计数据库时，我们必须记住以下几点：</p></blockquote><ol><li><p>How to efficiently work with the database connection pool.</p><blockquote><p>如何高效地使用数据库连接池。</p></blockquote></li><li><p>How to retry failed requests.</p><blockquote><p>如何重试失败的请求。</p></blockquote></li><li><p>Where to log those requests that failed even after some retries.</p><blockquote><p>在哪里记录那些重试后仍失败的请求。</p></blockquote></li><li><p>How to retry these logged requests (that failed after the retry) when all the issues have resolved.</p><blockquote><p>当所有问题都解决后，如何重试这些记录的请求（重试后失败）。</p></blockquote></li></ol><p><strong>Which storage system we should use?</strong> We need to have a database that can support a very high rate of small updates and also fetch a range of records quickly. This is required because we have a huge number of small messages that need to be inserted in the database and, while querying, a user is mostly interested in sequentially accessing the messages.</p><blockquote><p>我们应该使用哪种存储系统？我们需要一个能够支持非常高的小更新率并且能够快速获取一系列记录的数据库。这是必需的，因为我们有大量的小消息需要插入到数据库中，并且在查询时，用户最感兴趣的是顺序访问这些消息。</p></blockquote><p>We cannot use RDBMS like MySQL or NoSQL like MongoDB because we cannot afford to read/write a row from the database every time a user receives/sends a message. This will not only make the basic operations of our service run with high latency, but also create a huge load on databases.</p><blockquote><p>我们无法使用 MySQL 等 RDBMS 或 MongoDB 等 NoSQL，因为我们无法在用户每次接收/发送消息时从数据库中读取/写入一行。这不仅会使我们服务的基本操作以高延迟运行，还会对数据库造成巨大的负载。</p></blockquote><p>Both of our requirements can be easily met with a wide-column database solution like HBase. HBase is a column-oriented key-value NoSQL database that can store multiple values against one key into multiple columns. HBase is modeled after Google’s BigTable and runs on top of Hadoop Distributed File System (HDFS). HBase groups data together to store new data in a memory buffer and, once the buffer is full, it dumps the data to the disk. This way of storage not only helps storing a lot of small data quickly, but also fetching rows by the key or scanning ranges of rows. HBase is also an efficient database to store variably sized data, which is also required by our service.</p><blockquote><p>像 HBase 这样的宽列数据库解决方案就可以轻松满足我们的这两个要求。 HBase 是一种面向列的键值 NoSQL 数据库，可以将一个键的多个值存储到多个列中。 HBase 仿照 Google 的 BigTable 建模，并在 Hadoop 分布式文件系统 (HDFS) 之上运行。 HBase 将数据分组在一起，将新数据存储在内存缓冲区中，一旦缓冲区已满，它将数据转储到磁盘。这种存储方式不仅有助于快速存储大量小数据，而且还可以通过键或扫描行范围来获取行。 HBase也是一个高效的数据库，可以存储不同大小的数据，这也是我们的服务所需要的。</p></blockquote><p><strong>How should clients efficiently fetch data from the server?</strong> Clients should paginate while fetching data from the server. Page size could be different for different clients, e.g., cell phones have smaller screens, so we need a fewer number of message/conversations in the viewport.</p><blockquote><p>客户端应该如何高效地从服务器获取数据？客户端在从服务器获取数据时应该分页。对于不同的客户端，页面大小可能不同，例如，手机的屏幕较小，因此我们在视口中需要较少数量的消息/对话。</p></blockquote><p><strong>c. Managing user’s status</strong></p><blockquote><p><strong>c.管理用户状态</strong></p></blockquote><p>We need to keep track of user’s online/offline status and notify all the relevant users whenever a status change happens. Since we are maintaining a connection object on the server for all active users, we can easily figure out the user’s current status from this. With 500M active users at any time, if we have to</p><blockquote><p>我们需要跟踪用户的在线/离线状态，并在状态发生变化时通知所有相关用户。由于我们在服务器上为所有活动用户维护一个连接对象，因此我们可以轻松地从中找出用户的当前状态。任何时候都有 5 亿活跃用户，如果我们必须的话</p></blockquote><p>broadcast each status change to all the relevant active users, it will consume a lot of resources. We can do the following optimization around this:</p><blockquote><p>将每个状态变化广播给所有相关的活跃用户，会消耗大量资源。围绕这一点我们可以做如下优化：</p></blockquote><ol><li><p>Whenever a client starts the app, it can pull the current status of all users in their friends’ list.</p><blockquote><p>每当客户端启动应用程序时，它都可以提取好友列表中所有用户的当前状态。</p></blockquote></li><li><p>Whenever a user sends a message to another user that has gone offline, we can send a failure to the sender and update the status on the client.</p><blockquote><p>每当一个用户向另一个离线的用户发送消息时，我们可以向发送者并更新客户端上的状态。</p></blockquote></li><li><p>Whenever a user comes online, the server can always broadcast that status with a delay of a few seconds to see if the user does not go offline immediately.</p><blockquote><p>每当用户上线时，服务器总是可以延迟几秒广播该状态秒查看用户是否没有立即离线。</p></blockquote></li><li><p>Client’s can pull the status from the server about those users that are being shown on the user’s viewport. This should not be a frequent operation, as the server is broadcasting the online status of users and we can live with the stale offline status of users for a while.</p><blockquote><p>客户端可以从服务器获取有关用户的状态，这些状态显示在用户的视口。这不应该是一个频繁的操作，因为服务器正在广播在线状态用户的离线状态我们可以忍受一段时间。</p></blockquote></li><li><p>Whenever the client starts a new chat with another user, we can pull the status at that time.</p><blockquote><p>每当客户端与另一个用户开始新的聊天时，我们就可以提取当时的状态。</p></blockquote></li></ol><p>Detailed component design for Facebook messenger</p><blockquote><p>Facebook Messenger 的详细组件设计</p></blockquote><p><strong>Design Summary:</strong> Clients will open a connection to the chat server to send a message; the server will then pass it to the requested user. All the active users will keep a connection open with the server to receive messages. Whenever a new message arrives, the chat server will push it to the receiving user on the long poll request. Messages can be stored in HBase, which supports quick small updates, and range</p><blockquote><p>设计总结：客户端会打开一个到聊天服务器的连接来发送消息；然后服务器会将其传递给请求的用户。所有活动用户都将保持与服务器的连接以接收消息。每当有新消息到达时，聊天服务器都会通过长轮询请求将其推送给接收用户。消息可以存储在HBase中，支持快速小更新和范围</p></blockquote><p>based searches. The servers can broadcast the online status of a user to other relevant users. Clients can pull status updates for users who are visible in the client’s viewport on a less frequent basis.</p><blockquote><p>基于搜索。服务器可以向其他相关用户广播用户的在线状态。客户端可以不频繁地为在客户端视口中可见的用户拉取状态更新。</p></blockquote><h2 id=6-data-partitioning>6. Data partitioning<a hidden class=anchor aria-hidden=true href=#6-data-partitioning>#</a></h2><blockquote><ol start=6><li>数据分区</li></ol></blockquote><p>Since we will be storing a lot of data (3.6PB for five years), we need to distribute it onto multiple database servers. What will be our partitioning scheme?</p><blockquote><p>由于我们将存储大量数据（五年 3.6PB），因此我们需要将其分发到多个数据库服务器上。我们的分区方案是什么？</p></blockquote><p><strong>Partitioning based on UserID:</strong> Let’s assume we partition based on the hash of the UserID so that we can keep all messages of a user on the same database. If one DB shard is 4TB, we will have “3.6PB/4TB ~= 900” shards for five years. For simplicity, let’s assume we keep 1K shards. So we will find the shard number by “hash(UserID) % 1000” and then store/retrieve the data from there. This partitioning scheme will also be very quick to fetch chat history for any user.</p><blockquote><p>基于 UserID 的分区：假设我们基于 UserID 的哈希进行分区，以便我们可以将用户的所有消息保存在同一个数据库中。如果一个数据库分片是 4TB，那么五年内我们将拥有“3.6PB/4TB ~= 900”个分片。为了简单起见，我们假设我们保留 1K 分片。因此，我们将通过“hash(UserID) % 1000”找到分片编号，然后从那里存储/检索数据。这种分区方案也可以非常快速地获取任何用户的聊天历史记录。</p></blockquote><p>In the beginning, we can start with fewer database servers with multiple shards residing on one physical server. Since we can have multiple database instances on a server, we can easily store multiple partitions on a single server. Our hash function needs to understand this logical partitioning scheme so that it can map multiple logical partitions on one physical server.</p><blockquote><p>一开始，我们可以从较少的数据库服务器开始，在一台物理服务器上驻留多个分片。由于我们可以在一台服务器上拥有多个数据库实例，因此我们可以轻松地在一台服务器上存储多个分区。我们的哈希函数需要理解这种逻辑分区方案，以便它可以在一台物理服务器上映射多个逻辑分区。</p></blockquote><p>Since we will store an unlimited history of messages, we can start with a big number of logical partitions, which will be mapped to fewer physical servers, and as our storage demand increases, we can add more physical servers to distribute our logical partitions.</p><blockquote><p>由于我们将存储无限的消息历史记录，因此我们可以从大量逻辑分区开始，这些逻辑分区将映射到更少的物理服务器，并且随着存储需求的增加，我们可以添加更多物理服务器来分布我们的逻辑分区。</p></blockquote><p><strong>Partitioning based on MessageID:</strong> If we store different messages of a user on separate database shards, fetching a range of messages of a chat would be very slow, so we should not adopt this scheme.</p><blockquote><p>基于MessageID的分区：如果我们将一个用户的不同消息存储在不同的数据库分片上，那么获取一段聊天的一系列消息会非常慢，所以我们不应该采用这种方案。</p></blockquote><h2 id=7-cache>7. Cache<a hidden class=anchor aria-hidden=true href=#7-cache>#</a></h2><blockquote><ol start=7><li>缓存</li></ol></blockquote><p>We can cache a few recent messages (say last 15) in a few recent conversations that are visible in a user’s viewport (say last 5). Since we decided to store all of the user’s messages on one shard, cache for a user should entirely reside on one machine too.</p><blockquote><p>我们可以在用户视口中可见的一些最近对话（例如最后 5 条）中缓存一些最近的消息（例如最后 15 条）。由于我们决定将所有用户的消息存储在一个分片上，因此用户的缓存也应该完全驻留在一台机器上。</p></blockquote><h2 id=8-load-balancing>8. Load balancing<a hidden class=anchor aria-hidden=true href=#8-load-balancing>#</a></h2><blockquote><p>8.负载均衡</p></blockquote><p>We will need a load balancer in front of our chat servers; that can map each UserID to a server that holds the connection for the user and then direct the request to that server. Similarly, we would need a load balancer for our cache servers.</p><blockquote><p>我们需要在聊天服务器前面有一个负载均衡器；它可以将每个 UserID 映射到保存用户连接的服务器，然后将请求定向到该服务器。同样，我们的缓存服务器需要一个负载平衡器。</p></blockquote><h2 id=9-fault-tolerance-and-replication>9. Fault tolerance and Replication<a hidden class=anchor aria-hidden=true href=#9-fault-tolerance-and-replication>#</a></h2><blockquote><ol start=9><li>容错和复制</li></ol></blockquote><p><strong>What will happen when a chat server fails?</strong> Our chat servers are holding connections with the users. If a server goes down, should we devise a mechanism to transfer those connections to some other server? It’s extremely hard to failover TCP connections to other servers; an easier approach can be to have clients automatically reconnect if the connection is lost.</p><blockquote><p>当聊天服务器出现故障时会发生什么？我们的聊天服务器与用户保持连接。如果服务器出现故障，我们是否应该设计一种机制将这些连接转移到其他服务器？将 TCP 连接故障转移到其他服务器非常困难；一种更简单的方法是让客户端在连接丢失时自动重新连接。</p></blockquote><p><strong>Should we store multiple copies of user messages?</strong> We cannot have only one copy of the user’s data, because if the server holding the data crashes or is down permanently, we don’t have any mechanism to</p><blockquote><p>我们应该存储用户消息的多个副本吗？我们不能只有一份用户数据的副本，因为如果保存数据的服务器崩溃或永久关闭，我们没有任何机制可以</p></blockquote><p>recover that data. For this, either we have to store multiple copies of the data on different servers or use techniques like Reed-Solomon encoding to distribute and replicate it.</p><blockquote><p>恢复该数据。为此，我们要么必须在不同的服务器上存储数据的多个副本，要么使用 Reed-Solomon 编码等技术来分发和复制数据。</p></blockquote><h2 id=10-extended-requirements>10. Extended Requirements<a hidden class=anchor aria-hidden=true href=#10-extended-requirements>#</a></h2><blockquote><ol start=10><li>扩展要求</li></ol></blockquote><p><strong>a. Group chat</strong></p><blockquote><p><strong>a.群聊</strong></p></blockquote><p>We can have separate group-chat objects in our system that can be stored on the chat servers. A group- chat object is identified by GroupChatID and will also maintain a list of people who are part of that chat. Our load balancer can direct each group chat message based on GroupChatID and the server handling that group chat can iterate through all the users of the chat to find the server handling the connection of each user to deliver the message.</p><blockquote><p>我们可以在系统中拥有单独的群聊对象，这些对象可以存储在聊天服务器上。群聊对象由 GroupChatID 标识，并且还将维护属于该聊天的人员列表。我们的负载均衡器可以根据 GroupChatID 引导每个群聊消息，并且处理该群聊的服务器可以迭代所有聊天用户，找到处理每个用户连接的服务器来传递消息。</p></blockquote><p>In databases, we can store all the group chats in a separate table partitioned based on GroupChatID.</p><blockquote><p>在数据库中，我们可以将所有群聊存储在一个根据GroupChatID分区的单独表中。</p></blockquote><p><strong>b. Push notifications</strong></p><blockquote><p><strong>b.推送通知</strong></p></blockquote><p>In our current design user’s can only send messages to active users and if the receiving user is offline, we send a failure to the sending user. Push notifications will enable our system to send messages to offline users.</p><blockquote><p>在我们当前的设计中，用户只能向活动用户发送消息，如果接收用户离线，我们会向发送用户发送失败消息。推送通知将使我们的系统能够向离线用户发送消息。</p></blockquote><p>For Push notifications, each user can opt-in from their device (or a web browser) to get notifications whenever there is a new message or event. Each manufacturer maintains a set of servers that handles pushing these notifications to the user.</p><blockquote><p>对于推送通知，每个用户都可以选择从他们的设备（或网络浏览器）接收通知，只要有新消息或事件。每个制造商都维护一组服务器来处理将这些通知推送给用户。</p></blockquote><p>To have push notifications in our system, we would need to set up a Notification server, which will take the messages for offline users and send them to the manufacture’s push notification server, which will then send them to the user’s device.</p><blockquote><p>要在我们的系统中添加推送通知，我们需要设置一个通知服务器，该服务器将获取离线用户的消息并将其发送到制造商的推送通知服务器，然后制造商的推送通知服务器将它们发送到用户的设备。</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/architecture/>Architecture</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/11/24/designing-dropbox/><span class=title>« Prev</span><br><span>[译]《Grokking the System Design Interview》设计Dropbox</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/11/24/designing-instagram/><span class=title>Next »</span><br><span>[译]《Grokking the System Design Interview》设计Instagram</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Facebook Messenger on x" href="https://x.com/intent/tweet/?text=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Facebook%20Messenger&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-facebook-messenger%2f&amp;hashtags=architecture"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Facebook Messenger on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-facebook-messenger%2f&amp;title=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Facebook%20Messenger&amp;summary=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Facebook%20Messenger&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-facebook-messenger%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Facebook Messenger on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-facebook-messenger%2f&title=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Facebook%20Messenger"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Facebook Messenger on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-facebook-messenger%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Facebook Messenger on whatsapp" href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Facebook%20Messenger%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-facebook-messenger%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Facebook Messenger on telegram" href="https://telegram.me/share/url?text=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Facebook%20Messenger&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-facebook-messenger%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Facebook Messenger on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Facebook%20Messenger&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-facebook-messenger%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>