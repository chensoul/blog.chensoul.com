<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]《Grokking the System Design Interview》设计Pastebin | ChenSoul</title>
<meta name=keywords content="architecture"><meta name=description content="这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Pastebin》设计 Pastebin。 Let’s design a Pastebin like web service, where users can store plain text. Users of the service will enter a piece of text and get a randomly generated URL to access it. Similar Services: pastebin.com, pasted.co, chopapp.com Difficulty Level: Easy 让我们设"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/11/24/designing-pastebin/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.899d9a536396b9b03c9eae0c99cc6ec954a90da94036f5390d131eb8071bb417.css integrity="sha256-iZ2aU2OWubA8nq4MmcxuyVSpDalANvU5DRMeuAcbtBc=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/11/24/designing-pastebin/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="[译]《Grokking the System Design Interview》设计Pastebin"><meta property="og:description" content="这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Pastebin》设计 Pastebin。 Let’s design a Pastebin like web service, where users can store plain text. Users of the service will enter a piece of text and get a randomly generated URL to access it. Similar Services: pastebin.com, pasted.co, chopapp.com Difficulty Level: Easy 让我们设"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/11/24/designing-pastebin/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-24T00:00:00+08:00"><meta property="article:modified_time" content="2023-11-24T00:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]《Grokking the System Design Interview》设计Pastebin"><meta name=twitter:description content="这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Pastebin》设计 Pastebin。 Let’s design a Pastebin like web service, where users can store plain text. Users of the service will enter a piece of text and get a randomly generated URL to access it. Similar Services: pastebin.com, pasted.co, chopapp.com Difficulty Level: Easy 让我们设"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]《Grokking the System Design Interview》设计Pastebin","item":"https://blog.chensoul.cc/posts/2023/11/24/designing-pastebin/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]《Grokking the System Design Interview》设计Pastebin","name":"[译]《Grokking the System Design Interview》设计Pastebin","description":"这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Pastebin》设计 Pastebin。 Let’s design a Pastebin like web service, where users can store plain text. Users of the service will enter a piece of text and get a randomly generated URL to access it. Similar Services: pastebin.com, pasted.co, chopapp.com Difficulty Level: Easy 让我们设","keywords":["architecture"],"articleBody":"这是一篇双语翻译的文章，原文出自 grok_system_design_interview.pdf 的一篇文章《Designing Pastebin》设计 Pastebin。\nLet’s design a Pastebin like web service, where users can store plain text. Users of the service will enter a piece of text and get a randomly generated URL to access it. Similar Services: pastebin.com, pasted.co, chopapp.com Difficulty Level: Easy\n让我们设计一个类似 Pastebin 的 Web 服务，用户可以在其中存储纯文本。该服务的用户将输入一段文本并获得一个随机生成的 URL 来访问它。类似服务：pastebin.com、pasted.co、hopapp.com 难度级别：简单\n1. What is Pastebin? 1.Pastebin是什么？\nPastebin like services enable users to store plain text or images over the network (typically the Internet) and generate unique URLs to access the uploaded data. Such services are also used to share data over the network quickly, as users would just need to pass the URL to let other users see it.\nPastebin 之类的服务使用户能够通过网络（通常是互联网）存储纯文本或图像，并生成唯一的 URL 来访问上传的数据。此类服务还用于通过网络快速共享数据，因为用户只需传递 URL 即可让其他用户看到它。\nIf you haven’t used pastebin.com before, please try creating a new ‘Paste’ there and spend some time going through the different options their service offers. This will help you a lot in understanding this chapter.\n如果您以前没有使用过 pastebin.com，请尝试在那里创建一个新的“粘贴”，并花一些时间浏览他们的服务提供的不同选项。这将对你理解本章有很大帮助。\n2. Requirements and Goals of the System 系统的要求和目标 Our Pastebin service should meet the following requirements:\n我们的 Pastebin 服务应满足以下要求：\nFunctional Requirements:\n功能要求：\nUsers should be able to upload or “paste” their data and get a unique URL to access it.\n用户应该能够上传或“粘贴”他们的数据并获得唯一的 URL 来访问它。\nUsers will only be able to upload text.\n用户只能上传文本。\nData and links will expire after a specific timespan automatically; users should also be able to specify expiration time.\n数据和链接将在特定时间段后自动过期；用户还应该能够指定过期时间。\nUsers should optionally be able to pick a custom alias for their paste.\n用户应该可以选择为其粘贴选择自定义别名。\nNon-Functional Requirements:\n非功能性要求：\nThe system should be highly reliable, any data uploaded should not be lost.\n系统应高度可靠，上传的任何数据都不应丢失。\nThe system should be highly available. This is required because if our service is down, users will not be able to access their Pastes.\n系统应该是高可用的。这是必需的，因为如果我们的服务出现故障，用户将无法访问他们的粘贴。\nUsers should be able to access their Pastes in real-time with minimum latency.\n用户应该能够以最小的延迟实时访问他们的粘贴。\nPaste links should not be guessable (not predictable).\n粘贴链接不应是可猜测的（不可预测的）。\nExtended Requirements:\n扩展要求：\nAnalytics, e.g., how many times a paste was accessed?\n分析，例如粘贴被访问了多少次？\nOur service should also be accessible through REST APIs by other services.\n我们的服务还应该可以由其他服务通过 REST API 访问。\n3. Some Design Considerations 一些设计考虑 Pastebin shares some requirements with URL Shortening service, but there are some additional design considerations we should keep in mind.\nPastebin 与 URL 缩短服务有一些共同的要求，但我们还应该牢记一些额外的设计注意事项。\nWhat should be the limit on the amount of text user can paste at a time? We can limit users not to have Pastes bigger than 10MB to stop the abuse of the service.\n用户一次可以粘贴的文本量的限制应该是多少？我们可以限制用户粘贴的大小不得超过 10MB，以阻止滥用服务。\nShould we impose size limits on custom URLs? Since our service supports custom URLs, users can pick any URL that they like, but providing a custom URL is not mandatory. However, it is reasonable (and often desirable) to impose a size limit on custom URLs, so that we have a consistent URL database.\n我们应该对自定义 URL 施加大小限制吗？由于我们的服务支持自定义 URL，因此用户可以选择他们喜欢的任何 URL，但提供自定义 URL 不是强制性的。然而，对自定义 URL 施加大小限制是合理的（而且通常是可取的），这样我们就有一个一致的 URL 数据库。\n4. Capacity Estimation and Constraints 容量估计和约束 Our services will be read-heavy; there will be more read requests compared to new Pastes creation. We can assume a 5:1 ratio between read and write.\n我们的服务将需要大量阅读；与创建新的粘贴相比，将会有更多的读取请求。我们可以假设读和写之间的比例为 5:1。\nTraffic estimates: Pastebin services are not expected to have traffic similar to Twitter or Facebook, let’s assume here that we get one million new pastes added to our system every day. This leaves us with five million reads per day.\n流量估计：Pastebin 服务预计不会有类似于 Twitter 或 Facebook 的流量，我们假设每天有 100 万个新粘贴添加到我们的系统中。这使得我们每天的阅读量达到 500 万次。\nNew Pastes per second:\n每秒新粘贴数：\n1M / (24 hours * 3600 seconds) ~= 12 pastes/sec\nPaste reads per second:\n粘贴每秒读取次数：\n5M / (24 hours * 3600 seconds) ~= 58 reads/sec\nStorage estimates: Users can upload maximum 10MB of data; commonly Pastebin like services are\n存储预估：用户最多可上传10MB数据；通常类似 Pastebin 的服务是\nused to share source code, configs or logs. Such texts are not huge, so let’s assume that each paste on average contains 10KB.\n用于共享源代码、配置或日志。这些文本并不大，所以我们假设每个粘贴平均包含 10KB。\nAt this rate, we will be storing 10GB of data per day.\n按照这个速度，我们每天将存储 10GB 的数据。\n1M * 10KB =\u003e 10 GB/day\nIf we want to store this data for ten years we would need the total storage capacity of 36TB.\n如果我们想存储这些数据十年，我们需要 36TB 的总存储容量。\nWith 1M pastes every day we will have 3.6 billion Pastes in 10 years. We need to generate and store keys to uniquely identify these pastes. If we use base64 encoding ([A-Z, a-z, 0-9, ., -]) we would need six letters strings:\n每天有 100 万个焊膏，10 年后我们将拥有 36 亿个焊膏。我们需要生成并存储密钥来唯一标识这些粘贴。如果我们使用 Base64 编码（[A-Z, a-z, 0-9, ., -]），我们将需要六个字母的字符串：\n64^6 ~= 68.7 billion unique strings\n64^6 ~= 687 亿个唯一字符串\nIf it takes one byte to store one character, total size required to store 3.6B keys would be:\n如果需要 1 个字节存储 1 个字符，则存储 3.6B 个密钥所需的总大小为：\n3.6B * 6 =\u003e 22 GB\n22GB is negligible compared to 36TB. To keep some margin, we will assume a 70% capacity model (meaning we don’t want to use more than 70% of our total storage capacity at any point), which raises our storage needs to 51.4TB.\n与 36TB 相比，22GB 可以忽略不计。为了保留一定的余量，我们将假设 70% 的容量模型（这意味着我们在任何时候都不想使用超过总存储容量的 70%），这会将我们的存储需求提高到 51.4TB。\nBandwidth estimates: For write requests, we expect 12 new pastes per second, resulting in 120KB of ingress per second.\n带宽估计：对于写入请求，我们预计每秒 12 个新粘贴，导致每秒 120KB 的入口。\n12 * 10KB =\u003e 120 KB/s\nAs for the read request, we expect 58 requests per second. Therefore, total data egress (sent to users) will be 0.6 MB/s.\n至于读取请求，我们预计每秒有 58 个请求。因此，总数据输出（发送给用户）将为 0.6 MB/s。\n58 * 10KB =\u003e 0.6 MB/s\nAlthough total ingress and egress are not big, we should keep these numbers in mind while designing our service.\n尽管入口和出口总量并不大，但我们在设计服务时应该牢记这些数字。\nMemory estimates: We can cache some of the hot pastes that are frequently accessed. Following the 80-20 rule, meaning 20% of hot pastes generate 80% of traffic, we would like to cache these 20% pastes\n内存估算：我们可以缓存一些经常访问的热贴。遵循 80-20 规则，即 20% 的热门粘贴产生 80% 的流量，我们希望缓存这 20% 的粘贴\nSince we have 5M read requests per day, to cache 20% of these requests, we would need:\n由于我们每天有 500 万个读取请求，为了缓存这些请求的 20%，我们需要：\n0.2 * 5M * 10KB ~= 10 GB\n5. System APIs 系统API We can have SOAP or REST APIs to expose the functionality of our service. Following could be the definitions of the APIs to create/retrieve/delete Pastes:\n我们可以使用 SOAP 或 REST API 来公开我们服务的功能。以下是创建/检索/删除粘贴的 API 的定义：\n1 2 addPaste(api_dev_key, paste_data, custom_url=None user_name=None, paste_name=None, expire_date=None) Parameters:\n参数：\napi_dev_key (string): The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota. paste_data (string): Textual data of the paste. custom_url (string): Optional custom URL.\napi_dev_key (string): 注册账户的API开发者密钥。除其他外，这将用于根据分配的配额限制用户。 Paste_data（字符串）：粘贴的文本数据。 custom_url（字符串）：可选的自定义 URL。\nuser_name (string): Optional user name to be used to generate URL. paste_name (string): Optional name of the paste expire_date (string): Optional expiration date for the paste.\nuser_name（字符串）：用于生成 URL 的可选用户名。 Paste_name（字符串）：粘贴的可选名称 expire_date（字符串）：粘贴的可选到期日期。\nReturns: (string) A successful insertion returns the URL through which the paste can be accessed, otherwise, it will return an error code.\n返回：（字符串）成功插入将返回可访问粘贴的 URL，否则将返回错误代码。\nSimilarly, we can have retrieve and delete Paste APIs:\n同样，我们可以检索和删除粘贴 API：\n1 getPaste(api_dev_key, api_paste_key) Where “api_paste_key” is a string representing the Paste Key of the paste to be retrieved. This API will return the textual data of the paste.\n其中“api_paste_key”是一个字符串，表示要检索的粘贴的粘贴密钥。该 API 将返回粘贴的文本数据。\n1 deletePaste(api_dev_key, api_paste_key) A successful deletion returns ‘true’, otherwise returns ‘false’.\n成功删除返回“true”，否则返回“false”。\n6. Database Design 数据库设计 A few observations about the nature of the data we are storing:\n关于我们存储的数据的性质的一些观察：\nWe need to store billions of records.\n我们需要存储数十亿条记录。\nEach metadata object we are storing would be small (less than 100 bytes).\n我们存储的每个元数据对象都很小（小于 100 字节）。\nEach paste object we are storing can be of medium size (it can be a few MB).\n我们存储的每个粘贴对象可以是中等大小（可以是几 MB）。\nThere are no relationships between records, except if we want to store which user created what Paste.\n记录之间没有关系，除非我们想要存储哪个用户创建了哪个粘贴。\nOur service is read-heavy.\n我们的服务是重读的。\nDatabase Schema:\n数据库架构：\nWe would need two tables, one for storing information about the Pastes and the other for users’ data.\n我们需要两个表，一个用于存储有关粘贴的信息，另一个用于存储用户数据。\nHere, ‘URlHash’ is the URL equivalent of the TinyURL and ‘ContentKey’ is the object key storing the contents of the paste.\n这里，“URlHash”是相当于 TinyURL 的 URL，“ContentKey”是存储粘贴内容的对象键。\n7. High Level Design 高层设计 At a high level, we need an application layer that will serve all the read and write requests. Application layer will talk to a storage layer to store and retrieve data. We can segregate our storage layer with one database storing metadata related to each paste, users, etc., while the other storing the paste contents in some object storage (like Amazon S3). This division of data will also allow us to scale them individually.\n在较高的层面上，我们需要一个应用程序层来服务所有的读写请求。应用层将与存储层通信以存储和检索数据。我们可以将存储层隔离，一个数据库存储与每个粘贴、用户等相关的元数据，而另一个数据库将粘贴内容存储在某些对象存储（如 Amazon S3）中。这种数据划分还允许我们单独缩放它们。\n8. Component Design 组件设计 a. Application layer\na. 应用层\nOur application layer will process all incoming and outgoing requests. The application servers will be talking to the backend data store components to serve the requests.\n我们的应用程序层将处理所有传入和传出的请求。应用程序服务器将与后端数据存储组件通信以服务请求。\nHow to handle a write request? Upon receiving a write request, our application server will generate a six-letter random string, which would serve as the key of the paste (if the user has not provided a custom key). The application server will then store the contents of the paste and the generated key in the database. After the successful insertion, the server can return the key to the user. One possible problem here could be that the insertion fails because of a duplicate key. Since we are generating a random key, there is a possibility that the newly generated key could match an existing one. In that case, we should regenerate a new key and try again. We should keep retrying until we don’t see failure due to the duplicate key. We should return an error to the user if the custom key they have provided is already present in our database.\n如何处理写请求？收到写入请求后，我们的应用程序服务器将生成一个六字母的随机字符串，该字符串将用作粘贴的密钥（如果用户未提供自定义密钥）。然后应用程序服务器会将粘贴的内容和生成的密钥存储在数据库中。插入成功后，服务器可以将密钥返回给用户。这里一个可能的问题是插入由于重复的键而失败。由于我们生成随机密钥，因此新生成的密钥有可能与现有密钥匹配。在这种情况下，我们应该重新生成一个新密钥并重试。我们应该不断重试，直到看不到由于重复密钥而导致的失败。如果用户提供的自定义密钥已存在于我们的数据库中，我们应该向用户返回错误。\nAnother solution of the above problem could be to run a standalone Key Generation Service (KGS) that generates random six letters strings beforehand and stores them in a database (let’s call it key-DB). Whenever we want to store a new paste, we will just take one of the already generated keys and use it. This approach will make things quite simple and fast since we will not be worrying about duplications or collisions. KGS will make sure all the keys inserted in key-DB are unique. KGS can use two tables to store keys, one for keys that are not used yet and one for all the used keys. As soon as KGS gives some keys to an application server, it can move these to the used keys table. KGS can always keep some keys in memory so that whenever a server needs them, it can quickly provide them. As soon as KGS loads some keys in memory, it can move them to the used keys table, this way we can make sure each server gets unique keys. If KGS dies before using all the keys loaded in memory, we will be wasting those keys. We can ignore these keys given that we have a huge number of them.\n上述问题的另一个解决方案是运行一个独立的密钥生成服务（KGS），该服务预先生成随机的六个字母字符串并将它们存储在数据库中（我们称之为密钥数据库）。每当我们想要存储新的粘贴时，我们只需获取已生成的密钥之一并使用它即可。这种方法将使事情变得非常简单和快速，因为我们不会担心重复或冲突。 KGS 将确保插入 key-DB 中的所有密钥都是唯一的。 KGS 可以使用两张表来存储密钥，一张用于尚未使用的密钥，一张用于所有已使用的密钥。一旦 KGS 向应用程序服务器提供一些密钥，它就可以将这些密钥移动到已使用的密钥表中。 KGS 可以始终将一些密钥保留在内存中，以便每当服务器需要它们时，它可以快速提供它们。一旦 KGS 在内存中加载一些密钥，它就可以将它们移动到已使用的密钥表中，这样我们就可以确保每个服务器都获得唯一的密钥。如果 KGS 在使用内存中加载的所有密钥之前就死掉了，我们将浪费这些密钥。鉴于我们有大量的密钥，我们可以忽略这些密钥。\nIsn’t KGS a single point of failure? Yes, it is. To solve this, we can have a standby replica of KGS and whenever the primary server dies it can take over to generate and provide keys.\nKGS 不是单点故障吗？是的。为了解决这个问题，我们可以拥有一个 KGS 的备用副本，每当主服务器挂掉时，它就可以接管生成和提供密钥。\nCan each app server cache some keys from key-DB? Yes, this can surely speed things up. Although in this case, if the application server dies before consuming all the keys, we will end up losing those keys. This could be acceptable since we have 68B unique six letters keys, which are a lot more than we require.\n每个应用程序服务器可以缓存密钥数据库中的一些密钥吗？是的，这肯定可以加快速度。尽管在这种情况下，如果应用程序服务器在消耗所有密钥之前死亡，我们最终将丢失这些密钥。这是可以接受的，因为我们有 68B 个独特的六个字母键，这比我们需要的多得多。\nHow does it handle a paste read request? Upon receiving a read paste request, the application service layer contacts the datastore. The datastore searches for the key, and if it is found, returns the paste’s contents. Otherwise, an error code is returned.\n它如何处理粘贴读取请求？在接收到读取粘贴请求后，应用程序服务层联系数据存储。数据存储区搜索密钥，如果找到，则返回粘贴的内容。否则，返回错误代码。\nb. Datastore layer b.数据存储层\nWe can divide our datastore layer into two:\n我们可以将数据存储层分为两层：\nMetadata database: We can use a relational database like MySQL or a Distributed Key-Value store like Dynamo or Cassandra.\n元数据数据库：我们可以使用关系数据库（例如 MySQL）或分布式键值存储（例如 Dynamo 或 Cassandra）。\nObject storage: We can store our contents in an Object Storage like Amazon’s S3. Whenever we feel like hitting our full capacity on content storage, we can easily increase it by adding more servers.\n对象存储：我们可以将内容存储在对象存储中，例如 Amazon 的 S3。每当我们想要充分利用内容存储容量时，我们都可以通过添加更多服务器来轻松增加容量。\nDetailed component design for Pastebin\nPastebin 的详细组件设计\n9. Purging or DB Cleanup 清除或数据库清理 Please see Designing a URL Shortening service.\n请参阅设计 URL 缩短服务。\n10. Data Partitioning and Replication 数据分区和复制 Please see Designing a URL Shortening service.\n请参阅设计 URL 缩短服务。\n11. Cache and Load Balancer 缓存和负载均衡器 Please see Designing a URL Shortening service.\n请参阅设计 URL 缩短服务。\n12. Security and Permissions 安全和权限 Please see Designing a URL Shortening service.\n请参阅设计 URL 缩短服务。\n","wordCount":"5254","inLanguage":"en","datePublished":"2023-11-24T00:00:00+08:00","dateModified":"2023-11-24T00:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/11/24/designing-pastebin/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[译]《Grokking the System Design Interview》设计Pastebin</h1><div class=post-meta><span title='2023-11-24 00:00:00 +0800 CST'>2023-11-24</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;5254 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-what-is-pastebin aria-label="1. What is Pastebin?">1. What is Pastebin?</a></li><li><a href=#2-requirements-and-goals-of-the-system aria-label="2. Requirements and Goals of the System">2. Requirements and Goals of the System</a></li><li><a href=#3-some-design-considerations aria-label="3. Some Design Considerations">3. Some Design Considerations</a></li><li><a href=#4-capacity-estimation-and-constraints aria-label="4. Capacity Estimation and Constraints">4. Capacity Estimation and Constraints</a></li><li><a href=#5-system-apis aria-label="5. System APIs">5. System APIs</a></li><li><a href=#6-database-design aria-label="6. Database Design">6. Database Design</a></li><li><a href=#7-high-level-design aria-label="7. High Level Design">7. High Level Design</a></li><li><a href=#8-component-design aria-label="8. Component Design">8. Component Design</a></li><li><a href=#9-purging-or-db-cleanup aria-label="9. Purging or DB Cleanup">9. Purging or DB Cleanup</a></li><li><a href=#10-data-partitioning-and-replication aria-label="10. Data Partitioning and Replication">10. Data Partitioning and Replication</a></li><li><a href=#11-cache-and-load-balancer aria-label="11. Cache and Load Balancer">11. Cache and Load Balancer</a></li><li><a href=#12-security-and-permissions aria-label="12. Security and Permissions">12. Security and Permissions</a></li></ul></div></details></div><div class=post-content><p>这是一篇双语翻译的文章，原文出自 <a href=https://github.com/sharanyaa/grok_sdi_educative/blob/master/grok_system_design_interview.pdf>grok_system_design_interview.pdf</a> 的一篇文章《Designing Pastebin》设计 Pastebin。</p><hr><p>Let’s design a Pastebin like web service, where users can store plain text. Users of the service will enter a piece of text and get a randomly generated URL to access it. Similar Services: pastebin.com, pasted.co, chopapp.com Difficulty Level: Easy</p><blockquote><p>让我们设计一个类似 Pastebin 的 Web 服务，用户可以在其中存储纯文本。该服务的用户将输入一段文本并获得一个随机生成的 URL 来访问它。类似服务：pastebin.com、pasted.co、hopapp.com 难度级别：简单</p></blockquote><h2 id=1-what-is-pastebin>1. What is Pastebin?<a hidden class=anchor aria-hidden=true href=#1-what-is-pastebin>#</a></h2><blockquote><p>1.Pastebin是什么？</p></blockquote><p>Pastebin like services enable users to store plain text or images over the network (typically the Internet) and generate unique URLs to access the uploaded data. Such services are also used to share data over the network quickly, as users would just need to pass the URL to let other users see it.</p><blockquote><p>Pastebin 之类的服务使用户能够通过网络（通常是互联网）存储纯文本或图像，并生成唯一的 URL 来访问上传的数据。此类服务还用于通过网络快速共享数据，因为用户只需传递 URL 即可让其他用户看到它。</p></blockquote><p>If you haven’t used <a href=http://pastebin.com/>pastebin.com</a> before, please try creating a new ‘Paste’ there and spend some time going through the different options their service offers. This will help you a lot in understanding this chapter.</p><blockquote><p>如果您以前没有使用过 pastebin.com，请尝试在那里创建一个新的“粘贴”，并花一些时间浏览他们的服务提供的不同选项。这将对你理解本章有很大帮助。</p></blockquote><h2 id=2-requirements-and-goals-of-the-system>2. Requirements and Goals of the System<a hidden class=anchor aria-hidden=true href=#2-requirements-and-goals-of-the-system>#</a></h2><blockquote><ol start=2><li>系统的要求和目标</li></ol></blockquote><p>Our Pastebin service should meet the following requirements:</p><blockquote><p>我们的 Pastebin 服务应满足以下要求：</p></blockquote><p><strong>Functional Requirements:</strong></p><blockquote><p><strong>功能要求：</strong></p></blockquote><ol><li><p>Users should be able to upload or “paste” their data and get a unique URL to access it.</p><blockquote><p>用户应该能够上传或“粘贴”他们的数据并获得唯一的 URL 来访问它。</p></blockquote></li><li><p>Users will only be able to upload text.</p><blockquote><p>用户只能上传文本。</p></blockquote></li><li><p>Data and links will expire after a specific timespan automatically; users should also be able to specify expiration time.</p><blockquote><p>数据和链接将在特定时间段后自动过期；用户还应该能够指定过期时间。</p></blockquote></li><li><p>Users should optionally be able to pick a custom alias for their paste.</p><blockquote><p>用户应该可以选择为其粘贴选择自定义别名。</p></blockquote></li></ol><p><strong>Non-Functional Requirements:</strong></p><blockquote><p><strong>非功能性要求：</strong></p></blockquote><ol><li><p>The system should be highly reliable, any data uploaded should not be lost.</p><blockquote><p>系统应高度可靠，上传的任何数据都不应丢失。</p></blockquote></li><li><p>The system should be highly available. This is required because if our service is down, users will not be able to access their Pastes.</p><blockquote><p>系统应该是高可用的。这是必需的，因为如果我们的服务出现故障，用户将无法访问他们的粘贴。</p></blockquote></li><li><p>Users should be able to access their Pastes in real-time with minimum latency.</p><blockquote><p>用户应该能够以最小的延迟实时访问他们的粘贴。</p></blockquote></li><li><p>Paste links should not be guessable (not predictable).</p><blockquote><p>粘贴链接不应是可猜测的（不可预测的）。</p></blockquote></li></ol><p><strong>Extended Requirements:</strong></p><blockquote><p><strong>扩展要求：</strong></p></blockquote><ol><li><p>Analytics, e.g., how many times a paste was accessed?</p><blockquote><p>分析，例如粘贴被访问了多少次？</p></blockquote></li><li><p>Our service should also be accessible through REST APIs by other services.</p><blockquote><p>我们的服务还应该可以由其他服务通过 REST API 访问。</p></blockquote></li></ol><h2 id=3-some-design-considerations>3. Some Design Considerations<a hidden class=anchor aria-hidden=true href=#3-some-design-considerations>#</a></h2><blockquote><ol start=3><li>一些设计考虑</li></ol></blockquote><p>Pastebin shares some requirements with <a href=https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904>URL Shortening service</a>, but there are some additional design considerations we should keep in mind.</p><blockquote><p>Pastebin 与 URL 缩短服务有一些共同的要求，但我们还应该牢记一些额外的设计注意事项。</p></blockquote><p><strong>What should be the limit on the amount of text user can paste at a time?</strong> We can limit users not to have Pastes bigger than 10MB to stop the abuse of the service.</p><blockquote><p>用户一次可以粘贴的文本量的限制应该是多少？我们可以限制用户粘贴的大小不得超过 10MB，以阻止滥用服务。</p></blockquote><p><strong>Should we impose size limits on custom URLs?</strong> Since our service supports custom URLs, users can pick any URL that they like, but providing a custom URL is not mandatory. However, it is reasonable (and often desirable) to impose a size limit on custom URLs, so that we have a consistent URL database.</p><blockquote><p>我们应该对自定义 URL 施加大小限制吗？由于我们的服务支持自定义 URL，因此用户可以选择他们喜欢的任何 URL，但提供自定义 URL 不是强制性的。然而，对自定义 URL 施加大小限制是合理的（而且通常是可取的），这样我们就有一个一致的 URL 数据库。</p></blockquote><h2 id=4-capacity-estimation-and-constraints>4. Capacity Estimation and Constraints<a hidden class=anchor aria-hidden=true href=#4-capacity-estimation-and-constraints>#</a></h2><blockquote><ol start=4><li>容量估计和约束</li></ol></blockquote><p>Our services will be read-heavy; there will be more read requests compared to new Pastes creation. We can assume a 5:1 ratio between read and write.</p><blockquote><p>我们的服务将需要大量阅读；与创建新的粘贴相比，将会有更多的读取请求。我们可以假设读和写之间的比例为 5:1。</p></blockquote><p><strong>Traffic estimates:</strong> Pastebin services are not expected to have traffic similar to Twitter or Facebook, let’s assume here that we get one million new pastes added to our system every day. This leaves us with five million reads per day.</p><blockquote><p>流量估计：Pastebin 服务预计不会有类似于 Twitter 或 Facebook 的流量，我们假设每天有 100 万个新粘贴添加到我们的系统中。这使得我们每天的阅读量达到 500 万次。</p></blockquote><p>New Pastes per second:</p><blockquote><p>每秒新粘贴数：</p></blockquote><p>1M / (24 hours * 3600 seconds) ~= 12 pastes/sec</p><p>Paste reads per second:</p><blockquote><p>粘贴每秒读取次数：</p></blockquote><p>5M / (24 hours * 3600 seconds) ~= 58 reads/sec</p><p><strong>Storage estimates:</strong> Users can upload maximum 10MB of data; commonly Pastebin like services are</p><blockquote><p>存储预估：用户最多可上传10MB数据；通常类似 Pastebin 的服务是</p></blockquote><p>used to share source code, configs or logs. Such texts are not huge, so let’s assume that each paste on average contains 10KB.</p><blockquote><p>用于共享源代码、配置或日志。这些文本并不大，所以我们假设每个粘贴平均包含 10KB。</p></blockquote><p>At this rate, we will be storing 10GB of data per day.</p><blockquote><p>按照这个速度，我们每天将存储 10GB 的数据。</p></blockquote><p>1M * 10KB => 10 GB/day</p><p>If we want to store this data for ten years we would need the total storage capacity of 36TB.</p><blockquote><p>如果我们想存储这些数据十年，我们需要 36TB 的总存储容量。</p></blockquote><p>With 1M pastes every day we will have 3.6 billion Pastes in 10 years. We need to generate and store keys to uniquely identify these pastes. If we use base64 encoding ([A-Z, a-z, 0-9, ., -]) we would need six letters strings:</p><blockquote><p>每天有 100 万个焊膏，10 年后我们将拥有 36 亿个焊膏。我们需要生成并存储密钥来唯一标识这些粘贴。如果我们使用 Base64 编码（[A-Z, a-z, 0-9, ., -]），我们将需要六个字母的字符串：</p></blockquote><p>64^6 ~= 68.7 billion unique strings</p><blockquote><p>64^6 ~= 687 亿个唯一字符串</p></blockquote><p>If it takes one byte to store one character, total size required to store 3.6B keys would be:</p><blockquote><p>如果需要 1 个字节存储 1 个字符，则存储 3.6B 个密钥所需的总大小为：</p></blockquote><p>3.6B * 6 => 22 GB</p><p>22GB is negligible compared to 36TB. To keep some margin, we will assume a 70% capacity model (meaning we don’t want to use more than 70% of our total storage capacity at any point), which raises our storage needs to 51.4TB.</p><blockquote><p>与 36TB 相比，22GB 可以忽略不计。为了保留一定的余量，我们将假设 70% 的容量模型（这意味着我们在任何时候都不想使用超过总存储容量的 70%），这会将我们的存储需求提高到 51.4TB。</p></blockquote><p><strong>Bandwidth estimates:</strong> For write requests, we expect 12 new pastes per second, resulting in 120KB of ingress per second.</p><blockquote><p>带宽估计：对于写入请求，我们预计每秒 12 个新粘贴，导致每秒 120KB 的入口。</p></blockquote><p>12 * 10KB => 120 KB/s</p><p>As for the read request, we expect 58 requests per second. Therefore, total data egress (sent to users) will be 0.6 MB/s.</p><blockquote><p>至于读取请求，我们预计每秒有 58 个请求。因此，总数据输出（发送给用户）将为 0.6 MB/s。</p></blockquote><p>58 * 10KB => 0.6 MB/s</p><p>Although total ingress and egress are not big, we should keep these numbers in mind while designing our service.</p><blockquote><p>尽管入口和出口总量并不大，但我们在设计服务时应该牢记这些数字。</p></blockquote><p><strong>Memory estimates:</strong> We can cache some of the hot pastes that are frequently accessed. Following the 80-20 rule, meaning 20% of hot pastes generate 80% of traffic, we would like to cache these 20% pastes</p><blockquote><p>内存估算：我们可以缓存一些经常访问的热贴。遵循 80-20 规则，即 20% 的热门粘贴产生 80% 的流量，我们希望缓存这 20% 的粘贴</p></blockquote><p>Since we have 5M read requests per day, to cache 20% of these requests, we would need:</p><blockquote><p>由于我们每天有 500 万个读取请求，为了缓存这些请求的 20%，我们需要：</p></blockquote><p>0.2 * 5M * 10KB ~= 10 GB</p><h2 id=5-system-apis>5. System APIs<a hidden class=anchor aria-hidden=true href=#5-system-apis>#</a></h2><blockquote><ol start=5><li>系统API</li></ol></blockquote><p>We can have SOAP or REST APIs to expose the functionality of our service. Following could be the definitions of the APIs to create/retrieve/delete Pastes:</p><blockquote><p>我们可以使用 SOAP 或 REST API 来公开我们服务的功能。以下是创建/检索/删除粘贴的 API 的定义：</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>addPaste(api_dev_key, paste_data, custom_url=None user_name=None, paste_name=None,
</span></span><span class=line><span class=cl>expire_date=None)
</span></span></code></pre></td></tr></table></div></div><p><strong>Parameters:</strong></p><blockquote><p><strong>参数：</strong></p></blockquote><p>api_dev_key (string): The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota. paste_data (string): Textual data of the paste. custom_url (string): Optional custom URL.</p><blockquote><p>api_dev_key (string): 注册账户的API开发者密钥。除其他外，这将用于根据分配的配额限制用户。 Paste_data（字符串）：粘贴的文本数据。 custom_url（字符串）：可选的自定义 URL。</p></blockquote><p>user_name (string): Optional user name to be used to generate URL. paste_name (string): Optional name of the paste expire_date (string): Optional expiration date for the paste.</p><blockquote><p>user_name（字符串）：用于生成 URL 的可选用户名。 Paste_name（字符串）：粘贴的可选名称 expire_date（字符串）：粘贴的可选到期日期。</p></blockquote><p><strong>Returns:</strong> (string) A successful insertion returns the URL through which the paste can be accessed, otherwise, it will return an error code.</p><blockquote><p>返回：（字符串）成功插入将返回可访问粘贴的 URL，否则将返回错误代码。</p></blockquote><p>Similarly, we can have retrieve and delete Paste APIs:</p><blockquote><p>同样，我们可以检索和删除粘贴 API：</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>getPaste(api_dev_key, api_paste_key)
</span></span></code></pre></td></tr></table></div></div><p>Where “api_paste_key” is a string representing the Paste Key of the paste to be retrieved. This API will return the textual data of the paste.</p><blockquote><p>其中“api_paste_key”是一个字符串，表示要检索的粘贴的粘贴密钥。该 API 将返回粘贴的文本数据。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>deletePaste(api_dev_key, api_paste_key)
</span></span></code></pre></td></tr></table></div></div><p>A successful deletion returns ‘true’, otherwise returns ‘false’.</p><blockquote><p>成功删除返回“true”，否则返回“false”。</p></blockquote><h2 id=6-database-design>6. Database Design<a hidden class=anchor aria-hidden=true href=#6-database-design>#</a></h2><blockquote><ol start=6><li>数据库设计</li></ol></blockquote><p>A few observations about the nature of the data we are storing:</p><blockquote><p>关于我们存储的数据的性质的一些观察：</p></blockquote><ol><li><p>We need to store billions of records.</p><blockquote><p>我们需要存储数十亿条记录。</p></blockquote></li><li><p>Each metadata object we are storing would be small (less than 100 bytes).</p><blockquote><p>我们存储的每个元数据对象都很小（小于 100 字节）。</p></blockquote></li><li><p>Each paste object we are storing can be of medium size (it can be a few MB).</p><blockquote><p>我们存储的每个粘贴对象可以是中等大小（可以是几 MB）。</p></blockquote></li><li><p>There are no relationships between records, except if we want to store which user created what Paste.</p><blockquote><p>记录之间没有关系，除非我们想要存储哪个用户创建了哪个粘贴。</p></blockquote></li><li><p>Our service is read-heavy.</p><blockquote><p>我们的服务是重读的。</p></blockquote></li></ol><p><strong>Database Schema:</strong></p><blockquote><p><strong>数据库架构：</strong></p></blockquote><p>We would need two tables, one for storing information about the Pastes and the other for users’ data.</p><blockquote><p>我们需要两个表，一个用于存储有关粘贴的信息，另一个用于存储用户数据。</p></blockquote><p>Here, ‘URlHash’ is the URL equivalent of the TinyURL and ‘ContentKey’ is the object key storing the contents of the paste.</p><blockquote><p>这里，“URlHash”是相当于 TinyURL 的 URL，“ContentKey”是存储粘贴内容的对象键。</p></blockquote><h2 id=7-high-level-design>7. High Level Design<a hidden class=anchor aria-hidden=true href=#7-high-level-design>#</a></h2><blockquote><ol start=7><li>高层设计</li></ol></blockquote><p>At a high level, we need an application layer that will serve all the read and write requests. Application layer will talk to a storage layer to store and retrieve data. We can segregate our storage layer with one database storing metadata related to each paste, users, etc., while the other storing the paste contents in some object storage (like <a href=https://en.wikipedia.org/wiki/Amazon_S3>Amazon S3</a>). This division of data will also allow us to scale them individually.</p><blockquote><p>在较高的层面上，我们需要一个应用程序层来服务所有的读写请求。应用层将与存储层通信以存储和检索数据。我们可以将存储层隔离，一个数据库存储与每个粘贴、用户等相关的元数据，而另一个数据库将粘贴内容存储在某些对象存储（如 Amazon S3）中。这种数据划分还允许我们单独缩放它们。</p></blockquote><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/pastebin-01.png alt=image-20231116090334771></p><h2 id=8-component-design>8. Component Design<a hidden class=anchor aria-hidden=true href=#8-component-design>#</a></h2><blockquote><ol start=8><li>组件设计</li></ol></blockquote><p><strong>a. Application layer</strong></p><blockquote><p><strong>a. 应用层</strong></p></blockquote><p>Our application layer will process all incoming and outgoing requests. The application servers will be talking to the backend data store components to serve the requests.</p><blockquote><p>我们的应用程序层将处理所有传入和传出的请求。应用程序服务器将与后端数据存储组件通信以服务请求。</p></blockquote><p><strong>How to handle a write request?</strong> Upon receiving a write request, our application server will generate a six-letter random string, which would serve as the key of the paste (if the user has not provided a custom key). The application server will then store the contents of the paste and the generated key in the database. After the successful insertion, the server can return the key to the user. One possible problem here could be that the insertion fails because of a duplicate key. Since we are generating a random key, there is a possibility that the newly generated key could match an existing one. In that case, we should regenerate a new key and try again. We should keep retrying until we don’t see failure due to the duplicate key. We should return an error to the user if the custom key they have provided is already present in our database.</p><blockquote><p>如何处理写请求？收到写入请求后，我们的应用程序服务器将生成一个六字母的随机字符串，该字符串将用作粘贴的密钥（如果用户未提供自定义密钥）。然后应用程序服务器会将粘贴的内容和生成的密钥存储在数据库中。插入成功后，服务器可以将密钥返回给用户。这里一个可能的问题是插入由于重复的键而失败。由于我们生成随机密钥，因此新生成的密钥有可能与现有密钥匹配。在这种情况下，我们应该重新生成一个新密钥并重试。我们应该不断重试，直到看不到由于重复密钥而导致的失败。如果用户提供的自定义密钥已存在于我们的数据库中，我们应该向用户返回错误。</p></blockquote><p>Another solution of the above problem could be to run a standalone <strong>Key Generation Service</strong> (KGS) that generates random six letters strings beforehand and stores them in a database (let’s call it key-DB). Whenever we want to store a new paste, we will just take one of the already generated keys and use it. This approach will make things quite simple and fast since we will not be worrying about duplications or collisions. KGS will make sure all the keys inserted in key-DB are unique. KGS can use two tables to store keys, one for keys that are not used yet and one for all the used keys. As soon as KGS gives some keys to an application server, it can move these to the used keys table. KGS can always keep some keys in memory so that whenever a server needs them, it can quickly provide them. As soon as KGS loads some keys in memory, it can move them to the used keys table, this way we can make sure each server gets unique keys. If KGS dies before using all the keys loaded in memory, we will be wasting those keys. We can ignore these keys given that we have a huge number of them.</p><blockquote><p>上述问题的另一个解决方案是运行一个独立的密钥生成服务（KGS），该服务预先生成随机的六个字母字符串并将它们存储在数据库中（我们称之为密钥数据库）。每当我们想要存储新的粘贴时，我们只需获取已生成的密钥之一并使用它即可。这种方法将使事情变得非常简单和快速，因为我们不会担心重复或冲突。 KGS 将确保插入 key-DB 中的所有密钥都是唯一的。 KGS 可以使用两张表来存储密钥，一张用于尚未使用的密钥，一张用于所有已使用的密钥。一旦 KGS 向应用程序服务器提供一些密钥，它就可以将这些密钥移动到已使用的密钥表中。 KGS 可以始终将一些密钥保留在内存中，以便每当服务器需要它们时，它可以快速提供它们。一旦 KGS 在内存中加载一些密钥，它就可以将它们移动到已使用的密钥表中，这样我们就可以确保每个服务器都获得唯一的密钥。如果 KGS 在使用内存中加载的所有密钥之前就死掉了，我们将浪费这些密钥。鉴于我们有大量的密钥，我们可以忽略这些密钥。</p></blockquote><p><strong>Isn’t KGS a single point of failure?</strong> Yes, it is. To solve this, we can have a standby replica of KGS and whenever the primary server dies it can take over to generate and provide keys.</p><blockquote><p>KGS 不是单点故障吗？是的。为了解决这个问题，我们可以拥有一个 KGS 的备用副本，每当主服务器挂掉时，它就可以接管生成和提供密钥。</p></blockquote><p><strong>Can each app server cache some keys from key-DB?</strong> Yes, this can surely speed things up. Although in this case, if the application server dies before consuming all the keys, we will end up losing those keys. This could be acceptable since we have 68B unique six letters keys, which are a lot more than we require.</p><blockquote><p>每个应用程序服务器可以缓存密钥数据库中的一些密钥吗？是的，这肯定可以加快速度。尽管在这种情况下，如果应用程序服务器在消耗所有密钥之前死亡，我们最终将丢失这些密钥。这是可以接受的，因为我们有 68B 个独特的六个字母键，这比我们需要的多得多。</p></blockquote><p><strong>How does it handle a paste read request?</strong> Upon receiving a read paste request, the application service layer contacts the datastore. The datastore searches for the key, and if it is found, returns the paste’s contents. Otherwise, an error code is returned.</p><blockquote><p>它如何处理粘贴读取请求？在接收到读取粘贴请求后，应用程序服务层联系数据存储。数据存储区搜索密钥，如果找到，则返回粘贴的内容。否则，返回错误代码。</p></blockquote><p><strong>b. Datastore layer b.数据存储层</strong></p><p>We can divide our datastore layer into two:</p><blockquote><p>我们可以将数据存储层分为两层：</p></blockquote><ol><li><p>Metadata database: We can use a relational database like MySQL or a Distributed Key-Value store like Dynamo or Cassandra.</p><blockquote><p>元数据数据库：我们可以使用关系数据库（例如 MySQL）或分布式键值存储（例如 Dynamo 或 Cassandra）。</p></blockquote></li><li><p>Object storage: We can store our contents in an Object Storage like Amazon’s S3. Whenever we feel like hitting our full capacity on content storage, we can easily increase it by adding more servers.</p><blockquote><p>对象存储：我们可以将内容存储在对象存储中，例如 Amazon 的 S3。每当我们想要充分利用内容存储容量时，我们都可以通过添加更多服务器来轻松增加容量。</p></blockquote></li></ol><p><img loading=lazy src=https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/pastebin-02.png alt=image-20231116090313481></p><p>Detailed component design for Pastebin</p><blockquote><p>Pastebin 的详细组件设计</p></blockquote><h2 id=9-purging-or-db-cleanup>9. Purging or DB Cleanup<a hidden class=anchor aria-hidden=true href=#9-purging-or-db-cleanup>#</a></h2><blockquote><ol start=9><li>清除或数据库清理</li></ol></blockquote><p>Please see <a href=https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904>Designing a URL Shortening service</a>.</p><blockquote><p>请参阅设计 URL 缩短服务。</p></blockquote><h2 id=10-data-partitioning-and-replication>10. Data Partitioning and Replication<a hidden class=anchor aria-hidden=true href=#10-data-partitioning-and-replication>#</a></h2><blockquote><ol start=10><li>数据分区和复制</li></ol></blockquote><p>Please see <a href=https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904>Designing a URL Shortening service</a>.</p><blockquote><p>请参阅设计 URL 缩短服务。</p></blockquote><h2 id=11-cache-and-load-balancer>11. Cache and Load Balancer<a hidden class=anchor aria-hidden=true href=#11-cache-and-load-balancer>#</a></h2><blockquote><ol start=11><li>缓存和负载均衡器</li></ol></blockquote><p>Please see <a href=https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904>Designing a URL Shortening service</a>.</p><blockquote><p>请参阅设计 URL 缩短服务。</p></blockquote><h2 id=12-security-and-permissions>12. Security and Permissions<a hidden class=anchor aria-hidden=true href=#12-security-and-permissions>#</a></h2><blockquote><ol start=12><li>安全和权限</li></ol></blockquote><p>Please see <a href=https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904>Designing a URL Shortening service</a>.</p><blockquote><p>请参阅设计 URL 缩短服务。</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/architecture/>Architecture</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/11/24/designing-instagram/><span class=title>« Prev</span><br><span>[译]《Grokking the System Design Interview》设计Instagram</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/11/17/dns/><span class=title>Next »</span><br><span>[译]《Grokking the System Design Interview》域名系统</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Pastebin on x" href="https://x.com/intent/tweet/?text=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Pastebin&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-pastebin%2f&amp;hashtags=architecture"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Pastebin on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-pastebin%2f&amp;title=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Pastebin&amp;summary=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Pastebin&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-pastebin%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Pastebin on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-pastebin%2f&title=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Pastebin"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Pastebin on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-pastebin%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Pastebin on whatsapp" href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Pastebin%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-pastebin%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Pastebin on telegram" href="https://telegram.me/share/url?text=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Pastebin&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-pastebin%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]《Grokking the System Design Interview》设计Pastebin on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%e8%af%91%5d%e3%80%8aGrokking%20the%20System%20Design%20Interview%e3%80%8b%e8%ae%be%e8%ae%a1Pastebin&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f11%2f24%2fdesigning-pastebin%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>