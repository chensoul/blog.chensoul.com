<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何设计一个分布式ID生成器保证ID按时间有序？ | ChenSoul</title>
<meta name=keywords content="architecture,distributed"><meta name=description content="很多业务有生成唯一 ID 并作为数据库主键的需求。数据库会在这个字段上建立聚集索引（参考 MySQL InnoDB），即该字段会影响各条数据再物理存储上的顺序。
ID还要尽可能短，节省内存，让数据库索引效率更高。基本上64位整数能够满足绝大多数的场景，但是如果能做到比64位更短那就更好了。需要根据具体业务进行分析，预估出ID的最大值，这个最大值通常比64位整数的上限小很多，于是我们可以用更少的bit表示这个ID。
查询的时候，往往有分页或者排序的需求，所以需要给每条数据添加一个时间字段，并在其上建立普通索引(Secondary Index)。但是普通索引的访问效率比聚集索引慢，如果能够让ID按照时间粗略有序，则可以省去这个时间字段。为什么不是按照时间精确有序呢？因为按照时间精确有序是做不到的，除非用一个单机算法，在分布式场景下做到精确有序性能一般很差。
这就引出了 ID 生成的三大核心需求：
全局唯一 按照时间粗略有序 尽可能短 下面介绍一些常用的生成 ID 的方法。
UUID UUID 是一类算法的统称，具体有不同的实现。UUID 的优点是每台机器可以独立产生 ID，理论上保证不会重复，所以天然是分布式的；缺点是生成的 ID 太长，不仅占用内存，而且索引查询效率低。
MongoDB 的 ObjectId 使用的就是 UUID 算法。生成的 ObjectId 占 12 个字节，由以下几个部分组成，
4 个字节表示的 Unix timestamp 3 个字节表示的机器的 ID 2 个字节表示的进程 ID 3 个字节表示的计数器 使用数据库 可以使用数据库中的自增主键来生成ID。将ID生成的过程交给数据库管理，每个节点向数据库插入记录时，数据库会自动分配一个唯一的ID。通过使用数据库的自动递增功能，可以保证ID的唯一性和粗略有序性。
在分布式环境下，可以使用多台数据库协同工作生成 ID。假设用 8 台MySQL服务器协同工作，第一台 MySQL 初始值是 1，每次自增 8，第二台 MySQL 初始值是 2，每次自增 8，依次类推。在数据库前面添加一个负载均衡，每来一个请求，由负载均衡随机地将请求发给 8 台 MySQL 中的任意一个，然后返回一个ID。
Flickr就是这么做的，仅仅使用了两台 MySQL 服务器。可见这个方法虽然简单无脑，但是性能足够好。不过要注意，在 MySQL 中，不需要把所有 ID 都存下来，每台机器只需要存一个 MAX_ID 就可以了。这需要用到 MySQL 的一个 REPLACE INTO 特性。
Flickr 的实现方式如下。
Tickets64 表结构如下：
CREATE TABLE `Tickets64` ( `id` bigint(20) unsigned NOT NULL auto_increment, `stub` char(1) NOT NULL default '', PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ) ENGINE=InnoDB SELECT * from Tickets64 返回一行，如下所示："><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2023/12/05/distributed-id-generator/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2023/12/05/distributed-id-generator/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="如何设计一个分布式ID生成器保证ID按时间有序？"><meta property="og:description" content="很多业务有生成唯一 ID 并作为数据库主键的需求。数据库会在这个字段上建立聚集索引（参考 MySQL InnoDB），即该字段会影响各条数据再物理存储上的顺序。
ID还要尽可能短，节省内存，让数据库索引效率更高。基本上64位整数能够满足绝大多数的场景，但是如果能做到比64位更短那就更好了。需要根据具体业务进行分析，预估出ID的最大值，这个最大值通常比64位整数的上限小很多，于是我们可以用更少的bit表示这个ID。
查询的时候，往往有分页或者排序的需求，所以需要给每条数据添加一个时间字段，并在其上建立普通索引(Secondary Index)。但是普通索引的访问效率比聚集索引慢，如果能够让ID按照时间粗略有序，则可以省去这个时间字段。为什么不是按照时间精确有序呢？因为按照时间精确有序是做不到的，除非用一个单机算法，在分布式场景下做到精确有序性能一般很差。
这就引出了 ID 生成的三大核心需求：
全局唯一 按照时间粗略有序 尽可能短 下面介绍一些常用的生成 ID 的方法。
UUID UUID 是一类算法的统称，具体有不同的实现。UUID 的优点是每台机器可以独立产生 ID，理论上保证不会重复，所以天然是分布式的；缺点是生成的 ID 太长，不仅占用内存，而且索引查询效率低。
MongoDB 的 ObjectId 使用的就是 UUID 算法。生成的 ObjectId 占 12 个字节，由以下几个部分组成，
4 个字节表示的 Unix timestamp 3 个字节表示的机器的 ID 2 个字节表示的进程 ID 3 个字节表示的计数器 使用数据库 可以使用数据库中的自增主键来生成ID。将ID生成的过程交给数据库管理，每个节点向数据库插入记录时，数据库会自动分配一个唯一的ID。通过使用数据库的自动递增功能，可以保证ID的唯一性和粗略有序性。
在分布式环境下，可以使用多台数据库协同工作生成 ID。假设用 8 台MySQL服务器协同工作，第一台 MySQL 初始值是 1，每次自增 8，第二台 MySQL 初始值是 2，每次自增 8，依次类推。在数据库前面添加一个负载均衡，每来一个请求，由负载均衡随机地将请求发给 8 台 MySQL 中的任意一个，然后返回一个ID。
Flickr就是这么做的，仅仅使用了两台 MySQL 服务器。可见这个方法虽然简单无脑，但是性能足够好。不过要注意，在 MySQL 中，不需要把所有 ID 都存下来，每台机器只需要存一个 MAX_ID 就可以了。这需要用到 MySQL 的一个 REPLACE INTO 特性。
Flickr 的实现方式如下。
Tickets64 表结构如下：
CREATE TABLE `Tickets64` ( `id` bigint(20) unsigned NOT NULL auto_increment, `stub` char(1) NOT NULL default '', PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ) ENGINE=InnoDB SELECT * from Tickets64 返回一行，如下所示："><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/12/05/distributed-id-generator/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-05T00:00:00+08:00"><meta property="article:modified_time" content="2023-12-05T00:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何设计一个分布式ID生成器保证ID按时间有序？"><meta name=twitter:description content="很多业务有生成唯一 ID 并作为数据库主键的需求。数据库会在这个字段上建立聚集索引（参考 MySQL InnoDB），即该字段会影响各条数据再物理存储上的顺序。
ID还要尽可能短，节省内存，让数据库索引效率更高。基本上64位整数能够满足绝大多数的场景，但是如果能做到比64位更短那就更好了。需要根据具体业务进行分析，预估出ID的最大值，这个最大值通常比64位整数的上限小很多，于是我们可以用更少的bit表示这个ID。
查询的时候，往往有分页或者排序的需求，所以需要给每条数据添加一个时间字段，并在其上建立普通索引(Secondary Index)。但是普通索引的访问效率比聚集索引慢，如果能够让ID按照时间粗略有序，则可以省去这个时间字段。为什么不是按照时间精确有序呢？因为按照时间精确有序是做不到的，除非用一个单机算法，在分布式场景下做到精确有序性能一般很差。
这就引出了 ID 生成的三大核心需求：
全局唯一 按照时间粗略有序 尽可能短 下面介绍一些常用的生成 ID 的方法。
UUID UUID 是一类算法的统称，具体有不同的实现。UUID 的优点是每台机器可以独立产生 ID，理论上保证不会重复，所以天然是分布式的；缺点是生成的 ID 太长，不仅占用内存，而且索引查询效率低。
MongoDB 的 ObjectId 使用的就是 UUID 算法。生成的 ObjectId 占 12 个字节，由以下几个部分组成，
4 个字节表示的 Unix timestamp 3 个字节表示的机器的 ID 2 个字节表示的进程 ID 3 个字节表示的计数器 使用数据库 可以使用数据库中的自增主键来生成ID。将ID生成的过程交给数据库管理，每个节点向数据库插入记录时，数据库会自动分配一个唯一的ID。通过使用数据库的自动递增功能，可以保证ID的唯一性和粗略有序性。
在分布式环境下，可以使用多台数据库协同工作生成 ID。假设用 8 台MySQL服务器协同工作，第一台 MySQL 初始值是 1，每次自增 8，第二台 MySQL 初始值是 2，每次自增 8，依次类推。在数据库前面添加一个负载均衡，每来一个请求，由负载均衡随机地将请求发给 8 台 MySQL 中的任意一个，然后返回一个ID。
Flickr就是这么做的，仅仅使用了两台 MySQL 服务器。可见这个方法虽然简单无脑，但是性能足够好。不过要注意，在 MySQL 中，不需要把所有 ID 都存下来，每台机器只需要存一个 MAX_ID 就可以了。这需要用到 MySQL 的一个 REPLACE INTO 特性。
Flickr 的实现方式如下。
Tickets64 表结构如下：
CREATE TABLE `Tickets64` ( `id` bigint(20) unsigned NOT NULL auto_increment, `stub` char(1) NOT NULL default '', PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ) ENGINE=InnoDB SELECT * from Tickets64 返回一行，如下所示："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"如何设计一个分布式ID生成器保证ID按时间有序？","item":"https://blog.chensoul.cc/posts/2023/12/05/distributed-id-generator/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何设计一个分布式ID生成器保证ID按时间有序？","name":"如何设计一个分布式ID生成器保证ID按时间有序？","description":"很多业务有生成唯一 ID 并作为数据库主键的需求。数据库会在这个字段上建立聚集索引（参考 MySQL InnoDB），即该字段会影响各条数据再物理存储上的顺序。\nID还要尽可能短，节省内存，让数据库索引效率更高。基本上64位整数能够满足绝大多数的场景，但是如果能做到比64位更短那就更好了。需要根据具体业务进行分析，预估出ID的最大值，这个最大值通常比64位整数的上限小很多，于是我们可以用更少的bit表示这个ID。\n查询的时候，往往有分页或者排序的需求，所以需要给每条数据添加一个时间字段，并在其上建立普通索引(Secondary Index)。但是普通索引的访问效率比聚集索引慢，如果能够让ID按照时间粗略有序，则可以省去这个时间字段。为什么不是按照时间精确有序呢？因为按照时间精确有序是做不到的，除非用一个单机算法，在分布式场景下做到精确有序性能一般很差。\n这就引出了 ID 生成的三大核心需求：\n全局唯一 按照时间粗略有序 尽可能短 下面介绍一些常用的生成 ID 的方法。\nUUID UUID 是一类算法的统称，具体有不同的实现。UUID 的优点是每台机器可以独立产生 ID，理论上保证不会重复，所以天然是分布式的；缺点是生成的 ID 太长，不仅占用内存，而且索引查询效率低。\nMongoDB 的 ObjectId 使用的就是 UUID 算法。生成的 ObjectId 占 12 个字节，由以下几个部分组成，\n4 个字节表示的 Unix timestamp 3 个字节表示的机器的 ID 2 个字节表示的进程 ID 3 个字节表示的计数器 使用数据库 可以使用数据库中的自增主键来生成ID。将ID生成的过程交给数据库管理，每个节点向数据库插入记录时，数据库会自动分配一个唯一的ID。通过使用数据库的自动递增功能，可以保证ID的唯一性和粗略有序性。\n在分布式环境下，可以使用多台数据库协同工作生成 ID。假设用 8 台MySQL服务器协同工作，第一台 MySQL 初始值是 1，每次自增 8，第二台 MySQL 初始值是 2，每次自增 8，依次类推。在数据库前面添加一个负载均衡，每来一个请求，由负载均衡随机地将请求发给 8 台 MySQL 中的任意一个，然后返回一个ID。\nFlickr就是这么做的，仅仅使用了两台 MySQL 服务器。可见这个方法虽然简单无脑，但是性能足够好。不过要注意，在 MySQL 中，不需要把所有 ID 都存下来，每台机器只需要存一个 MAX_ID 就可以了。这需要用到 MySQL 的一个 REPLACE INTO 特性。\nFlickr 的实现方式如下。\nTickets64 表结构如下：\nCREATE TABLE `Tickets64` ( `id` bigint(20) unsigned NOT NULL auto_increment, `stub` char(1) NOT NULL default \u0026#39;\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ) ENGINE=InnoDB SELECT * from Tickets64 返回一行，如下所示：","keywords":["architecture","distributed"],"articleBody":"很多业务有生成唯一 ID 并作为数据库主键的需求。数据库会在这个字段上建立聚集索引（参考 MySQL InnoDB），即该字段会影响各条数据再物理存储上的顺序。\nID还要尽可能短，节省内存，让数据库索引效率更高。基本上64位整数能够满足绝大多数的场景，但是如果能做到比64位更短那就更好了。需要根据具体业务进行分析，预估出ID的最大值，这个最大值通常比64位整数的上限小很多，于是我们可以用更少的bit表示这个ID。\n查询的时候，往往有分页或者排序的需求，所以需要给每条数据添加一个时间字段，并在其上建立普通索引(Secondary Index)。但是普通索引的访问效率比聚集索引慢，如果能够让ID按照时间粗略有序，则可以省去这个时间字段。为什么不是按照时间精确有序呢？因为按照时间精确有序是做不到的，除非用一个单机算法，在分布式场景下做到精确有序性能一般很差。\n这就引出了 ID 生成的三大核心需求：\n全局唯一 按照时间粗略有序 尽可能短 下面介绍一些常用的生成 ID 的方法。\nUUID UUID 是一类算法的统称，具体有不同的实现。UUID 的优点是每台机器可以独立产生 ID，理论上保证不会重复，所以天然是分布式的；缺点是生成的 ID 太长，不仅占用内存，而且索引查询效率低。\nMongoDB 的 ObjectId 使用的就是 UUID 算法。生成的 ObjectId 占 12 个字节，由以下几个部分组成，\n4 个字节表示的 Unix timestamp 3 个字节表示的机器的 ID 2 个字节表示的进程 ID 3 个字节表示的计数器 使用数据库 可以使用数据库中的自增主键来生成ID。将ID生成的过程交给数据库管理，每个节点向数据库插入记录时，数据库会自动分配一个唯一的ID。通过使用数据库的自动递增功能，可以保证ID的唯一性和粗略有序性。\n在分布式环境下，可以使用多台数据库协同工作生成 ID。假设用 8 台MySQL服务器协同工作，第一台 MySQL 初始值是 1，每次自增 8，第二台 MySQL 初始值是 2，每次自增 8，依次类推。在数据库前面添加一个负载均衡，每来一个请求，由负载均衡随机地将请求发给 8 台 MySQL 中的任意一个，然后返回一个ID。\nFlickr就是这么做的，仅仅使用了两台 MySQL 服务器。可见这个方法虽然简单无脑，但是性能足够好。不过要注意，在 MySQL 中，不需要把所有 ID 都存下来，每台机器只需要存一个 MAX_ID 就可以了。这需要用到 MySQL 的一个 REPLACE INTO 特性。\nFlickr 的实现方式如下。\nTickets64 表结构如下：\nCREATE TABLE `Tickets64` ( `id` bigint(20) unsigned NOT NULL auto_increment, `stub` char(1) NOT NULL default '', PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ) ENGINE=InnoDB SELECT * from Tickets64 返回一行，如下所示：\n+-------------------+------+ | id | stub | +-------------------+------+ | 72157623227190423 | a | +-------------------+------+ 当我需要一个新的全局唯一 64 位 ID 时，我发出以下 SQL：\nREPLACE INTO Tickets64 (stub) VALUES ('a'); SELECT LAST_INSERT_ID(); 对于两台数据库服务器，分别设置表的自增值（auto_increment_increment）和偏移值（auto_increment_offset）。\nTicketServer1: auto_increment_increment = 2 auto_increment_offset = 1 TicketServer2: auto_increment_increment = 2 auto_increment_offset = 2 举例：一个数据库服务器设置：自增值为 2，起始值为 1，生成的 ID 为奇数。\nSET auto_increment_increment=2; SET auto_increment_offset=1; drop table Tickets64; CREATE TABLE `Tickets64` ( `id` bigint(20) unsigned NOT NULL auto_increment, `stub` char(1) NOT NULL default '', PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ); SELECT AUTO_INCREMENT FROM information_schema.tables WHERE table_name=\"Tickets64\"; REPLACE INTO Tickets64 (stub) VALUES ('a'); SELECT LAST_INSERT_ID(); 另一个数据库服务器如何设置？：自增值为 2，起始值为 2，生成的 ID 为偶数。\nSET auto_increment_increment=2; SET auto_increment_offset=2; drop table Tickets64; CREATE TABLE `Tickets64` ( `id` bigint(20) unsigned NOT NULL auto_increment, `stub` char(1) NOT NULL default '', PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ); SELECT AUTO_INCREMENT FROM information_schema.tables WHERE table_name=\"Tickets64\"; REPLACE INTO Tickets64 (stub) VALUES ('a'); SELECT LAST_INSERT_ID(); 这个方法跟单台数据库比，缺点是 ID 不是严格递增的，只是粗略递增的。不过这个问题不大，我们的目标是粗略有序，不需要严格递增。\nSnowflake算法 Twitter 开源的 Snowflake 算法。Snowflake是一种经典的分布式ID生成算法，由Twitter开发。它将64位的ID划分为不同的部分，包括时间戳、数据中心ID、机器ID和序列号。通过在不同的部分分配不同的位数，可以在分布式环境中生成唯一的ID，并且保证了ID的时间粗略有序性。\nInstagram 用了类似的方案，41 位表示时间戳，13 位表示 shard Id（一个shard Id对应一台PostgreSQL机器），最低10位表示自增 ID。这个方案用一个 PostgreSQL 集群代替了 Twitter Snowflake 集群，优点是利用了现成的 PostgreSQL。\n使用分布式锁 可以使用分布式锁来保证在生成 ID 时的互斥性，从而保证 ID 的有序性。可以使用一些分布式锁的实现，如 ZooKeeper、Redis 等，来协调各个节点的 ID 生成过程。每个节点在生成 ID 之前，首先获取分布式锁，然后按照一定规则生成 ID，释放锁后，下一个节点再获取锁生成ID。\n下面是一个基本的使用 ZooKeeper 锁生成分布式 ID 的示例：\n创建ZooKeeper客户端连接： CuratorFramework client = CuratorFrameworkFactory.newClient(\"localhost:2181\", new ExponentialBackoffRetry(1000, 3)); client.start(); 创建分布式锁： InterProcessMutex lock = new InterProcessMutex(client, \"/id_lock\"); 获取锁并生成ID： int timeoutSeconds = 10; // 设置锁超时时间为10秒 try { if (lock.acquire(timeoutSeconds, TimeUnit.SECONDS)) { // 成功获取锁 String distributedID = generateID(); // 使用生成的ID进行业务操作 // ... } else { // 未能在超时时间内获取到锁，进行相应处理 // ... } } catch (Exception e) { // 处理异常 } finally { try { lock.release(); // 释放锁 } catch (Exception e) { // 处理异常 } } 在这个示例中，使用 Curator 框架创建了一个 ZooKeeper 客户端连接，然后创建了一个 InterProcessMutex 对象，该对象表示一个分布式锁。在获取锁之前，节点会尝试获取并持有该锁。只有一个节点可以成功获取到锁，其他节点会阻塞等待。\n获取到锁后，可以执行生成 ID 的逻辑，生成唯一的分布式 ID。\n在业务操作完成后，通过 release()方法释放锁，使其他节点可以继续获取锁并生成 ID。\n通过使用 ZooKeeper 锁，我们可以确保在分布式环境下生成的 ID 是互斥的，并且按照获取锁的顺序生成。这样可以保证生成的 ID 是有序的，并且避免了并发冲突的问题。\nRedis 本身并没有提供原生的分布式锁功能，但可以借助 Redis 的原子性操作和过期时间来实现一个简单的分布式锁，并在获取锁时生成分布式 ID。下面是一个使用 Redis 锁生成分布式 ID 的示例代码：\nimport redis.clients.jedis.Jedis; public class DistributedIdGenerator { private static final String LOCK_KEY = \"id_lock\"; private static final int LOCK_EXPIRATION = 10; // 锁的过期时间，单位为秒 private static final String REDIS_HOST = \"localhost\"; private static final int REDIS_PORT = 6379; private Jedis jedis; public DistributedIdGenerator() { jedis = new Jedis(REDIS_HOST, REDIS_PORT); } public String generateDistributedId() { // 获取分布式锁 boolean lockAcquired = acquireLock(LOCK_KEY, LOCK_EXPIRATION); if (lockAcquired) { try { // 生成ID的逻辑 String distributedId = generateId(); // 使用生成的ID进行业务操作 // ... return distributedId; } finally { // 释放分布式锁 releaseLock(LOCK_KEY); } } else { // 未能获取到分布式锁，进行相应处理 // ... return null; } } private boolean acquireLock(String lockKey, int expiration) { String result = jedis.set(lockKey, \"locked\", \"NX\", \"EX\", expiration); return \"OK\".equals(result); } private void releaseLock(String lockKey) { jedis.del(lockKey); } private String generateId() { // 生成ID的逻辑 // ... return \"your_generated_id\"; } } 在上述示例代码中，我们使用 Jedis 客户端连接 Redis，并定义了获取锁和释放锁的方法 acquireLock() 和 releaseLock()。在 generateDistributedId() 方法中，我们首先尝试获取分布式锁，如果成功获取到锁，则执行生成 ID 的逻辑和业务操作，并在最后释放锁。如果无法获取到锁，则可以根据实际需求进行相应处理。\n请注意，上述示例代码是一个简单的实现，仅供参考。在实际使用中，还需要考虑异常处理、分布式锁的可重入性、处理锁超时等情况，以及根据具体的需求和系统架构进行适当的调整。\n参考资料 Sharding \u0026 IDs at Instagram Ticket Servers: Distributed Unique Primary Keys on the Cheap Twitter Snowflake 细聊分布式ID生成方法 - 沈剑 服务化框架－分布式Unique ID的生成方法一览 - 江南白衣 生成全局唯一ID的3个思路，来自一个资深架构师的总结 分布式ID中的SnowFlake ","wordCount":"564","inLanguage":"en","datePublished":"2023-12-05T00:00:00+08:00","dateModified":"2023-12-05T00:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/12/05/distributed-id-generator/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">如何设计一个分布式ID生成器保证ID按时间有序？</h1><div class=post-meta><span title='2023-12-05 00:00:00 +0800 CST'>2023-12-05</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;564 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#uuid aria-label=UUID>UUID</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%95%b0%e6%8d%ae%e5%ba%93 aria-label=使用数据库>使用数据库</a></li><li><a href=#snowflake%e7%ae%97%e6%b3%95 aria-label=Snowflake算法>Snowflake算法</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label=使用分布式锁>使用分布式锁</a></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><p>很多业务有生成唯一 ID 并作为数据库主键的需求。数据库会在这个字段上建立聚集索引（参考 MySQL InnoDB），即该字段会影响各条数据再物理存储上的顺序。</p><p>ID还要尽可能<strong>短</strong>，节省内存，让数据库索引效率更高。基本上64位整数能够满足绝大多数的场景，但是如果能做到比64位更短那就更好了。需要根据具体业务进行分析，预估出ID的最大值，这个最大值通常比64位整数的上限小很多，于是我们可以用更少的bit表示这个ID。</p><p>查询的时候，往往有分页或者<strong>排序</strong>的需求，所以需要给每条数据添加一个时间字段，并在其上建立普通索引(Secondary Index)。但是普通索引的访问效率比聚集索引慢，如果能够让ID<strong>按照时间粗略有序</strong>，则可以省去这个时间字段。为什么不是按照时间精确有序呢？因为按照时间精确有序是做不到的，除非用一个单机算法，在分布式场景下做到精确有序性能一般很差。</p><p>这就引出了 ID 生成的三大核心需求：</p><ul><li>全局唯一</li><li>按照时间粗略有序</li><li>尽可能短</li></ul><p>下面介绍一些常用的生成 ID 的方法。</p><h2 id=uuid>UUID<a hidden class=anchor aria-hidden=true href=#uuid>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Universally_unique_identifier>UUID </a>是一类算法的统称，具体有不同的实现。UUID 的优点是每台机器可以独立产生 ID，理论上保证不会重复，所以天然是分布式的；缺点是生成的 ID 太长，不仅占用内存，而且索引查询效率低。</p><p>MongoDB 的 <a href=https://docs.mongodb.com/manual/reference/method/ObjectId/>ObjectId</a> 使用的就是 UUID 算法。生成的 ObjectId 占 12 个字节，由以下几个部分组成，</p><ul><li>4 个字节表示的 Unix timestamp</li><li>3 个字节表示的机器的 ID</li><li>2 个字节表示的进程 ID</li><li>3 个字节表示的计数器</li></ul><h2 id=使用数据库>使用数据库<a hidden class=anchor aria-hidden=true href=#使用数据库>#</a></h2><p>可以使用数据库中的自增主键来生成ID。将ID生成的过程交给数据库管理，每个节点向数据库插入记录时，数据库会自动分配一个唯一的ID。通过使用数据库的自动递增功能，可以保证ID的唯一性和粗略有序性。</p><p>在分布式环境下，可以使用多台数据库协同工作生成 ID。假设用 8 台MySQL服务器协同工作，第一台 MySQL 初始值是 1，每次自增 8，第二台 MySQL 初始值是 2，每次自增 8，依次类推。在数据库前面添加一个负载均衡，每来一个请求，由负载均衡随机地将请求发给 8 台 MySQL 中的任意一个，然后返回一个ID。</p><p><a href=http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/>Flickr就是这么做的</a>，仅仅使用了两台 MySQL 服务器。可见这个方法虽然简单无脑，但是性能足够好。不过要注意，在 MySQL 中，不需要把所有 ID 都存下来，每台机器只需要存一个 MAX_ID 就可以了。这需要用到 MySQL 的一个 <a href=http://dev.mysql.com/doc/refman/5.0/en/replace.html>REPLACE INTO</a> 特性。</p><p>Flickr 的实现方式如下。</p><p>Tickets64 表结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>Tickets64</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=nb>bigint</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=n>unsigned</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>auto_increment</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>stub</span><span class=o>`</span><span class=w> </span><span class=nb>char</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>default</span><span class=w> </span><span class=s1>&#39;&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w>  </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>stub</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>stub</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w>
</span></span></span></code></pre></div><p><code>SELECT * from Tickets64</code> 返回一行，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>+</span><span class=c1>-------------------+------+
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>|</span><span class=w> </span><span class=n>id</span><span class=w>                </span><span class=o>|</span><span class=w> </span><span class=n>stub</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>+</span><span class=c1>-------------------+------+
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>|</span><span class=w> </span><span class=mi>72157623227190423</span><span class=w> </span><span class=o>|</span><span class=w>    </span><span class=n>a</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>+</span><span class=c1>-------------------+------+
</span></span></span></code></pre></div><p>当我需要一个新的全局唯一 64 位 ID 时，我发出以下 SQL：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>REPLACE</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>Tickets64</span><span class=w> </span><span class=p>(</span><span class=n>stub</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>LAST_INSERT_ID</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>对于两台数据库服务器，分别设置表的自增值（<code>auto_increment_increment</code>）和偏移值（<code>auto_increment_offset</code>）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>TicketServer1</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>auto_increment_increment</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>auto_increment_offset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>TicketServer2</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>auto_increment_increment</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>auto_increment_offset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w>
</span></span></span></code></pre></div><p>举例：一个数据库服务器设置：自增值为 2，起始值为 1，生成的 ID 为奇数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=n>auto_increment_increment</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SET</span><span class=w> </span><span class=n>auto_increment_offset</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>drop</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>Tickets64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>Tickets64</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=nb>bigint</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=n>unsigned</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>auto_increment</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>stub</span><span class=o>`</span><span class=w> </span><span class=nb>char</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>default</span><span class=w> </span><span class=s1>&#39;&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w>  </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>stub</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>stub</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>tables</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>table_name</span><span class=o>=</span><span class=s2>&#34;Tickets64&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>REPLACE</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>Tickets64</span><span class=w> </span><span class=p>(</span><span class=n>stub</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>LAST_INSERT_ID</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>另一个数据库服务器如何设置？：自增值为 2，起始值为 2，生成的 ID 为偶数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=n>auto_increment_increment</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SET</span><span class=w> </span><span class=n>auto_increment_offset</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>drop</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>Tickets64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>Tickets64</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=nb>bigint</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=n>unsigned</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>auto_increment</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>stub</span><span class=o>`</span><span class=w> </span><span class=nb>char</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>default</span><span class=w> </span><span class=s1>&#39;&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w>  </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>stub</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>stub</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>tables</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>table_name</span><span class=o>=</span><span class=s2>&#34;Tickets64&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>REPLACE</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>Tickets64</span><span class=w> </span><span class=p>(</span><span class=n>stub</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>LAST_INSERT_ID</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>这个方法跟单台数据库比，缺点是 <strong>ID 不是严格递增的</strong>，只是粗略递增的。不过这个问题不大，我们的目标是粗略有序，不需要严格递增。</p><h2 id=snowflake算法>Snowflake算法<a hidden class=anchor aria-hidden=true href=#snowflake算法>#</a></h2><p>Twitter 开源的 <a href=https://github.com/twitter/snowflake>Snowflake</a> 算法。Snowflake是一种经典的分布式ID生成算法，由Twitter开发。它将64位的ID划分为不同的部分，包括时间戳、数据中心ID、机器ID和序列号。通过在不同的部分分配不同的位数，可以在分布式环境中生成唯一的ID，并且保证了ID的时间粗略有序性。</p><p>Instagram <a href=https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c>用了类似的方案</a>，41 位表示时间戳，13 位表示 shard Id（一个shard Id对应一台PostgreSQL机器），最低10位表示自增 ID。这个方案用一个 PostgreSQL 集群代替了 Twitter Snowflake 集群，优点是利用了现成的 PostgreSQL。</p><h2 id=使用分布式锁>使用分布式锁<a hidden class=anchor aria-hidden=true href=#使用分布式锁>#</a></h2><p>可以使用分布式锁来保证在生成 ID 时的互斥性，从而保证 ID 的有序性。可以使用一些分布式锁的实现，如 ZooKeeper、Redis 等，来协调各个节点的 ID 生成过程。每个节点在生成 ID 之前，首先获取分布式锁，然后按照一定规则生成 ID，释放锁后，下一个节点再获取锁生成ID。</p><p>下面是一个基本的使用 ZooKeeper 锁生成分布式 ID 的示例：</p><ol><li>创建ZooKeeper客户端连接：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>CuratorFramework</span><span class=w> </span><span class=n>client</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>CuratorFrameworkFactory</span><span class=p>.</span><span class=na>newClient</span><span class=p>(</span><span class=s>&#34;localhost:2181&#34;</span><span class=p>,</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ExponentialBackoffRetry</span><span class=p>(</span><span class=n>1000</span><span class=p>,</span><span class=w> </span><span class=n>3</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>client</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li>创建分布式锁：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>InterProcessMutex</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>InterProcessMutex</span><span class=p>(</span><span class=n>client</span><span class=p>,</span><span class=w> </span><span class=s>&#34;/id_lock&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol start=3><li>获取锁并生成ID：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span><span class=w> </span><span class=n>timeoutSeconds</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10</span><span class=p>;</span><span class=w> </span><span class=c1>// 设置锁超时时间为10秒</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>lock</span><span class=p>.</span><span class=na>acquire</span><span class=p>(</span><span class=n>timeoutSeconds</span><span class=p>,</span><span class=w> </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 成功获取锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>distributedID</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>generateID</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 使用生成的ID进行业务操作</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 未能在超时时间内获取到锁，进行相应处理</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 处理异常</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>release</span><span class=p>();</span><span class=w> </span><span class=c1>// 释放锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 处理异常</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在这个示例中，使用 Curator 框架创建了一个 ZooKeeper 客户端连接，然后创建了一个 InterProcessMutex 对象，该对象表示一个分布式锁。在获取锁之前，节点会尝试获取并持有该锁。只有一个节点可以成功获取到锁，其他节点会阻塞等待。</p><p>获取到锁后，可以执行生成 ID 的逻辑，生成唯一的分布式 ID。</p><p>在业务操作完成后，通过 <code>release()</code>方法释放锁，使其他节点可以继续获取锁并生成 ID。</p><p>通过使用 ZooKeeper 锁，我们可以确保在分布式环境下生成的 ID 是互斥的，并且按照获取锁的顺序生成。这样可以保证生成的 ID 是有序的，并且避免了并发冲突的问题。</p><p>Redis 本身并没有提供原生的分布式锁功能，但可以借助 Redis 的原子性操作和过期时间来实现一个简单的分布式锁，并在获取锁时生成分布式 ID。下面是一个使用 Redis 锁生成分布式 ID 的示例代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>redis.clients.jedis.Jedis</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DistributedIdGenerator</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>LOCK_KEY</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;id_lock&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>LOCK_EXPIRATION</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10</span><span class=p>;</span><span class=w> </span><span class=c1>// 锁的过期时间，单位为秒</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>REDIS_HOST</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;localhost&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>REDIS_PORT</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>6379</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Jedis</span><span class=w> </span><span class=n>jedis</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>DistributedIdGenerator</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>jedis</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Jedis</span><span class=p>(</span><span class=n>REDIS_HOST</span><span class=p>,</span><span class=w> </span><span class=n>REDIS_PORT</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>generateDistributedId</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取分布式锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>boolean</span><span class=w> </span><span class=n>lockAcquired</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>acquireLock</span><span class=p>(</span><span class=n>LOCK_KEY</span><span class=p>,</span><span class=w> </span><span class=n>LOCK_EXPIRATION</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>lockAcquired</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 生成ID的逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>String</span><span class=w> </span><span class=n>distributedId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>generateId</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 使用生成的ID进行业务操作</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=n>distributedId</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 释放分布式锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>releaseLock</span><span class=p>(</span><span class=n>LOCK_KEY</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 未能获取到分布式锁，进行相应处理</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>acquireLock</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>lockKey</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>expiration</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>jedis</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>lockKey</span><span class=p>,</span><span class=w> </span><span class=s>&#34;locked&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;NX&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;EX&#34;</span><span class=p>,</span><span class=w> </span><span class=n>expiration</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=s>&#34;OK&#34;</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>result</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>releaseLock</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>lockKey</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>jedis</span><span class=p>.</span><span class=na>del</span><span class=p>(</span><span class=n>lockKey</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>generateId</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 生成ID的逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=s>&#34;your_generated_id&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上述示例代码中，我们使用 Jedis 客户端连接 Redis，并定义了获取锁和释放锁的方法 <code>acquireLock()</code> 和 <code>releaseLock()</code>。在 <code>generateDistributedId() </code>方法中，我们首先尝试获取分布式锁，如果成功获取到锁，则执行生成 ID 的逻辑和业务操作，并在最后释放锁。如果无法获取到锁，则可以根据实际需求进行相应处理。</p><p>请注意，上述示例代码是一个简单的实现，仅供参考。在实际使用中，还需要考虑异常处理、分布式锁的可重入性、处理锁超时等情况，以及根据具体的需求和系统架构进行适当的调整。</p><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c>Sharding & IDs at Instagram</a></li><li><a href=http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/>Ticket Servers: Distributed Unique Primary Keys on the Cheap</a></li><li><a href=https://github.com/twitter/snowflake>Twitter Snowflake</a></li><li><a href=http://chuansong.me/n/2459549>细聊分布式ID生成方法 - 沈剑</a></li><li><a href=http://calvin1978.blogcn.com/articles/uuid.html>服务化框架－分布式Unique ID的生成方法一览 - 江南白衣</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659598286&amp;idx=1&amp;sn=3172172ccea316b0ed83429ae718b54d&amp;chksm=8be9eadcbc9e63caa10d708274b4fa34ceffa416ef4527e10e6b7a1a2d2f32cf8592d65bf728">生成全局唯一ID的3个思路，来自一个资深架构师的总结</a></li><li><a href=https://huanxin-chen.github.io/en/page-4/>分布式ID中的SnowFlake</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/architecture/>Architecture</a></li><li><a href=https://blog.chensoul.cc/tags/distributed/>Distributed</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2023/12/12/til/><span class=title>« Prev</span><br><span>2023-12-12｜RMI、Java漏洞安全、Semgrep漏洞检测</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2023/11/24/designing-dropbox/><span class=title>Next »</span><br><span>[译]《Grokking the System Design Interview》设计Dropbox</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何设计一个分布式ID生成器保证ID按时间有序？ on x" href="https://x.com/intent/tweet/?text=%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e5%88%86%e5%b8%83%e5%bc%8fID%e7%94%9f%e6%88%90%e5%99%a8%e4%bf%9d%e8%af%81ID%e6%8c%89%e6%97%b6%e9%97%b4%e6%9c%89%e5%ba%8f%ef%bc%9f&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f12%2f05%2fdistributed-id-generator%2f&amp;hashtags=architecture%2cdistributed"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何设计一个分布式ID生成器保证ID按时间有序？ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f12%2f05%2fdistributed-id-generator%2f&amp;title=%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e5%88%86%e5%b8%83%e5%bc%8fID%e7%94%9f%e6%88%90%e5%99%a8%e4%bf%9d%e8%af%81ID%e6%8c%89%e6%97%b6%e9%97%b4%e6%9c%89%e5%ba%8f%ef%bc%9f&amp;summary=%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e5%88%86%e5%b8%83%e5%bc%8fID%e7%94%9f%e6%88%90%e5%99%a8%e4%bf%9d%e8%af%81ID%e6%8c%89%e6%97%b6%e9%97%b4%e6%9c%89%e5%ba%8f%ef%bc%9f&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f12%2f05%2fdistributed-id-generator%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何设计一个分布式ID生成器保证ID按时间有序？ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f12%2f05%2fdistributed-id-generator%2f&title=%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e5%88%86%e5%b8%83%e5%bc%8fID%e7%94%9f%e6%88%90%e5%99%a8%e4%bf%9d%e8%af%81ID%e6%8c%89%e6%97%b6%e9%97%b4%e6%9c%89%e5%ba%8f%ef%bc%9f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何设计一个分布式ID生成器保证ID按时间有序？ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f12%2f05%2fdistributed-id-generator%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何设计一个分布式ID生成器保证ID按时间有序？ on whatsapp" href="https://api.whatsapp.com/send?text=%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e5%88%86%e5%b8%83%e5%bc%8fID%e7%94%9f%e6%88%90%e5%99%a8%e4%bf%9d%e8%af%81ID%e6%8c%89%e6%97%b6%e9%97%b4%e6%9c%89%e5%ba%8f%ef%bc%9f%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f12%2f05%2fdistributed-id-generator%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何设计一个分布式ID生成器保证ID按时间有序？ on telegram" href="https://telegram.me/share/url?text=%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e5%88%86%e5%b8%83%e5%bc%8fID%e7%94%9f%e6%88%90%e5%99%a8%e4%bf%9d%e8%af%81ID%e6%8c%89%e6%97%b6%e9%97%b4%e6%9c%89%e5%ba%8f%ef%bc%9f&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f12%2f05%2fdistributed-id-generator%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何设计一个分布式ID生成器保证ID按时间有序？ on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e5%88%86%e5%b8%83%e5%bc%8fID%e7%94%9f%e6%88%90%e5%99%a8%e4%bf%9d%e8%af%81ID%e6%8c%89%e6%97%b6%e9%97%b4%e6%9c%89%e5%ba%8f%ef%bc%9f&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f12%2f05%2fdistributed-id-generator%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>