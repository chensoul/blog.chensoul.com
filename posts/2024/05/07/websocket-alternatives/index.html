<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]2024年最好的WebSocket替代品 | ChenSoul</title>
<meta name=keywords content="websocket,java"><meta name=description content="原文链接：https://ably.com/topic/websocket-alternatives
什么是 WebSocket？ 简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。
了解更多：
什么是 WebSocket？ WebSocket 是如何工作的？ 什么时候应该考虑使用 WebSocket 替代方案？ 对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括聊天应用程序、多人协作体验以及广播实时路况更新。
了解有关 WebSocket 用例的更多信息
然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。
我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。
了解 WebSocket 的优点和缺点
WebSocket 协议的五种替代方案 现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。
服务器发送的事件 服务器发送事件 (SSE)是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。
服务器发送事件的优点
内置对重新连接的支持。 所有现代浏览器都支持。 轻量级协议。 服务器发送事件的缺点
它是单向的；只有服务器可以将数据推送到客户端。 每个浏览器在同一时间只能有六个并发 SSE 连接。 仅支持UTF-8文本数据； SSE 无法处理二进制数据。 对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。
查看 SSE 与 WebSocket 的比较
长轮询 长轮询是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。
长轮询的优点
长轮询是在XMLHttpRequest的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。 在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。 长轮询的缺点
与 WebSocket 相比，长轮询在服务器上消耗更多资源。 长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。 可靠的消息排序可能是一个问题。 长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。
查看轮询与 WebSocket 相比需要多长时间"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/><meta name=twitter:title content="[译]2024年最好的WebSocket替代品 | ChenSoul"><meta name=twitter:description content="原文链接：https://ably.com/topic/websocket-alternatives
什么是 WebSocket？ 简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。
了解更多：
什么是 WebSocket？ WebSocket 是如何工作的？ 什么时候应该考虑使用 WebSocket 替代方案？ 对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括聊天应用程序、多人协作体验以及广播实时路况更新。
了解有关 WebSocket 用例的更多信息
然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。
我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。
了解 WebSocket 的优点和缺点
WebSocket 协议的五种替代方案 现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。
服务器发送的事件 服务器发送事件 (SSE)是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。
服务器发送事件的优点
内置对重新连接的支持。 所有现代浏览器都支持。 轻量级协议。 服务器发送事件的缺点
它是单向的；只有服务器可以将数据推送到客户端。 每个浏览器在同一时间只能有六个并发 SSE 连接。 仅支持UTF-8文本数据； SSE 无法处理二进制数据。 对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。
查看 SSE 与 WebSocket 的比较
长轮询 长轮询是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。
长轮询的优点
长轮询是在XMLHttpRequest的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。 在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。 长轮询的缺点
与 WebSocket 相比，长轮询在服务器上消耗更多资源。 长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。 可靠的消息排序可能是一个问题。 长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。
查看轮询与 WebSocket 相比需要多长时间"><meta property="og:title" content="[译]2024年最好的WebSocket替代品 | ChenSoul"><meta property="og:description" content="原文链接：https://ably.com/topic/websocket-alternatives
什么是 WebSocket？ 简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。
了解更多：
什么是 WebSocket？ WebSocket 是如何工作的？ 什么时候应该考虑使用 WebSocket 替代方案？ 对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括聊天应用程序、多人协作体验以及广播实时路况更新。
了解有关 WebSocket 用例的更多信息
然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。
我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。
了解 WebSocket 的优点和缺点
WebSocket 协议的五种替代方案 现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。
服务器发送的事件 服务器发送事件 (SSE)是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。
服务器发送事件的优点
内置对重新连接的支持。 所有现代浏览器都支持。 轻量级协议。 服务器发送事件的缺点
它是单向的；只有服务器可以将数据推送到客户端。 每个浏览器在同一时间只能有六个并发 SSE 连接。 仅支持UTF-8文本数据； SSE 无法处理二进制数据。 对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。
查看 SSE 与 WebSocket 的比较
长轮询 长轮询是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。
长轮询的优点
长轮询是在XMLHttpRequest的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。 在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。 长轮询的缺点
与 WebSocket 相比，长轮询在服务器上消耗更多资源。 长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。 可靠的消息排序可能是一个问题。 长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。
查看轮询与 WebSocket 相比需要多长时间"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-07T11:00:00+08:00"><meta property="article:modified_time" content="2024-05-07T11:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]2024年最好的WebSocket替代品","item":"https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]2024年最好的WebSocket替代品 | ChenSoul","name":"[译]2024年最好的WebSocket替代品","description":"原文链接：https://ably.com/topic/websocket-alternatives\n什么是 WebSocket？ 简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。\n了解更多：\n什么是 WebSocket？ WebSocket 是如何工作的？ 什么时候应该考虑使用 WebSocket 替代方案？ 对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括聊天应用程序、多人协作体验以及广播实时路况更新。\n了解有关 WebSocket 用例的更多信息\n然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。\n我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。\n了解 WebSocket 的优点和缺点\nWebSocket 协议的五种替代方案 现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。\n服务器发送的事件 服务器发送事件 (SSE)是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。\n服务器发送事件的优点\n内置对重新连接的支持。 所有现代浏览器都支持。 轻量级协议。 服务器发送事件的缺点\n它是单向的；只有服务器可以将数据推送到客户端。 每个浏览器在同一时间只能有六个并发 SSE 连接。 仅支持UTF-8文本数据； SSE 无法处理二进制数据。 对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。\n查看 SSE 与 WebSocket 的比较\n长轮询 长轮询是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。\n长轮询的优点\n长轮询是在XMLHttpRequest的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。 在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。 长轮询的缺点\n与 WebSocket 相比，长轮询在服务器上消耗更多资源。 长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。 可靠的消息排序可能是一个问题。 长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。\n查看轮询与 WebSocket 相比需要多长时间","keywords":["websocket","java"],"wordCount":"436","inLanguage":"en","datePublished":"2024-05-07T11:00:00+08:00","dateModified":"2024-05-07T11:00:00+08:00","author":[{"@type":"Person","name":"chensoul"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>[译]2024年最好的WebSocket替代品</h1><div class=post-meta><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-07</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/websocket/>Websocket</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>3 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-websocket aria-label="什么是 WebSocket？">什么是 WebSocket？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e5%ba%94%e8%af%a5%e8%80%83%e8%99%91%e4%bd%bf%e7%94%a8-websocket-%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88 aria-label="什么时候应该考虑使用 WebSocket 替代方案？">什么时候应该考虑使用 WebSocket 替代方案？</a></li><li><a href=#websocket-%e5%8d%8f%e8%ae%ae%e7%9a%84%e4%ba%94%e7%a7%8d%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88 aria-label="WebSocket 协议的五种替代方案">WebSocket 协议的五种替代方案</a><ul><li><a href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8f%91%e9%80%81%e7%9a%84%e4%ba%8b%e4%bb%b6 aria-label=服务器发送的事件>服务器发送的事件</a></li><li><a href=#%e9%95%bf%e8%bd%ae%e8%af%a2 aria-label=长轮询>长轮询</a></li><li><a href=#mqtt aria-label=MQTT>MQTT</a></li><li><a href=#%e7%bd%91%e7%bb%9crtc aria-label=网络RTC>网络RTC</a></li><li><a href=#%e7%bd%91%e7%bb%9c%e4%bc%a0%e8%be%93 aria-label=网络传输>网络传输</a></li></ul></li><li><a href=#websocket-%e5%8f%8a%e5%85%b6%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88%e5%a4%b4%e5%af%b9%e5%a4%b4%e6%af%94%e8%be%83 aria-label="WebSocket 及其替代方案：头对头比较">WebSocket 及其替代方案：头对头比较</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%a4%9a%e7%a7%8d%e5%8d%8f%e8%ae%ae%e6%8f%90%e4%be%9b%e5%ae%9e%e6%97%b6%e4%bd%93%e9%aa%8c aria-label=使用多种协议提供实时体验>使用多种协议提供实时体验</a></li><li><a href=#ably%e5%9c%a8%e4%bb%bb%e4%bd%95%e8%a7%84%e6%a8%a1%e4%b8%8b%e9%83%bd%e8%83%bd%e5%8f%af%e9%9d%a0%e8%bf%90%e8%a1%8c%e7%9a%84%e5%a4%9a%e5%8d%8f%e8%ae%ae%e5%ae%9e%e6%97%b6%e5%b9%b3%e5%8f%b0 aria-label=Ably，在任何规模下都能可靠运行的多协议实时平台>Ably，在任何规模下都能可靠运行的多协议实时平台</a></li></ul></div></details></div><div class=post-content><p>原文链接：<a href=https://ably.com/topic/websocket-alternatives>https://ably.com/topic/websocket-alternatives</a></p><h2 id=什么是-websocket>什么是 WebSocket？</h2><p>简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。</p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/0mExYcxsnzccWxnktAKjc/33a49e1e736a2f906216d630b84fb641/websockets.png?w=1840&amp;h=745&amp;q=50&amp;fm=png" alt=img></p><p>了解更多：</p><ul><li><a href=https://ably.com/topic/websockets>什么是 WebSocket？</a></li><li><a href=https://ably.com/topic/how-do-websockets-work>WebSocket 是如何工作的？</a></li></ul><h2 id=什么时候应该考虑使用-websocket-替代方案>什么时候应该考虑使用 WebSocket 替代方案？</h2><p>对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括<a href=https://ably.com/solutions/chat>聊天应用程序</a>、<a href=https://ably.com/solutions/multiplayer-collaboration>多人协作体验</a>以及<a href=https://ably.com/solutions/data-broadcast>广播实时路况更新</a>。</p><p><a href=https://ably.com/topic/what-are-websockets-used-for>了解有关 WebSocket 用例的更多信息</a></p><p>然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。</p><p>我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。</p><p><a href=https://ably.com/topic/websockets-pros-cons>了解 WebSocket 的优点和缺点</a></p><h2 id=websocket-协议的五种替代方案>WebSocket 协议的五种替代方案</h2><p>现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。</p><h3 id=服务器发送的事件>服务器发送的事件</h3><p><a href=https://ably.com/topic/server-sent-events>服务器发送事件 (SSE)</a>是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。</p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/5EGr0dYKI0QvIrKJT5yurZ/69d73a97e3eaf967a4021f5b32c04dc8/server_sent_events_how_it_works.png?w=1840&amp;h=872&amp;q=50&amp;fm=png" alt=img></p><p><strong>服务器发送事件的优点</strong></p><ul><li>内置对重新连接的支持。</li><li>所有现代浏览器都支持。</li><li>轻量级协议。</li></ul><p><strong>服务器发送事件的缺点</strong></p><ul><li>它是单向的；只有服务器可以将数据推送到客户端。</li><li>每个浏览器在同一时间只能有六个并发 SSE 连接。</li><li>仅支持UTF-8文本数据； SSE 无法处理二进制数据。</li></ul><p>对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。</p><p><a href=https://ably.com/blog/websockets-vs-sse>查看 SSE 与 WebSocket 的比较</a></p><h3 id=长轮询>长轮询</h3><p><a href=https://ably.com/topic/long-polling>长轮询</a>是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。</p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/1UuClqOdPD71XXPcFC8th1/57c06019e34acea200cf90ba941a7559/http-long-polling.png?w=1841&amp;h=742&amp;q=50&amp;fm=png" alt=img></p><p><strong>长轮询的优点</strong></p><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest>长轮询是在XMLHttpRequest</a>的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。</li><li>在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。</li></ul><p><strong>长轮询的缺点</strong></p><ul><li>与 WebSocket 相比，长轮询在服务器上消耗更多资源。</li><li>长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。</li><li>可靠的消息排序可能是一个问题。</li></ul><p>长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。</p><p><a href=https://ably.com/blog/websockets-vs-long-polling>查看轮询与 WebSocket 相比需要多长时间</a></p><h3 id=mqtt>MQTT</h3><p><a href=https://ably.com/topic/mqtt>MQTT</a>（消息队列遥测传输）是一种<a href=https://ably.com/topic/pub-sub>发布-订阅</a>消息传递协议，其历史可以追溯到 1999 年，当时 IBM 的 Andy Stanley-Clark 和 Cirrus Link 的 Arlen Nipper<a href=http://mqtt.org/2009/07/10th-birthday-party>发布了第一个迭代</a>。</p><p>在 MQTT 架构中，我们有：</p><ul><li>发布者（生产者）和订阅者（消费者）。请注意，发布者也可以是订阅者。</li><li>充当中间件 MQTT 服务器的代理，管理发布者和订阅者之间的消息交换。</li></ul><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/1TOFDCbQuE2eLsiVrATR3c/c8c3aad55c1b8d9717b600327cd990a1/mqtt-overview_2x.png?w=1840&amp;h=998&amp;q=50&amp;fm=png" alt=img></p><p><strong>MQTT 优势</strong></p><ul><li>轻量级协议非常适合带宽有限或连接不可预测的网络以及 CPU、内存和电池寿命有限的设备。</li><li>可靠协议，具有三种不同级别的数据传递保证：0（最多传递一次）、1（至少传递一次）和2（恰好传递一次）。</li><li>双向且灵活 - 它提供一对一、一对多和多对多通信。</li></ul><p><strong>MQTT 缺点</strong></p><ul><li>对于发送照片、视频或音频数据来说不是一个好的选择。</li><li>您无法将 MQTT 消息发送到浏览器，因为 Web 浏览器没有内置 MQTT 支持。</li><li>基本 MQTT 协议不使用加密通信。某些 MQTT 代理允许您使用 MQTT over TLS 来增强安全性，但这会导致 CPU 使用率增加，这对于受限设备来说可能是一个问题。</li></ul><p>由于设计轻量，对于许多物联网用例（例如从温度或压力传感器实时收集数据）来说，MQTT 是比 WebSocket 更好的选择。但是，如前所述，MQTT 无法直接向浏览器发送消息。这就是为什么 WebSocket 通常被用作将 MQTT 数据流式传输到浏览器客户端的传输方式（基于 WebSocket 的 MQTT）。</p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/497sFZqUwJ6gV8MGZdpgQT/540c531e38a511dbab8aea16d985aee2/mqtt-over-websocket-overview.png?w=1840&amp;h=740&amp;q=50&amp;fm=png" alt=img></p><p><a href=https://ably.com/topic/mqtt-vs-websocket>查看 MQTT 与 WebSocket 的比较</a></p><h3 id=网络rtc>网络RTC</h3><p><a href=https://ably.com/blog/what-is-webrtc>Web 实时通信 (WebRTC)</a>是一个框架，可让您向 Web 和移动应用程序添加实时通信 (RTC) 功能。 WebRTC 允许<em>以点对点方式传输任意数据（视频、语音和通用数据）。</em></p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/Mcj9xuaipsdgSbreNRkKw/4d4b5b213e0fb1e1edfdfe1c958dd965/webrtc-logo-vert-retro-255x305.png?w=255&amp;h=305&amp;q=50&amp;fm=png" alt=img></p><p><strong>WebRTC优势</strong></p><ul><li><a href=https://datatracker.ietf.org/doc/html/rfc3711>强大的安全保证，通过 WebRTC 传输的数据在安全实时传输协议 (SRTP)</a>的帮助下进行加密和验证。</li><li>开源且免费使用。</li><li>平台和设备无关； WebRTC 应用程序可以在任何支持 WebRTC 的浏览器上运行，无论操作系统或设备类型如何。</li></ul><p><strong>WebRTC 的缺点</strong></p><ul><li>尽管 WebRTC 是一种点对点技术，您仍然需要管理 Web 服务器并为其付费。为了使两个对等点能够相互“交谈”，您需要使用信令服务器来建立、管理和终止 WebRTC 通信会话。</li><li>在处理视频内容和大量用户时，WebRTC 可能会占用大量 CPU 资源。</li><li>WebRTC 入门很难。有很多概念需要探索和掌握：各种接口、编解码器、网络地址转换 (NAT) 和防火墙、UDP（WebRTC 使用的主要底层通信协议）等等。</li></ul><p>WebRTC 主要设计用于流式传输音频和视频内容（通过 UDP），在这种情况下通常是比 WebSocket 更好的选择。另一方面，当数据完整性（保证排序和交付）至关重要时，WebSocket 是更好的选择，因为您可以从 TCP 的底层可靠性中受益。</p><p>通常，WebRTC 和 WebSocket 是互补技术。 WebRTC 对等点通过称为信令的过程来协调通信。需要注意的是，WebRTC 不提供标准的信令实现，允许开发人员为此目的使用不同的协议。<em>WebSocket 协议通常用作 WebRTC 应用程序的信令机制</em>。</p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/9qHMoUzBFSIwLplan0yqa/e811a5fc90ce365f3aec0b49f7d53753/signaling-overview-webrtc-websockets_2x.png?w=1840&amp;h=666&amp;q=50&amp;fm=png" alt=img></p><p><a href=https://ably.com/topic/webrtc-vs-websocket>了解 WebRTC 与 WebSocket 的比较</a></p><h3 id=网络传输>网络传输</h3><p><a href=https://ably.com/blog/can-webtransport-replace-websockets>WebTransport</a>是一项新兴的实时技术，通过<a href=https://ably.com/topic/http3>HTTP/3</a>提供客户端-服务器消息传递。 WebTransport 有两个关键概念：</p><ul><li><strong>数据报</strong>。数据报是一个独立的数据包，可以按任何特定顺序到达。专为需要低延迟且尽力而为的数据传输就足够好的用例而设计。</li><li><strong>溪流</strong>。 Streams API 提供可靠、有序的数据传输。请注意，您可以创建单向和双向流。</li></ul><p><strong>网络传输优势</strong></p><ul><li>通过使用 Datagrams API 或通过多个 Streams API 实例，您不必担心队头阻塞。</li><li>建立新连接非常快——这是因为 HTTP/3 在底层使用了 QUIC；众所周知，QUIC 握手比通过 TLS 启动 TCP 更快。</li></ul><p><strong>Web传输的缺点</strong></p><ul><li>WebTransport 仍然是一项新兴技术。截至 2022 年 11 月，<a href=https://w3c.github.io/webtransport/>WebTransport 是 W3C 的草案规范</a>，与其工作方式相关的方面始终有可能发生变化。</li><li><a href=https://caniuse.com/webtransport>并非所有浏览器都支持 WebTransport</a>。例如，您无法在 Firefox 和 Safari 中使用 WebTransport。</li></ul><p>与我们在本文中介绍的其他 WebSocket 替代方案（这些都是已经存在一段时间的成熟技术）不同，WebTransport 更像是 WebSocket 的未来潜在替代方案。我们不知道它在未来几年将如何发展，开发人员采用它的可能性有多大，或者它在生产就绪系统中使用时可能存在哪些陷阱。相比之下，WebSocket 已经存在十多年了；它是一种强大、稳定的技术，拥有庞大而活跃的社区，目前使其成为 WebTransport 的卓越替代品。</p><p><a href=https://ably.com/blog/can-webtransport-replace-websockets>了解有关 WebTransport 的更多信息</a></p><h2 id=websocket-及其替代方案头对头比较>WebSocket 及其替代方案：头对头比较</h2><p>下表显示了 WebSocket 与我们在本文中介绍的替代实时技术之间的主要区别和相似之处。</p><table><thead><tr><th style=text-align:left><strong>标准</strong></th><th style=text-align:left><strong>WebSockets</strong></th><th style=text-align:left><strong>长轮询</strong></th><th style=text-align:left><strong>上证所</strong></th><th style=text-align:left><strong>MQTT</strong></th><th style=text-align:left><strong>网络RTC</strong></th><th style=text-align:left><strong>网络传输</strong></th></tr></thead><tbody><tr><td style=text-align:left>底层协议</td><td style=text-align:left>传输控制协议</td><td style=text-align:left>传输控制协议</td><td style=text-align:left>传输控制协议</td><td style=text-align:left>传输控制协议</td><td style=text-align:left>UDP、TCP</td><td style=text-align:left>WHO</td></tr><tr><td style=text-align:left>双向？</td><td style=text-align:left>是的</td><td style=text-align:left>不</td><td style=text-align:left>不</td><td style=text-align:left>是的</td><td style=text-align:left>是的</td><td style=text-align:left>是的</td></tr><tr><td style=text-align:left>潜伏</td><td style=text-align:left>低的</td><td style=text-align:left>高的</td><td style=text-align:left>低的</td><td style=text-align:left>低的</td><td style=text-align:left>低的</td><td style=text-align:left>低的</td></tr><tr><td style=text-align:left>带宽</td><td style=text-align:left>低的</td><td style=text-align:left>高的</td><td style=text-align:left>低的</td><td style=text-align:left>低的</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td></tr><tr><td style=text-align:left>浏览器支持</td><td style=text-align:left>广泛支持</td><td style=text-align:left>广泛支持</td><td style=text-align:left>广泛支持</td><td style=text-align:left>浏览器没有内置的 MQTT 支持</td><td style=text-align:left>Internet Explorer 和 Opera Mini 不支持</td><td style=text-align:left>支持有限</td></tr><tr><td style=text-align:left>使用方便</td><td style=text-align:left>缓和</td><td style=text-align:left>简单的</td><td style=text-align:left>简单的</td><td style=text-align:left>缓和</td><td style=text-align:left>难的</td><td style=text-align:left>简单的</td></tr><tr><td style=text-align:left>到期</td><td style=text-align:left>技术成熟</td><td style=text-align:left>技术成熟</td><td style=text-align:left>技术成熟</td><td style=text-align:left>技术成熟</td><td style=text-align:left>技术成熟</td><td style=text-align:left>新兴科技</td></tr><tr><td style=text-align:left>数据的完整性</td><td style=text-align:left>高的</td><td style=text-align:left>缓和</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td></tr><tr><td style=text-align:left>可扩展性</td><td style=text-align:left>高的</td><td style=text-align:left>缓和</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td><td style=text-align:left>低的</td><td style=text-align:left>高的</td></tr><tr><td style=text-align:left>它是干什么用的？</td><td style=text-align:left>服务器和客户端之间的实时通信。</td><td style=text-align:left>客户端发起的实时更新通信。</td><td style=text-align:left>单向数据流（服务器推送）。</td><td style=text-align:left>用于 IoT 和 M2M 通信的轻量级消息传递协议。</td><td style=text-align:left>用于实时音频和视频流的点对点通信。</td><td style=text-align:left>用于低延迟 Web 通信的多路复用传输协议。</td></tr></tbody></table><h2 id=使用多种协议提供实时体验>使用多种协议提供实时体验</h2><p>我们希望您发现本文对您发现 WebSocket 的潜在替代方案有所帮助。然而，现实情况是，许多生产就绪的实时系统不仅仅使用一种协议，而是多种协议的混合。</p><p>例如，如果您正在开发视频会议解决方案，WebRTC 是在对等点之间发送音频和视频数据的绝佳选择。在这种情况下，WebSocket 补充了 WebRTC，并经常用作WebRTC 对等方的<a href=https://ably.com/blog/solving-the-webrtc-signalling-challenge>信令机制</a>。</p><p>另一个例子：由于其轻量级设计，MQTT 是从物联网传感器收集遥测数据的绝佳选择。但是，如果您想使用这些数据来支持可以在浏览器中监控的实时仪表板，则 MQTT 不适合，因为浏览器不支持它。您可以做的就是通过 WebSocket 将数据发送到浏览器。这就是为什么现在许多 MQTT 代理也支持 WebSocket（或基于 WebSocket 的 MQTT）。</p><p>如果您确实决定使用 WebSocket 作为您的用例的主要传输协议，您仍然需要考虑支持后备传输，因为某些环境会阻止 WebSocket 连接（例如，限制性的公司网络）。 SSE 和长轮询通常用作 WebSocket 的后备方案。</p><h2 id=ably在任何规模下都能可靠运行的多协议实时平台>Ably，在任何规模下都能可靠运行的多协议实时平台</h2><p>Ably 是一家实时体验基础设施提供商。我们的 API 和 SDK 可帮助开发人员构建和提供实时体验，而无需担心维护和扩展混乱的实时基础设施。</p><p>Ably 的主要特性和功能：</p><ul><li>具有丰富功能的发布/订阅消息传递，例如消息增量压缩、连续性自动重新连接、用户状态、消息历史记录和消息交互。</li><li>多协议功能。 Ably 协议基于 WebSocket，但我们还支持长轮询作为后备、SSE、MQTT、AMQP、STOMP 和 HTTP/REST。</li><li>全球分布式数据中心网络和边缘加速接入点。</li><li>保证消息排序和传递。</li><li>全球容错和 99.999% 的正常运行时间 SLA。</li><li>&lt; 65 毫秒往返延迟 (P99)。</li><li>动态弹性，因此我们可以快速扩展以处理任何需求（发送到数百万个发布/订阅通道和客户端连接的数十亿条消息）。</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2024/05/07/long-polling/><span class=title><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>[译]什么是长轮询？</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2024/05/07/http2/><span class=title>Next Page&nbsp;<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>[译]HTTP 的演变 – HTTP2 深入探讨</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script><script>mediumZoom(".entry-cover img"),mediumZoom(".post-content img:not([no-zoom])")</script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>