<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]WebSocket与REST | ChenSoul</title>
<meta name=keywords content="websocket,rest,java"><meta name=description content="原文链接：https://ably.com/topic/websocket-vs-rest
无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。
好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.899d9a536396b9b03c9eae0c99cc6ec954a90da94036f5390d131eb8071bb417.css integrity="sha256-iZ2aU2OWubA8nq4MmcxuyVSpDalANvU5DRMeuAcbtBc=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="[译]WebSocket与REST"><meta property="og:description" content="原文链接：https://ably.com/topic/websocket-vs-rest
无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。
好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-07T00:00:00+08:00"><meta property="article:modified_time" content="2024-05-07T00:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]WebSocket与REST"><meta name=twitter:description content="原文链接：https://ably.com/topic/websocket-vs-rest
无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。
好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]WebSocket与REST","item":"https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]WebSocket与REST","name":"[译]WebSocket与REST","description":"原文链接：https://ably.com/topic/websocket-vs-rest\n无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。\n好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。\n","keywords":["websocket","rest","java"],"articleBody":"原文链接：https://ably.com/topic/websocket-vs-rest\n无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。\n好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。\n在本文中，我们将阐明 REST 与 WebSocket，涵盖：\n回顾一下 REST 和 WebSocket 是什么 他们的技术权衡，包括 WebSocket 与 REST 性能 何时应该使用 REST 以及何时 WebSocket 是更好的选择 如果您使用任一协议，则需要填补一些空白。 但如果您正在寻找快速摘要，那么您需要了解以下内容：\n当您需要轻松扩展的基础架构来进行无状态 CRUD 操作并且您希望坚持使用标准 Web 工具时，REST 是理想的选择。例如，如果您正在构建一个 API 来将更新发布到社交网络 当您需要客户端和服务器之间进行实时、双向、低延迟通信时，WebSocket 是正确的选择。例如，如果您正在构建聊天应用程序。 什么是REST？ 表述性状态传输 (REST) 是一组原则，定义了通过 HTTP 构建 API 的一种方法。这很容易被忽视，但 REST 不是一种协议，这意味着您可以非常灵活地根据您的需求来塑造它。它的流行很大程度上是由于它的简单性以及它重用了已经用于网络的方法和技术。这在很大程度上定义了它表现良好的用例以及您需要寻找替代方案的用例。\n让我们快速了解一下 REST 与其他方法的区别。\nREST 的主要特征 **无状态：**对 REST API 发出的每个请求都是独立且自包含的。这使得扩展变得更加简单。当流量增加时，您可以在负载均衡器后面添加更多服务器，因为特定客户端不需要每次都连接到同一台服务器。尽管 HTTP 和 REST 是无状态的，但您可以通过使用客户端 cookie 来跟踪会话和登录状态来维护长时间运行的会话。 **CRUD：**每个 REST 请求都使用标准 HTTP 动词（GET、POST、PUT、PATCH 和 DELETE），与创建、读取、更新、删除操作对齐。 有效负载格式： REST 通常使用 JSON 或 XML 等标准化消息格式进行数据交换。但是您可以使用任何您喜欢的数据格式，只要您设置正确的Content-Type标头即可。 **可缓存：**您可以选择允许客户端和中间基础设施缓存响应。这有助于扩展和响应时间。 同步： REST 所依赖的 HTTP 请求-响应周期最适合短暂、简单的事务，其中客户端在继续下一个任务之前等待响应。 什么是 WebSocket？ REST 适用于短暂、无状态的通信，而 WebSocket 则提供持续、低延迟的双向通信通道。这意味着您与 WebSocket 交互的方式是不同的。因此，您无需使用特定端点构建“WebSocket API”，而是打开一个连接，双方可以在需要时交换消息。这使其成为实时应用程序的理想选择，例如聊天、体育或金融数据的实时流媒体，以及 Figma、Miro 和 Google Docs 等交互式实时协作环境。\nWebSocket 关键特性 **持久连接：**每个 REST 请求都需要新的 HTTP 连接，这会由于 HTTP 握手的开销而增加延迟。 WebSocket 打开一次连接，然后根据需要将其保持打开状态，从而减少发送消息所需的时间。 有状态： WebSocket 的持久连接意味着客户端和服务器可以跟踪之前发生的情况，而不必像 REST 那样使用 cookie 来跟踪状态。 **全双工通信：**客户端和服务器端都可以在需要时同时发送数据。在 REST 中，只有客户端才能发起新连接。 有效负载格式： WebSocket 适用于离散消息，例如 JSON 对象或 Protobuf 消息。这与发送恒定字节流的流媒体格式形成鲜明对比。重要的是，WebSocket 允许您发送文本或二进制数据，并且由您来处理该数据的序列化和反序列化。 实时： WebSocket 尽可能减少延迟。持久连接和小标头（低至两个字节）都有帮助。 WebSocket 与 REST 概览 正如我们所看到的，WebSocket 和 REST 的设计导致客户端和服务器的连接方式截然不同。让我们回顾一下它们的与众不同之处。\n休息 WebSocket 沟通模式 请求-响应 基于事件 状态性 无国籍 有状态的 可扩展性 易于扩展 规模更复杂 数据格式 二进制或文本 二进制或文本 高架 更高，因为每次交互都需要新的连接 初次握手后降低 用例 CRUD API，离散数据单元的无状态传输 实时协作、聊天、数据广播、持续数据传输 我应该使用 WebSocket 还是 REST？ 在考虑 WebSocket 和 REST 之间的差异时，了解技术能力是很有必要的。但当我们查看用例时，事情变得非常有趣。您应该选择 WebSocket 还是 REST 的问题完全取决于您想要解决的问题。您最终可能会得到两者的混合。\n我们以手机银行应用程序为例。其大部分客户端-服务器通信（例如付款）最适合 REST API。收款人详细信息、付款金额和相关数据非常适合请求-响应模型。\n但假设您还想将实时客户服务聊天添加到银行应用程序中。仅就该功能而言，WebSocket 将是更好的选择。持久、有状态的连接和低延迟交付使其非常适合交互式实时通信。\n所以，也许问题应该是：“我可以同时使用 REST 和 WebSocket 吗？”。答案是坚定的“是”。事实上，根据当前的问题在同一应用程序中使用不同的通信方法是很常见的。\nWebSocket 与 REST 用例 为了开始思考应该在哪里使用 REST 以及在哪里应该使用 WebSocket，让我们比较一下它们对一些常见场景的适用性。\n使用案例 休息 WebSocket 聊天 效率低下，因为它需要频繁的手动轮询或长轮询等解决方法。 具有低延迟的持久双向连接非常适合 WebSocket 聊天。 在线游戏 不适合，因为多个请求-响应周期的开销会增加太多的延迟。 更好地匹配参与在线游戏的多个玩家的实时更新。 数据更新 适用于不频繁更新，其中立即数据刷新并不重要。 非常适合更新对时间敏感的仪表板、体育数据和财务数据。 实时协作 不切实际，因为延迟太高，而且 REST 缺乏服务器启动消息传输的方法，没有解决方法。 双向即时同步意味着所有参与者的更改会同时共享。 服务整合 非常适合集成基于无状态交互的第三方服务，例如支付处理。 不太适合，因为对持久连接的需求较少 公共API 这就是 REST 的优势所在，因为它可以使用标准 Web 工具轻松部署。 不太适合，因为没有资源发现机制，而且更难扩展。 物联网设备通信 如果设备需要定期发送数据或由状态更改触发，则 REST 可能适合。然而，它限制了单向通信，并且有更好的选择。 非常适合需要与物联网网络其余部分进行持续双向通信的设备。 尽管按用例进行思考很有帮助，但您可以应用一条通用规则来决定在何处使用 WebSocket 以及在何处使用 REST。对于实时通信，请使用 WebSocket。对于请求驱动的交互（例如典型的 CRUD 操作），REST 是更好的选择。\nREST API 可以使用 WebSocket 吗？ REST 的灵活性意味着您可以精确选择如何实现 REST API。例如，与其他协议相比，HTTP 的延迟可能会让您感到沮丧。你能把它换成 WebSocket 吗？理论上，你可以。 SwaggerSocket开源项目试图做到这一点。但 REST 和 HTTP 可以很好地结合在一起，因为它们都是围绕请求-响应模型设计的。 WebSocket 的有状态、基于事件的模型意味着它不是一对一的替代品。如果您想要解决的问题需要 REST，那么就使用 REST。\n用于构建 REST 和 WebSocket 基础设施的选项 在 WebSocket 和 REST 之间进行选择实际上只是第一步。请记住，它们都没有告诉您太多有关运行它们所需的基础设施的信息。对于 REST，构建可扩展的 HTTP 后端几乎是一个已解决的问题。但 WebSocket 的情况并非如此。持久的、有状态的连接会增加服务器的负载并使扩展变得复杂。\n值得庆幸的是，有各种各样的库、框架和托管服务可用于简化应用程序后端的构建和管理。它们往往分为四类：\n**托管您自己的后端：**尽管您承担了额外的 DevOps 负担，但您可以使用以下方法之一托管您自己的 WebSocket 后端： **纯 WebSocket 库：**大多数语言都有 WebSocket 协议的官方或半官方实现。例如，“ws”代表 NodeJS。它们为您提供低级 WebSocket 功能，如果您只想要轻量级实现或者确实需要创建自定义解决方案，那么这些功能可能会很好。 **功能齐全的消息传递库：**更高一级的是消息传递库，例如用于 .NET 的 SignalR 或用于 NodeJS 的 Socket.IO。他们负责处理更多问题，例如自动重新连接。 使用框架： Spring Boot for Java 本身也支持 WebSocket。 **使用专门的托管服务：**根据您的使用案例，可能会有一种软件即服务产品提供专门的 WebSocket 后端。例如，聊天 SaaS API 很常见。但是，您需要熟悉供应商所做的设计选择。 使用后端即服务 (BaaS)： Firebase 和 Supabase 等平台提供基于 WebSocket 构建的有限实时功能。然而，通常缺乏可扩展性和消息保证。 **使用实时平台即服务 (PaaS)：**对于可靠性、数据完整性和可扩展性很重要的应用程序，您应该考虑使用专用的实时 PaaS。 Ably 的实时 PaaS 可帮助您更快地进入市场，为您提供全球托管基础架构，并提供除纯 WebSocket 之外的丰富功能。 借助 Ably，您的应用程序可以利用：\n**全球边缘网络：**无论您的应用程序的用户位于世界何处，Ablly 边缘位置都可确保整个网络的延迟低于 65 毫秒。在 不仅仅是 WebSocket： Ably 可以根据您的应用程序需求和网络条件选择正确的协议，从 WebSocket、服务器发送事件和 MQTT 等选项中进行选择。 弹性交付： Aly 保证消息按顺序按时到达。 99.999% 的正常运行时间： Ably 的网络可以绕过故障，确保您的应用程序持续交付。 **扩展以满足需求：**随着需求的增长，Ablly 的消息数量从数千条扩展到数十亿条。 **无论您的技术堆栈如何，都能获得出色的开发人员体验：**凭借适用于超过 25 种语言和框架的 SDK、与常用工具的集成以及行业领先的文档，Ably 为您提供了快速提高生产力的工具。 ","wordCount":"3717","inLanguage":"en","datePublished":"2024-05-07T00:00:00+08:00","dateModified":"2024-05-07T00:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[译]WebSocket与REST</h1><div class=post-meta><span title='2024-05-07 00:00:00 +0800 CST'>2024-05-07</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;3717 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afrest aria-label=什么是REST？>什么是REST？</a><ul><li><a href=#rest-%e7%9a%84%e4%b8%bb%e8%a6%81%e7%89%b9%e5%be%81 aria-label="REST 的主要特征">REST 的主要特征</a></li></ul></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-websocket aria-label="什么是 WebSocket？">什么是 WebSocket？</a><ul><li><a href=#websocket-%e5%85%b3%e9%94%ae%e7%89%b9%e6%80%a7 aria-label="WebSocket 关键特性">WebSocket 关键特性</a></li><li><a href=#websocket-%e4%b8%8e-rest-%e6%a6%82%e8%a7%88 aria-label="WebSocket 与 REST 概览">WebSocket 与 REST 概览</a></li></ul></li><li><a href=#%e6%88%91%e5%ba%94%e8%af%a5%e4%bd%bf%e7%94%a8-websocket-%e8%bf%98%e6%98%af-rest aria-label="我应该使用 WebSocket 还是 REST？">我应该使用 WebSocket 还是 REST？</a><ul><li><a href=#websocket-%e4%b8%8e-rest-%e7%94%a8%e4%be%8b aria-label="WebSocket 与 REST 用例">WebSocket 与 REST 用例</a></li><li><a href=#rest-api-%e5%8f%af%e4%bb%a5%e4%bd%bf%e7%94%a8-websocket-%e5%90%97 aria-label="REST API 可以使用 WebSocket 吗？">REST API 可以使用 WebSocket 吗？</a></li></ul></li><li><a href=#%e7%94%a8%e4%ba%8e%e6%9e%84%e5%bb%ba-rest-%e5%92%8c-websocket-%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd%e7%9a%84%e9%80%89%e9%a1%b9 aria-label="用于构建 REST 和 WebSocket 基础设施的选项">用于构建 REST 和 WebSocket 基础设施的选项</a></li></ul></div></details></div><div class=post-content><p>原文链接：<a href=https://ably.com/topic/websocket-vs-rest target=_blank>https://ably.com/topic/websocket-vs-rest</a></p><p>无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。</p><p>好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。</p><p>在本文中，我们将阐明 REST 与 WebSocket，涵盖：</p><ul><li>回顾一下 REST 和 WebSocket 是什么</li><li>他们的技术权衡，包括 WebSocket 与 REST 性能</li><li>何时应该使用 REST 以及何时 WebSocket 是更好的选择</li><li>如果您使用任一协议，则需要填补一些空白。</li></ul><p>但如果您正在寻找快速摘要，那么您需要了解以下内容：</p><ul><li>当您需要轻松扩展的基础架构来进行无状态 CRUD 操作并且您希望坚持使用标准 Web 工具时，REST 是理想的选择。例如，如果您正在构建一个 API 来将更新发布到社交网络</li><li>当您需要客户端和服务器之间进行实时、双向、低延迟通信时，WebSocket 是正确的选择。例如，如果您正在构建聊天应用程序。</li></ul><h2 id=什么是rest>什么是REST？<a hidden class=anchor aria-hidden=true href=#什么是rest>#</a></h2><p>表述性状态传输 (REST) 是一组原则，定义了通过 HTTP 构建 API 的一种方法。这很容易被忽视，但 REST 不是一种协议，这意味着您可以非常灵活地根据您的需求来塑造它。它的流行很大程度上是由于它的简单性以及它重用了已经用于网络的方法和技术。这在很大程度上定义了它表现良好的用例以及您需要寻找替代方案的用例。</p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/WXfzz8k6MwYHqKs6baSXM/86003498805f6cff1565d2bdcd5b0990/client-server-communication-over-rest.png?w=1840&amp;h=440&amp;q=50&amp;fm=png" alt=img></p><p>让我们快速了解一下 REST 与其他方法的区别。</p><h3 id=rest-的主要特征>REST 的主要特征<a hidden class=anchor aria-hidden=true href=#rest-的主要特征>#</a></h3><ul><li>**无状态：**对 REST API 发出的每个请求都是独立且自包含的。这使得扩展变得更加简单。当流量增加时，您可以在负载均衡器后面添加更多服务器，因为特定客户端不需要每次都连接到同一台服务器。尽管 HTTP 和 REST 是无状态的，但您可以通过使用客户端 cookie 来跟踪会话和登录状态来维护长时间运行的会话。</li><li>**CRUD：**每个 REST 请求都使用标准 HTTP 动词（GET、POST、PUT、PATCH 和 DELETE），与创建、读取、更新、删除操作对齐。</li><li><strong>有效负载格式：</strong> REST 通常使用 JSON 或 XML 等标准化消息格式进行数据交换。但是您可以使用任何您喜欢的数据格式，只要您设置正确的<em>Content-Type</em>标头即可。</li><li>**可缓存：**您可以选择允许客户端和中间基础设施缓存响应。这有助于扩展和响应时间。</li><li><strong>同步：</strong> REST 所依赖的 HTTP 请求-响应周期最适合短暂、简单的事务，其中客户端在继续下一个任务之前等待响应。</li></ul><h2 id=什么是-websocket>什么是 WebSocket？<a hidden class=anchor aria-hidden=true href=#什么是-websocket>#</a></h2><p>REST 适用于短暂、无状态的通信，而 WebSocket 则提供持续、低延迟的双向通信通道。这意味着您与 WebSocket 交互的方式是不同的。因此，您无需使用特定端点构建“WebSocket API”，而是打开一个连接，双方可以在需要时交换消息。这使其成为实时应用程序的理想选择，例如聊天、体育或金融数据的实时流媒体，以及 Figma、Miro 和 Google Docs 等交互式实时协作环境。</p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/0mExYcxsnzccWxnktAKjc/33a49e1e736a2f906216d630b84fb641/websockets.png?w=1840&amp;h=745&amp;q=50&amp;fm=png" alt=img></p><h3 id=websocket-关键特性>WebSocket 关键特性<a hidden class=anchor aria-hidden=true href=#websocket-关键特性>#</a></h3><ul><li>**持久连接：**每个 REST 请求都需要新的 HTTP 连接，这会由于 HTTP 握手的开销而增加延迟。 WebSocket 打开一次连接，然后根据需要将其保持打开状态，从而减少发送消息所需的时间。</li><li><strong>有状态：</strong> WebSocket 的持久连接意味着客户端和服务器可以跟踪之前发生的情况，而不必像 REST 那样使用 cookie 来跟踪状态。</li><li>**全双工通信：**客户端和服务器端都可以在需要时同时发送数据。在 REST 中，只有客户端才能发起新连接。</li><li><strong>有效负载格式：</strong> WebSocket 适用于离散消息，例如 JSON 对象或 Protobuf 消息。这与发送恒定字节流的流媒体格式形成鲜明对比。重要的是，WebSocket 允许您发送文本或二进制数据，并且由您来处理该数据的序列化和反序列化。</li><li><strong>实时：</strong> WebSocket 尽可能减少延迟。持久连接和小标头（低至两个字节）都有帮助。</li></ul><h3 id=websocket-与-rest-概览>WebSocket 与 REST 概览<a hidden class=anchor aria-hidden=true href=#websocket-与-rest-概览>#</a></h3><p>正如我们所看到的，WebSocket 和 REST 的设计导致客户端和服务器的连接方式截然不同。让我们回顾一下它们的与众不同之处。</p><table><thead><tr><th style=text-align:left></th><th style=text-align:left><strong>休息</strong></th><th style=text-align:left><strong>WebSocket</strong></th></tr></thead><tbody><tr><td style=text-align:left><strong>沟通模式</strong></td><td style=text-align:left>请求-响应</td><td style=text-align:left>基于事件</td></tr><tr><td style=text-align:left><strong>状态性</strong></td><td style=text-align:left>无国籍</td><td style=text-align:left>有状态的</td></tr><tr><td style=text-align:left><strong>可扩展性</strong></td><td style=text-align:left>易于扩展</td><td style=text-align:left>规模更复杂</td></tr><tr><td style=text-align:left><strong>数据格式</strong></td><td style=text-align:left>二进制或文本</td><td style=text-align:left>二进制或文本</td></tr><tr><td style=text-align:left><strong>高架</strong></td><td style=text-align:left>更高，因为每次交互都需要新的连接</td><td style=text-align:left>初次握手后降低</td></tr><tr><td style=text-align:left><strong>用例</strong></td><td style=text-align:left>CRUD API，离散数据单元的无状态传输</td><td style=text-align:left>实时协作、聊天、数据广播、持续数据传输</td></tr></tbody></table><h2 id=我应该使用-websocket-还是-rest>我应该使用 WebSocket 还是 REST？<a hidden class=anchor aria-hidden=true href=#我应该使用-websocket-还是-rest>#</a></h2><p>在考虑 WebSocket 和 REST 之间的差异时，了解技术能力是很有必要的。但当我们查看用例时，事情变得非常有趣。您应该选择 WebSocket 还是 REST 的问题完全取决于您想要解决的问题。您最终可能会得到两者的混合。</p><p>我们以手机银行应用程序为例。其大部分客户端-服务器通信（例如付款）最适合 REST API。收款人详细信息、付款金额和相关数据非常适合请求-响应模型。</p><p>但假设您还想将实时客户服务聊天添加到银行应用程序中。仅就该功能而言，WebSocket 将是更好的选择。持久、有状态的连接和低延迟交付使其非常适合交互式实时通信。</p><p>所以，也许问题应该是：“我可以同时使用 REST 和 WebSocket 吗？”。答案是坚定的“是”。事实上，根据当前的问题在同一应用程序中使用不同的通信方法是很常见的。</p><h3 id=websocket-与-rest-用例>WebSocket 与 REST 用例<a hidden class=anchor aria-hidden=true href=#websocket-与-rest-用例>#</a></h3><p>为了开始思考应该在哪里使用 REST 以及在哪里应该使用 WebSocket，让我们比较一下它们对一些常见场景的适用性。</p><table><thead><tr><th style=text-align:left><strong>使用案例</strong></th><th style=text-align:left><strong>休息</strong></th><th style=text-align:left><strong>WebSocket</strong></th></tr></thead><tbody><tr><td style=text-align:left>聊天</td><td style=text-align:left>效率低下，因为它需要频繁的手动轮询或<a href=https://ably.com/topic/long-polling target=_blank>长轮询</a>等解决方法。</td><td style=text-align:left>具有低延迟的持久双向连接非常适合 WebSocket 聊天。</td></tr><tr><td style=text-align:left>在线游戏</td><td style=text-align:left>不适合，因为多个请求-响应周期的开销会增加太多的延迟。</td><td style=text-align:left>更好地匹配参与在线游戏的多个玩家的实时更新。</td></tr><tr><td style=text-align:left>数据更新</td><td style=text-align:left>适用于不频繁更新，其中立即数据刷新并不重要。</td><td style=text-align:left>非常适合更新对时间敏感的仪表板、体育数据和财务数据。</td></tr><tr><td style=text-align:left>实时协作</td><td style=text-align:left>不切实际，因为延迟太高，而且 REST 缺乏服务器启动消息传输的方法，没有解决方法。</td><td style=text-align:left>双向即时同步意味着所有参与者的更改会同时共享。</td></tr><tr><td style=text-align:left>服务整合</td><td style=text-align:left>非常适合集成基于无状态交互的第三方服务，例如支付处理。</td><td style=text-align:left>不太适合，因为对持久连接的需求较少</td></tr><tr><td style=text-align:left>公共API</td><td style=text-align:left>这就是 REST 的优势所在，因为它可以使用标准 Web 工具轻松部署。</td><td style=text-align:left>不太适合，因为没有资源发现机制，而且更难扩展。</td></tr><tr><td style=text-align:left>物联网设备通信</td><td style=text-align:left>如果设备需要定期发送数据或由状态更改触发，则 REST 可能适合。然而，它限制了单向通信，并且有更好的选择。</td><td style=text-align:left>非常适合需要与物联网网络其余部分进行持续双向通信的设备。</td></tr></tbody></table><p>尽管按用例进行思考很有帮助，但您可以应用一条通用规则来决定在何处使用 WebSocket 以及在何处使用 REST。对于实时通信，请使用 WebSocket。对于请求驱动的交互（例如典型的 CRUD 操作），REST 是更好的选择。</p><h3 id=rest-api-可以使用-websocket-吗>REST API 可以使用 WebSocket 吗？<a hidden class=anchor aria-hidden=true href=#rest-api-可以使用-websocket-吗>#</a></h3><p>REST 的灵活性意味着您可以精确选择如何实现 REST API。例如，与其他协议相比，HTTP 的延迟可能会让您感到沮丧。你能把它换成 WebSocket 吗？理论上，你可以。 SwaggerSocket开源项目试图做到这一点<a href=https://github.com/swagger-api/swagger-socket target=_blank>。</a>但 REST 和 HTTP 可以很好地结合在一起，因为它们都是围绕请求-响应模型设计的。 WebSocket 的有状态、基于事件的模型意味着它不是一对一的替代品。如果您想要解决的问题需要 REST，那么就使用 REST。</p><h2 id=用于构建-rest-和-websocket-基础设施的选项>用于构建 REST 和 WebSocket 基础设施的选项<a hidden class=anchor aria-hidden=true href=#用于构建-rest-和-websocket-基础设施的选项>#</a></h2><p>在 WebSocket 和 REST 之间进行选择实际上只是第一步。请记住，它们都没有告诉您太多有关运行它们所需的基础设施的信息。对于 REST，构建可扩展的 HTTP 后端几乎是一个已解决的问题。但 WebSocket 的情况并非如此。持久的、有状态的连接会增加服务器的负载并使扩展变得复杂。</p><p>值得庆幸的是，有各种各样的库、框架和托管服务可用于简化应用程序后端的构建和管理。它们往往分为四类：</p><ul><li>**托管您自己的后端：**尽管您承担了额外的 DevOps 负担，但您可以使用以下方法之一托管您自己的 WebSocket 后端：<ul><li>**纯 WebSocket 库：**大多数语言都有 WebSocket 协议的官方或半官方实现。例如，“ws”代表 NodeJS。它们为您提供低级 WebSocket 功能，如果您只想要轻量级实现或者确实需要创建自定义解决方案，那么这些功能可能会很好。</li><li>**功能齐全的消息传递库：**更高一级的是消息传递库，例如用于 .NET 的 SignalR 或用于 NodeJS 的 Socket.IO。他们负责处理更多问题，例如自动重新连接。</li><li><strong>使用框架：</strong> Spring Boot for Java 本身也支持 WebSocket。</li></ul></li><li>**使用专门的托管服务：**根据您的使用案例，可能会有一种软件即服务产品提供专门的 WebSocket 后端。例如，聊天 SaaS API 很常见。但是，您需要熟悉供应商所做的设计选择。</li><li><strong>使用后端即服务 (BaaS)：</strong> Firebase 和 Supabase 等平台提供基于 WebSocket 构建的有限实时功能。然而，通常缺乏可扩展性和消息保证。</li><li>**使用实时平台即服务 (PaaS)：**对于可靠性、数据完整性和可扩展性很重要的应用程序，您应该考虑使用专用的实时 PaaS。 Ably 的实时 PaaS 可帮助您更快地进入市场，为您提供全球托管基础架构，并提供除纯 WebSocket 之外的丰富功能。</li></ul><p>借助 Ably，您的应用程序可以利用：</p><ul><li>**全球边缘网络：**无论您的应用程序的用户位于世界何处，Ablly 边缘位置都可确保整个网络的延迟低于 65 毫秒。在</li><li><strong>不仅仅是 WebSocket：</strong> Ably 可以根据您的应用程序需求和网络条件选择正确的协议，从 WebSocket、服务器发送事件和 MQTT 等选项中进行选择。</li><li><strong>弹性交付：</strong> Aly 保证消息按顺序按时到达。</li><li><strong>99.999% 的正常运行时间：</strong> Ably 的网络可以绕过故障，确保您的应用程序持续交付。</li><li>**扩展以满足需求：**随着需求的增长，Ablly 的消息数量从数千条扩展到数十亿条。</li><li>**无论您的技术堆栈如何，都能获得出色的开发人员体验：**凭借适用于超过 25 种语言和框架的 SDK、与常用工具的集成以及行业领先的文档，Ably 为您提供了快速提高生产力的工具。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/websocket/>Websocket</a></li><li><a href=https://blog.chensoul.cc/tags/rest/>Rest</a></li><li><a href=https://blog.chensoul.cc/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/><span class=title>« Prev</span><br><span>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2024/05/07/http/><span class=title>Next »</span><br><span>[译]什么是 HTTP？</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]WebSocket与REST on x" href="https://x.com/intent/tweet/?text=%5b%e8%af%91%5dWebSocket%e4%b8%8eREST&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f07%2fwebsocket-vs-rest%2f&amp;hashtags=websocket%2crest%2cjava"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]WebSocket与REST on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f07%2fwebsocket-vs-rest%2f&amp;title=%5b%e8%af%91%5dWebSocket%e4%b8%8eREST&amp;summary=%5b%e8%af%91%5dWebSocket%e4%b8%8eREST&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f07%2fwebsocket-vs-rest%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]WebSocket与REST on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f07%2fwebsocket-vs-rest%2f&title=%5b%e8%af%91%5dWebSocket%e4%b8%8eREST"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]WebSocket与REST on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f07%2fwebsocket-vs-rest%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]WebSocket与REST on whatsapp" href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5dWebSocket%e4%b8%8eREST%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f07%2fwebsocket-vs-rest%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]WebSocket与REST on telegram" href="https://telegram.me/share/url?text=%5b%e8%af%91%5dWebSocket%e4%b8%8eREST&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f07%2fwebsocket-vs-rest%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]WebSocket与REST on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%e8%af%91%5dWebSocket%e4%b8%8eREST&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f07%2fwebsocket-vs-rest%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>