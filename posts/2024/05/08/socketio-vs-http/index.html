<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]比较 Socket.IO 和 HTTP：主要区别和用例 | ChenSoul</title>
<meta name=keywords content="socketio,java"><meta name=description content="原文链接：https://ably.com/topic/socketio-vs-http
在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。
什么是Socket.IO？
Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.899d9a536396b9b03c9eae0c99cc6ec954a90da94036f5390d131eb8071bb417.css integrity="sha256-iZ2aU2OWubA8nq4MmcxuyVSpDalANvU5DRMeuAcbtBc=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="[译]比较 Socket.IO 和 HTTP：主要区别和用例"><meta property="og:description" content="原文链接：https://ably.com/topic/socketio-vs-http
在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。
什么是Socket.IO？
Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-08T00:00:00+08:00"><meta property="article:modified_time" content="2024-05-08T00:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]比较 Socket.IO 和 HTTP：主要区别和用例"><meta name=twitter:description content="原文链接：https://ably.com/topic/socketio-vs-http
在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。
什么是Socket.IO？
Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]比较 Socket.IO 和 HTTP：主要区别和用例","item":"https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]比较 Socket.IO 和 HTTP：主要区别和用例","name":"[译]比较 Socket.IO 和 HTTP：主要区别和用例","description":"原文链接：https://ably.com/topic/socketio-vs-http\n在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。\n什么是Socket.IO？ Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。\n","keywords":["socketio","java"],"articleBody":"原文链接：https://ably.com/topic/socketio-vs-http\n在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。\n什么是Socket.IO？ Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。\nSocket.IO 需要两个库 - 一个在服务器上，一个在客户端上。 Socket.IO 创建者维护以下“官方”：\nSocket.IO是 Node.js 服务器组件。 Socket.IO-client是客户端 JavaScript 库。 一些 Socket.IO 客户端和服务器实现可以用其他语言实现。请阅读Socket.IO 是什么来获取列表。\n下图总结了典型的 Socket.IO 设置：\nSocket.IO 主要特性 Socket.IO 具有以下主要特性：\n**向后兼容性：**在现代浏览器中，Socket.IO 使用WebSocket API提供所需的连接并发送消息。 WebSocket 在服务器和浏览器之间提供全双工、低延迟、事件驱动的连接。它也是有状态的。如果需要旧版浏览器支持，或者 WebSocket 连接无法使用（由于防火墙或公司代理），Socket.IO 可以回退到 HTTP 和长轮询。 重连和缓冲： Socket.IO提供自动重连功能。当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送。 多种数据格式： Socket.IO 支持任何可序列化格式的数据传输，包括Buffer或TypedArray等二进制对象。 **致谢：**使用 Socket.IO，一旦成功接收到消息就可以发送响应消息。 命名空间： Socket.IO 使您能够设置具有不同客户端、房间、事件和应用程序逻辑的不同通道。 **广播到不同的客户端组：**从服务器，您可以向所有连接的客户端或子集发送消息。 Socket.IO 的优缺点 Socket.IO 专业人士 连接效率： Socket.IO 使用 HTTP 长轮询发起连接，一旦建立可用性就升级到 WebSocket（有关更多详细信息，请参阅升级机制）。当发生这种情况时，客户端-服务器连接使用单个 WebSocket，而不必启动多个连接，从而减少延迟并改善用户体验。 **客户端和服务器发起的通信：**由于WebSocket提供了全双工、双向的通信通道，因此服务器可以向客户端发送消息，并且两者可以同时发送消息。 事件驱动的通信： WebSocket是一种事件驱动的协议，这意味着您可以在收到消息后立即监听并响应消息，而不是使用轮询机制来检查更新，这样既浪费又低效。 丰富的功能集： Socket.IO 提供了实现实时应用程序所需的一切。当使用原始 HTTP 甚至原始 WebSocket 时，您必须自己实现其中大部分功能。 有状态： Socket.IO 使用 WebSocket，它是有状态的。该状态一直持续到连接关闭为止。 Socket.IO 缺点 **有限的平台支持：**我们之前提到，Socket.IO 在不同的平台和语言上有多种服务器和客户端实现。值得一提的是，其中一些没有得到积极维护，或者功能集有限，因此在考虑使用它们之前请仔细检查它们。此外，Socket.IO 实现与本机 WebSocket 不兼容，因为 Socket.IO 会向其发送的每个数据包添加额外的元数据。 可扩展性： Socket.IO 非常适合有限数量用户的实时通信应用程序。但是，如果您的用户数量和数据量开始变大，您的服务器可能会过载。当您的服务器达到最大负载时，您将需要将连接拆分到多个服务器上，否则可能会丢失重要信息。这种增加的架构复杂性带来了更多问题。阅读Scaling Socket.IO - 实际注意事项以获取更多信息。 **内存泄漏：**已知 Socket.IO 存在一些与内存泄漏相关的问题。内存泄漏不太可能导致任何直接问题，但如果您的应用程序使用了很长一段时间，它们最终可能会导致用户的设备冻结或崩溃。 什么是 HTTP？ HTTP 是一种请求/响应协议，作为 Web 的主要通信机制，构建在 TCP 网络协议之上。有限版本最初由 Tim Berners-Lee 于 1989 年提出，随后经过快速修改以支持更广泛的浏览器和服务器功能。 HTTP 工作组于 1996 年将这些修改记录为 HTTP/1.0 ( RFC 1945 )。\nHTTP 在 RESTful 架构（即 REST API）中很常见。 REST 的经典用例是 CRUD 应用程序，其中 HTTP POST、PUT、GET、PUT 和 DELETE 动词提供了一种简单的方法来实现创建、读取、更新和删除数据的操作。\n传统的 HTTP 消息流如下所示：\nHTTP 技术的出现可以实现实时应用程序：\n长轮询**：**对 HTTP 服务器的重复请求会浪费资源 - 在每个请求中，您都必须建立一个新连接，解析 HTTP 标头，查询新数据，生成和传递响应，以及关闭和清理连接。长轮询通过尽可能长时间地保持客户端-服务器连接打开，在新数据可用或达到超时阈值时提供响应来改进这一点。正如本文前面提到的，当 WebSocket 不可用时，Socket.IO 会转而使用 HTTP 长轮询。 服务器发送事件 (SSE)： SSE 允许浏览器订阅服务器生成的事件流，并在新事件发生时接收更新。 EventSource接口接受特定 URL 处的 HTTP 流连接，并在检索可用数据时保持连接打开。 SSE 听起来像是 WebSocket 的有力竞争对手，但它是单向的。 HTTP 关键特性 我们已经看到了 HTTP 的多个新版本，每个版本都添加了新功能。\n**HTTP/1.1 (1997)：**引入了一些重要的增强功能，最显着的是Keep-Alive标头（允许连接处理多个请求）和Upgrade标头（将连接升级到增强协议，例如 WebSockets）。 **HTTP/2 (2015)：**这是一项性能更新，旨在提高 Web 通信的速度。 HTTP/2 包括： 多路复用，涉及帧内的二进制数据封装，沿着多个称为流的双向通道发送，全部通过单个 TCP 连接，允许同时发生许多并行请求/响应。 服务器推送，一种允许服务器在客户端请求响应之前将响应发送到兼容 HTTP/2 的客户端的功能。当服务器知道客户端需要“推送”响应来完全处理原始请求时，此功能非常有用。 **HTTP/3（自 2018 年开始开发）：**旨在使用称为 QUIC 的不同传输层网络协议解决 HTTP/2 的传输相关问题（例如延迟），该协议在用户数据报协议 (UDP) 而不是 TCP 上运行。 HTTP 的优点和缺点 HTTP 优点： **平台支持：**每个服务器端平台和非浏览器客户端平台（想想用 Kotlin 构建的 Android 客户端，或用 Rust 构建的桌面应用程序）都具有出色的 HTTP 支持。如果您使用的平台对 Socket.IO 等库没有良好的支持，您可能会选择在标准 HTTP 之上实现解决方案。 HTTP 缺点： **连接效率：**尽管 Keep-Alive 标头和长轮询允许在每个连接上发送多个请求，但仍然需要多个连接，并且开销比基于 WebSocket 的解决方案（如 Socket.IO）更大。这会导致延迟增加和用户体验变差。 **单向通信：**在标准 HTTP 中，所有请求均由客户端发起，响应由服务器处理。 SSE 提供来自服务器的通信流，但这仍然只是单向的。 **缺乏事件驱动的通信：**尽管 SSE 允许在事件发生时使用事件来响应来自服务器的消息。在服务器上监听和响应来自客户端的消息仍然需要轮询机制来不断检查更新，这是浪费且低效的。 **有限的功能集：**使用原始 HTTP 将要求您自己实现应用程序所需的功能集，或者找到其他库来帮助您。 **无状态：**每次通信完成后，连接关闭，状态丢失。 Socket.IO 和 HTTP 有什么区别？ 下表快速总结了 Socket.IO 和 HTTP 之间的主要区别。\n套接字IO HTTP协议 良好的浏览器兼容性，可回退到 HTTP 长轮询 优秀的浏览器兼容性 服务器端平台兼容性和非浏览器客户端兼容性尚可，部分地方存在差距 出色的服务器端和非浏览器客户端兼容性 双向通讯 单向通讯 事件驱动的通信 非事件驱动通信（使用 SSE，事件驱动通信仅适用于从服务器到客户端） 出色的连接效率——一旦建立，WebSocket 连接的整个生命周期都需要单个 TCP 连接 连接效率良好——通信生命周期内需要多个连接 有状态的 无国籍 丰富的功能集 功能需要自行实现 我应该使用 Socket.IO 还是 HTTP？ 这取决于您的用例；在本节中，我们将研究两者的合适用例。\n何时使用 Socket.IO Socket.IO 非常适合构建涉及多个用户和服务器之间的消息交换的任何应用程序，您希望在其中维护整体状态并希望获得响应式双向实时用户体验。示例包括聊天/消息应用程序、多用户游戏、协作编辑（例如 Google 文档）、基于位置的应用程序等。\nSocket.IO 具有良好的跨浏览器兼容性，但其对不同平台（即非 JavaScript/Node.js）的支持可能参差不齐。如果您使用的是良好支持的客户端/服务器组合，并且您不关心支持旧版浏览器，那么 Socket.IO 就可以了。如果您需要替代方案，请阅读我们的Socket.IO 替代方案文章以获取选项。\n何时使用 HTTP HTTP 非常适合多用户应用程序，在这些应用程序中，您不需要两个方向的实时响应，但您仍然关心每个客户端和服务器之间可靠、安全的数据交换。想想传统的 REST/CRUD 应用程序——银行应用程序、电子邮件应用程序、天气应用程序和电子商务应用程序。\n如果您想要实时响应，但仅限于从服务器到客户端，那么 SSE 是一个可行的解决方案。 SSE 对于提供实时信息更新的应用程序很有用，但用户只是消费数据，而不是写入数据。很好的例子可能包括股票行情或新闻行情应用程序。\nHTTP 是一项非常成熟的技术，对 Web 浏览器、服务器平台和非浏览器客户端类型提供大力支持。如果您担心对 Socket.IO 等库的支持不完整，请考虑使用原始 HTTP 构建您的应用程序。\n总体而言，Socket.IO 和 HTTP 哪个更好？ 您应该使用 Socket.IO 还是 HTTP 取决于您的用例。 Socket.IO 等基于 WebSocket 的解决方案对于构建具有低延迟、高效连接和高性能要求的实时应用程序至关重要。然而，当涉及到平台兼容性和可扩展性时，Socket.IO 可能会下降——如果这些出现问题，HTTP 可能是更好的方法。\nAbly 是 Socket.IO 的替代品，具有强大的发布/订阅消息传递、针对每种主要语言和开发平台的超过 25 个 SDK、可用的专门专家支持等等。有关详细比较，请参阅Ably 与 Socket.IO。借助可用的 WebSocket 和 REST 库，您可以轻松集成。\n","wordCount":"3774","inLanguage":"en","datePublished":"2024-05-08T00:00:00+08:00","dateModified":"2024-05-08T00:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[译]比较 Socket.IO 和 HTTP：主要区别和用例</h1><div class=post-meta><span title='2024-05-08 00:00:00 +0800 CST'>2024-05-08</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;3774 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afsocketio aria-label=什么是Socket.IO？>什么是Socket.IO？</a><ul><li><a href=#socketio-%e4%b8%bb%e8%a6%81%e7%89%b9%e6%80%a7 aria-label="Socket.IO 主要特性">Socket.IO 主要特性</a></li><li><a href=#socketio-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label="Socket.IO 的优缺点">Socket.IO 的优缺点</a><ul><li><a href=#socketio-%e4%b8%93%e4%b8%9a%e4%ba%ba%e5%a3%ab aria-label="Socket.IO 专业人士">Socket.IO 专业人士</a></li><li><a href=#socketio-%e7%bc%ba%e7%82%b9 aria-label="Socket.IO 缺点">Socket.IO 缺点</a></li></ul></li></ul></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-http aria-label="什么是 HTTP？">什么是 HTTP？</a><ul><li><a href=#http-%e5%85%b3%e9%94%ae%e7%89%b9%e6%80%a7 aria-label="HTTP 关键特性">HTTP 关键特性</a></li><li><a href=#http-%e7%9a%84%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9 aria-label="HTTP 的优点和缺点">HTTP 的优点和缺点</a><ul><li><a href=#http-%e4%bc%98%e7%82%b9 aria-label="HTTP 优点：">HTTP 优点：</a></li><li><a href=#http-%e7%bc%ba%e7%82%b9 aria-label="HTTP 缺点：">HTTP 缺点：</a></li></ul></li></ul></li><li><a href=#socketio-%e5%92%8c-http-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="Socket.IO 和 HTTP 有什么区别？">Socket.IO 和 HTTP 有什么区别？</a></li><li><a href=#%e6%88%91%e5%ba%94%e8%af%a5%e4%bd%bf%e7%94%a8-socketio-%e8%bf%98%e6%98%af-http aria-label="我应该使用 Socket.IO 还是 HTTP？">我应该使用 Socket.IO 还是 HTTP？</a><ul><li><a href=#%e4%bd%95%e6%97%b6%e4%bd%bf%e7%94%a8-socketio aria-label="何时使用 Socket.IO">何时使用 Socket.IO</a></li><li><a href=#%e4%bd%95%e6%97%b6%e4%bd%bf%e7%94%a8-http aria-label="何时使用 HTTP">何时使用 HTTP</a></li></ul></li><li><a href=#%e6%80%bb%e4%bd%93%e8%80%8c%e8%a8%80socketio-%e5%92%8c-http-%e5%93%aa%e4%b8%aa%e6%9b%b4%e5%a5%bd aria-label="总体而言，Socket.IO 和 HTTP 哪个更好？">总体而言，Socket.IO 和 HTTP 哪个更好？</a></li></ul></div></details></div><div class=post-content><p>原文链接：<a href=https://ably.com/topic/socketio-vs-http target=_blank>https://ably.com/topic/socketio-vs-http</a></p><p>在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对<a href=https://ably.com/topic/socketio target=_blank>Socket.IO</a>实时库和<a href=https://ably.com/topic/websockets-vs-http#http target=_blank>HTTP</a>协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。</p><h2 id=什么是socketio>什么是Socket.IO？<a hidden class=anchor aria-hidden=true href=#什么是socketio>#</a></h2><p>Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。</p><p>Socket.IO 需要两个库 - 一个在服务器上，一个在客户端上。 Socket.IO 创建者维护以下“官方”：</p><ul><li><a href=https://github.com/socketio/socket.io target=_blank>Socket.IO</a>是 Node.js 服务器组件。</li><li><a href=https://github.com/socketio/socket.io-client target=_blank>Socket.IO-client</a>是客户端 JavaScript 库。</li></ul><p>一些 Socket.IO 客户端和服务器实现可以用其他语言实现。请阅读<a href=https://socket.io/docs/v4/#what-socketio-is target=_blank>Socket.IO 是什么</a>来获取列表。</p><p>下图总结了典型的 Socket.IO 设置：</p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/27G4lHu2Vj0Cm0CUC2x5p7/33813bbe794d2e8913c65f5ce23290e8/websocket.io-2_2x.png?w=1841&amp;h=699&amp;q=50&amp;fm=png" alt=img></p><h3 id=socketio-主要特性>Socket.IO 主要特性<a hidden class=anchor aria-hidden=true href=#socketio-主要特性>#</a></h3><p>Socket.IO 具有以下主要特性：</p><ul><li>**向后兼容性：**在现代浏览器中，Socket.IO 使用<a href=https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API target=_blank>WebSocket API</a>提供所需的连接并发送消息。 WebSocket 在服务器和浏览器之间提供全双工、低延迟、事件驱动的连接。它也是有状态的。如果需要旧版浏览器支持，或者 WebSocket 连接无法使用（由于防火墙或公司代理），Socket.IO 可以回退到 HTTP 和长轮询。</li><li><strong>重连和缓冲：</strong> Socket.IO提供自动重连功能。当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送。</li><li><strong>多种数据格式：</strong> Socket.IO 支持任何可序列化格式的数据传输，包括<a href=https://nodejs.org/docs/latest/api/buffer.html#buffer_buffer target=_blank>Buffer</a>或<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray target=_blank>TypedArray</a>等二进制对象。</li><li>**致谢：**使用 Socket.IO，一旦成功接收到消息就可以发送响应消息。</li><li><strong>命名空间：</strong> Socket.IO 使您能够设置具有不同客户端、房间、事件和应用程序逻辑的不同通道。</li><li>**广播到不同的客户端组：**从服务器，您可以向所有连接的客户端或子集发送消息。</li></ul><h3 id=socketio-的优缺点>Socket.IO 的优缺点<a hidden class=anchor aria-hidden=true href=#socketio-的优缺点>#</a></h3><h4 id=socketio-专业人士>Socket.IO 专业人士<a hidden class=anchor aria-hidden=true href=#socketio-专业人士>#</a></h4><ul><li><strong>连接效率：</strong> Socket.IO 使用 HTTP 长轮询发起连接，一旦建立可用性就升级到 WebSocket（有关更多详细信息，请参阅<a href=https://socket.io/docs/v4/how-it-works/#upgrade-mechanism target=_blank>升级机制</a>）。当发生这种情况时，客户端-服务器连接使用单个 WebSocket，而不必启动多个连接，从而减少延迟并改善用户体验。</li><li>**客户端和服务器发起的通信：**由于WebSocket提供了全双工、双向的通信通道，因此服务器可以向客户端发送消息，并且两者可以同时发送消息。</li><li><strong>事件驱动的通信：</strong> WebSocket是一种事件驱动的协议，这意味着您可以在收到消息后立即监听并响应消息，而不是使用轮询机制来检查更新，这样既浪费又低效。</li><li><strong>丰富的功能集：</strong> Socket.IO 提供了实现实时应用程序所需的一切。当使用原始 HTTP 甚至原始 WebSocket 时，您必须自己实现其中大部分功能。</li><li><strong>有状态：</strong> Socket.IO 使用 WebSocket，它是有状态的。该状态一直持续到连接关闭为止。</li></ul><h4 id=socketio-缺点>Socket.IO 缺点<a hidden class=anchor aria-hidden=true href=#socketio-缺点>#</a></h4><ul><li>**有限的平台支持：**我们之前提到，Socket.IO 在不同的平台和语言上有多种服务器和客户端实现。值得一提的是，其中一些没有得到积极维护，或者功能集有限，因此在考虑使用它们之前请仔细检查它们。此外，Socket.IO 实现与本机 WebSocket 不兼容，因为 Socket.IO 会向其发送的每个数据包添加额外的元数据。</li><li><strong>可扩展性：</strong> Socket.IO 非常适合有限数量用户的实时通信应用程序。但是，如果您的用户数量和数据量开始变大，您的服务器可能会过载。当您的服务器达到最大负载时，您将需要将连接拆分到多个服务器上，否则可能会丢失重要信息。这种增加的架构复杂性带来了更多问题。阅读<a href=https://ably.com/topic/scaling-socketio target=_blank>Scaling Socket.IO - 实际注意事项</a>以获取更多信息。</li><li>**内存泄漏：**已知 Socket.IO 存在<a href=https://serverfault.com/questions/1066025/how-to-fix-ws-and-socket-io-memory-leak target=_blank>一些与内存泄漏相关的问题</a>。内存泄漏不太可能导致任何直接问题，但如果您的应用程序使用了很长一段时间，它们最终可能会导致用户的设备冻结或崩溃。</li></ul><h2 id=什么是-http>什么是 HTTP？<a hidden class=anchor aria-hidden=true href=#什么是-http>#</a></h2><p>HTTP 是一种请求/响应协议，作为 Web 的主要通信机制，构建在 TCP 网络协议之上。有限版本最初由 Tim Berners-Lee 于 1989 年提出，随后经过快速修改以支持更广泛的浏览器和服务器功能。 HTTP 工作组于 1996 年将这些修改记录为 HTTP/1.0 ( <a href=https://tools.ietf.org/html/rfc1945 target=_blank>RFC 1945</a> )。</p><p>HTTP 在 RESTful 架构（即 REST API）中很常见。 REST 的经典用例是 CRUD 应用程序，其中 HTTP POST、PUT、GET、PUT 和 DELETE 动词提供了一种简单的方法来实现创建、读取、更新和删除数据的操作。</p><p><strong>传统的 HTTP 消息流如下所示：</strong></p><p><img loading=lazy src="https://images.ctfassets.net/ee3ypdtck0rk/1kp3L78PA3GizIQ9P8fPFZ/8fc93fc45005d6d0122c08f00d64873f/http-request-response-cycle.png?w=1841&amp;h=653&amp;q=50&amp;fm=png" alt=img></p><p><strong>HTTP 技术的出现可以实现实时应用程序：</strong></p><ul><li><a href=https://ably.com/topic/long-polling target=_blank><strong>长轮询</strong></a>**：**对 HTTP 服务器的重复请求会浪费资源 - 在每个请求中，您都必须建立一个新连接，解析 HTTP 标头，查询新数据，生成和传递响应，以及关闭和清理连接。长轮询通过尽可能长时间地保持客户端-服务器连接打开，在新数据可用或达到超时阈值时提供响应来改进这一点。正如本文前面提到的，当 WebSocket 不可用时，Socket.IO 会转而使用 HTTP 长轮询。</li><li><a href=https://ably.com/topic/server-sent-events target=_blank><strong>服务器发送事件 (SSE)</strong></a><strong>：</strong> SSE 允许浏览器订阅服务器生成的事件流，并在新事件发生时接收更新。 EventSource<a href=https://developer.mozilla.org/en-US/docs/Web/API/EventSource target=_blank>接口接受特定 URL 处的 HTTP 流连接，</a>并在检索可用数据时保持连接打开。 SSE 听起来像是 WebSocket 的有力竞争对手，但它是单向的。</li></ul><h3 id=http-关键特性>HTTP 关键特性<a hidden class=anchor aria-hidden=true href=#http-关键特性>#</a></h3><p>我们已经看到了 HTTP 的多个新版本，每个版本都添加了新功能。</p><ul><li>**HTTP/1.1 (1997)：**引入了一些重要的增强功能，最显着的是<a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive target=_blank>Keep-Alive</a>标头（允许连接处理多个请求）和<a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade target=_blank>Upgrade</a>标头（将连接升级到增强协议，例如 WebSockets）。</li><li>**HTTP/2 (2015)：**这是一项性能更新，旨在提高 Web 通信的速度。 HTTP/2 包括：<ul><li>多路复用，涉及帧内的二进制数据封装，沿着多个称为流的双向通道发送，全部通过单个 TCP 连接，允许同时发生许多并行请求/响应。</li><li>服务器推送，一种允许服务器在客户端请求响应之前将响应发送到兼容 HTTP/2 的客户端的功能。当服务器知道客户端需要“推送”响应来完全处理原始请求时，此功能非常有用。</li></ul></li><li>**HTTP/3（自 2018 年开始开发）：**旨在使用称为 QUIC 的不同传输层网络协议解决 HTTP/2 的传输相关问题（例如延迟），该协议在用户数据报协议 (UDP) 而不是 TCP 上运行。</li></ul><h3 id=http-的优点和缺点>HTTP 的优点和缺点<a hidden class=anchor aria-hidden=true href=#http-的优点和缺点>#</a></h3><h4 id=http-优点>HTTP 优点：<a hidden class=anchor aria-hidden=true href=#http-优点>#</a></h4><ul><li>**平台支持：**每个服务器端平台和非浏览器客户端平台（想想用 Kotlin 构建的 Android 客户端，或用 Rust 构建的桌面应用程序）都具有出色的 HTTP 支持。如果您使用的平台对 Socket.IO 等库没有良好的支持，您可能会选择在标准 HTTP 之上实现解决方案。</li></ul><h4 id=http-缺点>HTTP 缺点：<a hidden class=anchor aria-hidden=true href=#http-缺点>#</a></h4><ul><li>**连接效率：**尽管 Keep-Alive 标头和长轮询允许在每个连接上发送多个请求，但仍然需要多个连接，并且开销比基于 WebSocket 的解决方案（如 Socket.IO）更大。这会导致延迟增加和用户体验变差。</li><li>**单向通信：**在标准 HTTP 中，所有请求均由客户端发起，响应由服务器处理。 SSE 提供来自服务器的通信流，但这仍然只是单向的。</li><li>**缺乏事件驱动的通信：**尽管 SSE 允许在事件发生时使用事件来响应来自服务器的消息。在服务器上监听和响应来自客户端的消息仍然需要轮询机制来不断检查更新，这是浪费且低效的。</li><li>**有限的功能集：**使用原始 HTTP 将要求您自己实现应用程序所需的功能集，或者找到其他库来帮助您。</li><li>**无状态：**每次通信完成后，连接关闭，状态丢失。</li></ul><h2 id=socketio-和-http-有什么区别>Socket.IO 和 HTTP 有什么区别？<a hidden class=anchor aria-hidden=true href=#socketio-和-http-有什么区别>#</a></h2><p>下表快速总结了 Socket.IO 和 HTTP 之间的主要区别。</p><table><thead><tr><th style=text-align:left><strong>套接字IO</strong></th><th style=text-align:left><strong>HTTP协议</strong></th></tr></thead><tbody><tr><td style=text-align:left>良好的浏览器兼容性，可回退到 HTTP 长轮询</td><td style=text-align:left>优秀的浏览器兼容性</td></tr><tr><td style=text-align:left>服务器端平台兼容性和非浏览器客户端兼容性尚可，部分地方存在差距</td><td style=text-align:left>出色的服务器端和非浏览器客户端兼容性</td></tr><tr><td style=text-align:left>双向通讯</td><td style=text-align:left>单向通讯</td></tr><tr><td style=text-align:left>事件驱动的通信</td><td style=text-align:left>非事件驱动通信（使用 SSE，事件驱动通信仅适用于从服务器到客户端）</td></tr><tr><td style=text-align:left>出色的连接效率——一旦建立，WebSocket 连接的整个生命周期都需要单个 TCP 连接</td><td style=text-align:left>连接效率良好——通信生命周期内需要多个连接</td></tr><tr><td style=text-align:left>有状态的</td><td style=text-align:left>无国籍</td></tr><tr><td style=text-align:left>丰富的功能集</td><td style=text-align:left>功能需要自行实现</td></tr></tbody></table><h2 id=我应该使用-socketio-还是-http>我应该使用 Socket.IO 还是 HTTP？<a hidden class=anchor aria-hidden=true href=#我应该使用-socketio-还是-http>#</a></h2><p>这取决于您的用例；在本节中，我们将研究两者的合适用例。</p><h3 id=何时使用-socketio>何时使用 Socket.IO<a hidden class=anchor aria-hidden=true href=#何时使用-socketio>#</a></h3><p>Socket.IO 非常适合构建涉及多个用户和服务器之间的消息交换的任何应用程序，您希望在其中维护整体状态并希望获得响应式双向实时用户体验。示例包括聊天/消息应用程序、多用户游戏、协作编辑（例如 Google 文档）、基于位置的应用程序等。</p><p>Socket.IO 具有良好的跨浏览器兼容性，但其对不同平台（即非 JavaScript/Node.js）的支持可能参差不齐。如果您使用的是良好支持的客户端/服务器组合，并且您不关心支持旧版浏览器，那么 Socket.IO 就可以了。如果您需要替代方案，请阅读我们的<a href=https://ably.com/topic/socketio-alternatives target=_blank>Socket.IO 替代方案</a>文章以获取选项。</p><h3 id=何时使用-http>何时使用 HTTP<a hidden class=anchor aria-hidden=true href=#何时使用-http>#</a></h3><p>HTTP 非常适合多用户应用程序，在这些应用程序中，您不需要两个方向的实时响应，但您仍然关心每个客户端和服务器之间可靠、安全的数据交换。想想传统的 REST/CRUD 应用程序——银行应用程序、电子邮件应用程序、天气应用程序和电子商务应用程序。</p><p>如果您想要实时响应，但仅限于从服务器到客户端，那么 SSE 是一个可行的解决方案。 SSE 对于提供实时信息更新的应用程序很有用，但用户只是消费数据，而不是写入数据。很好的例子可能包括股票行情或新闻行情应用程序。</p><p>HTTP 是一项非常成熟的技术，对 Web 浏览器、服务器平台和非浏览器客户端类型提供大力支持。如果您担心对 Socket.IO 等库的支持不完整，请考虑使用原始 HTTP 构建您的应用程序。</p><h2 id=总体而言socketio-和-http-哪个更好>总体而言，Socket.IO 和 HTTP 哪个更好？<a hidden class=anchor aria-hidden=true href=#总体而言socketio-和-http-哪个更好>#</a></h2><p>您应该使用 Socket.IO 还是 HTTP 取决于您的用例。 Socket.IO 等基于 WebSocket 的解决方案对于构建具有低延迟、高效连接和高性能要求的实时应用程序至关重要。然而，当涉及到平台兼容性和可扩展性时，Socket.IO 可能会下降——如果这些出现问题，HTTP 可能是更好的方法。</p><p>Ably 是 Socket.IO 的替代品，具有强大的发布/订阅消息传递、针对每种主要语言和开发平台的超过 25 个 SDK、可用的专门专家支持等等。有关详细比较，请参阅<a href=https://ably.com/compare/ably-vs-socketio target=_blank>Ably 与 Socket.IO</a>。借助可用的 WebSocket 和 REST 库，您可以轻松集成。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/socketio/>Socketio</a></li><li><a href=https://blog.chensoul.cc/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/><span class=title>« Prev</span><br><span>[译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/><span class=title>Next »</span><br><span>[译]2024年最好的WebSocket替代品</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]比较 Socket.IO 和 HTTP：主要区别和用例 on x" href="https://x.com/intent/tweet/?text=%5b%e8%af%91%5d%e6%af%94%e8%be%83%20Socket.IO%20%e5%92%8c%20HTTP%ef%bc%9a%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab%e5%92%8c%e7%94%a8%e4%be%8b&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f08%2fsocketio-vs-http%2f&amp;hashtags=socketio%2cjava"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]比较 Socket.IO 和 HTTP：主要区别和用例 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f08%2fsocketio-vs-http%2f&amp;title=%5b%e8%af%91%5d%e6%af%94%e8%be%83%20Socket.IO%20%e5%92%8c%20HTTP%ef%bc%9a%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab%e5%92%8c%e7%94%a8%e4%be%8b&amp;summary=%5b%e8%af%91%5d%e6%af%94%e8%be%83%20Socket.IO%20%e5%92%8c%20HTTP%ef%bc%9a%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab%e5%92%8c%e7%94%a8%e4%be%8b&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f08%2fsocketio-vs-http%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]比较 Socket.IO 和 HTTP：主要区别和用例 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f08%2fsocketio-vs-http%2f&title=%5b%e8%af%91%5d%e6%af%94%e8%be%83%20Socket.IO%20%e5%92%8c%20HTTP%ef%bc%9a%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab%e5%92%8c%e7%94%a8%e4%be%8b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]比较 Socket.IO 和 HTTP：主要区别和用例 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f08%2fsocketio-vs-http%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]比较 Socket.IO 和 HTTP：主要区别和用例 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5d%e6%af%94%e8%be%83%20Socket.IO%20%e5%92%8c%20HTTP%ef%bc%9a%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab%e5%92%8c%e7%94%a8%e4%be%8b%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f08%2fsocketio-vs-http%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]比较 Socket.IO 和 HTTP：主要区别和用例 on telegram" href="https://telegram.me/share/url?text=%5b%e8%af%91%5d%e6%af%94%e8%be%83%20Socket.IO%20%e5%92%8c%20HTTP%ef%bc%9a%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab%e5%92%8c%e7%94%a8%e4%be%8b&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f08%2fsocketio-vs-http%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]比较 Socket.IO 和 HTTP：主要区别和用例 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%e8%af%91%5d%e6%af%94%e8%be%83%20Socket.IO%20%e5%92%8c%20HTTP%ef%bc%9a%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab%e5%92%8c%e7%94%a8%e4%be%8b&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f05%2f08%2fsocketio-vs-http%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>