<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[译]JMS 2.0 中的新增功能（第一部分）- 易于使用 | ChenSoul</title>
<meta name=keywords content="jms"><meta name=description content="原文链接：https://www.oracle.com/technical-resources/articles/java/jms20.html
作者：Nigel Deakin 出版日期：2013 年 5 月
了解新的易用性功能如何使您编写更少的代码行。
本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在第二部分中，我们将介绍新的消息传递特性。
JMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。
JMS 2.0 的重点是追赶其他企业 Java 技术的易用性改进。虽然企业 JavaBeans 或 Java 持久性等技术现在比十年前使用起来简单得多，但 JMS 仍然保持着成功但相当冗长的 API。
JMS 2.0 中最大的变化是引入了用于发送和接收消息的新 API，从而减少了开发人员必须编写的代码量。对于在 Java EE 应用服务器中运行的应用程序，新 API 还支持资源注入。这允许应用服务器负责创建和管理 JMS 对象，从而进一步简化应用程序。
JMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序，也可以在 Java SE 环境中独立使用。正如我在下面解释的那样，这里描述的某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。
简化的 API 新 API 称为简化 API。顾名思义，它旨在比现有的 JMS 1.1 API 更简单、更易于使用，而后者现在（相当可预测地）被称为经典 API。
简化的 API 包含三个新接口：JMSContext、JMSProducer和JMSConsumer：
JMSContext用单个对象替换经典 API 中单独的Connection和Session对象。 JMSProducer是经典 API 中对象的轻量级替代品。它允许使用方法链（有时称为构建器模式MessageProducer）配置消息传递选项、标头和属性。 JMSConsumer替代了MessageConsumer经典API中的对象，使用方式类似。 开发人员现在可以选择是使用传统 API（JMS 1."><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/2024/07/24/jms20/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/2024/07/24/jms20/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="[译]JMS 2.0 中的新增功能（第一部分）- 易于使用"><meta property="og:description" content="原文链接：https://www.oracle.com/technical-resources/articles/java/jms20.html
作者：Nigel Deakin 出版日期：2013 年 5 月
了解新的易用性功能如何使您编写更少的代码行。
本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在第二部分中，我们将介绍新的消息传递特性。
JMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。
JMS 2.0 的重点是追赶其他企业 Java 技术的易用性改进。虽然企业 JavaBeans 或 Java 持久性等技术现在比十年前使用起来简单得多，但 JMS 仍然保持着成功但相当冗长的 API。
JMS 2.0 中最大的变化是引入了用于发送和接收消息的新 API，从而减少了开发人员必须编写的代码量。对于在 Java EE 应用服务器中运行的应用程序，新 API 还支持资源注入。这允许应用服务器负责创建和管理 JMS 对象，从而进一步简化应用程序。
JMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序，也可以在 Java SE 环境中独立使用。正如我在下面解释的那样，这里描述的某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。
简化的 API 新 API 称为简化 API。顾名思义，它旨在比现有的 JMS 1.1 API 更简单、更易于使用，而后者现在（相当可预测地）被称为经典 API。
简化的 API 包含三个新接口：JMSContext、JMSProducer和JMSConsumer：
JMSContext用单个对象替换经典 API 中单独的Connection和Session对象。 JMSProducer是经典 API 中对象的轻量级替代品。它允许使用方法链（有时称为构建器模式MessageProducer）配置消息传递选项、标头和属性。 JMSConsumer替代了MessageConsumer经典API中的对象，使用方式类似。 开发人员现在可以选择是使用传统 API（JMS 1."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2024/07/24/jms20/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-24T08:00:00+08:00"><meta property="article:modified_time" content="2024-07-24T08:00:00+08:00"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]JMS 2.0 中的新增功能（第一部分）- 易于使用"><meta name=twitter:description content="原文链接：https://www.oracle.com/technical-resources/articles/java/jms20.html
作者：Nigel Deakin 出版日期：2013 年 5 月
了解新的易用性功能如何使您编写更少的代码行。
本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在第二部分中，我们将介绍新的消息传递特性。
JMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。
JMS 2.0 的重点是追赶其他企业 Java 技术的易用性改进。虽然企业 JavaBeans 或 Java 持久性等技术现在比十年前使用起来简单得多，但 JMS 仍然保持着成功但相当冗长的 API。
JMS 2.0 中最大的变化是引入了用于发送和接收消息的新 API，从而减少了开发人员必须编写的代码量。对于在 Java EE 应用服务器中运行的应用程序，新 API 还支持资源注入。这允许应用服务器负责创建和管理 JMS 对象，从而进一步简化应用程序。
JMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序，也可以在 Java SE 环境中独立使用。正如我在下面解释的那样，这里描述的某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。
简化的 API 新 API 称为简化 API。顾名思义，它旨在比现有的 JMS 1.1 API 更简单、更易于使用，而后者现在（相当可预测地）被称为经典 API。
简化的 API 包含三个新接口：JMSContext、JMSProducer和JMSConsumer：
JMSContext用单个对象替换经典 API 中单独的Connection和Session对象。 JMSProducer是经典 API 中对象的轻量级替代品。它允许使用方法链（有时称为构建器模式MessageProducer）配置消息传递选项、标头和属性。 JMSConsumer替代了MessageConsumer经典API中的对象，使用方式类似。 开发人员现在可以选择是使用传统 API（JMS 1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"},{"@type":"ListItem","position":2,"name":"[译]JMS 2.0 中的新增功能（第一部分）- 易于使用","item":"https://blog.chensoul.cc/posts/2024/07/24/jms20/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[译]JMS 2.0 中的新增功能（第一部分）- 易于使用","name":"[译]JMS 2.0 中的新增功能（第一部分）- 易于使用","description":"原文链接：https://www.oracle.com/technical-resources/articles/java/jms20.html\n作者：Nigel Deakin 出版日期：2013 年 5 月\n了解新的易用性功能如何使您编写更少的代码行。\n本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在第二部分中，我们将介绍新的消息传递特性。\nJMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。\nJMS 2.0 的重点是追赶其他企业 Java 技术的易用性改进。虽然企业 JavaBeans 或 Java 持久性等技术现在比十年前使用起来简单得多，但 JMS 仍然保持着成功但相当冗长的 API。\nJMS 2.0 中最大的变化是引入了用于发送和接收消息的新 API，从而减少了开发人员必须编写的代码量。对于在 Java EE 应用服务器中运行的应用程序，新 API 还支持资源注入。这允许应用服务器负责创建和管理 JMS 对象，从而进一步简化应用程序。\nJMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序，也可以在 Java SE 环境中独立使用。正如我在下面解释的那样，这里描述的某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。\n简化的 API 新 API 称为简化 API。顾名思义，它旨在比现有的 JMS 1.1 API 更简单、更易于使用，而后者现在（相当可预测地）被称为经典 API。\n简化的 API 包含三个新接口：JMSContext、JMSProducer和JMSConsumer：\nJMSContext用单个对象替换经典 API 中单独的Connection和Session对象。 JMSProducer是经典 API 中对象的轻量级替代品。它允许使用方法链（有时称为构建器模式MessageProducer）配置消息传递选项、标头和属性。 JMSConsumer替代了MessageConsumer经典API中的对象，使用方式类似。 开发人员现在可以选择是使用传统 API（JMS 1.","keywords":["jms"],"articleBody":"原文链接：https://www.oracle.com/technical-resources/articles/java/jms20.html\n作者：Nigel Deakin 出版日期：2013 年 5 月\n了解新的易用性功能如何使您编写更少的代码行。\n本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在第二部分中，我们将介绍新的消息传递特性。\nJMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。\nJMS 2.0 的重点是追赶其他企业 Java 技术的易用性改进。虽然企业 JavaBeans 或 Java 持久性等技术现在比十年前使用起来简单得多，但 JMS 仍然保持着成功但相当冗长的 API。\nJMS 2.0 中最大的变化是引入了用于发送和接收消息的新 API，从而减少了开发人员必须编写的代码量。对于在 Java EE 应用服务器中运行的应用程序，新 API 还支持资源注入。这允许应用服务器负责创建和管理 JMS 对象，从而进一步简化应用程序。\nJMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序，也可以在 Java SE 环境中独立使用。正如我在下面解释的那样，这里描述的某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。\n简化的 API 新 API 称为简化 API。顾名思义，它旨在比现有的 JMS 1.1 API 更简单、更易于使用，而后者现在（相当可预测地）被称为经典 API。\n简化的 API 包含三个新接口：JMSContext、JMSProducer和JMSConsumer：\nJMSContext用单个对象替换经典 API 中单独的Connection和Session对象。 JMSProducer是经典 API 中对象的轻量级替代品。它允许使用方法链（有时称为构建器模式MessageProducer）配置消息传递选项、标头和属性。 JMSConsumer替代了MessageConsumer经典API中的对象，使用方式类似。 开发人员现在可以选择是使用传统 API（JMS 1.1 中熟悉的Connection、Session、MessageProducer和MessageConsumer对象）还是简化的 API（JMS 2.0 中引入的 JMSContext、JMSProducer 和 JMSConsumer 对象）。\n简化版 API 提供经典 API 的所有功能以及一些附加功能。经典 API 并未弃用，并将无限期地保留为 JMS 的一部分。\n使用简化 API 发送消息 JMS 1.1 经典 API 已经使用了十多年，并且已经证明了它的实用性。JMS 2.0 简化 API 在哪些方面更胜一筹？JMS 2.0 简化 API 需要的代码更少。\n清单 1 展示了一个使用经典 API 发送单条文本消息的简单示例。\npublic void sendMessageJMS11(ConnectionFactory connectionFactory, Queue queue,String text) { try { Connection connection = connectionFactory.createConnection(); try { Session session =connection.createSession(false,Session.AUTO_ACKNOWLEDGE); MessageProducer messageProducer = session.createProducer(queue); TextMessage textMessage = session.createTextMessage(text); messageProducer.send(textMessage); } finally { connection.close(); } } catch (JMSException ex) { // handle exception (details omitted) } } 清单 1\n现在比较清单 1 和清单 2，它展示了我们如何在 JMS 2.0 中使用简化的 API 做完全相同的事情：\npublic void sendMessageJMS20(ConnectionFactory connectionFactory, Queue queue, String text) { try (JMSContext context = connectionFactory.createContext();){ context.createProducer().send(queue, text); } catch (JMSRuntimeException ex) { // handle exception (details omitted) } } 清单 2\n如您所见，我们需要编写的代码量显著减少。让我们更详细地看一下。\n我们不是创建单独的Connection对象Session，而是创建单个JMSContext对象。\nJMS 1.1 版本在使用 Connection 后使用时使用了一个 finally 块来调用 close 。在 JMS 2.0 中，对象 JMSContext 还有一个 close 方法，需要在使用后调用。但是，无需从代码中显式调用 close 。 JMSContext 实现 Java SE 7 java.lang.AutoCloseable 接口。这意味着，如果我们在 try-with-resources 块中创建 JMSContext （这也是 Java SE 7 的一个新功能），该方法将在块的末尾自动调用， close 而无需将其显式添加到您的代码中。\n事实上，所有具有 close 方法的 JMS 接口都已扩展以实现该 java.lang.AutoCloseable 接口，因此它们都可以在 try -with-resources 块中使用 。这包括 Connection 和 Session 接口以及 JMSContext 。因此，即使您使用的是经典 API，您仍然可以从此功能中受益。请注意，由于此更改，JMS 2.0 只能与 Java SE 7 一起使用。\n当 JMS 1.1 版本创建对象 Session 时，它传入参数 （ false 和 Session.AUTO_ACKNOWLEDGE ） 来指定我们想要创建一个非事务处理会话，在该会话中，任何接收到的消息都将被自动确认。在 JMS 2.0 中，这是默认设置（对于 Java SE 应用程序），因此我们不需要指定任何参数。\n如果我们想指定其他会话模式之一（本地事务、 CLIENT_ACKNOWLEDGE 或 DUPS_OK_ACKNOWLEDGE ），我们将只传入一个参数而不是两个参数。\n无需创建对象TextMessage并将其主体设置为指定的字符串。相反，我们只需将字符串传递给方法即可send。JMS 提供程序将自动创建一个TextMessage并将其主体设置为提供的字符串。\nJMS 1.1 示例catch为JMSException几乎所有方法都会抛出的 提供了一个块。JMS 2.0 简化 API 示例有一个类似的块，但它会捕获JMSRuntimeException。\n简化 API 的一个特点是其方法不声明已检查的异常。如果遇到错误情况，则会JMSRuntimeException抛出异常。此新异常是 RuntimeException 的子类，这意味着它不需要由调用方法显式捕获或在其throws子句中声明。这与经典 API 形成对比，在经典 API 中，几乎每个方法都声明为抛出异常JMSException，调用方法必须捕获或自行抛出异常。\n清单 1 和清单 2 均显示将ConnectionFactory和Queue对象作为参数传入。获取这些对象的方式没有改变，因此我们不会在此处或本文的其他清单中介绍这一点。通常，它们将通过从 JNDI 存储库进行 JNDI 查找来获取。\n使用简化 API 同步接收消息 清单 3 展示了一个使用 JMS 1.1 同步接收单一消息TextMessage并提取其文本的简单示例。\npublic String receiveMessageJMS11(ConnectionFactory connectionFactory,Queue queue){ String body=null; try { Connection connection = connectionFactory.createConnection(); try { Session session =connection.createSession(false,Session.AUTO_ACKNOWLEDGE); MessageConsumer messageConsumer = session.createConsumer(queue); connection.start(); TextMessage textMessage = TextMessage)messageConsumer.receive(); body = textMessage.getText(); } finally { connection.close(); } } catch (JMSException ex) { // handle exception (details omitted) } return body; } 清单 3\n清单 4 显示了如何使用 JMS 2.0 中的简化 API 做同样的事情：\npublic String receiveMessageJMS20( ConnectionFactory connectionFactory,Queue queue){ String body=null; try (JMSContext context = connectionFactory.createContext();){ JMSConsumer consumer = session.createConsumer(queue); body = consumer.receiveBody(String.class); } catch (JMSRuntimeException ex) { // handle exception (details omitted) } return body; } 清单 4\n与发送消息一样，我们需要编写的代码量减少了。部分原因与前面的示例相同：\n我们不是创建单独的Connection对象Session，而是创建单个JMSContext对象。 我们可以在 try-with-resources 块中创建 JMSContext，这样它就会在块结束时自动关闭。这样就无需调用close。 我们不需要指定希望自动确认收到的消息，因为这是默认的。 此外，JMS 2.0 还通过另外两种方式减少接收消息所需的代码量：\n在 JMS 1.1 中，我们需要调用connection.start()来开始向消费者传递消息，而在 JMS 2.0 简化 API 中则不需要：连接会自动启动。（如果需要，您可以禁用此行为。） 无需接收对象Message，将其转换为TextMessage，然后调用getText来提取消息正文。相反，我们调用receiveBody，它直接返回消息正文。 使用简化 API 异步接收消息 前面的示例展示了如何通过调用一个方法来同步接收消息，该方法是阻塞的，直到收到消息或发生超时。\n如果您需要在 Java SE 应用程序中异步接收消息，则在 JMS 1.1 中，您需要创建一个MessageConsumer对象，然后使用方法setMessageListener指定实现该接口的对象MessageListener。然后您需要调用connection.start()以开始传递消息：\nMessageConsumer messageConsumer = session.createConsumer(queue); messageConsumer.setMessageListener(messageListener); connection.start(); JMS 2.0 简化 API 代码类似。您需要创建一个JMSConsumer对象，然后使用方法setMessageListener指定实现该接口的对象MessageListener。消息传递会自动启动；无需调用start。\nJMSConsumer consumer = context.createConsumer(queue); consumer.setMessageListener(messageListener); 请注意，如果您需要在 Java EE 7 Web 或 EJB 应用程序中异步接收消息，那么与以前版本的 Java EE 一样，您需要使用消息驱动 Bean 而不是方法setMessageListener。\n注入JMSContextJava EE 应用程序 如果您正在编写 Java EE Web 或 EJB 应用程序，那么使用 JMS 2.0 简化 API 甚至比在 Java SE 中更容易。这是因为您现在可以将“注入”到JMSContext您的代码中，并让应用服务器确定何时创建它以及何时关闭它。\n以下代码是 Java EE 7 会话 bean 或 servlet 的一个片段，它注入JMSContext并使用它来发送消息：\n@Inject @JMSConnectionFactory(\"jms/connectionFactory\") private JMSContext context; @Resource(lookup = \"jms/dataQueue\") private Queue dataQueue; public void sendMessageJavaEE7(String body) { context.send(dataQueue, body); } 如您所见，没有代码可以创建它 JMSContext ，也没有代码可以关闭它。取而代之的是，我们只需声明一个类型的 JMSContext 字段并添加注释 @Inject 和 @JMSConnectionFactory .\n注释 @Inject 告诉容器在需要时创建。 JMSContext 注释 @JMSConnectionFactory 告诉容器它应该使用的 JNDI 名称 ConnectionFactory 。\n如果在 JTA 事务中使用注入 JMSContext 的事务（无论是容器管理的还是 Bean 管理的），则认为 JMSContext 具有事务作用域。这意味着在提交 JTA 事务后，将 JMSContext 自动关闭。\n如果在没有 JTA 事务的情况下使用注入 JMSContext 的，则认为 具有 JMSContext 请求范围。这意味着当请求结束时，将关闭。 JMSContext 请求的长度在上下文和依赖关系注入 （CDI） 规范中定义，它通常与来自客户端的 HTTP 请求或消息驱动的 Bean 接收的消息相关。\n注入除了由应用程序服务器自动创建和关闭之外，还 JMSContext 具有一些强大的功能。最重要的是，如果一个 servlet 调用了一个会话 bean，或者一个会话 bean 调用另一个会话 bean，并且都使用一个 injected JMSContext ，那么只要两个注入 JMSContext 的对象以相同的方式定义（例如，它们具有相同的 JMSConnectionFactory 注释），它们实际上将对应于同一个 JMSContext 对象。这样可以减少应用程序使用的 JMS 连接数。\nJMS 2.0 中的其他 API 简化 JMS 2.0 还提供了其他一些简化。\n直接从邮件中提取正文的新方法 JMS 消息由三部分组成：\n邮件标题 消息属性 邮件正文 正文的类型随消息类型而变化： TextMessage 的消息体是 String 。 BytesMessage 的消息体是一个字节数组，依此类推。\n在 JMS 1.1 中，消息体是使用特定于消息类型的方法获取的，例如 on getText TextMessage 的方法。但是，当应用程序接收到消息时，JMS API 始终将消息作为 javax.jms.Message 对象提供，在获取正文之前，需要将其转换为适当的子类型。当消息是从对 的 receive 调用返回的，以及当消息是通过对 onMessage 的方法 MessageListener 的调用异步传递时，这都适用。\n例如，如果您使用该 receive 方法来接收 ， TextMessage 则需要将返回的对象从 Message 转换为 TextMessage ，然后调用该 getText 方法：\nMessage message = consumer.receive(1000); // returns a TextMessage String body = ((TextMessage) message).getText(); JMS 2.0 增加了一种新方法，使提取消息正文变得稍微简单一些。这就是getBody上的方法Message，它可供传统 API 和简化 API 的用户使用。此方法将预期的正文类型作为参数，不需要您对消息或正文执行强制类型转换：\nMessage message = consumer.receive(1000); // returns a TextMessage String body = message.getBody(String.class); 让我们看看如何getBody简化获取其他消息类型正文所需的代码。\n如果消息是BytesMessage，JMS 1.1 提供了几种从 中提取字节数组的方法BytesMessage。最简单的方法是调用readBytes上的方法BytesMessage。这会将字节复制到指定的字节数组中。\nMessageListener下面是一个接收BytesMessage并以字节数组形式获取主体的示例：\nvoid onMessage(Message message){ // delivers a BytesMessage int bodyLength = ((BytesMessage)message).getBodyLength(); byte[] bytes = new byte[bodyLength]; int bytesCopied = ((BytesMessage)message).readBytes(bytes); ... 在 JMS 2.0 中，该getBody方法使这一过程变得更加简单：\nvoid onMessage(Message message){ // delivers a BytesMessage byte[] bytes = message.getBody(byte[].class); ... 如果消息是ObjectMessage，则在 JMS 1.1 中，您需要调用getObject方法ObjectMessage，然后将返回的转换Serializable为预期的主体类型：\nvoid onMessage(Message message){ // delivers an ObjectMessage MyObject body = (MyObject)((ObjectMessage) message).getObject(); ... 请注意需要执行两次强制转换。您需要将消息从 强制转换Message为ObjectMessage，以便调用getObject。这会将正文返回为Serializable，然后您需要将其强制转换为实际类型。\n在 JMS 2.0 中，无需任何强制类型转换即可完成此操作：\nvoid onMessage(Message message){ // delivers an ObjectMessage MyObject body = message.getBody(MyObject.class); ... 最后，如果消息是MapMessage，则该getBody方法允许您将正文作为 返回Map：\nMessage message = consumer.receive(1000); // returns a MapMessage Map body = message.getBody(Map.class); getBody不能使用的消息类型是StreamMessage。这是因为流通常由应用程序应单独读取的多个对象组成。\n使用 时getBody，如果指定的类与主体类型不匹配，则会MessageFormatException抛出 。isBodyAssignableTo还向 添加了配套方法Message，它可用于测试后续调用 是否getBody能够将特定Message对象的主体作为特定类型返回。 如果预期的消息类型不止一种，则这很有用。\n直接接收消息正文的方法 在 JMS 1.1 中，同步使用消息的应用程序使用receive()、receive(timeout)或receiveNoWait()上的方法MessageConsumer。\n在 JMS 2.0 中，使用简化 API 的应用程序可以使用 上的相同方法执行此操作JMSConsumer。\n这些方法返回一个Message对象，可以从中获取消息正文。getBody前面描述的方法提供了一种从此对象获取正文的简单方法。\n使用 JMS 2.0 简化 API 的应用程序还有一个附加选项。JMSConsumer提供了三种方法receiveBody(class)— 、receiveBody(class, timeout)和receiveBodyNoWait(class)—，它们将同步接收下一条消息并返回其正文。与 一样getBody，预期的类作为参数传入。\n因此，应用程序可以使用清单 7 中所示的单行代码，而不必使用清单 5 或清单 6 中的代码。\nJMSConsumer consumer = ... Message message = consumer.receive(1000); // returns a TextMessage String body = ((TextMessage) message).getText(); 清单 5\nJMSConsumer consumer = ... Message message = consumer.receive(1000); // returns a TextMessage String body = message.getBody(String.class); 清单 6\nJMSConsumer consumer = ... String body = consumer.receiveBody(String.class,1000); 清单 7\n这些receiveBody方法可用于接收除StreamMessage（出于同样的原因，此消息类型不支持getBody）和Message（因为它没有正文）之外的任何类型的消息，只要提前知道预期正文的类别即可。\n这些新方法仅添加到JMSConsumer。它们尚未添加到MessageConsumer。这意味着此功能仅适用于使用 JMS 2.0 简化 API 的应用程序。\n此外，这些方法不提供对消息头或属性（例如JMSRedelivered消息头字段或JMSXDeliveryCount消息属性）的访问，因此仅当应用程序不需要访问它们时才应使用它们。\n创建会话的新方法 在 JMS 1.1 中，使用了以下方法javax.jms.Connection来创建javax.jms.Session，其中 transacted 参数需要设置为true或 ，false而acknowledgeMode参数需要设置为Session.AUTO_ACKNOWLEDGE、Session.CLIENT_ACKNOWLEDGE或Session.DUPS_OK_ACKNOWLEDGE。\nSession createSession( boolean transacted, int acknowledgeMode) throws JMSException 这一直是一个相当令人困惑的方法，主要有两个原因：\n它使用两个参数来定义会话的单个方面。 在 Java EE 事务中，这两个参数都会被忽略。 让我们依次考虑这两个问题。\n定义同一事物的两个论据 JMS 1.1 中的方法的第一个问题createSession是，它使用两个参数来定义会话中实际上具有四种可能性的单个方面：\n如果该transacted参数设置为false，则会话为非事务性的，并且该acknowledgeMode参数用于指定在接收消息时应使用三种确认中的哪一种。 如果该transacted参数设置为true，则该acknowledgeMode参数将被忽略。 除了不必要的复杂性之外，这还会导致代码具有潜在的误导性，因为如果将transacted参数设置为，即使忽略该参数false，用户仍必须将参数设置为某个值。例如 acknowledgeMode，以下代码完全有效：\namb Session session = connection.createSession(true,Session.AUTO_ACKNOWLEDGE); 在 Java EE 事务中，两个参数都会被忽略 JMS 1.1 中方法的第二个问题createSession是，在 Java EE Web 或 EJB 应用程序中，如果存在当前 JTA 事务（默认情况下存在），则两个参数都会createSession被忽略。但是，由于 API 强制开发人员指定两个参数，这会导致代码极具误导性，因此编写 EJB bean 的用户可能会编写以下代码，而没有意识到会话实际上会使用 EJB 的容器管理 JTA 事务。\nSession session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); createSession为了解决这些问题，添加了两个名为 的新方法javax.jms.Connection。一个只有一个参数，另一个根本没有参数。我们将依次讨论这两个方法。\nJMS 2.0：createSession带有一个参数 createSession在 JMS 2.0 中，添加了第二种方法javax.jms.Connection。该方法只有一个参数sessionMode：\nSession createSession(int sessionMode) throws JMSException 在普通 Java SE 环境中，sessionMode可以设置为Session.AUTO_ACKNOWLEDGE、Session.CLIENT_ACKNOWLEDGE、Session.DUPS_OK_ACKNOWLEDGE或Session.TRANSACTED。在 Java EE 事务中，sessionMode将被忽略。\nJMS 2.0：createSession无参数 在 Java EE 事务中，即使传递单个参数也会createSession产生误导，因为如果存在 Java EE 事务，该参数将被忽略。为了让用户编写更少误导的代码，createSession添加了第三个javax.jms.Connection没有参数的方法：\nSession createSession() throws JMSException 此方法特别适用于 Java EE 事务，在这种情况下，指定会话模式毫无意义，因为它会被忽略。但是，此方法也可以在普通 Java SE 环境中使用，在这种情况下，它相当于调用createSession(Session.AUTO_ACKNOWLEDGE)。\nJMS 2.0：createSession具有两个参数 现有方法createSession(boolean transacted,int acknowledgeMode)仍可使用，并将无限期地保留为 API 的一部分。不过，我们鼓励开发人员改用此方法的单参数或无参数版本。\nJMS 2.0 中更简单的资源配置 JMS 2.0 通过多种方式使资源配置变得更加容易。\nJava EE 中的默认连接工厂 Java EE 7 引入了平台默认的 JMS 连接工厂。这是一个内置的连接工厂，可连接到应用服务器的内置 JMS 提供程序。\n应用程序可以通过使用名称执行 JNDI 查找来获取此连接工厂，java:comp:DefaultJMSConnectionFactory而无需先前使用管理工具创建连接工厂：\n@Resource(lookup=\"java:comp/DefaultJMSConnectionFactory\") ConnectionFactory cf 此连接工厂旨在供使用内置 JMS 提供程序的众多应用程序使用，无需添加任何特定于应用程序的配置。\n当将 注入JMSContext到应用程序时，JMSConnectionFactory使用注释来指定要使用的连接工厂：\n@Inject @JMSConnectionFactory(\" jms/connectionFactory\") JMSContext context1; 如果省略此注释，则将使用默认连接工厂：\n@Inject JMSContext context2; // uses the platform default connection factory Java EE 中的 JMS 资源定义注释 每个 JMS 应用程序都以一个连接工厂（实现 的对象javax.jms.ConnectionFactory）和至少一个目标（实现 或 的对象javax.jms.Queue）开始javax.jms.Topic。ConnectionFactory是在 JMS 中用于创建与 JMS 提供程序的连接的对象， 或Queue是Topic用于标识要向其发送消息或从其接收消息的物理队列或主题的对象。\n这些对象的创建方式和配置方式因 JMS 提供程序而异。这就是为什么 JMS 建议您使用单独的、提供程序特定的工具来创建、配置应用程序所需的连接工厂和目标并将其绑定到 JNDI 存储中。然后，您的应用程序可以使用 JNDI 查找这些对象，而无需使用任何非标准代码。除了保持应用程序代码的可移植性之外，这还意味着您可以编写代码而无需了解有关如何部署代码的详细信息。\n配置 时ConnectionFactory，通常需要了解 JMS 服务器的主机名和端口等信息。配置Queue或Topic对象时，通常需要了解队列或主题的物理名称。单独创建ConnectionFactory、Queue和Topic对象并将其存储在 JNDI 中，这样部署者或管理员（而不是开发人员）就可以定义这些详细信息。\n尽管在许多企业环境中，将代码与配置分开是必不可少的，但在较简单的环境中，这可能是不必要的负担。此外，如果将应用程序部署到自动化平台即服务 (PaaS) 系统中，则可能需要自动配置应用程序所需的ConnectionFactory、Queue和对象。Topic\n在许多 Java EE 应用程序中，现在任何 Java EE 7 应用服务器中都提供了默认的 JMS 连接工厂（上一节中已介绍），因此根本不需要配置任何连接工厂。但是，对于需要专门配置连接工厂的情况（以及队列和主题），Java EE 7 提供了另一项新功能，允许使用代码中的注释、部署描述符中的 XML 元素或两者的组合来创建这些对象。\n主要的新批注是javax.jms.JMSConnectionFactoryDefinition和javax.jms.JMSDestinationDefinition。它们可以在任何 Java EE 组件类（如 EJB bean 或 servlet）中定义，如清单 8 所示：\n@JMSConnectionFactoryDefinition( name=\"java:global/jms/MyConnectionFactory\", maxPoolSize = 30, minPoolSize= 20, properties = { \"addressList=mq://localhost:7676\", \"reconnectEnabled=true\" } ) @JMSDestinationDefinition( name = \"java:global/jms/DemoQueue\", interfaceName = \"javax.jms.Queue\", destinationName = \"demoQueue\" ) public class NewServlet extends HttpServlet { ... 清单 8\n如果需要定义多个连接工厂或目标，那么这些批注需要包含在JMSConnectionFactoryDefinitions或JMSDestinationDefinitions批注中，如清单 9 所示：\n@JMSConnectionFactoryDefinitions({ @JMSConnectionFactoryDefinition( name=\"java:global/jms/MyConnectionFactory1\", maxPoolSize = 30, minPoolSize= 20, properties = { \"addressList=mq://localhost:7676\", \"reconnectEnabled=true\" } ), @JMSConnectionFactoryDefinition( name=\"java:global/jms/MyConnectionFactory2\", maxPoolSize = 30, minPoolSize= 20, properties = { \"addressList=mq://localhost:7677\", \"reconnectEnabled=true\" } ) }) @JMSDestinationDefinitions({ @JMSDestinationDefinition( name=\"java:global/jms/DemoQueue1\", interfaceName = \"javax.jms.Queue\", destinationName = \"demoQueue1\" ), @JMSDestinationDefinition( name=\"java:global/jms/DemoQueue2\", interfaceName = \"javax.jms.Queue\", destinationName = \"demoQueue2\" ) }) public class NewServlet extends HttpServlet { ... 清单 9\n注释JMSConnectionFactoryDefinition定义了许多可以指定的标准属性，包括name（即 JNDI 名称）、clientId、user、password、maxPoolSize和minPoolSize。此外，properties属性还可用于指定应用服务器可能支持的其他非标准属性。清单 8 和清单 9 中的addressList和reconnectEnabled就是此类非标准属性的示例。\n该JMSConnectionFactoryDefinition注释定义了较少数量的可指定的标准属性，包括name（JNDI 名称）和destinationName（提供程序特定的队列或主题名称），以及允许使用 properties 属性来指定其他非标准属性。\n以这种方式定义的连接工厂和目标必须位于java:comp、java:module、java:app或java:global命名空间中，并且它们通常与定义它们的应用程序部署一样存在。\n还可以在部署描述符文件中指定这些定义（例如 web.xml或ejb-jar.xml），如清单 10 所示：\njava:global/jms/MyConnectionFactory 30 20 addressList mq://localhost:7676 reconnectEnabled true java:global/jms/DemoQueue javax.jms.Queue demoQueue 清单 10\n如果需要，开发人员可以在注释中指定一些必需的属性，而部署者则在部署描述符中指定其余属性。这在属性值直到部署时才知道的情况下非常有用。\n在上述所有示例中，应用服务器负责“配置”注释或部署描述符中定义的 JNDI 资源。但是，部署者仍有责任确保连接工厂引用的 JMS 服务器已安装且可用，并且物理队列和主题本身已创建。\n结论 在本文中，我们介绍了 JMS 2.0 中新增的易用功能，这些功能使开发人员能够编写更少的代码。在第二部分中，我们将介绍 JMS 2.0 中的新消息传递功能。\n也可以看看 JMS 2.0 中的新增功能（第二部分）— 新的消息传送功能 JMS 2.0 下载页面 GlassFish 关于作者 Nigel Deakin 是 Oracle 的首席技术人员，曾担任 JSR 343（Java 消息服务 2.0）的规范负责人。除了负责领导 JMS 规范的下一版本之外，他还是 Oracle JMS 开发团队的成员，致力于 Open Message Queue 和 GlassFish 应用服务器。他最近在美国旧金山的 JavaOne 和比利时安特卫普的 Devoxx 上发表过演讲，目前居住在英国剑桥。\n加入对话 在Facebook、Twitter和Oracle Java 博客上加入 Java 社区讨论！\n","wordCount":"1288","inLanguage":"en","datePublished":"2024-07-24T08:00:00+08:00","dateModified":"2024-07-24T08:00:00+08:00","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2024/07/24/jms20/"},"publisher":{"@type":"Organization","name":"ChenSoul","logo":{"@type":"ImageObject","url":"https://blog.chensoul.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[译]JMS 2.0 中的新增功能（第一部分）- 易于使用</h1><div class=post-meta><span title='2024-07-24 08:00:00 +0800 +0800'>2024-07-24</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1288 words&nbsp;·&nbsp;chensoul</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ae%80%e5%8c%96%e7%9a%84-api aria-label="简化的 API">简化的 API</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e7%ae%80%e5%8c%96-api-%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af aria-label="使用简化 API 发送消息">使用简化 API 发送消息</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e7%ae%80%e5%8c%96-api-%e5%90%8c%e6%ad%a5%e6%8e%a5%e6%94%b6%e6%b6%88%e6%81%af aria-label="使用简化 API 同步接收消息">使用简化 API 同步接收消息</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e7%ae%80%e5%8c%96-api-%e5%bc%82%e6%ad%a5%e6%8e%a5%e6%94%b6%e6%b6%88%e6%81%af aria-label="使用简化 API 异步接收消息">使用简化 API 异步接收消息</a></li><li><a href=#%e6%b3%a8%e5%85%a5jmscontextjava-ee-%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f aria-label="注入JMSContextJava EE 应用程序">注入JMSContextJava EE 应用程序</a></li></ul></li><li><a href=#jms-20-%e4%b8%ad%e7%9a%84%e5%85%b6%e4%bb%96-api-%e7%ae%80%e5%8c%96 aria-label="JMS 2.0 中的其他 API 简化">JMS 2.0 中的其他 API 简化</a><ul><li><a href=#%e7%9b%b4%e6%8e%a5%e4%bb%8e%e9%82%ae%e4%bb%b6%e4%b8%ad%e6%8f%90%e5%8f%96%e6%ad%a3%e6%96%87%e7%9a%84%e6%96%b0%e6%96%b9%e6%b3%95 aria-label=直接从邮件中提取正文的新方法>直接从邮件中提取正文的新方法</a></li><li><a href=#%e7%9b%b4%e6%8e%a5%e6%8e%a5%e6%94%b6%e6%b6%88%e6%81%af%e6%ad%a3%e6%96%87%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=直接接收消息正文的方法>直接接收消息正文的方法</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e4%bc%9a%e8%af%9d%e7%9a%84%e6%96%b0%e6%96%b9%e6%b3%95 aria-label=创建会话的新方法>创建会话的新方法</a></li><li><a href=#%e5%ae%9a%e4%b9%89%e5%90%8c%e4%b8%80%e4%ba%8b%e7%89%a9%e7%9a%84%e4%b8%a4%e4%b8%aa%e8%ae%ba%e6%8d%ae aria-label=定义同一事物的两个论据>定义同一事物的两个论据</a></li><li><a href=#%e5%9c%a8-java-ee-%e4%ba%8b%e5%8a%a1%e4%b8%ad%e4%b8%a4%e4%b8%aa%e5%8f%82%e6%95%b0%e9%83%bd%e4%bc%9a%e8%a2%ab%e5%bf%bd%e7%95%a5 aria-label="在 Java EE 事务中，两个参数都会被忽略">在 Java EE 事务中，两个参数都会被忽略</a></li><li><a href=#jms-20createsession%e5%b8%a6%e6%9c%89%e4%b8%80%e4%b8%aa%e5%8f%82%e6%95%b0 aria-label="JMS 2.0：createSession带有一个参数">JMS 2.0：createSession带有一个参数</a></li><li><a href=#jms-20createsession%e6%97%a0%e5%8f%82%e6%95%b0 aria-label="JMS 2.0：createSession无参数">JMS 2.0：createSession无参数</a></li><li><a href=#jms-20createsession%e5%85%b7%e6%9c%89%e4%b8%a4%e4%b8%aa%e5%8f%82%e6%95%b0 aria-label="JMS 2.0：createSession具有两个参数">JMS 2.0：createSession具有两个参数</a></li></ul></li><li><a href=#jms-20-%e4%b8%ad%e6%9b%b4%e7%ae%80%e5%8d%95%e7%9a%84%e8%b5%84%e6%ba%90%e9%85%8d%e7%bd%ae aria-label="JMS 2.0 中更简单的资源配置">JMS 2.0 中更简单的资源配置</a><ul><li><a href=#java-ee-%e4%b8%ad%e7%9a%84%e9%bb%98%e8%ae%a4%e8%bf%9e%e6%8e%a5%e5%b7%a5%e5%8e%82 aria-label="Java EE 中的默认连接工厂">Java EE 中的默认连接工厂</a></li><li><a href=#java-ee-%e4%b8%ad%e7%9a%84-jms-%e8%b5%84%e6%ba%90%e5%ae%9a%e4%b9%89%e6%b3%a8%e9%87%8a aria-label="Java EE 中的 JMS 资源定义注释">Java EE 中的 JMS 资源定义注释</a></li></ul></li><li><a href=#%e7%bb%93%e8%ae%ba aria-label=结论>结论</a></li><li><a href=#%e4%b9%9f%e5%8f%af%e4%bb%a5%e7%9c%8b%e7%9c%8b aria-label=也可以看看>也可以看看</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e4%bd%9c%e8%80%85 aria-label=关于作者>关于作者</a></li><li><a href=#%e5%8a%a0%e5%85%a5%e5%af%b9%e8%af%9d aria-label=加入对话>加入对话</a></li></ul></div></details></div><div class=post-content><p>原文链接：<a href=https://www.oracle.com/technical-resources/articles/java/jms20.html>https://www.oracle.com/technical-resources/articles/java/jms20.html</a></p><p><em>作者：Nigel Deakin</em>
出版日期：2013 年 5 月</p><p><strong>了解新的易用性功能如何使您编写更少的代码行。</strong></p><p>本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在<a href=https://www.oracle.com/technical-resources/articles/java/jms2messaging.html>第二部分</a>中，我们将介绍新的消息传递特性。</p><p>JMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。</p><p>JMS 2.0 的重点是追赶其他企业 Java 技术的易用性改进。虽然企业 JavaBeans 或 Java 持久性等技术现在比十年前使用起来简单得多，但 JMS 仍然保持着成功但相当冗长的 API。</p><p>JMS 2.0 中最大的变化是引入了用于发送和接收消息的新 API，从而减少了开发人员必须编写的代码量。对于在 Java EE 应用服务器中运行的应用程序，新 API 还支持资源注入。这允许应用服务器负责创建和管理 JMS 对象，从而进一步简化应用程序。</p><p>JMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序，也可以在 Java SE 环境中独立使用。正如我在下面解释的那样，这里描述的某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。</p><h3 id=简化的-api>简化的 API<a hidden class=anchor aria-hidden=true href=#简化的-api>#</a></h3><p>新 API 称为<em>简化 API</em>。顾名思义，它旨在比现有的 JMS 1.1 API 更简单、更易于使用，而后者现在（相当可预测地）被称为<em>经典 API</em>。</p><p>简化的 API 包含三个新接口：<code>JMSContext</code>、<code>JMSProducer</code>和<code>JMSConsumer</code>：</p><ul><li><code>JMSContext</code>用单个对象替换经典 API 中单独的<code>Connection</code>和<code>Session</code>对象。</li><li><code>JMSProducer</code>是经典 API 中对象的轻量级替代品。它允许使用<em>方法链</em>（有时称为<em>构建器模式</em><code>MessageProducer</code>）配置消息传递选项、标头和属性。</li><li><code>JMSConsumer</code>替代了<code>MessageConsumer</code>经典API中的对象，使用方式类似。</li></ul><p>开发人员现在可以选择是使用传统 API（JMS 1.1 中熟悉的<code>Connection</code>、<code>Session</code>、<code>MessageProducer</code>和<code>MessageConsumer</code>对象）还是简化的 API（JMS 2.0 中引入的 <code>JMSContext</code>、<code>JMSProducer </code>和 <code>JMSConsumer</code> 对象）。</p><p>简化版 API 提供经典 API 的所有功能以及一些附加功能。经典 API 并未弃用，并将无限期地保留为 JMS 的一部分。</p><h4 id=使用简化-api-发送消息>使用简化 API 发送消息<a hidden class=anchor aria-hidden=true href=#使用简化-api-发送消息>#</a></h4><p>JMS 1.1 经典 API 已经使用了十多年，并且已经证明了它的实用性。JMS 2.0 简化 API 在哪些方面更胜一筹？JMS 2.0 简化 API 需要的代码更少。</p><p>清单 1 展示了一个使用经典 API 发送单条文本消息的简单示例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sendMessageJMS11</span><span class=p>(</span><span class=n>ConnectionFactory</span><span class=w> </span><span class=n>connectionFactory</span><span class=p>,</span><span class=w> </span><span class=n>Queue</span><span class=w> </span><span class=n>queue</span><span class=p>,</span><span class=n>String</span><span class=w> </span><span class=n>text</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Connection</span><span class=w> </span><span class=n>connection</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>connectionFactory</span><span class=p>.</span><span class=na>createConnection</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>Session</span><span class=w> </span><span class=n>session</span><span class=w> </span><span class=o>=</span><span class=n>connection</span><span class=p>.</span><span class=na>createSession</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=n>Session</span><span class=p>.</span><span class=na>AUTO_ACKNOWLEDGE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>MessageProducer</span><span class=w> </span><span class=n>messageProducer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>session</span><span class=p>.</span><span class=na>createProducer</span><span class=p>(</span><span class=n>queue</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>TextMessage</span><span class=w> </span><span class=n>textMessage</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>session</span><span class=p>.</span><span class=na>createTextMessage</span><span class=p>(</span><span class=n>text</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>messageProducer</span><span class=p>.</span><span class=na>send</span><span class=p>(</span><span class=n>textMessage</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>connection</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>JMSException</span><span class=w> </span><span class=n>ex</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c1>// handle exception (details omitted)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>清单 1</strong></p><p>现在比较清单 1 和清单 2，它展示了我们如何在 JMS 2.0 中使用简化的 API 做完全相同的事情：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sendMessageJMS20</span><span class=p>(</span><span class=n>ConnectionFactory</span><span class=w> </span><span class=n>connectionFactory</span><span class=p>,</span><span class=w> </span><span class=n>Queue</span><span class=w> </span><span class=n>queue</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>text</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>try</span><span class=w> </span><span class=p>(</span><span class=n>JMSContext</span><span class=w> </span><span class=n>context</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>connectionFactory</span><span class=p>.</span><span class=na>createContext</span><span class=p>();){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>context</span><span class=p>.</span><span class=na>createProducer</span><span class=p>().</span><span class=na>send</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span><span class=w> </span><span class=n>text</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>JMSRuntimeException</span><span class=w> </span><span class=n>ex</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c1>// handle exception (details omitted)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>清单 2</strong></p><p>如您所见，我们需要编写的代码量显著减少。让我们更详细地看一下。</p><ul><li><p>我们不是创建单独的<code>Connection</code>对象<code>Session</code>，而是创建单个<code>JMSContext</code>对象。</p></li><li><p>JMS 1.1 版本在使用 <code>Connection</code> 后使用时使用了一个 <code>finally</code> 块来调用 <code>close</code> 。在 JMS 2.0 中，对象 <code>JMSContext</code> 还有一个 <code>close</code> 方法，需要在使用后调用。但是，无需从代码中显式调用 <code>close</code> 。 <code>JMSContext</code> 实现 Java SE 7 <code>java.lang.AutoCloseable</code> 接口。这意味着，如果我们在 <code>try-with-resources</code> 块中创建 <code>JMSContext</code> （这也是 Java SE 7 的一个新功能），该方法将在块的末尾自动调用， <code>close</code> 而无需将其显式添加到您的代码中。</p><p>事实上，所有具有 <code>close</code> 方法的 JMS 接口都已扩展以实现该 <code>java.lang.AutoCloseable</code> 接口，因此它们都可以在 <code>try -with-resources</code> 块中使用 。这包括 <code>Connection</code> 和 <code>Session</code> 接口以及 <code>JMSContext</code> 。因此，即使您使用的是经典 API，您仍然可以从此功能中受益。请注意，由于此更改，JMS 2.0 只能与 Java SE 7 一起使用。</p></li><li><p>当 JMS 1.1 版本创建对象 <code>Session</code> 时，它传入参数 （ <code>false</code> 和 <code>Session.AUTO_ACKNOWLEDGE</code> ） 来指定我们想要创建一个非事务处理会话，在该会话中，任何接收到的消息都将被自动确认。在 JMS 2.0 中，这是默认设置（对于 Java SE 应用程序），因此我们不需要指定任何参数。</p><p>如果我们想指定其他会话模式之一（本地事务、 <code>CLIENT_ACKNOWLEDGE</code> 或 <code>DUPS_OK_ACKNOWLEDGE</code> ），我们将只传入一个参数而不是两个参数。</p></li><li><p>无需创建对象<code>TextMessage</code>并将其主体设置为指定的字符串。相反，我们只需将字符串传递给方法即可<code>send</code>。JMS 提供程序将自动创建一个<code>TextMessage</code>并将其主体设置为提供的字符串。</p></li><li><p>JMS 1.1 示例<code>catch</code>为<code>JMSException</code>几乎所有方法都会抛出的 提供了一个块。JMS 2.0 简化 API 示例有一个类似的块，但它会捕获<code>JMSRuntimeException</code>。</p><p>简化 API 的一个特点是其方法不声明已检查的异常。如果遇到错误情况，则会<code>JMSRuntimeException</code>抛出异常。此新异常是 <code>RuntimeException</code> 的子类，这意味着它不需要由调用方法显式捕获或在其<code>throws</code>子句中声明。这与经典 API 形成对比，在经典 API 中，几乎每个方法都声明为抛出异常<code>JMSException</code>，调用方法必须捕获或自行抛出异常。</p></li></ul><p>清单 1 和清单 2 均显示将<code>ConnectionFactory</code>和<code>Queue</code>对象作为参数传入。获取这些对象的方式没有改变，因此我们不会在此处或本文的其他清单中介绍这一点。通常，它们将通过从 JNDI 存储库进行 JNDI 查找来获取。</p><h4 id=使用简化-api-同步接收消息>使用简化 API 同步接收消息<a hidden class=anchor aria-hidden=true href=#使用简化-api-同步接收消息>#</a></h4><p>清单 3 展示了一个使用 JMS 1.1 同步接收单一消息<code>TextMessage</code>并提取其文本的简单示例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>receiveMessageJMS11</span><span class=p>(</span><span class=n>ConnectionFactory</span><span class=w> </span><span class=n>connectionFactory</span><span class=p>,</span><span class=n>Queue</span><span class=w> </span><span class=n>queue</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>String</span><span class=w> </span><span class=n>body</span><span class=o>=</span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Connection</span><span class=w> </span><span class=n>connection</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>connectionFactory</span><span class=p>.</span><span class=na>createConnection</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>Session</span><span class=w> </span><span class=n>session</span><span class=w> </span><span class=o>=</span><span class=n>connection</span><span class=p>.</span><span class=na>createSession</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=n>Session</span><span class=p>.</span><span class=na>AUTO_ACKNOWLEDGE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>MessageConsumer</span><span class=w> </span><span class=n>messageConsumer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>session</span><span class=p>.</span><span class=na>createConsumer</span><span class=p>(</span><span class=n>queue</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>connection</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>TextMessage</span><span class=w> </span><span class=n>textMessage</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TextMessage</span><span class=p>)</span><span class=n>messageConsumer</span><span class=p>.</span><span class=na>receive</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>textMessage</span><span class=p>.</span><span class=na>getText</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>connection</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>JMSException</span><span class=w> </span><span class=n>ex</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c1>// handle exception (details omitted)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>return</span><span class=w> </span><span class=n>body</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>清单 3</strong></p><p>清单 4 显示了如何使用 JMS 2.0 中的简化 API 做同样的事情：</p><pre tabindex=0><code>public String receiveMessageJMS20(
ConnectionFactory connectionFactory,Queue queue){
   String body=null;
   try (JMSContext context = connectionFactory.createContext();){
      JMSConsumer consumer = session.createConsumer(queue);
      body = consumer.receiveBody(String.class);
   } catch (JMSRuntimeException ex) {
      // handle exception (details omitted)
   }
   return body;
}
</code></pre><p><strong>清单 4</strong></p><p>与发送消息一样，我们需要编写的代码量减少了。部分原因与前面的示例相同：</p><ul><li>我们不是创建单独的<code>Connection</code>对象<code>Session</code>，而是创建单个<code>JMSContext</code>对象。</li><li>我们可以在 <code>try-with-resources</code> 块中创建 <code>JMSContext</code>，这样它就会在块结束时自动关闭。这样就无需调用<code>close</code>。</li><li>我们不需要指定希望自动确认收到的消息，因为这是默认的。</li></ul><p>此外，JMS 2.0 还通过另外两种方式减少接收消息所需的代码量：</p><ul><li>在 JMS 1.1 中，我们需要调用<code>connection.start()</code>来开始向消费者传递消息，而在 JMS 2.0 简化 API 中则不需要：连接会自动启动。（如果需要，您可以禁用此行为。）</li><li>无需接收对象<code>Message</code>，将其转换为<code>TextMessage</code>，然后调用<code>getText</code>来提取消息正文。相反，我们调用<code>receiveBody</code>，它直接返回消息正文。</li></ul><h4 id=使用简化-api-异步接收消息>使用简化 API 异步接收消息<a hidden class=anchor aria-hidden=true href=#使用简化-api-异步接收消息>#</a></h4><p>前面的示例展示了如何通过调用一个方法来同步接收消息，该方法是阻塞的，直到收到消息或发生超时。</p><p>如果您需要在 Java SE 应用程序中异步接收消息，则在 JMS 1.1 中，您需要创建一个<code>MessageConsumer</code>对象，然后使用方法<code>setMessageListener</code>指定实现该接口的对象<code>MessageListener</code>。然后您需要调用<code>connection.start()</code>以开始传递消息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>MessageConsumer</span><span class=w> </span><span class=n>messageConsumer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>session</span><span class=p>.</span><span class=na>createConsumer</span><span class=p>(</span><span class=n>queue</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>messageConsumer</span><span class=p>.</span><span class=na>setMessageListener</span><span class=p>(</span><span class=n>messageListener</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>connection</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>JMS 2.0 简化 API 代码类似。您需要创建一个<code>JMSConsumer</code>对象，然后使用方法<code>setMessageListener</code>指定实现该接口的对象<code>MessageListener</code>。消息传递会自动启动；无需调用<code>start</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>JMSConsumer</span><span class=w> </span><span class=n>consumer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>createConsumer</span><span class=p>(</span><span class=n>queue</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>consumer</span><span class=p>.</span><span class=na>setMessageListener</span><span class=p>(</span><span class=n>messageListener</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>请注意，如果您需要在 Java EE 7 Web 或 EJB 应用程序中异步接收消息，那么与以前版本的 Java EE 一样，您需要使用消息驱动 Bean 而不是方法<code>setMessageListener</code>。</p><h4 id=注入jmscontextjava-ee-应用程序>注入<code>JMSContext</code>Java EE 应用程序<a hidden class=anchor aria-hidden=true href=#注入jmscontextjava-ee-应用程序>#</a></h4><p>如果您正在编写 Java EE Web 或 EJB 应用程序，那么使用 JMS 2.0 简化 API 甚至比在 Java SE 中更容易。这是因为您现在可以将“注入”到<code>JMSContext</code>您的代码中，并让应用服务器确定何时创建它以及何时关闭它。</p><p>以下代码是 Java EE 7 会话 bean 或 servlet 的一个片段，它注入<code>JMSContext</code>并使用它来发送消息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Inject</span><span class=w> </span><span class=nd>@JMSConnectionFactory</span><span class=p>(</span><span class=s>&#34;jms/connectionFactory&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>JMSContext</span><span class=w> </span><span class=n>context</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Resource</span><span class=p>(</span><span class=n>lookup</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;jms/dataQueue&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>Queue</span><span class=w> </span><span class=n>dataQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sendMessageJavaEE7</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>body</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>context</span><span class=p>.</span><span class=na>send</span><span class=p>(</span><span class=n>dataQueue</span><span class=p>,</span><span class=w> </span><span class=n>body</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>如您所见，没有代码可以创建它 <code>JMSContext</code> ，也没有代码可以关闭它。取而代之的是，我们只需声明一个类型的 <code>JMSContext</code> 字段并添加注释 <code>@Inject</code> 和 <code>@JMSConnectionFactory</code> .</p><p>注释 <code>@Inject</code> 告诉容器在需要时创建。 <code>JMSContext</code> 注释 <code>@JMSConnectionFactory</code> 告诉容器它应该使用的 JNDI 名称 <code>ConnectionFactory</code> 。</p><p>如果在 JTA 事务中使用注入 <code>JMSContext</code> 的事务（无论是容器管理的还是 Bean 管理的），则认为 <code>JMSContext</code> 具有事务作用域。这意味着在提交 JTA 事务后，将 <code>JMSContext</code> 自动关闭。</p><p>如果在没有 JTA 事务的情况下使用注入 <code>JMSContext</code> 的，则认为 具有 <code>JMSContext</code> 请求范围。这意味着当请求结束时，将关闭。 <code>JMSContext</code> 请求的长度在上下文和依赖关系注入 （CDI） 规范中定义，它通常与来自客户端的 HTTP 请求或消息驱动的 Bean 接收的消息相关。</p><p>注入除了由应用程序服务器自动创建和关闭之外，还 <code>JMSContext</code> 具有一些强大的功能。最重要的是，如果一个 servlet 调用了一个会话 bean，或者一个会话 bean 调用另一个会话 bean，并且都使用一个 injected <code>JMSContext</code> ，那么只要两个注入 <code>JMSContext</code> 的对象以相同的方式定义（例如，它们具有相同的 <code>JMSConnectionFactory</code> 注释），它们实际上将对应于同一个 <code>JMSContext</code> 对象。这样可以减少应用程序使用的 JMS 连接数。</p><h3 id=jms-20-中的其他-api-简化>JMS 2.0 中的其他 API 简化<a hidden class=anchor aria-hidden=true href=#jms-20-中的其他-api-简化>#</a></h3><p>JMS 2.0 还提供了其他一些简化。</p><h4 id=直接从邮件中提取正文的新方法>直接从邮件中提取正文的新方法<a hidden class=anchor aria-hidden=true href=#直接从邮件中提取正文的新方法>#</a></h4><p>JMS 消息由三部分组成：</p><ul><li>邮件标题</li><li>消息属性</li><li>邮件正文</li></ul><p>正文的类型随消息类型而变化： <code>TextMessage</code> 的消息体是 <code>String</code> 。 <code>BytesMessage</code> 的消息体是一个字节数组，依此类推。</p><p>在 JMS 1.1 中，消息体是使用特定于消息类型的方法获取的，例如 on <code>getText</code> <code>TextMessage</code> 的方法。但是，当应用程序接收到消息时，JMS API 始终将消息作为 <code>javax.jms.Message</code> 对象提供，在获取正文之前，需要将其转换为适当的子类型。当消息是从对 的 <code>receive</code> 调用返回的，以及当消息是通过对 <code>onMessage</code> 的方法 <code>MessageListener</code> 的调用异步传递时，这都适用。</p><p>例如，如果您使用该 <code>receive</code> 方法来接收 ， <code>TextMessage</code> 则需要将返回的对象从 <code>Message</code> 转换为 <code>TextMessage</code> ，然后调用该 <code>getText</code> 方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>receive</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w> </span><span class=c1>// returns a TextMessage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>((</span><span class=n>TextMessage</span><span class=p>)</span><span class=w> </span><span class=n>message</span><span class=p>).</span><span class=na>getText</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>JMS 2.0 增加了一种新方法，使提取消息正文变得稍微简单一些。这就是<code>getBody</code>上的方法<code>Message</code>，它可供传统 API 和简化 API 的用户使用。此方法将预期的正文类型作为参数，不需要您对消息或正文执行强制类型转换：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>receive</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w> </span><span class=c1>// returns a TextMessage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>message</span><span class=p>.</span><span class=na>getBody</span><span class=p>(</span><span class=n>String</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>让我们看看如何<code>getBody</code>简化获取其他消息类型正文所需的代码。</p><p>如果消息是<code>BytesMessage</code>，JMS 1.1 提供了几种从 中提取字节数组的方法<code>BytesMessage</code>。最简单的方法是调用<code>readBytes</code>上的方法<code>BytesMessage</code>。这会将字节复制到指定的字节数组中。</p><p><code>MessageListener</code>下面是一个接收<code>BytesMessage</code>并以字节数组形式获取主体的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span><span class=w> </span><span class=nf>onMessage</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=p>){</span><span class=w> </span><span class=c1>// delivers a BytesMessage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>bodyLength</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>((</span><span class=n>BytesMessage</span><span class=p>)</span><span class=n>message</span><span class=p>).</span><span class=na>getBodyLength</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>bytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>bodyLength</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>bytesCopied</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>((</span><span class=n>BytesMessage</span><span class=p>)</span><span class=n>message</span><span class=p>).</span><span class=na>readBytes</span><span class=p>(</span><span class=n>bytes</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>...</span><span class=w>
</span></span></span></code></pre></div><p>在 JMS 2.0 中，该<code>getBody</code>方法使这一过程变得更加简单：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span><span class=w> </span><span class=nf>onMessage</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=p>){</span><span class=w> </span><span class=c1>// delivers a BytesMessage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>bytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>message</span><span class=p>.</span><span class=na>getBody</span><span class=p>(</span><span class=kt>byte</span><span class=o>[]</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>...</span><span class=w>
</span></span></span></code></pre></div><p>如果消息是<code>ObjectMessage</code>，则在 JMS 1.1 中，您需要调用<code>getObject</code>方法<code>ObjectMessage</code>，然后将返回的转换<code>Serializable</code>为预期的主体类型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span><span class=w> </span><span class=nf>onMessage</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=p>){</span><span class=w> </span><span class=c1>// delivers an ObjectMessage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>MyObject</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>MyObject</span><span class=p>)((</span><span class=n>ObjectMessage</span><span class=p>)</span><span class=w> </span><span class=n>message</span><span class=p>).</span><span class=na>getObject</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>...</span><span class=w>
</span></span></span></code></pre></div><p>请注意需要执行两次强制转换。您需要将消息从 强制转换<code>Message</code>为<code>ObjectMessage</code>，以便调用<code>getObject</code>。这会将正文返回为<code>Serializable</code>，然后您需要将其强制转换为实际类型。</p><p>在 JMS 2.0 中，无需任何强制类型转换即可完成此操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span><span class=w> </span><span class=nf>onMessage</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=p>){</span><span class=w> </span><span class=c1>// delivers an ObjectMessage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>MyObject</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>message</span><span class=p>.</span><span class=na>getBody</span><span class=p>(</span><span class=n>MyObject</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>...</span><span class=w>
</span></span></span></code></pre></div><p>最后，如果消息是<code>MapMessage</code>，则该<code>getBody</code>方法允许您将正文作为 返回<code>Map</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>receive</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w> </span><span class=c1>// returns a MapMessage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Map</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>message</span><span class=p>.</span><span class=na>getBody</span><span class=p>(</span><span class=n>Map</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p><code>getBody</code>不能使用的消息类型是<code>StreamMessage</code>。这是因为流通常由应用程序应单独读取的多个对象组成。</p><p>使用 时<code>getBody</code>，如果指定的类与主体类型不匹配，则会<code>MessageFormatException</code>抛出 。<code>isBodyAssignableTo</code>还向 添加了配套方法<code>Message</code>，它可用于测试后续调用 是否<code>getBody</code>能够将特定<code>Message</code>对象的主体作为特定类型返回。 如果预期的消息类型不止一种，则这很有用。</p><h4 id=直接接收消息正文的方法>直接接收消息正文的方法<a hidden class=anchor aria-hidden=true href=#直接接收消息正文的方法>#</a></h4><p>在 JMS 1.1 中，同步使用消息的应用程序使用<code>receive()</code>、<code>receive(timeout)</code>或<code>receiveNoWait()</code>上的方法<code>MessageConsumer</code>。</p><p>在 JMS 2.0 中，使用简化 API 的应用程序可以使用 上的相同方法执行此操作<code>JMSConsumer</code>。</p><p>这些方法返回一个<code>Message</code>对象，可以从中获取消息正文。<code>getBody</code>前面描述的方法提供了一种从此对象获取正文的简单方法。</p><p>使用 JMS 2.0 简化 API 的应用程序还有一个附加选项。<code>JMSConsumer</code>提供了三种方法<code>receiveBody(class)</code>— 、<code>receiveBody(class, timeout)</code>和<code>receiveBodyNoWait(class)</code>—，它们将同步接收下一条消息并返回其正文。与 一样<code>getBody</code>，预期的类作为参数传入。</p><p>因此，应用程序可以使用清单 7 中所示的单行代码，而不必使用清单 5 或清单 6 中的代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>JMSConsumer</span><span class=w> </span><span class=n>consumer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>receive</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w> </span><span class=c1>// returns a TextMessage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>((</span><span class=n>TextMessage</span><span class=p>)</span><span class=w> </span><span class=n>message</span><span class=p>).</span><span class=na>getText</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p><strong>清单 5</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>JMSConsumer</span><span class=w> </span><span class=n>consumer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>receive</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w> </span><span class=c1>// returns a TextMessage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>message</span><span class=p>.</span><span class=na>getBody</span><span class=p>(</span><span class=n>String</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p><strong>清单 6</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>JMSConsumer</span><span class=w> </span><span class=n>consumer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>receiveBody</span><span class=p>(</span><span class=n>String</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=n>1000</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p><strong>清单 7</strong></p><p>这些<code>receiveBody</code>方法可用于接收除<code>StreamMessage</code>（出于同样的原因，此消息类型不支持<code>getBody</code>）和<code>Message</code>（因为它没有正文）之外的任何类型的消息，只要提前知道预期正文的类别即可。</p><p>这些新方法仅添加到<code>JMSConsumer</code>。它们尚未添加到<code>MessageConsumer</code>。这意味着此功能仅适用于使用 JMS 2.0 简化 API 的应用程序。</p><p>此外，这些方法不提供对消息头或属性（例如<code>JMSRedelivered</code>消息头字段或<code>JMSXDeliveryCount</code>消息属性）的访问，因此仅当应用程序不需要访问它们时才应使用它们。</p><h4 id=创建会话的新方法>创建会话的新方法<a hidden class=anchor aria-hidden=true href=#创建会话的新方法>#</a></h4><p>在 JMS 1.1 中，使用了以下方法<code>javax.jms.Connection</code>来创建<code>javax.jms.Session</code>，其中 transacted 参数需要设置为<code>true</code>或 ，<code>false</code>而<code>acknowledgeMode</code>参数需要设置为<code>Session.AUTO_ACKNOWLEDGE</code>、<code>Session.CLIENT_ACKNOWLEDGE</code>或<code>Session.DUPS_OK_ACKNOWLEDGE</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Session</span><span class=w> </span><span class=nf>createSession</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>boolean</span><span class=w> </span><span class=n>transacted</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>acknowledgeMode</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>JMSException</span><span class=w>
</span></span></span></code></pre></div><p>这一直是一个相当令人困惑的方法，主要有两个原因：</p><ul><li>它使用两个参数来定义会话的单个方面。</li><li>在 Java EE 事务中，这两个参数都会被忽略。</li></ul><p>让我们依次考虑这两个问题。</p><h4 id=定义同一事物的两个论据>定义同一事物的两个论据<a hidden class=anchor aria-hidden=true href=#定义同一事物的两个论据>#</a></h4><p>JMS 1.1 中的方法的第一个问题<code>createSession</code>是，它使用两个参数来定义会话中实际上具有四种可能性的单个方面：</p><ul><li>如果该<code>transacted</code>参数设置为<code>false</code>，则会话为非事务性的，并且该<code>acknowledgeMode</code>参数用于指定在接收消息时应使用三种确认中的哪一种。</li><li>如果该<code>transacted</code>参数设置为<code>true</code>，则该<code>acknowledgeMode</code>参数将被忽略。</li></ul><p>除了不必要的复杂性之外，这还会导致代码具有潜在的误导性，因为如果将<code>transacted</code>参数设置为，即使忽略该参数<code>false</code>，用户仍必须将参数设置为某个值。例如 <code>acknowledgeMode</code>，以下代码完全有效：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>amb</span><span class=w> </span><span class=n>Session</span><span class=w> </span><span class=n>session</span><span class=w> </span><span class=o>=</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>connection</span><span class=p>.</span><span class=na>createSession</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span><span class=n>Session</span><span class=p>.</span><span class=na>AUTO_ACKNOWLEDGE</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h4 id=在-java-ee-事务中两个参数都会被忽略>在 Java EE 事务中，两个参数都会被忽略<a hidden class=anchor aria-hidden=true href=#在-java-ee-事务中两个参数都会被忽略>#</a></h4><p>JMS 1.1 中方法的第二个问题<code>createSession</code>是，在 Java EE Web 或 EJB 应用程序中，如果存在当前 JTA 事务（默认情况下存在），则两个参数都会<code>createSession</code>被忽略。但是，由于 API 强制开发人员指定两个参数，这会导致代码极具误导性，因此编写 EJB bean 的用户可能会编写以下代码，而没有意识到会话实际上会使用 EJB 的容器管理 JTA 事务。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Session</span><span class=w> </span><span class=n>session</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>connection</span><span class=p>.</span><span class=na>createSession</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=n>Session</span><span class=p>.</span><span class=na>AUTO_ACKNOWLEDGE</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p><code>createSession</code>为了解决这些问题，添加了两个名为 的新方法<code>javax.jms.Connection</code>。一个只有一个参数，另一个根本没有参数。我们将依次讨论这两个方法。</p><h4 id=jms-20createsession带有一个参数>JMS 2.0：<code>createSession</code>带有一个参数<a hidden class=anchor aria-hidden=true href=#jms-20createsession带有一个参数>#</a></h4><p><code>createSession</code>在 JMS 2.0 中，添加了第二种方法<code>javax.jms.Connection</code>。该方法只有一个参数<code>sessionMode</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Session</span><span class=w> </span><span class=nf>createSession</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>sessionMode</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>JMSException</span><span class=w>
</span></span></span></code></pre></div><p>在普通 Java SE 环境中，<code>sessionMode</code>可以设置为<code>Session.AUTO_ACKNOWLEDGE</code>、<code>Session.CLIENT_ACKNOWLEDGE</code>、<code>Session.DUPS_OK_ACKNOWLEDGE</code>或<code>Session.TRANSACTED</code>。在 Java EE 事务中，<code>sessionMode</code>将被忽略。</p><h4 id=jms-20createsession无参数>JMS 2.0：<code>createSession</code>无参数<a hidden class=anchor aria-hidden=true href=#jms-20createsession无参数>#</a></h4><p>在 Java EE 事务中，即使传递单个参数也会<code>createSession</code>产生误导，因为如果存在 Java EE 事务，该参数将被忽略。为了让用户编写更少误导的代码，<code>createSession</code>添加了第三个<code>javax.jms.Connection</code>没有参数的方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Session</span><span class=w> </span><span class=nf>createSession</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>JMSException</span><span class=w>
</span></span></span></code></pre></div><p>此方法特别适用于 Java EE 事务，在这种情况下，指定会话模式毫无意义，因为它会被忽略。但是，此方法也可以在普通 Java SE 环境中使用，在这种情况下，它相当于调用<code>createSession(Session.AUTO_ACKNOWLEDGE)</code>。</p><h4 id=jms-20createsession具有两个参数>JMS 2.0：<code>createSession</code>具有两个参数<a hidden class=anchor aria-hidden=true href=#jms-20createsession具有两个参数>#</a></h4><p>现有方法<code>createSession(boolean transacted,int acknowledgeMode)</code>仍可使用，并将无限期地保留为 API 的一部分。不过，我们鼓励开发人员改用此方法的单参数或无参数版本。</p><h3 id=jms-20-中更简单的资源配置>JMS 2.0 中更简单的资源配置<a hidden class=anchor aria-hidden=true href=#jms-20-中更简单的资源配置>#</a></h3><p>JMS 2.0 通过多种方式使资源配置变得更加容易。</p><h4 id=java-ee-中的默认连接工厂>Java EE 中的默认连接工厂<a hidden class=anchor aria-hidden=true href=#java-ee-中的默认连接工厂>#</a></h4><p>Java EE 7 引入了<em>平台默认的 JMS 连接工厂</em>。这是一个内置的连接工厂，可连接到应用服务器的内置 JMS 提供程序。</p><p>应用程序可以通过使用名称执行 JNDI 查找来获取此连接工厂，<code>java:comp:DefaultJMSConnectionFactory</code>而无需先前使用管理工具创建连接工厂：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Resource</span><span class=p>(</span><span class=n>lookup</span><span class=o>=</span><span class=s>&#34;java:comp/DefaultJMSConnectionFactory&#34;</span><span class=p>)</span><span class=w> </span><span class=n>ConnectionFactory</span><span class=w> </span><span class=n>cf</span><span class=w>
</span></span></span></code></pre></div><p>此连接工厂旨在供使用内置 JMS 提供程序的众多应用程序使用，无需添加任何特定于应用程序的配置。</p><p>当将 注入<code>JMSContext</code>到应用程序时，<code>JMSConnectionFactory</code>使用注释来指定要使用的连接工厂：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Inject</span><span class=w> </span><span class=nd>@JMSConnectionFactory</span><span class=p>(</span><span class=s>&#34;
</span></span></span><span class=line><span class=cl><span class=s>  jms/connectionFactory&#34;</span><span class=p>)</span><span class=w> </span><span class=n>JMSContext</span><span class=w> </span><span class=n>context1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>如果省略此注释，则将使用默认连接工厂：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Inject</span><span class=w> </span><span class=n>JMSContext</span><span class=w> </span><span class=n>context2</span><span class=p>;</span><span class=w> </span><span class=c1>// uses the platform default connection factory</span><span class=w>
</span></span></span></code></pre></div><h4 id=java-ee-中的-jms-资源定义注释>Java EE 中的 JMS 资源定义注释<a hidden class=anchor aria-hidden=true href=#java-ee-中的-jms-资源定义注释>#</a></h4><p>每个 JMS 应用程序都以一个连接工厂（实现 的对象<code>javax.jms.ConnectionFactory</code>）和至少一个目标（实现 或 的对象<code>javax.jms.Queue</code>）开始<code>javax.jms.Topic</code>。<code>ConnectionFactory</code>是在 JMS 中用于创建与 JMS 提供程序的连接的对象， 或<code>Queue</code>是<code>Topic</code>用于标识要向其发送消息或从其接收消息的物理队列或主题的对象。</p><p>这些对象的创建方式和配置方式因 JMS 提供程序而异。这就是为什么 JMS 建议您使用单独的、提供程序特定的工具来创建、配置应用程序所需的连接工厂和目标并将其绑定到 JNDI 存储中。然后，您的应用程序可以使用 JNDI 查找这些对象，而无需使用任何非标准代码。除了保持应用程序代码的可移植性之外，这还意味着您可以编写代码而无需了解有关如何部署代码的详细信息。</p><p>配置 时<code>ConnectionFactory</code>，通常需要了解 JMS 服务器的主机名和端口等信息。配置<code>Queue</code>或<code>Topic</code>对象时，通常需要了解队列或主题的物理名称。单独创建<code>ConnectionFactory</code>、<code>Queue</code>和<code>Topic</code>对象并将其存储在 JNDI 中，这样部署者或管理员（而不是开发人员）就可以定义这些详细信息。</p><p>尽管在许多企业环境中，将代码与配置分开是必不可少的，但在较简单的环境中，这可能是不必要的负担。此外，如果将应用程序部署到自动化平台即服务 (PaaS) 系统中，则可能需要自动配置应用程序所需的<code>ConnectionFactory</code>、<code>Queue</code>和对象。<code>Topic</code></p><p>在许多 Java EE 应用程序中，现在任何 Java EE 7 应用服务器中都提供了默认的 JMS 连接工厂（上一节中已介绍），因此根本不需要配置任何连接工厂。但是，对于需要专门配置连接工厂的情况（以及队列和主题），Java EE 7 提供了另一项新功能，允许使用代码中的注释、部署描述符中的 XML 元素或两者的组合来创建这些对象。</p><p>主要的新批注是<code>javax.jms.JMSConnectionFactoryDefinition</code>和<code>javax.jms.JMSDestinationDefinition</code>。它们可以在任何 Java EE 组件类（如 EJB bean 或 servlet）中定义，如清单 8 所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@JMSConnectionFactoryDefinition</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span><span class=o>=</span><span class=s>&#34;java:global/jms/MyConnectionFactory&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>maxPoolSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>30</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>minPoolSize</span><span class=o>=</span><span class=w> </span><span class=n>20</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>properties</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;addressList=mq://localhost:7676&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;reconnectEnabled=true&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@JMSDestinationDefinition</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;java:global/jms/DemoQueue&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>interfaceName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;javax.jms.Queue&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>destinationName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;demoQueue&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>NewServlet</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>HttpServlet</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>...</span><span class=w>
</span></span></span></code></pre></div><p><strong>清单 8</strong></p><p>如果需要定义多个连接工厂或目标，那么这些批注需要包含在<code>JMSConnectionFactoryDefinitions</code>或<code>JMSDestinationDefinitions</code>批注中，如清单 9 所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@JMSConnectionFactoryDefinitions</span><span class=p>({</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@JMSConnectionFactoryDefinition</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>name</span><span class=o>=</span><span class=s>&#34;java:global/jms/MyConnectionFactory1&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>maxPoolSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>30</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>minPoolSize</span><span class=o>=</span><span class=w> </span><span class=n>20</span><span class=p>,</span><span class=w>       
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>properties</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=s>&#34;addressList=mq://localhost:7676&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=s>&#34;reconnectEnabled=true&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@JMSConnectionFactoryDefinition</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>name</span><span class=o>=</span><span class=s>&#34;java:global/jms/MyConnectionFactory2&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>maxPoolSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>30</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>minPoolSize</span><span class=o>=</span><span class=w> </span><span class=n>20</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>properties</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=s>&#34;addressList=mq://localhost:7677&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=s>&#34;reconnectEnabled=true&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@JMSDestinationDefinitions</span><span class=p>({</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@JMSDestinationDefinition</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>name</span><span class=o>=</span><span class=s>&#34;java:global/jms/DemoQueue1&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>interfaceName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;javax.jms.Queue&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>destinationName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;demoQueue1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@JMSDestinationDefinition</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>name</span><span class=o>=</span><span class=s>&#34;java:global/jms/DemoQueue2&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>interfaceName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;javax.jms.Queue&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>destinationName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;demoQueue2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>NewServlet</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>HttpServlet</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>...</span><span class=w>
</span></span></span></code></pre></div><p><strong>清单 9</strong></p><p>注释<code>JMSConnectionFactoryDefinition</code>定义了许多可以指定的标准属性，包括<code>name</code>（即 JNDI 名称）、<code>clientId</code>、<code>user</code>、<code>password</code>、<code>maxPoolSize</code>和<code>minPoolSize</code>。此外，<code>properties</code>属性还可用于指定应用服务器可能支持的其他非标准属性。清单 8 和清单 9 中的<code>addressList</code>和<code>reconnectEnabled</code>就是此类非标准属性的示例。</p><p>该<code>JMSConnectionFactoryDefinition</code>注释定义了较少数量的可指定的标准属性，包括<code>name</code>（JNDI 名称）和<code>destinationName</code>（提供程序特定的队列或主题名称），以及允许使用 properties 属性来指定其他非标准属性。</p><p>以这种方式定义的连接工厂和目标必须位于<code>java:comp</code>、<code>java:module</code>、<code>java:app</code>或<code>java:global</code>命名空间中，并且它们通常与定义它们的应用程序部署一样存在。</p><p>还可以在部署描述符文件中指定这些定义（例如 <code>web.xml</code>或<code>ejb-jar.xml</code>），如清单 10 所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;jms-connection-factory&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;name&gt;</span>java:global/jms/MyConnectionFactory<span class=nt>&lt;/name&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;max-pool-size&gt;</span>30<span class=nt>&lt;/max-pool-size&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;min-pool-size&gt;</span>20<span class=nt>&lt;/min-pool-size&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;property&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nt>&lt;name&gt;</span>addressList<span class=nt>&lt;/name&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nt>&lt;value&gt;</span>mq://localhost:7676<span class=nt>&lt;/value&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;/property&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;property&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nt>&lt;name&gt;</span>reconnectEnabled<span class=nt>&lt;/name&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nt>&lt;value&gt;</span>true<span class=nt>&lt;/value&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;/property&gt;</span>    
</span></span><span class=line><span class=cl><span class=nt>&lt;/jms-connection-factory&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nt>&lt;jms-destination&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;name&gt;</span>java:global/jms/DemoQueue<span class=nt>&lt;/name&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;interfaceName&gt;</span>javax.jms.Queue<span class=nt>&lt;/interfaceName&gt;</span>
</span></span><span class=line><span class=cl>   <span class=nt>&lt;destinationName&gt;</span>demoQueue<span class=nt>&lt;/destinationName&gt;</span> 
</span></span><span class=line><span class=cl><span class=nt>&lt;/jms-destination&gt;</span>
</span></span></code></pre></div><p><strong>清单 10</strong></p><p>如果需要，开发人员可以在注释中指定一些必需的属性，而部署者则在部署描述符中指定其余属性。这在属性值直到部署时才知道的情况下非常有用。</p><p>在上述所有示例中，应用服务器负责“配置”注释或部署描述符中定义的 JNDI 资源。但是，部署者仍有责任确保连接工厂引用的 JMS 服务器已安装且可用，并且物理队列和主题本身已创建。</p><h3 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h3><p>在本文中，我们介绍了 JMS 2.0 中新增的易用功能，这些功能使开发人员能够编写更少的代码。在第二部分中，我们将介绍 JMS 2.0 中的新消息传递功能。</p><h3 id=也可以看看>也可以看看<a hidden class=anchor aria-hidden=true href=#也可以看看>#</a></h3><ul><li><a href=https://www.oracle.com/technical-resources/articles/java/jms2messaging.html>JMS 2.0 中的新增功能（第二部分）— 新的消息传送功能</a></li><li><a href="http://jcp.org/en/jsr/detail?id=343">JMS 2.0 下载页面</a></li><li><a href=https://glassfish.java.net/>GlassFish</a></li></ul><h3 id=关于作者>关于作者<a hidden class=anchor aria-hidden=true href=#关于作者>#</a></h3><p>Nigel Deakin 是 Oracle 的首席技术人员，曾担任 JSR 343（Java 消息服务 2.0）的规范负责人。除了负责领导 JMS 规范的下一版本之外，他还是 Oracle JMS 开发团队的成员，致力于 Open Message Queue 和 GlassFish 应用服务器。他最近在美国旧金山的 JavaOne 和比利时安特卫普的 Devoxx 上发表过演讲，目前居住在英国剑桥。</p><h3 id=加入对话>加入对话<a hidden class=anchor aria-hidden=true href=#加入对话>#</a></h3><p><a href=https://www.facebook.com/ilovejava>在Facebook</a>、<a href=https://twitter.com/#!/java>Twitter</a>和<a href=https://blogs.oracle.com/java/>Oracle Java 博客</a>上加入 Java 社区讨论！</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chensoul.cc/tags/jms/>Jms</a></li></ul><nav class=paginav><a class=prev href=https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/><span class=title>« Prev</span><br><span>[译]JMS 2.0 中的新增功能</span>
</a><a class=next href=https://blog.chensoul.cc/posts/2024/07/24/jms20/><span class=title>Next »</span><br><span>[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]JMS 2.0 中的新增功能（第一部分）- 易于使用 on x" href="https://x.com/intent/tweet/?text=%5b%e8%af%91%5dJMS%202.0%20%e4%b8%ad%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd%ef%bc%88%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%89-%20%e6%98%93%e4%ba%8e%e4%bd%bf%e7%94%a8&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f07%2f24%2fjms20%2f&amp;hashtags=jms"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]JMS 2.0 中的新增功能（第一部分）- 易于使用 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f07%2f24%2fjms20%2f&amp;title=%5b%e8%af%91%5dJMS%202.0%20%e4%b8%ad%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd%ef%bc%88%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%89-%20%e6%98%93%e4%ba%8e%e4%bd%bf%e7%94%a8&amp;summary=%5b%e8%af%91%5dJMS%202.0%20%e4%b8%ad%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd%ef%bc%88%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%89-%20%e6%98%93%e4%ba%8e%e4%bd%bf%e7%94%a8&amp;source=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f07%2f24%2fjms20%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]JMS 2.0 中的新增功能（第一部分）- 易于使用 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f07%2f24%2fjms20%2f&title=%5b%e8%af%91%5dJMS%202.0%20%e4%b8%ad%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd%ef%bc%88%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%89-%20%e6%98%93%e4%ba%8e%e4%bd%bf%e7%94%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]JMS 2.0 中的新增功能（第一部分）- 易于使用 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f07%2f24%2fjms20%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]JMS 2.0 中的新增功能（第一部分）- 易于使用 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5dJMS%202.0%20%e4%b8%ad%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd%ef%bc%88%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%89-%20%e6%98%93%e4%ba%8e%e4%bd%bf%e7%94%a8%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f07%2f24%2fjms20%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]JMS 2.0 中的新增功能（第一部分）- 易于使用 on telegram" href="https://telegram.me/share/url?text=%5b%e8%af%91%5dJMS%202.0%20%e4%b8%ad%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd%ef%bc%88%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%89-%20%e6%98%93%e4%ba%8e%e4%bd%bf%e7%94%a8&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f07%2f24%2fjms20%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [译]JMS 2.0 中的新增功能（第一部分）- 易于使用 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%e8%af%91%5dJMS%202.0%20%e4%b8%ad%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd%ef%bc%88%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%89-%20%e6%98%93%e4%ba%8e%e4%bd%bf%e7%94%a8&u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2024%2f07%2f24%2fjms20%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>