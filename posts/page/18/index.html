<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | ChenSoul</title>
<meta name=keywords content><meta name=description content="Posts - ChenSoul"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/posts/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Posts"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/posts/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>用户故事如何应用到个人管理</h2></header><div class=entry-content><p>用户故事（User Stories）是敏捷软件开发中的一种需求表达方式，用于描述用户的需求、期望和价值。尽管用户故事主要应用于软件开发团队，但其原则和方法也可以应用到个人管理中，以帮助个人更好地管理自己的任务和目标。
在个人管理中，可以将用户故事的思维方式应用如下：
角色定义：将自己作为一个角色，例如“个人”或“自己的名字”。明确自己的身份和角色，以便更好地理解自己的需求和期望。 需求描述：将自己的需求和期望转化为用户故事的形式。例如：“作为一个个人，我希望每天早晨锻炼，以保持健康和增加活力。” 价值定义：确定每个用户故事的价值和意义。例如，锻炼身体可以增强健康、提高精力和改善心情，从而提升整体生活质量。 优先级排序：对用户故事进行优先级排序，以确定哪些是最重要的和紧急的。这有助于集中精力和资源，实现最有价值的目标。 制定计划：根据用户故事的优先级，制定个人管理计划。将每个用户故事转化为具体的任务、行动和时间安排，以实现期望的结果。 迭代和反馈：将个人管理过程视为一个迭代循环，不断评估和调整。根据实际执行情况和反馈，对计划进行调整和改进。 以下是一个制定个人管理计划的示例：
用户故事：作为一个个人，我希望提高工作效率和时间管理，以更好地完成任务和增加工作成果。
计划：
用户故事：作为一个个人，我希望设定明确的目标和优先级，以便更好地管理我的任务。 任务 1：制定长期目标和短期目标，并将其记录在个人笔记本或任务管理工具中。 任务 2：为每个目标设定优先级，以确定最重要的任务和活动。 用户故事：作为一个个人，我希望改善时间管理，以充分利用我的时间。 任务 1：分析我的日常时间分配，并识别时间浪费的区域。 任务 2：制定时间表或日程安排，将任务和活动合理分配到特定时间段。 任务 3：学习和采用时间管理技巧，如番茄工作法（Pomodoro Technique）或时间块（Time Blocking）。 用户故事：作为一个个人，我希望提高专注力和减少干扰，以更好地完成任务。 任务 1：创建一个有利于专注的工作环境，如清理工作区域、关闭手机通知或使用专注应用程序。 任务 2：学习并使用注意力管理技巧，如集中注意力训练（Focused Attention Training）或冥想。 用户故事：作为一个个人，我希望保持健康和提高精力，以更好地应对工作和任务。 任务 1：制定健康的生活习惯，如定期锻炼、健康饮食和充足的睡眠。 任务 2：安排休息和放松的时间，以避免过度劳累和疲劳。 用户故事：作为一个个人，我希望定期评估和调整我的个人管理计划，以适应变化和改进效果。 任务 1：每周或每月回顾我的个人管理计划，并记录我取得的成果和遇到的挑战。 任务 2：根据反馈和经验，调整计划中的任务和策略，以改进效果和适应新的需求。 这只是一个示例个人管理计划，你可以根据自己的需求和目标进行定制和调整。记得将计划中的任务具体化、可衡量，并逐步实施，以确保计划的可行性和有效性。
逐步实施个人管理计划是确保计划可行性和有效性的重要步骤。以下是一些方法来逐步实施你的个人管理计划：
制定优先级：根据计划中的任务和目标，确定它们的优先级顺序。将重要且紧急的任务放在首位，逐步处理其他任务。 制定计划：为每个任务制定具体的计划和行动步骤。将任务分解为更小的可管理的子任务，并为每个子任务设定截止日期或时间范围。 设定目标：为每个任务设定明确的目标和可衡量的指标。这样可以更好地跟踪和评估你的进展。 时间管理：合理安排时间以实施计划。使用时间管理技巧，如时间块，将任务和活动分配到特定的时间段，并设定时间限制以保持专注和高效。 建立习惯：将计划中的任务和行动转化为习惯。重复执行任务并坚持一段时间，以形成良好的习惯。 监控和评估：定期监控和评估你的进展。检查完成的任务，评估是否达到预期的目标和指标。根据反馈和经验，进行调整和改进。 适应变化：灵活应对变化和调整。如果遇到新的需求或情况，根据实际情况重新安排任务和优先级。 持续改进：根据实施的经验和反馈，不断改进个人管理计划。尝试新的方法和策略，寻找提高效率和成果的机会。 逐步实施个人管理计划需要耐心和坚持，一步一个脚印地完成每个任务，并逐渐扩大和提高目标的范围。记得给自己一定的弹性和容错空间，以适应意外情况和挑战。最重要的是保持积极的态度和动力，不断努力实现个人目标和提升自我管理能力。</p></div><footer class=entry-footer><span title='2023-08-21 00:00:00 +0000 UTC'>2023-08-21</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;54 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 用户故事如何应用到个人管理" href=https://blog.chensoul.cc/posts/2023/08/21/user-stories-in-self-manager/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>软件开发流程和常用开发方法</h2></header><div class=entry-content><p>软件开发流程和常用开发方法，如敏捷开发和 DevOps，对于架构师来说非常重要。下面我将简要介绍这些概念：
软件开发流程：
软件开发流程是指在开发软件时，按照一定的步骤和阶段进行工作的过程。常见的软件开发流程包括瀑布模型、迭代模型和增量模型等。这些流程以不同的方式组织和管理开发过程，包括需求分析、设计、编码、测试和部署等阶段。
敏捷开发：
敏捷开发是一种迭代和增量的软件开发方法，强调团队协作、快速响应变化和持续交付。敏捷开发强调通过迭代周期（如 Scrum 中的 Sprint）来开发软件，每个迭代都会产生可部署的软件功能。常见的敏捷方法包括 Scrum、XP（极限编程）和 Kanban 等。
DevOps：
DevOps 是一种软件开发和运维的方法论，旨在通过自动化和协作来加速软件交付和提高质量。DevOps 强调开发团队和运维团队之间的协作和共享责任，借助自动化工具和流程来实现持续集成、持续交付和持续部署。
开发流程 软件开发流程通常包括以下阶段：
需求收集：收集和记录软件的功能和非功能性需求。 分析与规划：分析需求并规划开发过程，包括资源分配、时间表和交付物。 设计：基于需求创建软件架构、模块和组件的详细设计。 实现：编写代码并集成设计的组件，进行软件开发。 测试：进行各种测试活动，如单元测试、集成测试和系统测试，确保软件按预期功能。 部署：发布软件并在生产环境中向最终用户提供使用。 维护与支持：在部署后提供持续的维护、错误修复和支持。 在整个过程中，遵循版本控制、文档化和协作等最佳实践是非常重要的，以确保软件开发生命周期的顺利和高效进行。
常见的软件开发流程包括瀑布模型、迭代模型和增量模型等：
瀑布模型（Waterfall Model）： 瀑布模型是一种线性顺序的软件开发流程，按照固定的阶段依次执行，每个阶段的输出作为下一个阶段的输入。典型的阶段包括需求分析、系统设计、编码、测试和维护等。瀑布模型适用于需求稳定且较小规模的项目，但缺乏灵活性和适应变化的能力。
下面是瀑布模型的典型阶段：
需求分析阶段：在这个阶段，与用户和利益相关者一起收集和明确软件系统的需求。定义系统的功能和性能要求，并编写详细的需求规格说明书。 系统设计阶段：在需求分析完成后，进行系统设计。这包括定义系统的整体架构、模块划分、数据结构和算法设计等。设计结果通常以文档形式呈现。 编码阶段：在系统设计完成后，开发团队开始实际的编码工作。根据设计文档，开发人员编写代码并实现系统的各个功能模块。 测试阶段：在编码完成后，进行系统测试。测试人员根据需求和设计规范执行功能测试、集成测试和系统测试，以验证系统的正确性和稳定性。 集成和部署阶段：在测试通过后，将各个模块进行集成，并进行系统级的测试和部署准备。确保整个系统能够协同工作，并准备好部署到目标环境中。 运维和维护阶段：一旦系统部署并投入使用，进入运维和维护阶段。在这个阶段，团队负责监控系统的运行状况，处理问题和错误，并进行必要的修复和更新。 瀑布模型的特点是每个阶段的工作是线性、顺序的，下一个阶段的开始依赖于前一个阶段的完成。这种模型适合需求稳定、项目规模较小、技术风险较低的项目。然而，瀑布模型缺乏灵活性和对变化的适应能力，难以应对需求变更和项目延期等问题。
因此，在面对需求变化频繁、项目复杂度高、风险较大的情况下，敏捷开发方法如 Scrum 和 Kanban 等更为适用，它们强调迭代、增量和持续交付，能更好地满足客户需求并快速响应变化。
迭代模型（Iterative Model）： 迭代模型强调通过多个迭代周期来逐步构建和完善软件。每个迭代周期包括需求分析、设计、编码、测试和部署等阶段，每个迭代都会产生可部署的软件版本。迭代模型适用于需求不完全明确或可能变化的项目，能够更好地适应变化和快速反馈。
以下是迭代模型的一般流程：
阶段规划：确定每个迭代周期的目标、范围和计划。这包括确定要开发的功能、分配资源、制定时间表等。 需求分析：在每个迭代的开始阶段，与用户和利益相关者一起收集和分析需求，并明确每个迭代的功能和优先级。 设计和开发：根据需求分析的结果，进行系统设计和开发工作。在每个迭代中，系统的某个部分会被设计、开发和测试。 测试和验证：在每个迭代周期结束时，进行系统的内部测试和验证。确保开发的功能符合需求，并满足预期的质量标准。 评审和反馈：在每个迭代周期结束后，与用户和利益相关者进行评审和反馈。他们提供对当前功能的评价和建议，以指导下一个迭代的开发工作。 迭代调整：根据用户的反馈和评审结果，对下一个迭代的计划进行调整和优化。可能需要重新定义需求、调整功能优先级、增加新的需求等。 重复迭代：通过不断重复上述步骤，每个迭代周期都会逐步增加系统的功能、完善系统的性能，并在每个迭代中交付一个可用的软件增量。 迭代模型的优势在于能够快速响应变化和不断提供增值。它允许在开发过程中灵活调整需求，并通过每个迭代的反馈和评审来改进产品。然而，迭代模型也需要适当的计划和管理，以确保每个迭代都能按时交付，并控制开发过程中的风险。
敏捷方法如 Scrum 和 Kanban 是迭代模型的典型实践，它们更加强调团队的协作、自组织和持续交付，适用于需求变化频繁和项目复杂度较高的环境
增量模型（Incremental Model）： 增量模型将软件按模块或功能进行划分，每个模块或功能被称为一个增量，通过逐步添加增量来逐渐构建完整的软件系统。每个增量都经历需求分析、设计、开发和测试等阶段。增量模型适用于大规模项目和需要分阶段交付的情况，可以提供更早的价值交付和更好的风险管理。
以下是增量模型的一般流程：
阶段划分：将整个软件系统划分为多个增量，每个增量都代表一个可用的软件部分。划分的方式可以基于功能、模块、业务流程等来定义。 需求分析：在每个增量开始时，与用户和利益相关者一起收集和明确关于该增量的需求和功能。确定每个增量的优先级和范围。 设计和开发：根据需求分析的结果，进行系统设计和开发工作。每个增量的设计和开发都是独立进行的，可以采用适合的开发方法和技术。 测试和验证：在每个增量完成开发后，进行系统的测试和验证。确保该增量的功能符合需求，并满足预期的质量标准。 增量交付：经过测试和验证后，将该增量交付给用户或利益相关者。用户可以开始使用该增量，并提供反馈和建议以进一步改进和优化。 增量整合：在完成一个增量的交付后，将该增量与之前交付的增量进行整合。确保不同增量之间的功能和模块可以协同工作，并形成一个完整的软件系统。 通过不断重复上述步骤，每个增量都逐步增加系统的功能和完善系统的性能。增量模型允许在开发过程中快速交付可用的软件部分，并根据用户的反馈和需求变化进行调整。它可以提高软件开发的可见性和用户满意度，降低项目风险。
与迭代模型相比，增量模型更加强调不同增量之间的独立性和可用性。每个增量都是一个可用的软件部分，用户可以在开发过程中逐步使用和评估系统功能。然而，增量模型可能需要更好的规划和管理，以确保增量之间的集成和整合顺利进行，并避免系统架构上的问题。
敏捷开发 敏捷开发（Agile Development）是一种以迭代、增量和协作为核心的软件开发方法。它强调团队合作、快速响应变化和持续交付，以提高客户满意度和项目成功率。以下是敏捷开发的核心原则和常用实践：
核心原则：
个体和互动胜过流程和工具（Individuals and interactions over processes and tools）：强调团队成员之间的沟通、合作和相互支持，重视人与人之间的交流。 可工作的软件胜过详尽的文档（Working software over comprehensive documentation）：注重以可工作的软件作为验证和沟通的手段，而不是过多依赖繁杂的文档。 客户合作胜过合同谈判（Customer collaboration over contract negotiation）：鼓励与客户密切合作，及时获取反馈并根据需求变化进行调整。 响应变化胜过遵循计划（Responding to change over following a plan）：灵活应对需求变化，通过迭代和增量的方式快速适应变化的环境。 常用实践：...</p></div><footer class=entry-footer><span title='2023-08-21 00:00:00 +0000 UTC'>2023-08-21</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;254 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 软件开发流程和常用开发方法" href=https://blog.chensoul.cc/posts/2023/08/21/the-software-development-process/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Boot项目如何实现JWT认证？</h2></header><div class=entry-content><p>没有人可以否认这样一个事实：安全性是生产就绪应用程序的一项重要功能。尽管我们可以使用内存身份验证、JDBC 身份验证或通过 UserDetailsS​​ervice 来保护一个 Web 应用程序的安全。但是，当一个应用程序在内部使用其他应用程序的服务时，使用 Web 服务概念实现安全性就变得很重要。在这种情况下，我们使用具有特定有效期的令牌来保护我们的应用程序。此外，我们将学习“如何在 Spring Boot 项目中实现 JWT 身份验证？”以整体了解 JWT（JSON Web Token）身份验证背后的概念。
由于 JWT 代表“JSON Web Token”，很明显，该令牌仅以 JSON 形式保存数据。
此外，与上述身份验证技术不同，JWT 属于无状态身份验证。简而言之，它没有数据。通常，这种类型的身份验证用于 Web 服务、服务器的水平扩展，甚至在某种程度上用于 OAuth 技术。为了说明该网络服务，让我们可视化从亚马逊预订订单的过程。在这里，用户与 Amazon 应用程序交互，而 Amazon 应用程序在内部通过 Web 服务调用与支付网关应用程序交互。
现在让我们开始讨论我们的主题“如何在 Spring Boot 项目中实现 JWT 身份验证？”以及相关点。
您对整篇文章有何期望？ 读完本文后，您将能够回答：
什么是安全上下文中的无状态和有状态身份验证？ 无状态认证和有状态认证有什么区别？ 那么什么是 Token，什么是 JWT(JSON Web Token)？
使用 JWT 认证有什么好处？
JWT 内部如何运作？
我们在什么情况下使用 JWT 身份验证？
此外，JWT 身份验证和状态身份验证之间有什么区别？
此外，如何生成 JWT 编码令牌以及如何将其解码回来？
如何在 Spring Boot 项目中逐步实现 JWT 认证？
在 Spring Boot 3.0 中，如何在不使用 WebSecurityConfigurerAdapter 的情况下编写安全配置类？
最后，如何测试启用 JWT 安全的应用程序？
什么是无状态和有状态身份验证？ 通常有两种类型的认证技术。两者都发生在客户端服务器概念中，服务器仅在身份验证后才向客户端提供服务。这里的客户端可以是浏览器，也可以是另一个服务器。
状态认证 在这种类型的身份验证中，客户端和服务器之间涉及会话管理。当客户端向服务器请求服务时，它首先登录到服务器。然后服务器创建一个会话并以键值对的形式存储该信息。这个会话是服务器端的一种内存。我们也称其为 HttpSession，因为 Http 协议管理它。
此外，为了响应客户端请求，服务器以 Cookie 的形式向客户端提供带有响应的会话 id。该 cookie 存储在客户端浏览器中。当同一个客户端第二次发出请求时，请求头中也会带有 cookie。因此，服务器会检查请求标头，如果在 cookie 中发现相同的 SID（会话 ID），则假定该请求来自同一客户端。通过这种方式，会话管理就发生了。
当客户端从服务器注销时，会话会相应地被销毁。结果，服务器相应地从内存中删除会话信息（键值）。同样重要的是，对于每个新客户端，服务器都会创建一个新会话（内存）。
无状态身份验证 当客户端向服务器发送服务请求时，它首先登录到服务器。因此，服务器生成一个令牌（编码格式的数据）并将响应发送到客户端。在发出第二个请求时，客户端将相同的令牌与请求一起发送到服务器。现在，服务器从请求中读取令牌并验证令牌。事实上，从第一个请求开始，服务器就检查客户端的有效登录（凭据）。...</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1974 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Boot项目如何实现JWT认证？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Boot项目如何实现Security？</h2></header><div class=entry-content><p>如今，几乎每个客户都要求在实时应用程序中实现强大的安全功能。安全功能对于保持机密性、完整性和可用性的需求是非常有效的。现实世界中有很多类型的安全性，但我们作为开发人员将重点关注应用程序/软件安全性。
此外，在应用程序安全方面，我们的工作基本上是确保两件事。首先，只有有效的用户才能访问该应用程序。其次，如果用户有效，他/她只能访问该应用程序中允许的数据/信息。我认为，没有什么可以解释它们，因为您必须已经了解这两个术语，即身份验证和授权。
您可能已经猜到我们将在当前主题“如何在 Spring Boot 项目中实现安全性？”中讨论什么内容。
在本文中，我们将从基本原理开始学习。接下来，我们将逐步结束它，直到我们有信心在 Spring Boot 应用程序中实现安全功能。因此，让我们开始逐步讨论“如何在 Spring Boot 项目中实现安全性？”。 Spring Boot 教程页面上有一系列有关 Spring Boot Security 的教程。
我们在本文中介绍了两个版本的“如何在 Spring Boot 项目中实现安全性？”的示例：使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。此外，还涵盖了使用 Spring Boot 3.0 及更高版本的“如何在 Spring Boot 项目中实现安全性？”的示例。
您将从本文中学到什么？ 为什么我们需要在 Spring Boot 应用程序中实现安全性？
Security 在 Spring Boot 应用程序内部如何工作？
javax.servlet.Filter 在 Spring Boot 应用程序中实现安全性方面的作用是什么？
Spring Boot 项目中使用了多少种授权类型？
Spring Boot 项目中有多少种实现安全性的方法？
在 Spring Boot 项目中实现 WebSecurity 的步骤是什么？
另外，如何在 Spring Boot 项目中使用@EnableWebSecurity、@Configuration、@Bean？
如何实现内存中身份验证安全示例
如何实现 JDBC 认证安全示例
如何在 Spring Boot 项目中使用 Thymeleaf ？
如何测试启用安全的功能？
相反，如何禁用应用程序的安全功能？
最后但并非最不重要的一点是，您将学习“如何在 Spring Boot 项目中实现安全性？”使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。
为什么我们需要应用程序中的安全性？ 现在，随着恶意攻击将重点从操作系统和网络转移到应用程序/软件和移动设备/设备，一天的数据面临最大的风险。此外，从业务/客户的角度来看，应用程序安全在维护信任、建立品牌形象和降低风险方面发挥着重要作用。事实上，没有其中任何一项，都无法想象一家成功的企业。
总之，无论您是为了内部使用、销售目的还是购买目的而创建应用程序，安全性都是每个应用程序最重要的功能。
根据最新的 2020 年 Verizon 数据泄露调查报告，所有数据泄露中有 43% 是针对 Web 应用程序的攻击。这一数字比 2019 年增加了一倍。此外，86% 的违规行为都是出于经济动机。...</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1807 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Boot项目如何实现Security？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]如何在Spring Boot2中使用UserDetailsService实现安全性？</h2></header><div class=entry-content><p>继续上一篇关于实现 Spring Security 的两种不同方法的文章，在本文中，我们将学习第三种方法“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现 Security？”。经过上一篇文章后，我希望我们都非常熟悉安全性的基础知识，甚至是 Spring Boot 应用程序中的安全性基础知识。这次我们将创建一个用户注册表并将用户及其角色保存到数据库中。
然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
如果您正在寻找“如何在 Spring Boot 3 及以上版本中使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”，请访问有关使用 Spring Boot 3 的 Spring Security UserDetailsS​​ervice 的单独文章。
为了说明这一点，我们将把一些角色发挥作用，并在整个过程中围绕它们进行发挥，以使其变得清晰。此外，我们将有一些页面并限制它们仅可由某些特定角色访问。同样重要的是，我们必须创建一个小型 MVC Web 应用程序，以使注册过程向用户开放。用户在注册时将输入自己的角色。然后我们可以在其之上实现安全功能。
让我们开始相应的主题“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”。
总体而言，您对这篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 在 Spring Security 应用程序中如何内部工作并带有流程图？
另外，如何使用注解：@EnableWebSecurity、@Configuration、@Bean、@GetMapping、@Autowired、@Data、@Entity、@Table、@Id、@GenerateValue、@Column、@ElementCollection、@CollectionTable、@JoinColumn ， @服务
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 是做什么的？使用它有什么好处？ UserDetailsS​​ervice 是 Spring 中 org.springframework.security.core.userdetails 包下的预定义接口。我们的实现类实现了这个接口并重写了它的 loadUserByUsername(String username) 方法。此方法返回 UserDetails，它又是一个接口。预定义的 User 类（org.springframework.security.core.userdetails.User）是 UserDetails 接口的实现。总之，在 loadUserByUsername(String username) 方法中，我们传递用户名，它返回我们预定义的 User 对象（org....</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1597 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何在Spring Boot2中使用UserDetailsService实现安全性？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot2-using-userdetailsservice/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]如何在Spring Boot3中使用UserDetailsService实现安全性？</h2></header><div class=entry-content><p>作为有关 Spring Security 的系列文章的继续，在本文中我们将学习“如何在 Spring Boot 3 中使用 UserDetailsService 实现 Spring Boot 中的安全性？”。经过前面的文章，我希望我们都非常熟悉安全性的基础知识，甚至 Spring Boot 应用程序中的安全性基础知识。 Spring Boot 3 发布后，我们将在这里实现“使用 Spring Boot 3 的 Spring Security UserDetailsService”。
在本文中，我们将创建一个用户注册表单并将用户及其角色保存在数据库中。然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
您对整篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 Spring Boot 3 实现 Spring Security UserDetailsService？
如何在基于 Spring 的应用程序中实现基于角色的安全性？
此外，如何以及在哪里使用注释：@EnableWebSecurity，@Configuration，@Bean，@GetMapping，@Autowired，@Data，@Entity，@Table，@Id，@GenerateValue，@Column，@ElementCollection，@CollectionTable， @JoinColumn，@Service
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
示例中使用的软件/技术 有时某些版本与其他版本冲突。因此，列出经过测试可以相互协作的组合。下面是经过测试的软件组合，用于使用 Spring Boot 3 开发 Spring Security UserDetailsS​​ervice。它也使实现完美无缺。
Spring Boot 3.0.0
JDK 17 or later
Maven 3.8.1 3）Maven 3.8.1
IDE – STS 4.7.1. RELEASE
IDE – STS 4.7.1。发布
Jars Used 下面是这些示例中 maven 使用 pom....</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1651 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何在Spring Boot3中使用UserDetailsService实现安全性？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot3-using-userdetailsservice/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]没有WebSecurityConfigurerAdapter的Spring Security.md</h2></header><div class=entry-content><p>在 Spring Security 模块的上下文中，WebSecurityConfigurerAdapter 是一个抽象类，根据 Spring 官方网站 2022 年 2 月 21 日发布的公告，该类已从 Spring Security 5.7.0-M2 中弃用。它通常用于扩展 configure() 方法由自定义配置子类实现。因此，它鼓励用户转向基于组件的安全配置。为了支持对这种新配置设计的更改，我们将讨论常见用例列表和未来建议的替代方案。因此，我们将讨论没有 WebSecurityConfigurerAdapter 的 Spring Security 用例的实现。
了解这一变化很重要，因为迟早我们将使用最新版本的 Spring Security 来开发安全功能。让我们讨论“没有 WebSecurityConfigurerAdapter 的 Spring Security”主题及其相关概念。
什么是 WebSecurityConfigurerAdapter？ WebSecurityConfigurerAdapter 是 Spring Security 模块提供的一个抽象类。一般来说，我们使用它来重写它的 configure()方法来定义我们的安全配置类。通常，我们在应用程序中实现 Spring Security 时使用两个具有不同参数的 configure() 方法。一种用于声明与身份验证相关的配置，另一种用于声明与授权相关的配置。该代码类似于下面的代码片段。
@Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // configure Authentication ...... } @Override protected void configure(HttpSecurity http) throws Exception { // configure Authorization ...... } } 为什么我们需要学习这个改变？ 如果您使用 Spring Boot 2.7.0 和 maven，它将自动下载 Spring Security 5.7.0 或更高版本。在这种情况下，您会发现 WebSecurityConfigurerAdapter 已被弃用。如果您仍然想使用此类而不弃用，您可以在 pom.xml 中将 Spring Boot 版本更改为较低版本（例如 2.6.6 ），如下所示。它将自动下载低于 5....</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;882 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]没有WebSecurityConfigurerAdapter的Spring Security.md" href=https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security - JWT</h2></header><div class=entry-content><p>简介和概述 JSON Web Token 或 JWT（更常见的名称）是一种开放的互联网标准 (RFC 7519)，用于以紧凑的方式在各方之间安全地传输可信信息。令牌包含编码为 JSON 对象的声明，并使用私有密钥或公钥/私钥对进行数字签名。它们是独立且可验证的，因为它们经过数字签名。 JWT 可以进行签名和/或加密。
签名的令牌验证令牌中包含的声明的完整性，而加密的令牌则向其他方隐藏声明。
JWT 也可用于信息交换，尽管它们更常用于授权，因为它们比使用内存中随机令牌的会话管理具有很多优势。其中最重要的是允许将身份验证逻辑委托给第三方服务器，例如 AuthO 等。
JWT 令牌分为 3 部分，即标头、有效负载和签名，格式为
[Header].[Payload].[Signature] Header − JWT 令牌的标头包含应用于 JWT 的加密操作列表。这可以是签名技术、有关内容类型的元数据信息等。标头以 JSON 对象的形式呈现，该对象被编码为 base64URL。有效 JWT 标头的示例是 { "alg": "HS256", "typ": "JWT" } 这里，“alg”为我们提供了有关所用算法类型的信息，“typ”为我们提供了信息的类型。
Payload − JWT 的有效负载部分包含使用令牌传输的实际数据。这部分也称为 JWT 令牌的“声明”部分。索赔可以分为三种类型：注册索赔、公开索赔和私人索赔。 注册的声明是推荐的但不是强制的声明，例如 iss(发行者)、sub(主题)、aud(受众) 等。 公共声明是那些使用 JWT 的人定义的声明。 私人声明或自定义声明是为了在相关方之间共享信息而创建的用户定义的声明。 有效负载对象的示例可以是。
{ "sub": "12345", "name": "Johnny Hill", "admin": false } 有效负载对象与标头对象一样，也采用 base64Url 编码，并且该字符串构成 JWT 的第二部分。
Signature− JWT 的签名部分用于验证消息在此过程中没有更改。如果令牌是用私钥签名的，它还会验证发送者的身份。它是使用编码的标头、编码的有效负载、秘密和标头中指定的算法创建的。签名的一个例子是。 HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret); 如果我们输入标头、有效负载和签名，我们会得到一个令牌，如下所示。
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6I kpvaG4gRG9lIiwiYWRtaW4iOmZhbHNlfQ.gWDlJdpCTIHVYKkJSfAVNUn0ZkAjMxskDDm-5Fhe WJ7xXgW8k5CllcGk4C9qPrfa1GdqfBrbX_1x1E39JY8BYLobAfAg1fs_Ky8Z7U1oCl6HL63yJq_ wVNBHp49hWzg3-ERxkqiuTv0tIuDOasIdZ5FtBdtIP5LM9Oc1tsuMXQXCGR8GqGf1Hl2qv8MCyn NZJuVdJKO_L3WGBJouaTpK1u2SEleVFGI2HFvrX_jS2ySzDxoO9KjbydK0LNv_zOI7kWv-gAmA j-v0mHdJrLbxD7LcZJEGRScCSyITzo6Z59_jG_97oNLFgBKJbh12nvvPibHpUYWmZuHkoGvuy5RLUA 现在，可以使用承载模式在授权标头中使用此令牌。
Authorization − Bearer 授权 - 持有者
使用 JWT 令牌进行授权是其最常见的应用。令牌通常在服务器中生成并发送到客户端，并存储在会话存储或本地存储中。要访问受保护的资源，客户端将在标头中发送 JWT，如上所述。我们将在下面的部分中看到 Spring Security 中的 JWT 实现。...</p></div><footer class=entry-footer><span title='2023-08-16 00:00:00 +0000 UTC'>2023-08-16</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1173 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security - JWT" href=https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-jwt/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security - OAuth2</h2></header><div class=entry-content><p>OAuth 2.0 基础知识 OAuth 2.0 由 IETF OAuth 工作组开发并于 2012 年 10 月发布。它作为一种开放授权协议，使第三方应用程序能够代表资源所有者对 HTTP 服务进行有限访问。它可以在不泄露用户身份或长期凭证的情况下做到这一点。第三方应用程序本身也可以代表其使用它。
OAuth 的工作原理包括将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问用户的帐户。
让我们考虑一个例子。假设我们要登录网站“clientsite.com”。我们可以通过 Facebook、Github、Google 或 Microsoft 登录。我们选择上面给出的选项中的任何选项，然后我们将被重定向到相应的网站进行登录。如果登录成功，系统会询问我们是否要授予 clientsite.com 访问其请求的特定数据的权限。
我们选择所需的选项，然后使用授权代码或错误代码重定向到 clientsite.com，登录是否成功取决于我们在第三方资源中的操作。这就是 OAuth 2 的基本工作原理。
OAuth 系统涉及五个关键角色。让我们把它们列出来 -
User / Resource Owner − 用户/资源所有者- 最终用户，负责身份验证并同意与客户端共享资源。 User-Agent − 用户代理- 用户使用的浏览器。 Client − 客户端 - 请求访问令牌的应用程序。 Authorization Server − 授权服务器- 用于验证用户/客户端的服务器。它颁发访问令牌并在其整个生命周期内对其进行跟踪。 Resource Server − 资源服务器- 提供对所请求资源的访问的 API。它验证访问令牌并提供授权。 入门 我们将使用 Spring Security 和 OAuth 2.0 开发一个 Spring Boot 应用程序来说明上述内容。我们现在将开发一个带有内存数据库的基本应用程序来存储用户凭据。该应用程序将使我们轻松了解 OAuth 2.0 与 Spring Security 的工作原理。
让我们使用 Spring 初始化程序在 Java 8 中创建一个 Maven 项目。让我们从 start.spring.io 开始。我们生成一个具有以下依赖项的应用程序 -
Spring Web Spring Security Cloud OAuth2 Spring Boot Devtools 通过上面的配置，我们点击 Generate 按钮生成一个项目。该项目将以 zip 文件形式下载。我们将 zip 解压到一个文件夹中。然后我们可以在我们选择的 IDE 中打开该项目。我在这里使用 Spring Tools Suite，因为它针对 Spring 应用程序进行了优化。我们也可以根据需要使用 Eclipse 或 IntelliJ Idea。...</p></div><footer class=entry-footer><span title='2023-08-16 00:00:00 +0000 UTC'>2023-08-16</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;720 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security - OAuth2" href=https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-oauth2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security - 使用数据库表单登录</h2></header><div class=entry-content><p>内容 简介和概述 Spring Security 的基本组件 AuthenticationFilter 认证过滤器 AuthenticationManager 认证管理器 AuthenticationProvider 认证提供者 UserDetailsService 用户详情服务 PasswordEncoder 密码编码器 Spring 安全上下文 表单登录 使用数据库登录 登录尝试限制 入门（实用指南） 简介和概述 除了提供各种内置的身份验证和授权选项之外，Spring Security 还允许我们根据需要自定义身份验证过程。从自定义登录页面到我们自己的自定义身份验证提供程序和身份验证过滤器，我们几乎可以自定义身份验证过程的各个方面。
我们可以定义自己的身份验证过程，范围可以从使用用户名和密码的基本身份验证到复杂的身份验证，例如使用令牌和 OTP 的双因素身份验证。此外，我们可以使用各种数据库 - 关系数据库和非关系数据库，使用各种密码编码器，将恶意用户锁定在其帐户之外，等等。
今天，我们将讨论三种此类自定义，即自定义表单登录、数据库提供的身份验证以及限制登录尝试。尽管这些都是非常基本的用例，但它们仍然可以让我们更仔细地了解 Spring Security 的身份验证和授权过程。我们还将建立一个注册页面，用户可以通过该页面在我们的应用程序中进行注册。
首先我们看一下 Spring Security 的架构。它从 servlet 过滤器开始。这些过滤器拦截请求，对其执行操作，然后将请求传递到过滤器链中的下一个过滤器或请求处理程序，或者在不满足某些条件时阻止它们。正是在这个过程中，Spring Security 可以对请求进行身份验证并对请求执行各种身份验证检查。
它还可以通过不允许未经身份验证或恶意请求访问我们受保护的资源来阻止它们通过。因此我们的应用程序和资源受到保护。
Spring Security 架构的组件 正如我们在上图中看到的那样，Spring Security 的基本组件如下所示。我们将在讨论过程中简要讨论它们。我们还将讨论它们在身份验证和授权过程中的角色。
AuthenticationFilter 认证过滤器 这是拦截请求并尝试对其进行身份验证的过滤器。在 Spring Security 中，它将请求转换为身份验证对象并将身份验证委托给 AuthenticationManager。
AuthenticationManager 认证管理器 它是身份验证的主要策略接口。它使用单独的方法 authenticate()来验证请求。 authenticate() 方法执行身份验证，并在身份验证成功时返回 Authentication 对象，或者在身份验证失败时抛出 AuthenticationException。如果该方法无法决定，它将返回 null。这个过程中的认证过程委托给了我们接下来要讨论的 AuthenticationProvider。
AuthenticationProvider 认证提供者 AuthenticationManager 由 ProviderManager 实现，后者将流程委托给一个或多个 AuthenticationProvider 实例。任何实现 AuthenticationProvider 接口的类都必须实现两个方法——authenticate() 和 supports()。首先，我们来谈谈 supports()方法。它用于检查我们的 AuthenticationProvider 实现类是否支持特定的身份验证类型。如果支持则返回 true，否则返回 false。
接下来是 authenticate() 方法。这是身份验证发生的地方。如果支持该认证类型，则启动认证过程。这里这个类可以使用 UserDetailsS​​ervice 实现的 loadUserByUsername() 方法。如果未找到用户，则会抛出 UsernameNotFoundException。
另一方面，如果找到用户，则使用该用户的身份验证详细信息来验证该用户。例如，在基本认证场景中，可以将用户提供的密码与数据库中的密码进行核对。如果发现它们彼此匹配，则说明成功。然后我们可以从此方法返回一个 Authentication 对象，该对象将存储在安全上下文中，我们将在稍后讨论。
UserDetailsService 用户详情服务 它是 Spring Security 的核心接口之一。任何请求的身份验证主要取决于 UserDetailsS​​ervice 接口的实现。它最常用于数据库支持的身份验证中以检索用户数据。通过单独的 loadUserByUsername() 方法的实现来检索数据，我们可以在其中提供逻辑来获取用户的用户详细信息。如果未找到用户，该方法将抛出 UsernameNotFoundException。...</p></div><footer class=entry-footer><span title='2023-08-16 00:00:00 +0000 UTC'>2023-08-16</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1725 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security - 使用数据库表单登录" href=https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-with-database/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/posts/page/17/>«&nbsp;Prev&nbsp;17/28
</a><a class=next href=https://blog.chensoul.cc/posts/page/19/>Next&nbsp;19/28&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>