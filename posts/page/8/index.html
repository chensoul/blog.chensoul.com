<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | ChenSoul</title>
<meta name=keywords content><meta name=description content="Posts - ChenSoul"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/posts/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/posts/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Posts"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/posts/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chensoul.cc/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是HTTP/3？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/http-3/
什么是 HTTP/3？ HTTP/3（或 HTTP-over-QUIC）是超文本传输协议 ( HTTP ) 的第三个主要版本。它是用于 Web 浏览器和服务器之间通信的应用层协议。 HTTP/3 旨在提高 Web 通信的性能和安全性。
HTTP/3的主要功能之一是它构建在用户数据报协议 (UDP)之上，而不是建立在 HTTP 早期版本中使用的传输控制协议(TCP) 之上。 UDP 是一种无连接协议，可为实时应用程序提供更低的延迟和更好的性能。
HTTP/3 还引入了一种新的传输协议，称为QUIC（快速 UDP 互联网连接）。与 TCP 相比，QUIC 具有多种优势，包括减少延迟、提高可靠性和更好的拥塞控制。它还包括内置加密，增强网页和通信安全性。
HTTP/3 的另一个重要特性是它对多路复用的支持。这意味着可以通过单个连接同时发送和接收多个请求和响应，从而提高数据传输效率。
HTTP/3 还包括其他优化以提高性能，例如标头压缩和流优先级。这些优化有助于减少开销并提高 Web 通信的整体速度。
总体而言，HTTP/3 在性能和安全性方面比其前身 HTTP/2 显着改进了功能。它对于构建实时聊天和消息传递应用程序的开发人员特别有利，因为它提供更低的延迟和更高的可靠性，使其成为需要快速交付实时数据的用例的理想选择。
让我们退一步看看这一切从第一个 HTTP 版本开始。
HTTP 简史 HTTP（超文本传输协议）协议有着长达数十年的丰富历史。它于 20 世纪 90 年代初首次推出，作为万维网上客户端和服务器之间的通信方式。
HTTP 最初是由Tim Berners-Lee和他在CERN（欧洲核研究组织）的团队开发的，旨在促进超文本文档的交换。第一个版本 HTTP/0.9 是一个简单的协议，仅支持用于检索 HTML 文档的 GET 请求。
1996 年，HTTP/1.0 协议由互联网工程任务组(IETF)标准化。该版本引入了几个重要的功能，包括对 POST 请求、响应状态代码和标头的支持。 HTTP/1.0 还允许传输不同的媒体类型，例如图像和视频以及 HTML 文档。
然而，随着网络变得更加复杂和交互，HTTP/1.0 的局限性变得明显。它是围绕请求-响应模型设计的，其中每个请求都需要与服务器的单独连接。这导致了高延迟和网络资源的低效使用。
HTTP/1.1 协议解决了这些问题。
HTTP/1.1 HTTP/1.1 是超文本传输协议 (HTTP) 的第二个主要版本，于 1999 年推出，如今在互联网上广泛使用。
HTTP/1.1 的关键功能之一是支持持久连接，也称为保持活动连接。在以前版本的 HTTP 中，必须为每个请求和响应建立一个新的 TCP 连接，这导致延迟和开销增加。使用 HTTP/1.1，可以通过单个连接发送多个请求和响应，从而减少建立新连接的需要并提高性能。
HTTP/1.1 的另一个重要特性是它对管道的支持。流水线允许发送多个请求而无需等待相应的响应，这有助于减少延迟并提高数据传输效率。
HTTP/1.1还引入了缓存的概念。缓存允许 Web 浏览器存储和重用以前访问的资源，例如图像和样式表，这可以显着缩短页面加载时间并减少带宽使用。
然而，尽管有这些改进，HTTP/1.1 仍然存在一些局限性。同时处理多个请求和响应可能效率低下，因为它需要严格的消息排序。这可能会导致性能问题，特别是对于需要低延迟和高并发的实时应用程序。
此外，HTTP/1.1 不支持标头压缩，这可能会导致开销增加和数据传输速度变慢。
HTTP/2 HTTP/2 是超文本传输协议 (HTTP)的最新主要版本，于 2015 年推出，作为对之前 HTTP/1....</p></div><footer class=entry-footer><span title='2024-05-07 14:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;415 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是HTTP/3？" href=https://blog.chensoul.cc/posts/2024/05/07/http3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是HTTP流式传输？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/http-streaming/
什么是 HTTP 流式传输？ HTTP 流，也称为基于 HTTP 的流或 HTTP 实时流，是一种用于通过 Internet 传送实时多媒体内容（例如音频或视频）的技术。该协议允许从服务器到客户端设备的连续数据传输，使用户能够消费媒体内容而无需完整的文件下载。
与传统的文件下载方法不同，在开始播放之前需要下载整个文件，HTTP 流允许立即播放媒体内容。它的工作原理是将媒体文件分成更小的片段或块，然后将其连续传送到客户端设备。
HTTP 流利用超文本传输协议 (HTTP)作为其通信协议。它利用现有的 Web 基础设施并使用 HTTP 服务器的可扩展性、缓存和负载平衡功能。这使其成为向许多用户提供实时内容的高效且灵活的解决方案。
HTTP 流如何工作？ 从较高层面来看，HTTP 流式传输的工作原理是将媒体文件分成小块并通过 HTTP 连接将其传输到客户端。客户端（通常是网络浏览器或媒体播放器）不断请求和接收这些块，从而实现媒体的无缝播放。
HTTP 流式传输有两种主要方法：渐进式下载和自适应流式传输。
1.渐进式下载：
渐进式下载缺乏自适应流媒体提供的适应性。在客户端开始播放之前，会通过渐进式下载来下载整个媒体文件。这意味着，如果在下载过程中出现任何 Wi-Fi 网络中断或带宽波动，用户可能会遇到播放缓冲或延迟的情况。这可能会让用户感到沮丧，并可能导致糟糕的用户体验。
2.[自适应流媒体](https://www.cloudflare.com/learning/video/what-is-adaptive-bitrate-streaming/#:~:text=Adaptive bitrate streaming adjusts video,%2C location%2C or Internet speed.)：
自适应流媒体对于开发人员构建实时聊天和消息传递应用程序（提供视频或音频等媒体文件）来说是一项至关重要的技术。它确保无论用户的网络条件如何，媒体内容都可以流畅、高效地传输。这在当今的数字环境中尤其重要，用户期望高质量、不间断的媒体播放，但有时具有不同的互联网速度。
自适应流式传输通常涉及以下步骤：
内容编码：媒体文件被编码为具有不同比特率和质量级别的多种变体。这些变化存储在服务器上。 清单文件：创建一个清单文件，其中包含有关可用变体及其相应 URL 的信息。 初始请求：客户端向服务器请求清单文件，该文件提供有关媒体文件的可用变体的信息。 变体选择：客户端根据网络条件和设备功能选择所需的变体。然后它从服务器请求相应的媒体块。 块传送：服务器通过 HTTP 连接将分块媒体传送到客户端。客户端不断请求并接收这些块，并在必要时调整播放质量。 比特率适应：在播放期间，客户端监视网络状况并根据可用带宽动态调整所选变体。如果网络变得拥塞，它可能会切换到较低的比特率变体，或者如果网络状况改善，它可能会切换到较高的比特率变体。 无缝播放：通过连续接收和播放媒体块，自适应流媒体提供无缝播放体验，使用户能够在没有中断或缓冲的情况下享受内容。 HTTP 流有什么好处？ HTTP 流式传输为构建实时聊天和消息传递应用程序的开发人员提供了多种好处：
实时数据传送：HTTP流可以实现数据的实时传送，允许用户即时发送和接收消息。这确保用户可以进行实时对话，而不会出现任何明显的延迟。 可扩展性：HTTP 流具有高度可扩展性，能够处理许多并发连接并向多个用户实时传送消息。这对于支持不断增长的用户群和处理大量消息的应用程序至关重要。 减少网络开销：使用 HTTP 流式传输，当有新信息可用时，仅通过网络发送必要的数据，从而减少网络开销。这与轮询等其他方法形成鲜明对比，即使不存在新数据，也会不断发出请求。 高效的资源利用：HTTP 流可以有效地利用服务器资源，因为它消除了频繁的轮询请求。这可以减少服务器负载并提高性能，特别是在具有许多活跃用户的应用程序中。 更好的用户体验：HTTP 流通过提供实时更新和即时消息传递，增强了聊天和消息传递应用程序的用户体验。用户可以进行更具互动性和吸引力的对话，而不会因延迟或错过消息而感到沮丧。 安全性：HTTP 流可以利用 HTTPS 等现有安全措施提供安全的通信通道。这可确保敏感的用户数据和对话免受未经授权的访问和窃听。 使用 HTTP 流有哪些缺点？ 使用 HTTP 流进行实时聊天和消息传递应用程序有几个缺点：
延迟： HTTP 流媒体依赖于客户端和服务器之间的持续连接。这可能会引入延迟，因为服务器需要维持开放连接并以块的形式发送数据。因此，向用户发送实时消息可能会出现延迟，从而影响用户体验。
可扩展性： HTTP 流对于客户端和服务器来说可能是资源密集型的。维护大量打开的连接会给服务器带来压力并限制其可扩展性。此外，客户端需要处理传入的数据流，这也可能对其资源提出要求。
**兼容性：**所有设备或网络可能不支持 HTTP 流。某些防火墙或代理可能会阻止或干扰流连接，从而导致通信问题。这可能会将聊天应用程序的可用性限制为部分用户。
**可靠性：**由于 HTTP 流媒体依赖于长期连接，因此中断或网络故障可能会破坏流媒体过程。如果连接丢失，客户端可能需要重新建立连接，这可能会导致消息丢失或重复。
安全性： HTTP 流本身并不为数据传输提供加密或安全措施。如果没有额外的安全层，通过聊天应用程序交换的敏感信息可能容易遭到窃听或未经授权的访问。
**电池消耗：**连续连接和数据流会快速耗尽移动设备的电池。这可能是实时聊天应用程序的用户所关心的问题，尤其是在长时间使用这些应用程序时。
开发人员在选择实时聊天和消息应用程序技术时需要考虑这些缺点。虽然 HTTP 流提供了一些好处，例如利用现有的安全措施，但开发人员应该权衡这些优点与潜在的缺点，并评估它们是否符合其特定的用例和要求。
HTTP 流式传输有哪些替代方案？ HTTP 流的一些替代方案包括：...</p></div><footer class=entry-footer><span title='2024-05-07 14:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;902 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是HTTP流式传输？" href=https://blog.chensoul.cc/posts/2024/05/07/http-streaming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是Socket.IO？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/socket-io/
什么是Socket.IO？ Socket.IO是一个开源的跨平台库，它提供客户端和服务器之间基于事件的全双工双向通信。它基于 WebSocket 协议构建，提供附加功能，例如自动重新连接以及在无法使用 WebSocket时回退到HTTP 长轮询。
Socket.IO 客户端由客户端和服务器端库组成。虽然最初在服务器上支持NodeJS ，在客户端支持JavaScript，但现在它支持各种服务器和客户端技术，包括Java、Python、Swift和Kotlin，它们都是官方代码库的一部分，由活跃社区贡献。
Socket.io 有何用途？ Socket.IO 允许您实现依赖于消息交换的各种应用程序，例如即时消息传递、多用户协作、实时分析、文件共享和通知。
Socket.io 适合实时应用程序吗？ 是的，Socket.IO 是构建实时 Web 应用程序的不错选择，因为它提供了许多对开发人员有用的开箱即用功能，包括：
房间和命名空间支持允许您将客户端分组到可以接收广播或多播消息的房间中。 自动重连意味着您无需担心客户端上线或离线。 二进制数据支持，使您不仅可以交换聊天消息，还可以交换图像或其他媒体。 Socket.io 是 API 吗？ Socket.IO不是传统意义上的API。它是一个库或框架，抽象了底层传输机制，并提供了一组用于在客户端和服务器之间构建实时双向通信的工具和实用程序。
Socket.IO 包含客户端和服务器组件，每个组件都公开其 API。
Socket.io是TCP还是UDP，有什么区别？ Socket.IO可以使用TCP和UDP作为底层传输协议，但它主要使用TCP。
TCP（传输控制协议）是一种可靠的、面向连接的协议，可确保数据按顺序且无错误地传送。
另一方面，UDP（用户数据报协议）是一种无连接、不可靠的协议，它发送数据时不检查数据是否已成功接收。
UDP 比 TCP 更轻量级，因为只有后者在客户端和服务器之间建立连接，但它只能由能够抵御丢失消息的应用程序使用。
Socket.io 与 Web Sockets 虽然 Socket.IO 明确不是WebSocket实现，但有一些相似之处。两者都是基于事件的，这意味着您可以“侦听”连接、断开连接或 new_message 等事件，并且都允许您发送JSON 对象等结构化数据。
您可以将 Socket.IO 视为底层传输协议之上的抽象层。除了底层通信层之外，该库还实现了其他功能，例如自动重新连接、数据包缓冲和消息确认，以及在 WebSocket 不可用时回退到 HTTP 长轮询，从而增加了鲁棒性。
Socket.io 示例：客户端/服务器 JavaScript 中 Socket.IO 的 Hello World 客户端/服务器实现将编写如下，摘自4.x Socket.IO 文档：
Socket.io 服务器示例：
Socket.io 客户端示例：
Socket.IO 是如何工作的？ 该库支持两种传输方法：HTTP 长轮询和 WebSockets。首先建立 HTTP 长轮询连接，然后在可能的情况下升级为 WebSocket 连接。 WebSocket 不能在任何地方运行，例如，它们被许多公司代理和防火墙阻止，因此首先发起 HTTP 长轮询，因为它更有可能成功。 HTTP 长轮询连接建立后，会在对最终用户完全透明的过程中“升级”为 WebSocket 连接。
Socket.IO的架构是怎样的？ Socket.IO 由两个不同的层组成，分别存在于客户端和服务器上：
底层管道由一个名为Engine.IO的单独库提供 Socket.IO 提供的高级 API 作为开发人员或用户，您通常不会直接与 Engine.IO 交互，但它在幕后运行以建立连接、协商传输机制并检测任何断开连接。将 Engine.IO 与 WebSocket 进行比较时，两者在功能上非常相似，只是 Engine....</p></div><footer class=entry-footer><span title='2024-05-07 14:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;128 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是Socket.IO？" href=https://blog.chensoul.cc/posts/2024/05/07/socket-io/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是WebSocket？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/websockets/
什么是 WebSocket？ WebSocket 是一种通过单个TCP连接提供全双工通信通道的通信协议。它支持客户端和服务器之间的实时、事件驱动的连接。
与遵循请求-响应模型的传统 HTTP 软件不同，WebSocket 允许双向（双向）通信。这意味着客户端和服务器可以随时向对方发送数据，而无需持续轮询。
WebSocket 有何用途？ WebSocket 用于客户端和服务器之间的实时、事件驱动的通信。它们对于构建需要即时更新的软件应用程序特别有用，例如实时聊天、消息传递和多人游戏。
在传统的 HTTP 中，客户端向服务器发送请求，服务器用请求的数据进行响应。这种请求-响应模型需要从客户端到服务器进行连续轮询，这可能会导致延迟增加和效率降低。
另一方面，WebSockets 在客户端和服务器之间建立持久连接。这意味着一旦建立连接，客户端和服务器就可以随时向对方发送数据，而无需不断轮询请求。这允许实时通信，可以立即发送和接收更新。
例如，当用户在聊天应用程序中发送消息时，该消息可以立即传递给所有其他用户，而无需刷新页面或发出频繁的 HTTP 请求。这将带来更加无缝和高效的用户体验。
此外，Web Sockets 还允许双向通信，这意味着客户端和服务器都可以相互发送数据。这为更具交互性和吸引力的应用程序提供了可能性，其中服务器可以处理向客户端推送更新或通知，而无需客户端明确请求它们。
Web 套接字的缺点 WebSocket 的缺点包括：
浏览器支持：虽然大多数现代浏览器支持 WebSocket，但一些旧浏览器不支持。这可能会限制应用程序的范围，并且需要针对旧版浏览器的额外后备机制。 代理和防火墙限制：某些代理服务器和防火墙可能会阻止或干扰 WebSocket 连接。这可能会导致连接问题，尤其是在安全的公司或受限的网络环境中。 可扩展性：Web Sockets 在客户端和服务器之间维护持久连接，这在处理许多并发连接时可能会导致服务器资源紧张。必须实施适当的负载平衡和资源管理技术以确保可扩展性。像 Socket.io 这样的开源资源不适合大规模运营或快速增长。 有状态性：与无状态的传统 HTTP 不同，WebSocket 是有状态的。这意味着服务器需要维护每个客户端的连接状态，从而导致内存使用量增加和潜在的可扩展性挑战。 安全注意事项：通过 WebSocket 建立持久连接，需要采取适当的安全措施来防止潜在的漏洞，例如跨站点脚本 (XSS) 和跨站点请求伪造(CSRF)。应实施使用SSL/TLS加密的安全 WebSocket 连接 (wss://)，以确保数据隐私和完整性。 如果通过 Web 套接字的连接丢失，则不包含负载平衡或重新连接机制。 在可能不支持 Web Sockets 的环境中，仍然需要有后备选项，例如HTTP 流或长轮询。 像Presence这样的功能在 WebSocket 连接上不能很好地工作，因为断开连接很难检测到。 WebSockets、HTTP、Web 服务器、轮询 HTTP 连接与 WebSockets 要了解WebSocket API，了解其构建基础 — HTTP（超文本传输协议）及其请求/响应模型也很重要。 HTTP 是一种应用层协议，是所有基于 Web 的通信和数据传输的基础。
使用 HTTP 时，客户端（例如 Web 浏览器）向服务器发送请求，然后服务器发回消息（称为响应）。我们今天所知道的网络是建立在这种基本的客户端-服务器循环之上的，尽管对 HTTP 进行了许多添加和更新以使其更具交互性。当前有一些可行且受支持的 HTTP 版本（HTTP/1.1 和 HTTP/2）以及称为 HTTPS 的安全版本。
基本 HTTP 请求适用于许多用例，例如当有人需要在网页上搜索并接收相关的、非时间敏感的信息时。然而，它并不总是最适合需要实时通信或需要以最小延迟快速更新的数据的 Web 应用程序。
每当客户端发出新的 HTTP 服务器请求时，默认行为是打开新的 HTTP 连接。这是低效的，因为它使用循环非有效负载数据的带宽并增加了数据传输之间的延迟。
此外，HTTP 请求只能从客户端向一个方向流动。传统上没有服务器发起与客户端通信的机制。除非服务器首先请求数据，否则服务器无法向客户端发送数据。这可能会给需要从服务器端实时发出消息的用例带来问题。
短轮询与 WebSockets HTTP 轮询是接收定期数据更新的第一个解决方案。轮询是一种客户端重复向服务器发送请求直到服务器更新的技术。例如，所有现代 Web 浏览器都提供对 XMLHttpRequest 的支持，这是轮询服务器的原始方法之一。...</p></div><footer class=entry-footer><span title='2024-05-07 14:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;329 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是WebSocket？" href=https://blog.chensoul.cc/posts/2024/05/07/websockets/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]什么是长轮询？</h2></header><div class=entry-content><p>原文链接：https://www.pubnub.com/guides/long-polling/
什么是长轮询？ 长轮询用于实时 Web 应用程序，以实现客户端和 Web 服务器之间近乎即时的通信。它在实时更新至关重要的聊天和消息应用程序中特别有用。
在传统的HTTP通信中，客户端向服务器发送新请求并等待响应。这称为短轮询。然而，在实时场景中，短轮询可能效率不高，因为它需要频繁向服务器请求，导致不必要的网络开销和增加延迟。
另一方面，长轮询通过在新数据可用之前保持请求长时间打开来提高效率。服务器保持请求打开并等待，直到有新信息发送回客户端。一旦服务器有新数据，它就会响应客户端，然后客户端可以处理数据并发起新的长轮询请求。
通过维持客户端和服务器之间的长期连接，长轮询减少了请求数量，最大限度地减少了延迟，并提高了实时通信。这使得它非常适合需要有效技术来构建可扩展和响应式聊天和消息传递应用程序以及其他利用游戏等实时数据的应用程序的用例。
长轮询如何工作？ 长轮询是一种用于实时通信的技术，用于在客户端和服务器之间实现近乎即时的消息传递。它在构建低延迟和实时更新至关重要的聊天和消息传递应用程序时特别有用。
传统上，Web 浏览器使用基于拉取的方法从服务器获取数据。客户端向服务器发送请求，服务器以请求的数据进行响应。这种方法称为短轮询，可能会造成通信延迟，因为客户端必须重复发送请求来检查更新。
另一方面，长轮询是一种基于推送的方法，允许服务器在更新可用时立即向客户端发送更新。它的工作原理如下：
客户端向服务器发起请求，通常通过 HTTP 请求。 服务器不会立即响应，而是将请求保持打开状态，从而保持连接处于活动状态。 如果没有新数据可用，服务器将等待，直到有数据要发回。 一旦服务器有新的数据或者发生预定义的超时，它就会用最新的信息响应客户端。 客户端收到响应后，立即向服务器发送另一个请求以维持连接。 这种发送请求和接收响应的循环持续进行，确保实时更新。 长轮询通过长时间保持请求-响应周期打开来有效地模拟客户端和服务器之间的实时连接。它允许服务器在更新可用时立即将更新推送到客户端，并且无需客户端重复检查更新。
使用什么技术来实现长轮询？ 长轮询是一种实现客户端和服务器之间实时通信的技术。它通常用于即时更新至关重要的聊天和消息传递应用程序。可以使用多种技术来实现长轮询，每种技术都有优点和注意事项。让我们探讨一些用于实现长轮询的常用技术。
HTTP 长轮询：
这是实现长轮询的最基本、最广泛使用的方法。它利用 HTTP 协议建立并维护客户端和服务器之间的长期连接。客户端向服务器发送请求，服务器将请求保持打开状态，直到有新数据可用或达到某个超时。一旦有新数据可用，服务器就会用更新的信息进行响应，客户端立即发送另一个请求以继续循环。这种方法易于实现，不需要特殊的服务器端技术。
网络套接字：
WebSocket 是一种全双工通信协议，可通过单个长期连接在客户端和服务器之间实现实时通信。它提供了比长轮询更高效、低延迟的替代方案。 WebSocket 支持双向数据流，允许客户端和服务器异步发送消息。它消除了频繁的 HTTP 请求并减少了网络开销。 WebSocket 非常适合需要即时更新和实时交互的应用程序。
服务器发送的事件 (SSE)：
SSE 是一种单向通信技术，允许服务器通过单个长期 HTTP 连接将数据推送到客户端。通过SSE，服务器可以向客户端发送多个更新，而不需要客户端不断地发出请求。服务器启动连接并以一系列事件的形式发送数据。客户端接收这些事件并可以根据需要进行处理。
在选择在应用程序中实现长轮询的技术时，需要考虑以下几个因素：
可扩展性：确保所选技术可以处理大量并发连接，并且可以随着用户群的增长而扩展。 WebSocket 和 SSE 通常比基于 HTTP 的长轮询更具可扩展性，因为它们允许更有效地使用服务器资源。 安全性：考虑所选技术的安全影响。 WebSocket 和 SSE 可以使用SSL/TLS等加密协议进行保护，从而确保数据隐私和完整性。基于 HTTP 的长轮询也可以得到保护，但可能需要额外的身份验证和访问控制措施。 浏览器支持：检查所选技术的浏览器兼容性。 WebSocket 和 SSE 比基于 HTTP 的长轮询具有更好的浏览器支持，这可能需要额外的技术或针对旧浏览器的后备选项。 实施复杂性：评估所选技术的实施和维护难易程度。基于 HTTP 的长轮询相对简单，而 WebSocket 和 SSE 可能需要更高级的知识和基础设施。考虑开发团队可用的专业知识水平以及实施和维护所选技术所需的资源。 长轮询与 WebSockets 长轮询和 WebSocket是在客户端（例如 Web 浏览器）和服务器之间实现实时连接的技术。尽管它们的目的相似，但两者存在显着差异。
长轮询是一种技术，客户端向 Web 服务器发出请求，服务器保持连接打开，直到有新数据要发回。如果服务器有新数据可用，则可以立即响应，或者在发送空响应之前等待指定的超时时间。无论哪种情况，客户端一旦收到响应，就会立即向服务器发出另一个请求以建立新连接。此过程不断重复，允许服务器在更新可用时立即将更新推送到客户端。
另一方面，WebSockets 在客户端和服务器之间提供持久的双向通信通道。与长轮询不同的是，长轮询会为每个请求建立一个新连接，而 WebSocket 连接只会建立一次并无限期地保持打开状态。这允许双向实时、低延迟通信。服务器可以随时向客户端推送数据，客户端也可以不等待响应就向服务器发送数据。
长轮询和 Web Sockets 之间的相似之处： 1.实时更新：长轮询和WebSockets都可以实现服务器和客户端之间的实时通信，允许即时更新，无需连续轮询或刷新。
减少服务器负载：这两种技术都通过仅在数据可用时发送数据来最大程度地减少不必要的请求，从而减少服务器负载并提高可扩展性。 广泛的语言和框架支持：许多流行的编程语言和框架都支持长轮询和WebSocket，使不同生态系统的开发人员都可以使用它们。 长轮询和 Web Sockets 之间的区别： 1.延迟：长轮询会引入延迟，因为服务器发送响应和客户端接收响应之间存在延迟。 WebSocket 提供双向、低延迟通信，从而实现更快的实时功能。...</p></div><footer class=entry-footer><span title='2024-05-07 14:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;205 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]什么是长轮询？" href=https://blog.chensoul.cc/posts/2024/05/07/long-polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]2024年最好的WebSocket替代品</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/websocket-alternatives
什么是 WebSocket？ 简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。
了解更多：
什么是 WebSocket？ WebSocket 是如何工作的？ 什么时候应该考虑使用 WebSocket 替代方案？ 对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括聊天应用程序、多人协作体验以及广播实时路况更新。
了解有关 WebSocket 用例的更多信息
然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。
我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。
了解 WebSocket 的优点和缺点
WebSocket 协议的五种替代方案 现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。
服务器发送的事件 服务器发送事件 (SSE)是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。
服务器发送事件的优点
内置对重新连接的支持。 所有现代浏览器都支持。 轻量级协议。 服务器发送事件的缺点
它是单向的；只有服务器可以将数据推送到客户端。 每个浏览器在同一时间只能有六个并发 SSE 连接。 仅支持UTF-8文本数据； SSE 无法处理二进制数据。 对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。
查看 SSE 与 WebSocket 的比较
长轮询 长轮询是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。
长轮询的优点
长轮询是在XMLHttpRequest的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。 在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。 长轮询的缺点
与 WebSocket 相比，长轮询在服务器上消耗更多资源。 长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。 可靠的消息排序可能是一个问题。 长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。
查看轮询与 WebSocket 相比需要多长时间...</p></div><footer class=entry-footer><span title='2024-05-07 11:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;436 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]2024年最好的WebSocket替代品" href=https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]HTTP 的演变 – HTTP2 深入探讨</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/http2
可以毫不夸张地说，超文本传输协议 (HTTP) 造就了我们所熟知的互联网。 HTTP 最初是由万维网的发明者蒂姆·伯纳斯·李 (Tim Berners-Lee) 于 1989 年提出的应用程序协议。第一个记录版本 HTTP/0.9 被称为单行协议。鉴于它催生了万维网，它现在可以被描述为有史以来最伟大的俏皮话。
随着我们对互联网的需求不断增长，HTTP 作为网络协议也必须不断发展才能提供可接受的性能。 HTTP/2 标志着一次重大改革，是自 1997 年 HTTP/1.1 ( RFC 2068 ) 提供以来第一个新的标准化。本文介绍了 HTTP/2 如何设计来克服 HTTP/1.1 的限制、新协议的实现、HTTP/2 的工作原理以及其自身的限制。
通过单个 TCP 连接的 HTTP/2 客户端-服务器。
出身卑微——HTTP 简史 HTTP/0.9 的“单行协议”由请求组成：方法GET后跟文档地址、可选端口地址，并以回车符和换行符结束。由一串 ASCII 字符组成的请求。只能传输 HTML 文件。没有 HTTP 标头、状态代码或错误代码。
进化的第一阶段必须很快到来。
HTTP/1.0 – 突破限制 为了克服 HTTP/0.9 的严重限制，浏览器和服务器独立修改了协议。一些关键的协议更改：
请求允许包含多个由换行符分隔的标头字段。 服务器发送了包含单个状态行的响应。 响应中添加了一个标头字段。响应标头对象由由换行符分隔的标头字段组成。 服务器可以使用 HTML 以外的文件进行响应。 这些修改没有以有序或商定的方式完成，导致 HTTP/0.9 的不同风格，进而导致互操作性问题。为了解决这些问题，HTTP 工作组成立，并于 1996 年发布了 HTTP/1.0（RFC 1945）。它是一个信息性 RFC，仅记录当时的所有用法。因此，HTTP/1.0 不被视为正式规范或互联网标准。
HTTP/1.0 请求/响应的代码示例 来自客户端的使用 GET 方法的请求
GET /contact HTTP/1.0 Host: www.ably.io User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0) Accept: text/*, text/html, text/html;level=1, */*Accept-Language: en-us 客户端通过 POST 方法发出请求
POST /contact HTTP/1.0 Host: www.ably.io User-Agent: Mozilla/4....</p></div><footer class=entry-footer><span title='2024-05-07 11:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1012 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]HTTP 的演变 – HTTP2 深入探讨" href=https://blog.chensoul.cc/posts/2024/05/07/http2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/websockets-vs-http
当谈到 WebSocket 与 HTTP 时，决定使用哪一种并不总是那么明确。哪一个更好？您的应用程序应该使用哪一款？
但问题的答案不一定是其中之一 - 开发人员经常根据场景在同一个应用程序中同时使用 WebSocket 和 HTTP。更重要的问题是 - 我如何确定 WebSockets 还是 HTTP 是特定类型通信的正确通信协议？
这是您需要了解的一切。
WebSocket 与 HTTP 概览 在此页面上，我们将探讨这些技术的工作原理、它们在实现实时通信方面的表现如何，并就在哪些场景中使用哪些技术提供具体指导。
如果您正在寻找高级比较，以下是主要差异一目了然：
请继续阅读以详细了解这两种流行协议的比较。
HTTP协议 什么是 HTTP？ 从根本上讲，HTTP 是一种通信协议，使客户端（例如 Web 浏览器）和服务器能够共享信息。
例如，HTML 文档、图像、应用程序数据 (JSON) 等。
很难想出比您现在正在阅读的此页面更好的 HTTP 实际示例。
当您加载此页面时，您的浏览器会发出 HTTP 请求，服务器会使用您当前正在阅读的 HTML 文档来响应该请求。
HTTP 是如何工作的？ HTTP 遵循请求-响应消息传递模式，其中客户端发出请求，Web 服务器发送响应，该响应不仅包括请求的内容，还包括有关请求的相关信息。
在底层，每个请求都会打开一个与服务器的短暂连接，然后关闭。
HTTP 示例
网页浏览。 下载图像、视频或二进制文件，例如桌面应用程序。 使用 JavaScript 中的 fetch 函数向 API 发出异步请求。 由于每个 HTTP 请求都包含处理它所需的所有信息，因此服务器无需跟踪连接和请求。
这种无状态设计是有利的，因为它使得可以部署额外的服务器来处理请求，而不需要在服务器之间同步状态逻辑。
此外，由于每个请求都是独立的，因此通过代理路由消息以执行缓存、加密和压缩等增值功能变得非常简单。
这种无状态方法的缺点是客户端打开一个临时连接并为每个请求发送元数据，从而产生少量开销。
当加载网页或下载文件时，这种开销可以忽略不计。但是，如果您发送负载较小的高频请求，它可能会对应用程序的性能产生显着影响。
通过 HTTP 进行实时更新 这种模式（客户端发出请求，服务器发出响应）非常适合网页、文件或应用程序数据等静态资源。
但是，请考虑这样一种情况：客户不知道新信息何时可用。
例如，假设您正在为 BBC 实施突发新闻功能。
在这种情况下，客户不知道故事的下一次更新何时会发生。
现在，您可以对客户端进行编码，以频繁地发出 HTTP 请求，以防万一发生某些情况，并且对于少数客户端来说，这可能工作得足够好。
但是假设您有成百上千个客户端（在 BBC 的情况下有数十万个）向服务器发送请求，而这些请求在更新之间没有产生任何新内容。
这不仅浪费带宽和服务器资源，而且在最近的请求完成后不久更新就会中断 - 可能需要几秒钟才能发送下一个请求并且用户获得更新。一般来说，这种方法称为HTTP 轮询，它既不高效也不实时！
相反，如果服务器能够在新信息可用时将数据推送到客户端，那就更好了，但这从根本上违背了请求-响应模式的原则。
或者确实如此？
HTTP 流式传输 尽管 HTTP 从根本上遵循请求-响应模式，但有一种解决方法可用于实现实时更新。
服务器不是发出完整的响应，而是发出部分 HTTP 响应并保持底层连接打开。
基于上一节的突发新闻示例，通过 HTTP 流，服务器可以在每次新闻更新中断时将部分响应（如果您愿意，可以是块）附加到响应流 - 连接无限期保持打开状态，使服务器能够推送当新信息可用时，以最短的延迟向客户端提供新信息。...</p></div><footer class=entry-footer><span title='2024-05-07 11:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;452 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]WebSocket与HTTP：2024年为您的项目选择哪一个" href=https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/websockets-kafka
Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。
由于 Kafka 如此受欢迎，我很好奇是否可以使用它通过互联网和 WebSockets 将实时数据直接流式传输给最终用户。毕竟，Kafka 具有一系列特征，似乎使其成为一个值得注意的选择，例如：
高通量 低延迟 高并发 容错能力 持久性（持久性） 用于将 Kafka 消息流式传输到面向互联网的客户端的现有解决方案 我开始研究实时开发社区对这个用例的看法。我很快发现 Kafka 最初设计用于安全网络内进行机器对机器通信。这让我想到，如果您想通过 WebSocket 将数据从 Kafka 流式传输到面向互联网的用户，您可能需要使用某种中间件。
我继续研究，希望找到一些可以充当中间件的开源解决方案。我发现了其中的几个，理论上可以用作 Kafka 和通过互联网连接数据流的客户端之间的中介：
transfers_websockets_service kafka-websocket kafka-proxy-ws 不幸的是，上面列出的所有解决方案都只是概念证明，仅此而已。它们的功能集有限，并且尚未做好生产准备（尤其是大规模生产）。
然后我研究了成熟的科技公司如何解决这个 Kafka 用例；看来他们确实在使用某种中间件。例如，Trello 开发了WebSocket 协议的简化版本，仅支持订阅和取消订阅命令。 Slack 提供了另一个例子。该公司构建了一个名为Flannel的代理，它本质上是部署到边缘存在点的应用程序级缓存服务。
当然，像 Trello 或 Slack 这样的公司有能力投资所需的资源来构建此类解决方案。然而，开发自己的中间件并不总是一个可行的选择——这是一项非常复杂的任务，需要大量的资源和时间。另一种选择（最方便、最常见的一种）是使用已建立的第三方解决方案。
正如我们所看到的，普遍的共识似乎是 Kafka 本身不适合通过互联网进行最后一英里交付；您需要将它与另一个组件结合使用：面向互联网的实时消息传递服务。
在 Ably，我们的许多客户都通过我们面向互联网的 pub/sub 实时消息服务传输 Kafka消息。为了演示它是多么简单，下面是如何从 Kafka 消费数据并将其发布到 Ably 的示例：
const kafka = require('kafka-node'); const Ably = require('ably'); const ably = new Ably.Realtime({{ABLY_API_KEY}}); const ablyChannel = ably.channels.get('kafka-example'); const Consumer = kafka.Consumer; const client = new kafka....</p></div><footer class=entry-footer><span title='2024-05-07 10:10:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;549 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端" href=https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[译]Apache Kafka、RabbitMQ 与 AWS SNSSQS：哪个消息代理最好？</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs
将消息从一个组件获取到另一个组件是微服务架构中最重要的部分之一。每个服务必须能够与任何其他服务异步、可靠且大规模地通信。
这就是消息代理的用武之地。消息代理（例如 Apache Kafka、RabbitMQ 和AWS SNS/SQS）为您提供一个通用接口和一组保证，而不是手动协调可能数千个微服务之间的通信。这简化了集成并更容易推理您的系统。
然而，比较消息代理可能很棘手，因为每个消息代理都采用不同的方法来完成工作。那么，您如何决定哪个消息代理最适合您的用例？
在本文中，您将找到有关业界最受欢迎的三个消息代理如何适用于不同用例的指南。我们将研究诸如它们的扩展方法、它们支持的消息传递模式以及它们如何处理性能和智能消息路由之间的权衡等特征。
比较消息代理：您应该寻找什么？ 消息代理是一个广泛的类别。虽然我们正在考虑的三个选项中的每一个都在更大系统中的组件之间移动数据，但在它们之间做出决定取决于它们如何做到这一点。
因此，我们需要检查每个消息代理的特征，根据它们如何影响其移动数据的能力以及它的工作方式。我们将研究以下六个因素以及它们如何应用于 Apache Kafka、RabbitMQ 和 AWS SNS/SQS：
**消息传递模式：**消息代理组织和分发消息的方式（例如发布/订阅或请求回复）比其他架构和用例更适合某些架构和用例。 **消息路由：**消息代理能否根据消息的内容和其他标准来路由消息？ **可扩展性：**并非每种情况都需要每秒处理数百万条消息。确保消息代理可以扩展到您需要的吞吐量级别，同时牢记这将如何影响设置和操作的复杂性。 **可靠性：**消息代理如何处理故障？它会保留消息还是仅通过系统传递消息？ **安全性：**数据是否加密？消息代理是否提供审核日志？它如何处理身份验证和访问控制？是否经过 HIPAA 和 PCI DSS 等行业标准认证？ **成本和许可：**消息代理是开源的吗？需要哪些云或服务器资源？是否持续收取许可费？您的团队需要花费多少时间来运行它？ 介绍 Apache Kafka、RabbitMQ 以及 AWS SNS 和 SQS 在详细进行比较之前，我们先来谈谈为什么我们关注这三种解决方案。原因之一是它们是您可能遇到的最常见的消息代理解决方案之一。研究表明，全球有近 50,000 家公司使用 RabbitMQ，而超过60,000 家公司正在使用 Apache Kafka。尽管 AWS SQS 的用户群似乎较小，但只有超过 24,000 家公司，但它在更广泛的 Amazon Web Services 生态系统中发挥着重要作用。这种广泛的部署使得您可以更轻松地招募经验丰富的员工、与现有技术堆栈集成，以及当您需要时寻求支持。但还有另一个考虑因素。我们正在研究的每个消息代理都从不同的角度解决该问题。 Apache Kafka 专为吞吐量而设计，而 RabbitMQ 更关注复杂的消息路由。与 RabbitMQ 一样，SNS 和 SQS 这两种 AWS 解决方案更关注路由而不是吞吐量，我们在这里考虑它们是因为 AWS 生态系统的重要性。
阿帕奇·卡夫卡 Apache Kafka 是一个实时流平台，旨在构建可扩展、容错的分布式应用程序。它专门以非常高的吞吐量传输数据，通常用于操作数据，例如日志记录和指标。
拥有如此庞大的安装基础，有一些工具可以将 Apache Kafka 连接到几乎任何其他正在运行的系统。尽管 Apache Kafka 专注于高吞吐量，但它也可以处理传输中的数据，例如触发操作和转换数据。然而，这种灵活性和强大功能是有代价的，因为 Apache Kafka 比某些替代方案更难设置和操作。
RabbitMQ 与 Apache Kafka 专注于流数据不同，RabbitMQ 是一个开源分布式消息代理，支持多种不同的消息传递模式，例如发布/订阅和生产者/消费者。尽管它确实拥有高吞吐量，但它的重点更多地是根据消息内容、一天中的时间、发送者和其他标准智能地路由数据，这使得它非常适合事件驱动的架构。
与 Apache Kafka 一样，RabbitMQ 得到了广泛的支持，具有丰富的集成生态系统。
AWS SNS 和 SQS Amazon Web Services (AWS) 提供了两种适合消息代理旗帜的产品。 AWS Simple Notification Service (SNS) 是一种高吞吐量消息传递服务，它使用发布/订阅模型在微服务或分发应用程序的组件之间传递消息。...</p></div><footer class=entry-footer><span title='2024-05-07 10:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;420 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Apache Kafka、RabbitMQ 与 AWS SNSSQS：哪个消息代理最好？" href=https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/posts/page/7/>«&nbsp;Prev&nbsp;7/28
</a><a class=next href=https://blog.chensoul.cc/posts/page/9/>Next&nbsp;9/28&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>