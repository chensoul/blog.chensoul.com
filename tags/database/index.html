<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Database | ChenSoul</title>
<meta name=keywords content><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/tags/database/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/tags/database/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/tags/database/><meta name=twitter:title content="Database | ChenSoul"><meta name=twitter:description content><meta property="og:title" content="Database | ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/tags/database/"><meta property="og:site_name" content="ChenSoul"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-tags kind-term layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签 class=active>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><header class=page-header><h1>tag: Database</h1><div class=inline-links><span><a href=https://blog.chensoul.cc/tags/database/index.xml target=_blank>RSS</a></span></div></header><article class="post-entry tag-entry"><header class=entry-header><h2>[译]数据库分片速成课程</h2></header><section class=entry-content><p>原文链接：https://blog.bytebytego.com/p/a-crash-course-in-database-sharding
随着应用程序越来越受欢迎，它会吸引更多活跃用户并加入更多功能。这种增长导致每日数据生成量增加，从业务角度来看，这是一个积极的指标。
然而，它也给应用程序的架构带来挑战，特别是在数据库可扩展性方面。
数据库是任何应用程序的关键组件，但它也是最难水平扩展的组件之一。当应用程序的流量和数据量增加时，数据库可能会成为性能瓶颈，影响用户体验。
分片是一种解决数据库横向扩展难题的技术。它涉及将数据库划分为更小、更易于管理的单元（称为分片）。
在这篇文章中，我们将介绍数据库分片的基础知识，探讨其各种方法、技术考虑因素，以及展示公司如何实施分片来扩展其数据库的真实案例研究。
什么是分片？ 分片是一种架构模式，用于解决管理和查询数据库中大型数据集的难题。它涉及将大型数据库拆分为更小、更易于管理的部分（称为分片）。
共享建立在水平分区的概念之上，水平分区涉及根据分区键将表的行分成多个表。这些表称为分区。跨分区分布数据可减少查询和操作数据所需的工作量。
下图说明了水平分区的一个例子。
数据库分片将水平分区提升到了一个新的水平。分区将所有数据组存储在同一台计算机中，而分片则将它们分布在不同的计算机或节点上。这种方法通过利用多台机器的资源来实现更好的可扩展性和性能。
值得注意的是，不同数据库使用的分片术语有所不同。
在 MongoDB 中，分区称为分片 (shard)。 Couchbase 使用术语 vBucket 来表示分片。 Cassandra 将分片称为 vNode。 尽管术语存在差异，但其基本概念保持不变：将数据分成更小、更易于管理的单元，以提高查询性能和可扩展性。
数据库分片的好处 数据库分片有几个主要优点：
可扩展性： 分片的主要动机是实现可扩展性。通过将大型数据集分布在多个分片上，查询负载可以分散到多个节点上。对于对单个分片进行操作的查询，每个节点都可以独立执行针对其分配数据的查询。此外，可以在运行时动态添加新分片，而无需关闭应用程序进行维护。 性能提升： 从单个大型数据库中检索数据可能非常耗时。查询需要搜索大量行才能找到所需数据。相比之下，与整个数据库相比，分片包含的行子集更小。由于查询需要处理的行更少，因此搜索空间的减少可加快数据检索速度。 可用性： 在单片数据库架构中，如果托管数据库的节点发生故障，依赖该数据库的应用程序也会停机。数据库分片通过将数据分布在多个节点上来降低这种风险。如果发生节点故障，应用程序可以使用剩余的分片继续运行。 分片和复制 分片通常与复制一起使用，以实现分布式数据库系统中的高可用性和容错能力。
复制涉及创建数据的多个副本并将其存储在不同的节点上。在主从复制模型中，一个节点充当主节点并处理写入操作，而从节点复制主节点的数据并处理读取操作。
通过在多个节点上复制每个分片，系统可确保即使个别节点发生故障，数据仍可访问。一个节点可以存储多个分片，每个分片在主从复制模型中可以是主分片或从分片。
下图说明了一种安排，其中每个分片的领导者被分配给一个节点，而其追随者分布在其他节点上：
在此设置中，一个节点可以同时充当某些分区的领导者和其他分区的追随者。这种分布式架构允许系统在发生节点故障或网络中断时保持数据可用性和弹性。
分片类型 数据库分片的主要目标是在多个节点上均匀分布数据和查询负载。
然而，如果数据分区不平衡，一些分片最终可能会处理比其他分片多得多的数据或查询。这种情况称为倾斜分片，它会削弱分片的优势。
在极端情况下，设计不良的分片策略可能导致单个分片承担全部负载，而其余分片保持空闲状态。
这种情况称为热点，其中一个节点因过高的负载而变得不堪重负。
为了减轻分片倾斜和热点的风险，选择适当的分片策略以确保数据和查询在分片之间均匀分布至关重要。
我们来了解一些常用的分片策略：
基于范围的分片 基于范围的分片是一种根据一系列值拆分数据库行的技术。
在这种方法中，每个分片都会分配一个连续的键范围，从最小值到最大值。每个分片内的键都按排序顺序维护，以实现高效的范围扫描。
为了说明这个概念，让我们考虑一个存储产品信息的产品数据库。
可以应用基于范围的分片，根据产品的价格范围将数据库拆分为不同的分片。例如，一个分片可以存储价格范围在 0 美元到 75 美元之间的所有产品，而另一个分片可以包含价格范围在 76 美元到 150 美元之间的产品。
需要注意的是，键的范围不一定需要均匀分布。在实际应用中，数据分布可能不均匀，可以相应地调整键范围，以实现分片间数据分布的平衡。
然而，基于范围的分片有一个潜在的缺点。 某些访问模式可能会导致热点的形成。例如，如果数据库中很大一部分产品属于特定价格范围，则负责存储该范围的分片可能会承受不成比例的高负载，而其他分片仍未得到充分利用。
基于键或哈希的分片 基于密钥的分片（也称为基于哈希的分片）是一种使用哈希函数将特定密钥分配给分片的技术。
精心设计的哈希函数对于实现密钥的均衡分布起着至关重要的作用。基于哈希的分片不会为每个分片分配一系列密钥，而是为每个分片分配一系列哈希。一致性哈希是一种常用于实现基于哈希的分片的技术。
下图说明了基于键或哈希的分片的基本概念：
基于哈希的分片的主要优势之一是它能够在分片之间公平分配密钥。通过对密钥应用哈希函数，该技术有助于降低热点风险。
但是，基于哈希的分片也存在弊端。通过使用键的哈希而不是键本身，我们失去了执行高效范围查询的能力。这是因为相邻的键可能分散在不同的分区中，并且在此过程中会丢失它们的自然排序顺序。
需要注意的是，基于哈希的分片虽然有助于减少热点，但无法消除热点。在所有读取和写入都集中在单个键上的极端情况下，所有请求仍可能被路由到同一分区。例如，在社交媒体网站上，名人用户可以发布对同一键产生大量写入的内容。
基于目录的分片 基于目录的分片是一种依赖查找表来确定分片间记录分布的方法。
查找表充当目录或地址簿，映射数据与其所在的特定分片之间的关系。此表与分片本身分开存储。
下图说明了基于目录的分片的概念，使用“位置”字段作为分片键：
与其他分片策略相比，基于目录的分片的主要优势之一是灵活性。它允许更好地控制分片间数据的放置，因为数据和分片之间的映射在查找表中明确定义。
然而，基于目录的分片也有一个明显的缺点：它严重依赖查找表。与查找表相关的任何问题或故障都可能影响数据库的整体性能和可用性。
选择分片键时要考虑的因素 选择合适的分片键对于实施有效的分片策略至关重要。数据库设计人员在做出此决定时应考虑几个关键因素：
基数 基数是指分片键可以具有的可能值的数量。它决定了可以创建的最大分片数量。
例如，如果选择布尔数据字段作为分片键，则系统将仅限于两个分片。
为了最大限度地发挥水平扩展的优势，通常建议选择具有高基数的分片键。
频率 分片键的频率表示特定分片键值在数据集中出现的频率。
如果大部分记录仅包含可能的分片键值的子集，则负责存储该子集的分片可能会成为热点。
例如，如果健身网站的数据库使用年龄作为分片键，则大多数记录可能最终会出现在包含 30 至 45 岁之间的订阅者的分片中，从而导致数据分布不均匀。
单调变化 单调变化是指对于给定的记录，分片键值随着时间的推移而增加或减少。
如果分片键基于单调增加或减少的值，则可能导致分片不平衡。
考虑存储用户评论的数据库的分片方案。
分片A存储评论少于10条的用户的数据。 分片B存储有11-20条评论的用户的数据。 分片 C 存储了评论超过 30 条的用户的数据。 随着用户随着时间的推移不断添加评论，他们会逐渐迁移到分片 C，这使得它比分片 A 和 B 更加不平衡。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-08-05</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/database/>Database</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]数据库分片速成课程" href=https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-in-database-sharding/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]数据库扩展策略速成课程</h2></header><section class=entry-content><p>原文链接：https://blog.bytebytego.com/p/a-crash-course-in-database-scaling
数据库是现代应用程序开发的支柱。它们在存储、管理和检索数据方面发挥着至关重要的作用，使应用程序和服务能够有效运行。
随着应用程序越来越受欢迎并吸引越来越多的用户群，数据库面临着处理不断增加的数据量、并发用户和复杂查询的挑战。
有效地扩展数据库以确保最佳性能和良好的用户体验变得至关重要。
数据库扩展是调整和扩展数据库基础架构以适应增长并在负载增加的情况下保持性能的过程。它涉及采用各种技术和策略来有效地分配数据，优化查询执行并明智地利用硬件资源。
组织和开发人员必须了解并实施正确的数据库扩展策略。针对特定情况选择错误的策略可能会弊大于利。
在这篇文章中，我们将详细介绍最流行的数据库扩展策略，讨论它们的优点和权衡。
索引 索引是增强数据库可扩展性和性能的基础技术之一。
索引可以看作是数据库的“目录”。它包含对主数据库表中特定数据位置的引用，以便快速搜索和检索。
通过创建单独的数据结构（例如索引），数据库可以快速定位和检索特定数据，而无需扫描主表中的每个记录。
索引本身是数据的一个子集，以针对高效查询进行优化的方式组织。
为了更清楚地理解这个概念，我们假设有一个名为“客户”的数据库表，其中包含“ID”、“姓名”、“电子邮件”和“城市”等列。如果经常需要根据客户的电子邮件地址搜索客户，则在“电子邮件”列上创建索引可以提高搜索性能。
如果没有索引，通过电子邮件搜索客户将需要数据库扫描“客户”表中的每一行，直到找到匹配的记录。这个过程可能非常耗时，尤其是当表的大小增加时，这会导致查询响应时间变慢。
但是，通过在“电子邮件”列上创建索引，数据库可以使用索引数据结构快速查找所需的电子邮件地址并直接检索相应的行。这样就无需进行全表扫描，从而加快了搜索操作。
请参阅下图中的“电子邮件”列的示例索引：
索引的好处 索引提供了几个显著的好处，在处理大型数据库时这些好处变得越来越重要：
提高查询性能： 随着数据量的增长，如果数据库必须扫描大量记录，查询性能可能会下降。创建正确的索引可使数据库快速定位和检索特定的数据子集，而无需进行全表扫描。 减少资源消耗： 索引允许数据库有效地定位数据子集，从而最大限度地减少所需的磁盘 I/O 量和内存使用量。 提高并发性： 借助索引，数据库可以处理更多查询并容纳更多并发用户。这种改进的并发性在数据库必须扩展以支持大量用户的情况下尤其有益。 与索引的权衡 值得注意的是，索引会带来多重权衡。
当在列上创建索引时（例如我们示例中的电子邮件地址列），数据库会将索引数据与主表分开存储。这意味着对于每个索引列，都有一个额外的数据结构占用磁盘空间。 需要考虑的另一个权衡是索引对写入操作的潜在影响。在表中插入、更新或删除数据时，应更新相应的索引以保持准确性和一致性。这个额外的步骤增加了写入操作的开销，随着表上索引数量的增加，这种开销会变得更加明显。 为了达到正确的平衡，根据特定的查询模式和应用程序的性能要求仔细选择要索引的列非常重要。
物化视图 物化视图是一个数据库对象，它将查询结果存储为单独的、预先计算的结果集。
它源自一个或多个基表或视图，并且独立于底层数据源进行维护。
为了解释物化视图的概念，我们来考虑一个电子商务应用程序，它有一个包含数百万条记录的大型“订单”表。该应用程序经常生成每个产品类别的总销售收入报告。
如果没有物化视图，每次生成报告都需要扫描整个“订单”表，将其与“产品”表连接以获取类别信息，并执行聚合以计算每个类别的总收入。随着数据的增长，此查询会变得更慢且占用大量资源。
通过创建存储预先聚合的数据（例如每个产品类别的总收入）的物化视图，可以加快报告生成过程。
请参见下图，其中显示了存储每个产品类别的总收入的物化视图。
物化视图可以定期刷新，例如每天或每小时刷新一次，以确保数据保持最新状态。然后，可以直接从物化视图执行销售报告查询，提供即时结果，而无需处理整个“订单”表。
物化视图的好处 物化视图可以通过多种方式极大地增强数据库的可扩展性：
改进的查询性能： 物化视图存储预先计算的结果，无需重复执行复杂且耗时的查询。 减少基表的负载： 通过将计算成本高的查询结果存储在物化视图中，可以减少基表的负载。 与物化视图的权衡 虽然物化视图提供了显着的可伸缩性提升，但仍需要牢记一些权衡：
物化视图会消耗额外的存储空间，因为它们存储了结果集的单独副本。 刷新物化视图可能很耗时，尤其是对于大型数据集而言。 物化视图最终与源数据一致。换句话说，物化视图可以在短时间内包含陈旧数据。 反规范化 在规范化数据库设计中，数据被组织到单独的表中，以最大限度地减少冗余并确保数据完整性。每个表代表一个实体或概念，并使用外键建立表关系。这种方法遵循规范化的原则，旨在减少数据重复并保持数据一致性。
然而，严格遵守规范化规则有时会导致性能挑战，特别是在处理涉及跨表的多个连接的复杂查询时。
这就是非规范化发挥作用的地方。
非规范化是一种放宽严格规范化规则并允许受控数据冗余的技术。它涉及在多个表中策略性地复制数据以优化查询性能。目标是减少检索数据所需的连接和计算次数，从而提高查询速度和可扩展性。
为了理解非规范化的概念，请考虑一个包含“产品”表和“订单”表的电子商务应用程序。
在规范化设计中，“订单”表将仅存储对“产品”表的外键引用。需要将两个表连接起来才能检索带有订单信息的产品详细信息。
但随着订单数量的增长，如果应用程序经常需要在订单详情旁边显示产品名称和价格，那么连接操作可能会成为性能瓶颈。在这种情况下，可以应用非规范化来提高查询性能。
下图显示了在“订单”表上应用非规范化的示例：
通过对数据库进行非规范化并将产品名称和价格直接存储在“订单”表中，查询订单详细信息以及产品信息变得更简单、更快捷。冗余数据消除了连接的需求，使数据库在高查询负载下具有更好的扩展性。
非规范化如何帮助提高可扩展性？ 非规范化可以通过多种方式提高数据库的可伸缩性：
更快的查询执行： 消除或减少连接可以显著加快查询执行速度，尤其是对于经常访问或性能至关重要的查询。换句话说，数据库可以处理大量并发查询，从而提高整体可扩展性。 减少数据检索开销： 由于派生数据与主数据一起存储在同一张表中，因此无需执行昂贵的即时计算。 提高读取性能： 非规范化对于扩展读取密集型工作负载特别有益，因为查询无需连接多个表即可访问信息。 与非规范化的权衡 虽然非规范化可以提高查询性能和可伸缩性，但它也有一些缺点：
非规范化会引入数据冗余，从而增加存储需求。 非规范化使数据修改操作（插入、更新、删除）变得更加复杂和缓慢，因为冗余数据需要在多个表之间保持同步。 如果实施不当，非规范化可能会损害数据一致性。 垂直扩展 垂直扩展，也称为“向上扩展”，是一种通过增加单个服务器的硬件资源来提高数据库性能和可扩展性的技术。
这种方法侧重于通过为单个服务器分配更多资源来增强其功能。
垂直扩展的过程可能涉及几个关键升级：
用更快或多核处理器替换现有的 CPU，以提高处理能力并实现更快的查询执行。 向服务器添加更多 RAM 以增加内存容量，从而改善缓存。 升级到更快的存储设备，例如固态硬盘 (SSD)。 为了了解垂直扩展的好处，我们来考虑一个在购物旺季流量激增的电子商务应用程序。随着数据库服务器上的负载增加，查询响应时间可能会受到影响，从而导致用户体验不佳。
为了解决这一可扩展性挑战，应用程序所有者决定垂直扩展数据库服务器。他们使用更强大的 CPU 升级服务器，将 RAM 容量增加一倍，并用 SSD 替换硬盘驱动器 (HDD)。
这些硬件增强功能显著提高了数据库服务器的性能。更快的 CPU 和更大的内存可实现更快的查询执行和高效的缓存，而 SSD 则可提供更快的数据检索和写入速度。
因此，数据库服务器可以处理更多并发用户并提供更高的性能。
垂直扩展与数据库可扩展性的优势 垂直扩展可以通过多种方式提高数据库的可扩展性：...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-08-05</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/database/>Database</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译]数据库扩展策略速成课程" href=https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-in-database-scaling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]关系数据库设计速成课程</h2></header><section class=entry-content><p>原文链接：https://blog.bytebytego.com/p/a-crash-course-on-relational-database
在当今数据驱动的世界中，高效存储和管理信息是各种规模的企业和组织的关键要求。
关系数据库提供了一个强大的框架，用于根据实体之间明确定义的关系来存储和检索数据。它们提供了一种结构化的数据管理方法，使用户能够：
定义表 建立关系 执行复杂查询以从存储的信息中提取有意义的见解 然而，仅仅使用关系数据库还不足以获得其好处。
有效的数据库设计对于优化性能、确保数据完整性和促进高效的数据检索至关重要。数据库设计原则（例如规范化、索引、连接和关系）在创建结构良好且性能良好的数据库中起着至关重要的作用。
在这篇文章中，我们将研究关系数据库的基础知识，探讨其关键概念、管理系统以及有效数据库设计的基础原则。
什么是关系数据库？ 关系数据库是一种将数据组织成结构化表格（也称为关系）的数据库。这些表格由行（记录）和列（字段）组成，形成表格结构，可实现高效的数据存储和检索。
关系数据库的强大之处在于它能够在多个表之间建立关系。
通过定义相关表之间的连接，可以链接和组合信息。这允许跨多个表进行复杂的查询和数据检索操作，使您能够以各种方式访问和分析数据。
为了有效地使用关系数据库，我们需要一个关系数据库管理系统 (RDBMS)。
RDBMS 是一种用于创建、管理和与关系数据库交互的软件应用程序。
RDBMS 提供的一些关键功能包括：
数据定义： 定义数据库的结构，包括表、列、数据类型和约束。 数据操作： 对数据库中存储的数据执行各种操作。包括插入新记录、更新现有记录、删除记录等。 数据完整性： RDBMS 强制执行数据完整性规则来维护数据的准确性和一致性。 数据安全： RDBMS 还通过定义用户角色、权限和身份验证措施来提供控制数据库访问的机制。 查询优化： RDBMS 优化复杂查询的执行，以高效检索数据。它采用各种技术，例如索引和查询优化算法。 市场上有多种 RDBMS，每种都具有一组特性和功能。以下是一些示例：
MySQL： 一种开源 RDBMS，以其简单性、可靠性和广泛采用而闻名。 PostgreSQL： 一个强大的开源 RDBMS，具有高级功能和对数据完整性的强大支持。 Oracle 数据库： 一种功能全面、丰富的 RDBMS，常用于企业环境。 SQL：关系数据库语言 SQL（结构化查询语言）是用于与关系数据库交互的标准编程语言。
其主要优势之一是通用性。在 MySQL、PostgreSQL、Oracle 等上工作时，语法基本保持不变。
这种可移植性使开发人员能够以最小的学习曲线从一个 RDBMS 切换到另一个 RDBMS。
SQL 提供了一套全面的命令和语法，允许开发人员和数据库管理员对数据库中存储的数据执行各种操作。
SQL 支持四种基本的数据操作，通常称为 CRUD：
创建： 将新记录插入数据库表，有效地创建新的数据条目。 读取： 根据特定条件从一个或多个表中检索数据。 更新： 修改数据库中现有的记录。 删除： 从数据库表中删除不再需要或满足特定删除条件的记录。 除了数据操作之外，SQL 还提供定义和修改数据库结构的命令。
基本 RDBMS 概念 使用关系数据库时，了解基本概念和术语至关重要。
让我们探讨一些关键术语：
表： 按行和列组织的相关数据的结构化集合。每个表代表一个特定的实体或概念，例如客户、订单或产品。 行： 行，也称为记录或元组，表示表中的单个实例或条目。例如，在“客户”表中，每一行都属于具有某些属性的单个客户。 列： 列，也称为字段或属性，表示表中特定记录的特定特征或属性。列用于组织和分类表中的数据。 主键： 主键是一列或多列的组合，用作表中每条记录的唯一标识符。它通过防止主键列中的重复值或空值来确保数据的唯一性和完整性。 外键： 外键是表中引用另一个表的主键的列或列组合。它建立两个表之间的关系，并有助于加强引用完整性和数据一致性。 连接： 连接是一种根据相关列将两个或多个表中的行组合在一起的操作。通过指定组合表的条件，可以从多个表中检索数据。 索引： 索引是一种数据结构，可提高数据库中数据检索操作的性能。它根据一个或多个列创建表中数据的排序表示。 视图： 视图是从一个或多个基础表动态生成的虚拟表。它提供数据的自定义和简化表示。视图可用于安全性、简化或数据抽象目的。 关系数据库中的键 键是关系数据库设计中的基本组件，在数据完整性和建立表间关系方面发挥着至关重要的作用。
它们作为记录的唯一标识符，使数据检索和处理更加高效。
让我们看看不同类型的键及其在关系数据库设计中的意义。
主键和索引 主键是唯一标识表中每条记录的一列或多列的组合。
它确保每条记录都是唯一的，并且可以在表中轻松找到。主键约束强制主键列的唯一性和非空性。
下面的示例显示如何将表中的某一列定义为主键：
CREATE TABLE books ( book_id INT PRIMARY KEY, title VARCHAR(100), author VARCHAR(100), isbn VARCHAR(20) UNIQUE, publication_year INT, genre VARCHAR(50) ); 通过指定 book_id INT PRIMARY KEY，我们将 book_id 列声明为“books”表的主键。换句话说，book_id 列中的每个值都必须是唯一的，并且不能为空。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-08-05</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/database/>Database</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>4 min</span></span></footer><a class=entry-link aria-label="post link to [译]关系数据库设计速成课程" href=https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-relational-database/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>数据库如何设计树形结构</h2></header><section class=entry-content><p>在 MySQL 中，设计树形结构的区域表有多种方式。以下是一些常见的方案：
父子关系（Parent-Child Relationship）模型：在这种模型中，每个行记录包含一个指向其父级的引用。可以使用一个额外的列来存储父级 ID，或者使用自连接表来表示关系。这种模型简单直观，易于理解和管理。 路径（Path）模型：在这种模型中，每个行记录都包含一个代表其完整路径的字段。路径可以是以某种分隔符（如斜杠）分隔的字符串，例如：/地区/国家/城市。通过解析和处理路径字段，可以轻松地查询父级、子级和兄弟节点。 嵌套集模型（Nested Set Model）：这是一种基于左右值的模型，通过预先计算每个节点的左右值，可以高效地查询树形结构。每个节点都有一个左值和一个右值，用于表示其在树中的位置。这种模型适用于大型树结构，但需要特殊的操作来维护左右值。 物化路径（Materialized Path）模型：这是路径模型的一种改进版本，它使用额外的列来存储节点的层级关系。除了路径字段外，还可以添加一个表示节点级别的字段。这样可以更高效地进行查询，并且可以轻松地获取节点的父级、子级和兄弟节点。 父子关系（Parent-Child Relationship）模型 父子关系（Parent-Child Relationship）模型是一种在 MySQL 中设计树形结构的方式。在该模型中，每个区域记录包含一个指向其父级区域的引用。通过这种父子关系，可以建立区域之间的层级结构。
以区域为例，我们可以创建一个名为"area"的表来存储区域信息。该表可以包含以下列：
id：区域的唯一标识符（主键） name：区域的名称 parent_id：指向父级区域的引用 通过使用父子关系模型，我们可以创建以下区域的层级结构：
id | name | parent_id --------------------------- 1 | 世界 | NULL 2 | 亚洲 | 1 3 | 欧洲 | 1 4 | 北美洲 | 1 5 | 中国 | 2 6 | 日本 | 2 7 | 德国 | 3 8 | 法国 | 3 9 | 美国 | 4 10 | 加拿大 | 4 11 | 北京市 | 5 12 | 上海市 | 5 13 | 东京都 | 6 14 | 横滨市 | 6 在上述示例中，“area"表的每一行代表一个区域，通过"parent_id"列建立父子关系。根区域（世界）的"parent_id"为 NULL，表示没有父级区域。其他区域通过指定父级区域的"id"来建立层级关系。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-08-15</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/database/>Database</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to 数据库如何设计树形结构" href=https://blog.chensoul.cc/posts/2023/08/15/tree-structure-in-database/></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>