<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>github on ChenSoul</title>
    <link>https://blog.chensoul.com/tags/github/</link>
    <description>Recent content in github on ChenSoul</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 22 May 2023 15:00:00 +0800</lastBuildDate><atom:link href="https://blog.chensoul.com/tags/github/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[译]Build Robust Continuous Integration With Docker and Friends</title>
      <link>https://blog.chensoul.com/posts/2023/05/22/docker-continuous-integration/</link>
      <pubDate>Mon, 22 May 2023 15:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/22/docker-continuous-integration/</guid>
      <description>持续集成 (CI) 已成为软件开发的关键，它允许团队频繁合并代码更改并及早发现错误。 Docker 容器通过提供一致的环境帮助促进持续集成过程，您可以在其中测试和发</description>
      <content:encoded><![CDATA[<p><img loading="lazy" src="https://files.realpython.com/media/UPDATE-Docker-in-Action-Fitter-Happier-More-Productive_Watermarked.479cfb791c17.jpg" alt="Build Robust Continuous Integration With Docker and Friends"  />
</p>
<p>持续集成 (CI) 已成为软件开发的关键，它允许团队频繁合并代码更改并及早发现错误。</p>
<p>Docker 容器通过提供一致的环境帮助促进持续集成过程，您可以在其中测试和发送每次提交的代码。</p>
<p>在本教程中，您将学习如何使用 Docker 为 Flask Web 应用程序创建强大的持续集成管道。</p>
<p>您将完成在本地开发和测试应用程序、将其容器化、使用 Docker Compose 编排容器以及使用 GitHub Actions 定义 CI 管道的步骤。</p>
<p>在本教程结束时，您将能够为您的 Web 应用程序创建一个完全自动化的 CI 管道。</p>
<p><strong>在本教程中，您将</strong>：</p>
<ul>
<li>在 Docker 容器中本地运行 Redis 服务器</li>
<li>用 Docker 编排 Flask 编写的 Python Web 应用程序</li>
<li>构建 Docker 镜像并将它们推送到 Docker Hub 仓库</li>
<li>使用 Docker Compose 编排多容器应用程序</li>
<li>在任何地方复制类似生产的基础设施</li>
<li>使用 GitHub Actions 定义持续集成工作流</li>
</ul>
<p>理想情况下，您应该具有使用 Python 进行 <a href="https://realpython.com/learning-paths/become-python-web-developer/">Web 开发</a>、<a href="https://realpython.com/learning-paths/test-your-python-apps/">测试自动化</a>、将 <a href="https://realpython.com/python-redis/">Redis 与 Python 结合使用</a>以及<a href="https://realpython.com/python-git-github-intro/">使用 Git 和 GitHub 进行源代码版本控制</a>的经验。以前接触过 <a href="https://realpython.com/python-versions-docker/">Docker</a> 会更好，但不是必需的。您还应该拥有一个 Git 客户端和一个 GitHub 帐户，以便跟随并复制本教程的步骤。</p>
<blockquote>
<p>注意：本教程大致基于名为 Docker in Action - Fitter, Happier, More Productive 的旧教程，该教程由 Michael Herman 编写，他于 2015 年 2 月 8 日在 PyTennessee 展示了他的 CI 工作流程。如果你有兴趣，您可以查看展示的相应幻灯片在会议上。</p>
<p>不幸的是，原始教程中描述的许多工具不再受支持或免费提供。在此更新的教程中，您将使用最新的工具和技术，例如 GitHub Actions。</p>
</blockquote>
<p>如果您想跳过在计算机上设置 Docker 和构建示例 Web 应用程序的初始步骤，那么直接跳到定义持续集成管道。无论哪种方式，您都需要下载支持材料，它们与完成的 Flask Web 应用程序和相关资源一起提供，它们将帮助您学习本教程：</p>
<blockquote>
<p>免费下载：单击<a href="https://realpython.com/bonus/docker-continuous-integration-code/">此处</a>下载您的 Flask 应用程序和相关资源，以便您可以使用 Docker 定义持续集成管道。</p>
</blockquote>
<h2 id="项目架构概览">项目架构概览</h2>
<p>在本教程结束时，您将拥有一个 Flask Web 应用程序，用于跟踪持久存储在 Redis 数据存储中的页面视图。</p>
<p>它将是一个由 Docker Compose 编排的多容器应用程序，您将能够在本地和云端构建和测试，为持续集成铺平道路：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/page_tracker_architecture.drawio_2.1c8cf20462ae.png" alt="The Architecture of the Page Tracker Application"  />
</p>
<p>该应用程序由两个 Docker 容器组成。第一个容器将在 Gunicorn 之上运行一个 Flask 应用程序，响应 HTTP 请求并更新页面浏览量。</p>
<p>第二个容器将运行一个 Redis 实例，用于将页面视图数据持久存储在主机上的本地卷中。</p>
<p>Docker 是运行此应用程序所需的全部，您现在将对其进行设置。</p>
<h2 id="在您的计算机上设置-docker">在您的计算机上设置 Docker</h2>
<p>Docker 是一个总称，根据上下文，它对不同的人有不同的含义。例如，当有人提到 docker 时，他们可能指以下之一：</p>
<ul>
<li>Docker, Inc.：平台和相关工具背后的公司</li>
<li>Docker：开源容器平台</li>
<li>Docker CLI： <code>docker</code> 客户端命令行程序</li>
<li><code>dockerd</code> : 管理容器的 Docker 守护进程</li>
</ul>
<p>还有一些与 Docker 平台相关的工具和项目，例如：</p>
<ul>
<li>Docker Compose</li>
<li>Docker Desktop</li>
<li>Docker Engine</li>
<li>Docker Hub</li>
<li>Docker Swarm Mode Docker 集群模式</li>
</ul>
<p>在本教程中，您将使用上面列表中除最后一个之外的所有内容。顺便说一句，不要将遗留的 <a href="https://github.com/docker-archive/classicswarm">Docker Classic Swarm</a> 与 1.12 版以来内置于 Docker 引擎中的 Docker Swarm Mode 混淆，后者是一个外部工具。</p>
<blockquote>
<p>注意：您可能听说过 Docker Machine 和 Docker Toolbox。这些是不再维护的旧工具。</p>
</blockquote>
<p>Docker 解决的主要问题是能够在几乎没有或没有配置的情况下在一致且可重现的环境中的任何地方运行应用程序。它可以将您的应用程序代码、二进制文件和依赖项（例如语言运行时和库）打包到一个工件中。您将在开发期间和持续集成服务器上使用 Docker 在本地计算机上模拟假设的生产环境。</p>
<p>安装 Docker 有两种选择：</p>
<ol>
<li><a href="https://docs.docker.com/engine/">Docker Engine</a></li>
<li><a href="https://docs.docker.com/desktop/">Docker Desktop</a></li>
</ol>
<p>如果您熟悉终端并喜欢额外的控制级别，那么开源 Docker 引擎就是您的最佳选择，它提供核心运行时和用于管理容器的命令行界面。另一方面，如果您更喜欢具有直观图形用户界面的一站式解决方案，那么您应该考虑使用 Docker Desktop。</p>
<blockquote>
<p>注意：开箱即用的桌面应用程序附带 <a href="https://docs.docker.com/compose/">Docker Compose</a>，稍后在<a href="https://realpython.com/docker-continuous-integration/#orchestrate-containers-using-docker-compose">编排容器</a>以进行持续集成时将需要它。</p>
</blockquote>
<p>当您浏览 <a href="https://docs.docker.com/">Docker 官方文档</a>时，您可能会觉得 Docker Desktop 占据了聚光灯下。这是一个非常棒的工具，但您必须记住，Docker Desktop 仍然免费供个人使用。自 2021 年 8 月起，您需要<a href="https://www.docker.com/pricing/">付费订阅</a>才能在商业项目中使用它。</p>
<p>虽然在技术上可以并排安装这两种工具，但您通常应该避免同时使用它们，以尽量减少虚拟网络或端口绑定之间任何潜在干扰的风险。您可以通过停止其中之一并在 Docker Engine 和 Docker Desktop 之间<a href="https://docs.docker.com/desktop/faqs/linuxfaqs/#context">切换上下文</a>来实现。</p>
<blockquote>
<p>注意：Docker Desktop 过去只能在 Windows 和 macOS 上使用，但现在情况发生了变化，您现在也可以在某些 Linux 发行版上安装它，包括 <a href="https://docs.docker.com/desktop/install/ubuntu/">Ubuntu</a>、<a href="https://docs.docker.com/desktop/install/debian/">Debian</a> 和 <a href="https://docs.docker.com/desktop/install/fedora/">Fedora</a>。但是，Linux 版本的 Docker Desktop 运行在<a href="https://docs.docker.com/desktop/faqs/linuxfaqs/#why-does-docker-desktop-for-linux-run-a-vm">虚拟机</a>之上，以模仿在其他操作系统上使用它的用户体验。</p>
</blockquote>
<p>要验证您是否已在系统上成功安装 Docker（作为 Docker Engine 或 Docker Desktop 包装器应用程序），请打开终端并键入以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker --version
</span></span><span class="line"><span class="cl">Docker version 23.0.4, build f480fb1
</span></span></code></pre></div><p>您应该会看到您的 Docker 版本以及内部版本号。如果您使用的是 Linux，那么您可能希望按照<a href="https://docs.docker.com/engine/install/linux-postinstall/">安装后的步骤</a>使用 <code>docker</code> 命令，而无需在其前面加上 <code>sudo</code> 以获得管理权限。</p>
<p>在开始使用 Docker 来帮助进行持续集成之前，您需要创建一个基本的 Web 应用程序。</p>
<h2 id="在-flask-中开发页面视图跟踪器">在 Flask 中开发页面视图跟踪器</h2>
<p>在接下来的几节中，您将使用 <a href="https://realpython.com/tutorials/flask/">Flask</a> 框架实现一个基本的 Web 应用程序。您的应用程序将跟踪页面浏览总数，并在每次请求时向用户显示该数字：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/screenshot-browser.5036973f0aae.png" alt="A web application for tracking page views"  />
</p>
<p>应用程序的当前状态将保存在 <a href="https://redis.io/">Redis</a> 数据存储中，该存储通常用于缓存和其他类型的数据持久化。这样，停止您的网络服务器不会重置观看次数。您可以将 Redis 视为一种数据库。</p>
<p>如果您对从头开始构建此应用程序不感兴趣，请随时通过单击下面的链接下载其完整源代码，然后跳到对您的 Flask Web 应用程序<a href="https://realpython.com/docker-continuous-integration/#dockerize-your-flask-web-application">进行 docker 化</a>：</p>
<p>即使您打算自己编写代码，下载完成的项目并将其用作参考与您的实现进行比较仍然是个好主意，以防您遇到困难。</p>
<blockquote>
<p>免费下载：单击<a href="https://realpython.com/bonus/docker-continuous-integration-code/">此处</a>下载您的 Flask 应用程序和相关资源，以便您可以使用 Docker 定义持续集成管道。</p>
</blockquote>
<p>在开始开发应用程序之前，您需要设置工作环境。</p>
<h3 id="准备环境">准备环境</h3>
<p>与每个 <a href="https://realpython.com/tutorials/projects/">Python 项目</a>一样，您在开始时应该遵循大致相同的步骤，包括创建一个新目录，然后为您的项目创建并激活一个隔离的<a href="https://realpython.com/python-virtual-environments-a-primer/">虚拟环境</a>。您可以直接从您最喜欢的<a href="https://realpython.com/python-ides-code-editors-guide/">代码编辑器</a>（如 <a href="https://realpython.com/python-development-visual-studio-code/">Visual Studio Code</a>）或功能齐全的 IDE（如 <a href="https://realpython.com/pycharm-guide/">PyCharm</a>）执行此操作，或者您可以在终端中键入一些命令：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">PS&gt; mkdir page-tracker
</span></span><span class="line"><span class="cl">PS&gt; <span class="nb">cd</span> page-tracker
</span></span><span class="line"><span class="cl">PS&gt; python -m venv venv --prompt page-tracker
</span></span><span class="line"><span class="cl">PS&gt; venv<span class="se">\S</span>cripts<span class="se">\a</span>ctivate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; python -m pip install --upgrade pip
</span></span></code></pre></div><p>Linux + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ mkdir page-tracker/
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> page-tracker/
</span></span><span class="line"><span class="cl">$ python3 -m venv venv/ --prompt page-tracker
</span></span><span class="line"><span class="cl">$ <span class="nb">source</span> venv/bin/activate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --upgrade pip
</span></span></code></pre></div><p>首先，创建一个名为 <code>page-tracker/</code> 的新目录，然后在其中创建一个名为 <code>venv/</code> 的Python 虚拟环境。为虚拟环境提供描述性提示，使其易于识别。最后，激活新建的虚拟环境后，将 <a href="https://realpython.com/what-is-pip/"><code>pip</code></a> 升级到最新版本，以免以后安装<a href="https://realpython.com/python-modules-packages/">Python包</a>时出现问题。</p>
<blockquote>
<p>注意：在 Windows 上，您可能需要先以管理员身份运行 <a href="https://realpython.com/python-coding-setup-windows/#discovering-the-windows-terminal">Windows Terminal</a> 并在创建虚拟环境之前<a href="https://realpython.com/python-coding-setup-windows/#loosening-your-execution-policy">放宽脚本执行策略</a>。</p>
</blockquote>
<p>在本教程中，您将使用现代方式通过 <a href="https://realpython.com/courses/packaging-with-pyproject-toml/">pyproject.toml</a> 配置文件和 <a href="https://setuptools.pypa.io/en/latest/">setuptools</a> 指定项目的依赖项和元数据<a href="https://peps.python.org/pep-0517/">作为构建后端</a>。此外，您将遵循 <a href="https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/">src 布局</a>，将应用程序的源代码放在单独的 <code>src/</code> 子目录中，以更好地组织项目中的文件。这将使您可以直接打包代码，而无需稍后添加的自动化测试。</p>
<p>继续使用以下命令构建您的 Python 项目占位符：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; mkdir src<span class="se">\p</span>age_tracker
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; ni src<span class="se">\p</span>age_tracker<span class="se">\_</span>_init__.py
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; ni src<span class="se">\p</span>age_tracker<span class="se">\a</span>pp.py
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; ni constraints.txt
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; ni pyproject.toml
</span></span></code></pre></div><p>Linux + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ mkdir -p src/page_tracker
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ touch src/page_tracker/__init__.py
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ touch src/page_tracker/app.py
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ touch constraints.txt
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ touch pyproject.toml
</span></span></code></pre></div><p>完成后，您应该具有以下目录结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>如您所见，您将只有一个 Python 模块， <code>app</code> ，定义在一个名为 <code>page_tracker</code> 的包中，位于 <code>src/</code> 目录中。 <code>constraints.txt</code> 文件将指定项目依赖项的固定版本，以实现可<a href="https://pip.pypa.io/en/stable/topics/repeatable-installs/">重复安装</a>。</p>
<p>该项目将依赖于两个外部库， <a href="https://pypi.org/project/Flask/">Flask</a> 和 <a href="https://pypi.org/project/redis/">Redis</a> ，您可以在 <code>pyproject.toml</code> 文件中声明它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>请注意，您通常不会在此处指定依赖项版本。相反，您可以将它们与<a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files">需求</a>或<a href="https://pip.pypa.io/en/stable/user_guide/#constraints-files">约束文件</a>中的任何<a href="https://en.wikipedia.org/wiki/Transitive_dependency">传递依赖项</a>一起<a href="https://pip.pypa.io/en/stable/cli/pip_freeze/#pip-freeze">冻结</a>。第一个告诉 <code>pip</code> 要安装什么包，后者强制执行传递依赖项的特定包版本，类似于 <a href="https://realpython.com/pipenv-guide/">Pipenv</a> 或 <a href="https://realpython.com/dependency-management-python-poetry/">Poetry</a> 锁定文件。</p>
<p>要生成约束文件，您必须首先将您的 <code>page-tracker</code> 项目安装到活动的虚拟环境中，这将从 <a href="https://pypi.org/">Python 包索引 (PyPI)</a> 中获取所需的外部库。确保您已经创建了所需的文件夹结构，然后发出以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable .
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip freeze --exclude-editable &gt; constraints.txt
</span></span></code></pre></div><p>即使您还没有输入一行代码，Python 也会识别并安装您的包占位符。因为您的包遵循 <code>src</code> 布局，所以在开发期间以<a href="https://setuptools.pypa.io/en/latest/userguide/development_mode.html">可编辑模式</a>安装它很方便。这将允许您更改源代码并立即将它们反映在虚拟环境中，而无需重新安装。但是，您想从约束文件中排除可编辑包。</p>
<blockquote>
<p>注意：如果您打算共享您的项目，生成的约束文件非常有价值。这意味着其他人可以在他们的终端中运行以下命令来重现与您相同的环境：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install -c constraints.txt .
</span></span></code></pre></div><p>因为您通过 <code>-c</code> 选项提供了一个约束文件， <code>pip</code> 安装了固定的依赖项而不是最新的可用依赖项。这意味着您有可重复的安装。稍后您将使用类似的命令来构建 Docker 镜像。</p>
</blockquote>
<p>好的。您几乎已经准备好开始编写您的 Flask Web 应用程序了。在执行此操作之前，您将切换一下方式并准备一个本地 Redis 服务器以通过网络连接。</p>
<h3 id="通过-docker-运行-redis-服务器">通过 Docker 运行 Redis 服务器</h3>
<p>Redis 这个名字是单词远程字典服务器的合成词，它非常准确地表达了它作为远程内存数据结构存储的目的。作为一个键值存储，Redis 就像一个远程 <a href="https://realpython.com/python-dicts/">Python 字典</a>，您可以从任何地方连接到它。它也被认为是在许多不同环境中使用的最流行的 NoSQL 数据库之一。通常，它用于关系数据库之上的<a href="https://realpython.com/caching-in-django-with-redis/">缓存</a>。</p>
<blockquote>
<p>注意：虽然 Redis 将其所有数据保存在易失性内存中，这使其速度极快，但该服务器具有多种持久性选项。在断电或重启的情况下，它们可以确保不同级别的数据持久性。然而，正确配置 Redis 通常很困难，这就是为什么许多团队决定使用外包给云提供商的托管服务的原因。</p>
</blockquote>
<p>在您的计算机上安装 Redis 非常简单，但假设您之前已经安装和配置了 Docker，通过 Docker 运行它会更加简单和优雅。当您在 Docker 容器中运行诸如 Redis 之类的服务时，它会与系统的其余部分保持隔离，而不会造成混乱或占用有限的网络端口号等系统资源。</p>
<p>要在不将 Redis 安装在主机上的情况下运行 Redis，您可以通过调用以下命令从<a href="https://hub.docker.com/_/redis">官方 Redis 镜像</a>运行新的 Docker 容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d --name redis-server redis
</span></span><span class="line"><span class="cl">Unable to find image <span class="s1">&#39;redis:latest&#39;</span> locally
</span></span><span class="line"><span class="cl">latest: Pulling from library/redis
</span></span><span class="line"><span class="cl">26c5c85e47da: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">39f79586dcf2: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">79c71d0520e5: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">60e988668ca1: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">873c3fc9fdc6: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">50ce7f9bf183: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">Digest: sha256:f50031a49f41e493087fb95f96fdb3523bb25dcf6a3f0b07c588ad3cdb...
</span></span><span class="line"><span class="cl">Status: Downloaded newer image <span class="k">for</span> redis:latest
</span></span><span class="line"><span class="cl">09b9842463c78a2e9135add810aba6c4573fb9e2155652a15310009632c40ea8
</span></span></code></pre></div><p>这将基于最新版本的 <code>redis</code> 镜像创建一个新的 Docker 容器，自定义名称为 <code>redis-server</code> ，稍后您将引用它。容器以分离模式 ( <code>-d</code> ) 在后台运行。当您第一次运行此命令时，Docker 会从 Docker Hub 中拉取相应的 Docker 镜像，这是 Docker 镜像的官方存储库，类似于 PyPI。</p>
<p>只要一切按计划进行，您的 Redis 服务器就应该启动并运行。因为您以分离模式 ( <code>-d</code> ) 启动了容器，所以它将在后台保持活动状态。要验证这一点，您可以使用 <code>docker container ls</code> 命令或等效的 <code>docker ps</code> 别名列出您的 Docker 容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker ps
</span></span><span class="line"><span class="cl">CONTAINER ID   IMAGE   ...   STATUS              PORTS      NAMES
</span></span><span class="line"><span class="cl">09b9842463c7   redis   ...   Up About a minute   6379/tcp   redis-server
</span></span></code></pre></div><p>在这里，您可以看到一个 ID 前缀与您在运行 <code>docker run</code> 命令时获得的 ID 前缀匹配的容器从大约一分钟前开始启动。该容器基于 <code>redis</code> 镜像，已命名为 <code>redis-server</code> ，并使用TCP 端口号 <code>6379</code> ，这是Redis 的默认端口。</p>
<p>接下来，您将尝试以各种方式连接到该 Redis 服务器。</p>
<h3 id="测试与-redis-的连接">测试与 Redis 的连接</h3>
<p>在 Docker Hub 上官方 Redis 镜像的概述页面上，您将找到有关如何连接到在 Docker 容器中运行的 Redis 服务器的说明。具体而言，此页面讨论了如何使用 Docker 镜像附带的专用交互式命令行界面 Redis CLI 。</p>
<p>您可以从同一个 <code>redis</code> 镜像启动另一个 Docker 容器，但这一次，将容器的入口点设置为 <code>redis-cli</code> 命令而不是默认的 Redis 服务器二进制文件。当您设置多个容器一起工作时，您应该使用 Docker 网络，这需要一些额外的配置步骤。</p>
<p>首先，新建一个以你的项目命名的自定义桥接网络，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network create page-tracker-network
</span></span><span class="line"><span class="cl">c942131265bf097da294edbd2ac375cd5410d6f0d87e250041827c68a3197684
</span></span></code></pre></div><p>通过定义这样的虚拟网络，您可以连接任意数量的 Docker 容器，并让它们通过描述性名称相互发现。您可以通过运行以下命令列出您创建的网络：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network ls
</span></span><span class="line"><span class="cl">NETWORK ID     NAME                   DRIVER    SCOPE
</span></span><span class="line"><span class="cl">1bf8d998500e   bridge                 bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">d5cffd6ea76f   host                   host      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">a85d88fc3abe   none                   null      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">c942131265bf   page-tracker-network   bridge    <span class="nb">local</span>
</span></span></code></pre></div><p>接下来，将现有的 <code>redis-server</code> 容器连接到这个新的虚拟网络，并在启动相应容器时为 Redis CLI 指定相同的网络：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network connect page-tracker-network redis-server
</span></span><span class="line"><span class="cl">$ docker run --rm -it <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --name redis-client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --network page-tracker-network <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             redis redis-cli -h redis-server
</span></span></code></pre></div><p><code>--rm</code> 标志告诉 Docker 在您终止它后立即删除创建的容器，因为这是一个您不需要再次启动的临时或临时容器。 <code>-i</code> 和 <code>-t</code> 标志，缩写为 <code>-it</code> ，以交互方式运行容器，让您通过连接到终端的标准流来键入命令。使用 <code>--name</code> 选项，您可以为新容器指定一个描述性名称。</p>
<p><code>--network</code> 选项将你的新 <code>redis-client</code> 容器连接到之前创建的虚拟网络，允许它与 <code>redis-server</code> 容器通信。这样，两个容器都将收到与 <code>--name</code> 选项给定的名称相对应的主机名。请注意，通过使用 <code>-h</code> 参数，您告诉 Redis CLI 连接到由其容器名称标识的 Redis 服务器。</p>
<blockquote>
<p>注意：有一种更快的方法可以通过虚拟网络连接两个容器，而无需显式创建容器。您可以在运行新容器时指定 <code>--link</code> 选项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run --rm -it <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --name redis-client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --link redis-server:redis-client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             redis redis-cli -h redis-server
</span></span></code></pre></div><p>但是，此选项已被弃用，并且可能会在某个时候从 Docker 中删除。</p>
</blockquote>
<p>当您的新 Docker 容器启动时，您将进入一个交互式 Redis CLI，它类似于带有以下提示的 Python REPL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">redis-server:6379&gt; SET pi 3.14
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-server:6379&gt; GET pi
</span></span><span class="line"><span class="cl"><span class="s2">&#34;3.14&#34;</span>
</span></span><span class="line"><span class="cl">redis-server:6379&gt; DEL pi
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">redis-server:6379&gt; KEYS *
</span></span><span class="line"><span class="cl"><span class="o">(</span>empty array<span class="o">)</span>
</span></span></code></pre></div><p>在那里，您可以测试一些 Redis 命令，例如，设置键值对、获取相应键的值、删除该键值对或检索当前存储在服务器中的所有键的列表。要退出交互式 Redis CLI，请按键盘上的 Ctrl+C。</p>
<blockquote>
<p>如果您安装了 Docker Desktop，那么在大多数情况下，它不会将流量从您的主机路由到容器。你的本地网络和默认的 Docker 网络之间没有连接：</p>
<ul>
<li>
<p>Docker Desktop for Mac 无法将流量路由到容器。</p>
</li>
<li>
<p>适用于 Windows 的 Docker Desktop 无法将流量路由到 Linux 容器。但是，您可以对 Windows 容器执行 ping 操作。</p>
</li>
</ul>
<p>Linux 上的 Docker Desktop 也是如此。另一方面，如果您使用 Docker 引擎或在 Windows 主机上运行 Windows 容器，那么您将能够通过它们的 IP 地址访问这些容器。</p>
<p>因此，有时您可以直接从主机与 Redis 服务器通信。首先，找出对应的Docker容器的IP地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker inspect redis-server <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  -f <span class="s1">&#39;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{println}}{{end}}&#39;</span>
</span></span><span class="line"><span class="cl">172.17.0.2
</span></span><span class="line"><span class="cl">172.18.0.2
</span></span></code></pre></div><p>如果您看到多个 IP 地址，则表示您的容器连接到多个网络。当您启动容器时，容器会自动连接到默认的 Docker 网络。</p>
<p>记下其中一个地址，您可能会有所不同。现在，您可以将此 IP 地址用作 <code>-h</code> 参数的值，而不是 <code>redis-cli</code> 中的链接容器名称。您还可以使用此 IP 地址通过 <code>netcat</code> 或 Telnet 客户端连接到 Redis，例如 PuTTY 或 <code>telnet</code> 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ telnet 172.17.0.2 <span class="m">6379</span>
</span></span><span class="line"><span class="cl">Trying 172.17.0.2...
</span></span><span class="line"><span class="cl">Connected to 172.17.0.2.
</span></span><span class="line"><span class="cl">Escape character is <span class="s1">&#39;^]&#39;</span>.
</span></span><span class="line"><span class="cl">SET pi 3.14
</span></span><span class="line"><span class="cl">+OK
</span></span><span class="line"><span class="cl">GET pi
</span></span><span class="line"><span class="cl"><span class="nv">$4</span>
</span></span><span class="line"><span class="cl">3.14
</span></span><span class="line"><span class="cl">DEL pi
</span></span><span class="line"><span class="cl">:1
</span></span><span class="line"><span class="cl">KEYS *
</span></span><span class="line"><span class="cl">*0
</span></span><span class="line"><span class="cl">^<span class="o">]</span>
</span></span><span class="line"><span class="cl">telnet&gt; Connection closed.
</span></span></code></pre></div><p>请记住提供默认为 <code>6379</code> 的端口号，Redis 会在该端口上侦听传入连接。您可以在此处以明文形式键入 Redis 命令，因为服务器使用未加密的协议，除非您在配置中明确启用 TLS 支持。</p>
</blockquote>
<p>最后，您可以利用端口映射使 Redis 在 Docker 容器之外可用。在开发过程中，您将希望直接连接到 Redis，而不是通过来自另一个容器的虚拟网络，因此您不必将它连接到任何网络。</p>
<p>要使用端口映射，请停止并删除现有的 <code>redis-server</code> ，然后使用定义如下的 <code>-p</code> 选项运行一个新容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker stop redis-server
</span></span><span class="line"><span class="cl">$ docker rm redis-server
</span></span><span class="line"><span class="cl">$ docker run -d --name redis-server -p 6379:6379 redis
</span></span></code></pre></div><p>冒号左边的数字（ <code>:</code> ）代表主机或你电脑上的端口号，而右边的数字代表即将运行的Docker容器内的映射端口。</p>
<p>在两侧使用相同的端口号可以有效地转发它，这样您就可以连接到 Redis，就像它在您的计算机上本地运行一样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ telnet localhost <span class="m">6379</span>
</span></span><span class="line"><span class="cl">Trying 127.0.0.1...
</span></span><span class="line"><span class="cl">Connected to localhost.
</span></span><span class="line"><span class="cl">Escape character is <span class="s1">&#39;^]&#39;</span>.
</span></span><span class="line"><span class="cl">INCR page_views
</span></span><span class="line"><span class="cl">:1
</span></span><span class="line"><span class="cl">INCR page_views
</span></span><span class="line"><span class="cl">:2
</span></span><span class="line"><span class="cl">INCR page_views
</span></span><span class="line"><span class="cl">:3
</span></span><span class="line"><span class="cl">^<span class="o">]</span>
</span></span><span class="line"><span class="cl">telnet&gt; Connection closed.
</span></span></code></pre></div><p>连接到现在在本地主机和默认端口上可见的 Redis 后，您可以使用 <code>INCR</code> 命令增加页面浏览量。如果底层键尚不存在，则 Redis 将使用值 <code>1</code> 对其进行初始化。</p>
<blockquote>
<p>注意：如果您在本地安装了 Redis，或者某些系统进程也在您的主机上使用端口 <code>6379</code> ，那么您需要使用未占用的端口以不同方式映射您的端口号。例如，您可以执行以下操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d --name redis-server -p 9736:6379 redis
</span></span></code></pre></div><p>这将允许您连接到端口 <code>9736</code> 上的本地主机（如果该端口尚未被其他服务占用）。只要可用，使用哪个端口并不重要。</p>
</blockquote>
<p>现在您已经知道如何从命令行连接到 Redis，您可以继续看看如何通过 Python 程序执行相同的操作。</p>
<h3 id="从-python-连接到-redis">从 Python 连接到 Redis</h3>
<p>此时，您有一个在 Docker 容器中运行的 Redis 服务器，您可以使用 Redis 的默认端口号在本地主机上访问它。</p>
<p>如果您想了解有关您的容器或任何其他 Docker 资源的更多信息，那么您始终可以通过检查手头的对象来检索有价值的信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker inspect redis-server
</span></span><span class="line"><span class="cl"><span class="o">[</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;Id&#34;</span>: <span class="s2">&#34;09b9842463c78a2e9135add810aba6...2a15310009632c40ea8&#34;</span>,
</span></span><span class="line"><span class="cl">        ⋮
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;NetworkSettings&#34;</span>: <span class="o">{</span>
</span></span><span class="line"><span class="cl">            ⋮
</span></span><span class="line"><span class="cl">            <span class="s2">&#34;Ports&#34;</span>: <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;6379/tcp&#34;</span>: null
</span></span><span class="line"><span class="cl">            <span class="o">}</span>,
</span></span><span class="line"><span class="cl">            ⋮
</span></span><span class="line"><span class="cl">            <span class="s2">&#34;IPAddress&#34;</span>: <span class="s2">&#34;172.17.0.2&#34;</span>,
</span></span><span class="line"><span class="cl">            ⋮
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">]</span>
</span></span></code></pre></div><p>在这种情况下，您要询问有关 <code>redis-server</code> 容器的信息，其中包括大量详细信息，例如容器的网络配置。 <code>docker inspect</code> 命令默认返回 JSON 格式的数据，您可以使用 Go 模板进一步过滤。</p>
<p>接下来，打开终端，激活项目的虚拟环境，并启动一个新的 Python REPL：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">PS&gt; venv<span class="se">\S</span>cripts<span class="se">\a</span>ctivate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; python
</span></span></code></pre></div><p>Linux + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">source</span> venv/bin/activate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python
</span></span></code></pre></div><p>假设您之前在此虚拟环境中安装了 <code>redis</code> 包，您应该能够导入 Python 的 Redis 客户端并调用其中一种方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>
</span></span></code></pre></div><p>当您在不指定任何参数的情况下创建新的 <code>Redis</code> 实例时，它将尝试连接到在本地主机和默认端口 <code>6379</code> 上运行的 Redis 服务器。在这种情况下，调用 <code>.incr()</code> 确认您已成功与位于 Docker 容器中的 Redis 建立连接，因为它记住了 <code>page_views</code> 键的最后一个值。</p>
<p>如果您需要连接到位于远程计算机上的 Redis，请提供自定义主机和端口号作为参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s2">&#34;127.0.0.1&#34;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span>
</span></span></code></pre></div><p>请注意，您应该将端口号作为整数传递，但如果您传递一个字符串，库也不会抱怨。</p>
<p>连接到 Redis 的另一种方法是使用特殊格式的字符串，它代表一个 URL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span><span class="s2">&#34;redis://localhost:6379/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span>
</span></span></code></pre></div><p>如果您想将 Redis 配置存储在文件或环境变量中，这会特别方便。</p>
<p>好极了！您可以获取这些代码片段之一并将其与您的 Flask Web 应用程序集成。在下一节中，您将看到如何做到这一点。</p>
<h3 id="在本地实现并运行-flask-应用程序">在本地实现并运行 Flask 应用程序</h3>
<p>返回代码编辑器，打开 <code>page-tracker</code> 项目中的 <code>app</code> 模块，并编写以下几行 Python 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@app.get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">page_views</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;This page has been seen </span><span class="si">{</span><span class="n">page_views</span><span class="si">}</span><span class="s2"> times.&#34;</span>
</span></span></code></pre></div><p>您首先从项目各自列为依赖项的第三方库中导入 <code>Flask</code> 和 <code>Redis</code> 。接下来，您使用默认参数实例化 Flask 应用程序和 Redis 客户端，这意味着客户端将尝试连接到本地 Redis 服务器。</p>
<p>最后，您定义一个控制器函数来处理到达 Web 服务器根地址 ( <code>/</code> ) 的 HTTP GET 请求。</p>
<p>您的端点会增加 Redis 中的页面浏览量，并在客户端的 Web 浏览器中显示合适的消息。就是这样！您拥有一个完整的 Web 应用程序，它可以使用不到十行的代码处理 HTTP 流量并将状态持久保存在远程数据存储中。</p>
<p>要验证您的 Flask 应用程序是否按预期工作，请在终端中发出以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ flask --app page_tracker.app run
</span></span><span class="line"><span class="cl"> * Serving Flask app <span class="s1">&#39;page_tracker.app&#39;</span>
</span></span><span class="line"><span class="cl"> * Debug mode: off
</span></span><span class="line"><span class="cl">WARNING: This is a development server. Do not use it in a production
</span></span><span class="line"><span class="cl">⮑ deployment. Use a production WSGI server instead.
</span></span><span class="line"><span class="cl"> * Running on http://127.0.0.1:5000
</span></span><span class="line"><span class="cl">Press CTRL+C to quit
</span></span></code></pre></div><p>你可以在你的文件系统的任何地方运行这个命令，只要你已经激活了正确的虚拟环境并安装了你的 <code>page-tracker</code> 包。这应该在禁用调试模式的情况下在本地主机和端口 <code>5000</code> 上运行 Flask 开发服务器。</p>
<p>如果你想从同一网络上的另一台计算机访问你的服务器，那么你必须使用特殊地址 <code>0.0.0.0</code> 而不是默认的 localhost 将它绑定到所有网络接口，它代表环回接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ flask --app page_tracker.app run --host<span class="o">=</span>0.0.0.0 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                                                  --port<span class="o">=</span><span class="m">8080</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                                                  --debug
</span></span><span class="line"><span class="cl"> * Serving Flask app <span class="s1">&#39;page_tracker.app&#39;</span>
</span></span><span class="line"><span class="cl"> * Debug mode: on
</span></span><span class="line"><span class="cl">WARNING: This is a development server. Do not use it in a production
</span></span><span class="line"><span class="cl">⮑ deployment. Use a production WSGI server instead.
</span></span><span class="line"><span class="cl"> * Running on all addresses <span class="o">(</span>0.0.0.0<span class="o">)</span>
</span></span><span class="line"><span class="cl"> * Running on http://127.0.0.1:8080
</span></span><span class="line"><span class="cl"> * Running on http://192.168.0.115:8080
</span></span><span class="line"><span class="cl">Press CTRL+C to quit
</span></span><span class="line"><span class="cl"> * Restarting with stat
</span></span><span class="line"><span class="cl"> * Debugger is active!
</span></span><span class="line"><span class="cl"> * Debugger PIN: 123-167-546
</span></span></code></pre></div><p>如果需要，您还可以使用适当的命令行选项或标志更改端口号并启用调试模式。</p>
<p>启动服务器后，您可以点击终端中显示的链接，并在您的网络浏览器中查看包含浏览量的页面。每次刷新此页面时，计数器应加一：</p>
<p>做得很好！您已经成功创建了一个基本的 Flask 应用程序，它使用 Redis 跟踪页面浏览量。接下来，您将学习如何测试和保护您的 Web 应用程序。</p>
<h2 id="测试和保护您的-web-应用程序">测试和保护您的 Web 应用程序</h2>
<p>在将任何项目打包并部署到生产环境之前，您应该彻底测试、检查和保护底层源代码。在本教程的这一部分，您将练习单元测试、集成测试和端到端测试。您还将执行静态代码分析和安全扫描，以在修复成本仍然低廉的情况下识别潜在的问题和漏洞。</p>
<h3 id="用单元测试覆盖源代码">用单元测试覆盖源代码</h3>
<p>单元测试涉及测试程序的各个单元或组件，以确保它们按预期工作。如今，它已成为软件开发的必要组成部分。许多工程师甚至更进一步，严格遵循<a href="https://realpython.com/python-hash-table/#take-a-crash-course-in-test-driven-development">测试驱动开发</a>方法，首先编写单元测试来驱动代码设计。</p>
<p>在编写单元测试时，Python 社区中的人们选择 <a href="https://realpython.com/pytest-python-testing/">pytest</a> 而不是标准库的 <code>unittest</code> 模块是很常见的。由于 <code>pytest</code> 相对简单，这个测试框架上手很快。继续并将 <code>pytest</code> 添加为项目的可选依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>您可以将以某种方式相关的可选依赖项分组在一个通用名称下。例如，在这里，您创建了一个名为 <code>dev</code> 的组来收集您将在开发过程中使用的工具和库。通过将 <code>pytest</code> 与主要依赖项分开，您将能够仅在需要时按需安装它。毕竟，将您的测试或相关的测试框架与构建的分发包捆绑在一起是没有意义的。</p>
<p>不要忘记重新安装带有可选依赖项的 Python 包，以使 <code>pytest</code> 进入项目的虚拟环境：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;.[dev]&#34;</span>
</span></span></code></pre></div><p>您可以使用方括号列出在您的 <code>pyproject.toml</code> 文件中定义的可选依赖组的名称。在这种情况下，您要求安装用于开发目的的依赖项，包括测试框架。请注意，建议在方括号周围使用引号 ( <code>&quot;&quot;</code> ) 以防止 shell 中潜在的文件名扩展。</p>
<p>因为您在项目中遵循了 <code>src</code> 布局，所以您不必将测试模块保存在与被测代码相同的文件夹或相同的命名空间包中。您可以为测试创建一个单独的目录分支，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│   └── unit/
</span></span><span class="line"><span class="cl">│       └── test_app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>您已将测试模块放在 <code>test/unit/</code> 文件夹中以保持井井有条。 <code>pytest</code> 框架将在您为测试添加前缀 <code>test</code> 时发现您的测试。虽然您可以更改它，但通常在使用相应的测试模块镜像每个 Python 模块时保持默认约定。例如，您将在 <code>test/unit/</code> 文件夹中用 <code>test_app</code> 覆盖 <code>app</code> 模块。</p>
<p>您将从测试 Web 应用程序的成功路径开始，这通常意味着向服务器发送请求。每个 Flask 应用程序都带有一个方便的测试客户端，您可以使用它来发出模拟的 HTTP 请求。因为测试客户端不需要运行实时服务器，所以你的单元测试执行得更快并且会变得更加孤立。</p>
<p>您可以获得测试客户端并将其方便地包装在测试装置中，以使其可用于您的测试功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/unit/test_app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">page_tracker.app</span> <span class="kn">import</span> <span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">http_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</span></span></code></pre></div><p>首先，您导入 <code>pytest</code> 包以针对您的自定义函数利用其 <code>@fixture</code> 装饰器。仔细选择您的函数名称，因为它也会成为您可以作为参数传递给各个测试函数的夹具的名称。您还可以从 <code>page_tracker</code> 包中导入 Flask 应用程序以获取相应的测试客户端实例。</p>
<p>当您打算编写单元测试时，您必须始终通过消除代码单元可能具有的任何依赖关系来隔离它。这意味着您应该模拟或存根您的代码所依赖的任何外部服务、数据库或库。在您的情况下，Redis 服务器就是这样的依赖项。</p>
<p>不幸的是，您的代码目前使用硬编码的 Redis 客户端，这会阻止模拟。这是从一开始就遵循测试驱动开发的一个很好的论据，但这并不意味着您必须返回并重新开始。相反，您将通过实施依赖注入设计模式来<a href="https://realpython.com/python-refactoring/">重构</a>您的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"># src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gi">+from functools import cache
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>
</span></span><span class="line"><span class="cl"> from flask import Flask
</span></span><span class="line"><span class="cl"> from redis import Redis
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> app = Flask(__name__)
</span></span><span class="line"><span class="cl"><span class="gd">-redis = Redis()
</span></span></span><span class="line"><span class="cl"><span class="gd"></span>
</span></span><span class="line"><span class="cl"> @app.get(&#34;/&#34;)
</span></span><span class="line"><span class="cl"> def index():
</span></span><span class="line"><span class="cl"><span class="gd">-    page_views = redis.incr(&#34;page_views&#34;)
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+    page_views = redis().incr(&#34;page_views&#34;)
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>     return f&#34;This page has been seen {page_views} times.&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gi">+@cache
</span></span></span><span class="line"><span class="cl"><span class="gi">+def redis():
</span></span></span><span class="line"><span class="cl"><span class="gi">+    return Redis()
</span></span></span></code></pre></div><p>本质上，您将 Redis 客户端创建代码从<a href="https://realpython.com/python-scope-legb-rule/#modules-the-global-scope">全局范围</a>移动到一个新的 <code>redis()</code> 函数，您的控制器函数会在运行时针对每个传入请求调用该函数。这将允许您的测试用例在正确的时间用模拟对应物替换返回的 Redis 实例。但是，为了确保内存中只有一个客户端实例，有效地使其成为一个单例，您还<a href="https://realpython.com/lru-cache-python/">缓存</a>了新函数的结果。</p>
<p>现在回到您的测试模块并实施以下单元测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/unit/test_app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">unittest.mock</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">page_tracker.app</span> <span class="kn">import</span> <span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">http_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@unittest.mock.patch</span><span class="p">(</span><span class="s2">&#34;page_tracker.app.redis&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_should_call_redis_incr</span><span class="p">(</span><span class="n">mock_redis</span><span class="p">,</span> <span class="n">http_client</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Given</span>
</span></span><span class="line"><span class="cl">    <span class="n">mock_redis</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">incr</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># When</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span> <span class="o">=</span> <span class="n">http_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Then</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&#34;This page has been seen 5 times.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mock_redis</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">incr</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>您使用 Python 的 <code>@patch</code> 装饰器包装您的测试函数，以将模拟的 Redis 客户端作为参数注入其中。您还告诉 <code>pytest</code> 将您的 HTTP 测试客户端装置作为另一个参数注入。测试函数有一个描述性名称，以动词 should 开头并遵循 Given-When-Then 模式。这两个常用于行为驱动开发的约定，使您的测试被解读为行为规范。</p>
<p>在您的测试用例中，您首先将模拟 Redis 客户端设置为在其 <code>.incr()</code> 方法被调用时始终返回 <code>5</code> 。然后，您向根端点 ( <code>/</code> ) 发出伪造的 HTTP 请求并检查服务器的响应状态和正文。因为模拟可以帮助您测试单元的行为，所以您只需验证服务器是否使用预期参数调用了正确的方法，并相信 Redis 客户端库可以正常工作。</p>
<p>要执行单元测试，您可以使用代码编辑器中集成的测试运行器，也可以在终端中键入以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest -v test/unit/
</span></span></code></pre></div><p>您从虚拟环境中将 <code>pytest</code> 作为 Python 模块运行，指示它扫描 <code>test/unit/</code> 目录以便在那里查找测试模块。 <code>-v</code> 开关增加了测试报告的详细程度，以便您可以看到有关各个测试用例的更多详细信息。</p>
<p>在所有单元测试都通过后盯着绿色报告会感到满足。它使您对代码有一定程度的信心，但不足以做出任何形式的保证。许多模因说明了即使在单元测试通过后运行集成测试的重要性。</p>
<p>例如，其中一个经典模因显示有两个抽屉，但一次只能打开一个。虽然每个单独的抽屉或单元都经过测试并独立工作，但当您尝试将它们集成到一件家具中时，就会出现问题。接下来，您将向您的项目添加一个基本的集成测试。</p>
<h3 id="通过集成测试检查组件交互">通过集成测试检查组件交互</h3>
<p>集成测试应该是运行单元测试后的下一个阶段。集成测试的目标是检查您的组件作为更大系统的一部分如何相互交互。</p>
<p>例如，您的页面跟踪器 Web 应用程序可能具有集成测试，用于检查与真正的 Redis 服务器而不是模拟服务器的通信。</p>
<p>您可以重复使用 <code>pytest</code> 来实施和运行集成测试。但是，您将安装一个额外的 <code>pytest-timeout</code> 插件，以允许您强制运行时间过长的测试用例失败：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest-timeout&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>理想情况下，您不必担心单元测试超时，因为它们应该针对速度进行优化。另一方面，集成测试将需要更长的时间来运行，并且可能会在停滞的网络连接上无限挂起，从而阻止您的测试套件完成。因此，在这种情况下有办法中止它们很重要。</p>
<p>请记住再次重新安装带有可选依赖项的包，以使 <code>pytest-timeout</code> 插件可用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;.[dev]&#34;</span>
</span></span></code></pre></div><p>在继续之前，为您的集成测试添加另一个子文件夹，并在您的 <code>test/</code> 文件夹中定义一个 <code>conftest.py</code> 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│   ├── integration/
</span></span><span class="line"><span class="cl">│   │   └── test_app_redis.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── unit/
</span></span><span class="line"><span class="cl">│   │   └── test_app.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   └── conftest.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>您将在 <code>conftest.py</code> 中放置公共装置，不同类型的测试将共享这些装置。</p>
<p>虽然您的 Web 应用程序只有一个组件，但您可以将 Redis 视为 Flask 需要使用的另一个组件。因此，集成测试可能看起来与您的单元测试类似，只是不再模拟 Redis 客户端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/integration/test_app_redis.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.mark.timeout</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_should_update_redis</span><span class="p">(</span><span class="n">redis_client</span><span class="p">,</span> <span class="n">http_client</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Given</span>
</span></span><span class="line"><span class="cl">    <span class="n">redis_client</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># When</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span> <span class="o">=</span> <span class="n">http_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Then</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&#34;This page has been seen 5 times.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">redis_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&#34;5&#34;</span>
</span></span></code></pre></div><p>从概念上讲，您的新测试用例包含与以前相同的步骤，但它与真正的 Redis 服务器交互。这就是为什么你给测试最多 <code>1.5</code> 秒来完成使用 <code>@pytest.mark.timeout</code> 装饰器。测试函数将两个夹具作为参数：</p>
<ul>
<li>连接到本地数据存储的 Redis 客户端</li>
<li>Flask 的测试客户端连接到您的 Web 应用程序</li>
</ul>
<p>为了使第二个在您的集成测试中也可用，您必须将 <code>http_client()</code> 夹具从 <code>test_app</code> 模块移动到 <code>conftest.py</code> 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/conftest.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">redis</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">page_tracker.app</span> <span class="kn">import</span> <span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">http_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&#34;module&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">redis</span><span class="o">.</span><span class="n">Redis</span><span class="p">()</span>
</span></span></code></pre></div><p>由于此文件位于文件夹层次结构的上一层， <code>pytest</code> 将选取其中定义的所有灯具，并使它们在整个嵌套文件夹中可见。除了您从另一个 Python 模块移动的熟悉的 <code>http_client()</code> 夹具之外，您还定义了一个返回默认 Redis 客户端的新夹具。请注意，您为它指定了 <code>module</code> 范围，以便为测试模块中的所有函数重用相同的 Redis 客户端实例。</p>
<p>要执行集成测试，您必须仔细检查 Redis 服务器是否在本地默认端口 <code>6379</code> 上运行，然后像以前一样启动 <code>pytest</code> ，但将其指向包含集成测试的文件夹：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest -v test/integration/
</span></span></code></pre></div><p>因为您的集成测试连接到实际的 Redis 服务器，所以它会覆盖您之前可能存储在 <code>page_views</code> 键下的值。但是，如果在执行集成测试时 Redis 服务器未运行，或者如果 Redis 在其他地方运行，那么您的测试将失败。这种失败可能是出于错误的原因，使结果成为假阴性错误，因为您的代码实际上可能按预期工作。</p>
<p>要观察此问题，请立即停止 Redis 并重新运行集成测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ docker stop redis-server
</span></span><span class="line"><span class="cl">redis-server
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest -v test/integration/
</span></span><span class="line"><span class="cl">⋮
</span></span><span class="line"><span class="cl"><span class="o">=========================</span> short <span class="nb">test</span> summary <span class="nv">info</span> <span class="o">==========================</span>
</span></span><span class="line"><span class="cl">FAILED test/integration/test_app_redis.py::test_should_update_redis -
</span></span><span class="line"><span class="cl">⮑redis.exceptions.ConnectionError: Error <span class="m">111</span> connecting to localhost:6379.
</span></span><span class="line"><span class="cl">⮑Connection <span class="nv">refused</span>
</span></span><span class="line"><span class="cl"><span class="o">============================</span> <span class="m">1</span> failed in 0.19s <span class="o">=============================</span>
</span></span></code></pre></div><p>这揭示了您的代码中的一个问题，该问题目前无法妥善处理 Redis 连接错误。本着测试驱动开发的精神，您可以首先编写一个重现该问题的测试用例，然后修复它。切换一下，使用模拟的 Redis 客户端在 <code>test_app</code> 模块中添加以下单元测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/unit/test_app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">unittest.mock</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="ne">ConnectionError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@unittest.mock.patch</span><span class="p">(</span><span class="s2">&#34;page_tracker.app.redis&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_should_handle_redis_connection_error</span><span class="p">(</span><span class="n">mock_redis</span><span class="p">,</span> <span class="n">http_client</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Given</span>
</span></span><span class="line"><span class="cl">    <span class="n">mock_redis</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">incr</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="ne">ConnectionError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># When</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span> <span class="o">=</span> <span class="n">http_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Then</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">500</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&#34;Sorry, something went wrong </span><span class="se">\N{pensive face}</span><span class="s2">&#34;</span>
</span></span></code></pre></div><p>您设置模拟的 <code>.incr()</code> 方法的副作用，以便调用该方法将引发 <code>redis.ConnectionError</code> 异常，这是您在集成测试失败时观察到的。您的新单元测试是负面测试的一个示例，它期望 Flask 以 HTTP 状态代码 500 和描述性消息进行响应。以下是满足该单元测试的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span><span class="p">,</span> <span class="n">RedisError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@app.get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">page_views</span> <span class="o">=</span> <span class="n">redis</span><span class="p">()</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="n">RedisError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&#34;Redis error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;Sorry, something went wrong </span><span class="se">\N{pensive face}</span><span class="s2">&#34;</span><span class="p">,</span> <span class="mi">500</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;This page has been seen </span><span class="si">{</span><span class="n">page_views</span><span class="si">}</span><span class="s2"> times.&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@cache</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Redis</span><span class="p">()</span>
</span></span></code></pre></div><p>您拦截顶级异常类 <code>redis.RedisError</code> ，它是 Redis 客户端引发的所有异常类型的祖先。如果出现任何问题，您将返回预期的 HTTP 状态代码和一条消息。为方便起见，您还使用 Flask 内置的<a href="https://realpython.com/python-logging/">记录</a>器记录异常。</p>
<blockquote>
<p>注意：虽然父类是子类直接扩展的直接基类，但祖先类可以位于<a href="https://realpython.com/python-classes/#using-inheritance-and-building-class-hierarchies">继承</a>层次结构中更上层的任何位置。</p>
</blockquote>
<p>好极了！由于测试，您修改了单元测试，实施了集成测试，并在发现代码中的缺陷后修复了它。</p>
<p>尽管如此，当您将应用程序部署到远程环境时，您如何知道所有部分都组合在一起并且一切都按预期工作？</p>
<p>在下一节中，您将通过对实际 Flask 服务器而不是测试客户端执行端到端测试来模拟真实场景。</p>
<h3 id="测试真实场景端到端">测试真实场景端到端</h3>
<p>端到端测试，也称为广泛堆栈测试，包含多种测试，可以帮助您验证整个系统。他们通过模拟实际用户通过应用程序的流程来测试完整的软件堆栈。因此，端到端测试需要一个尽可能模拟生产环境的部署环境。通常还需要专门的测试工程师团队。</p>
<blockquote>
<p>注意：由于端到端测试的维护成本很高，而且往往需要花费大量时间来设置和运行，因此它们位于 Google 测试金字塔的顶端。换句话说，您的目标应该是进行更多的集成测试，甚至在您的项目中进行更多的单元测试。</p>
</blockquote>
<p>由于您最终希望为您的 Docker 应用程序构建一个成熟的持续集成管道，因此进行一些端到端测试将变得至关重要。首先为您的 E2E 测试添加另一个子文件夹：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│   ├── e2e/
</span></span><span class="line"><span class="cl">│   │   └── test_app_redis_http.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── integration/
</span></span><span class="line"><span class="cl">│   │   └── test_app_redis.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── unit/
</span></span><span class="line"><span class="cl">│   │   └── test_app.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   └── conftest.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>您将要实施的测试场景将类似于您的集成测试。不过，主要区别在于您将通过网络将实际的 HTTP 请求发送到实时 Web 服务器，而不是依赖 Flask 的测试客户端。</p>
<p>为此，您将使用第三方 <a href="https://realpython.com/python-requests/">requests</a> 库，您必须首先在 <code>pyproject.toml</code> 文件中将其指定为另一个可选依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest-timeout&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;requests&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>您不会使用 <code>requests</code> 在生产环境中运行服务器，因此无需将其作为常规依赖项。同样，使用可编辑模式重新安装带有可选依赖项的 Python 包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;.[dev]&#34;</span>
</span></span></code></pre></div><p>您现在可以在端到端测试中使用已安装的 <code>requests</code> 库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"> <span class="c1"># test/e2e/test_app_redis_http.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">requests</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.mark.timeout</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_should_update_redis</span><span class="p">(</span><span class="n">redis_client</span><span class="p">,</span> <span class="n">flask_url</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Given</span>
</span></span><span class="line"><span class="cl">    <span class="n">redis_client</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># When</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">flask_url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Then</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&#34;This page has been seen 5 times.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">redis_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&#34;5&#34;</span>
</span></span></code></pre></div><p>除了负责发送 HTTP GET 请求的第 12 行之外，此代码与您的集成测试几乎相同。之前，您将该请求发送到测试客户端的根地址，用斜杠字符 ( <code>/</code> ) 表示。现在，您不知道可能在远程主机上运行的 Flask 服务器的确切域或 IP 地址。因此，您的函数接收一个 Flask URL 作为参数， <code>pytest</code> 将其作为固定装置注入。</p>
<p>您可以通过命令行提供特定的网络服务器地址。同样，您的 Redis 服务器可能在不同的主机上运行，因此您也需要提供其地址作为命令行参数。可是等等！您的 Flask 应用程序当前期望 Redis 始终在本地主机上运行。继续并更新您的代码以使其可配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span><span class="p">,</span> <span class="n">RedisError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@app.get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">page_views</span> <span class="o">=</span> <span class="n">redis</span><span class="p">()</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="n">RedisError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&#34;Redis error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;Sorry, something went wrong </span><span class="se">\N{pensive face}</span><span class="s2">&#34;</span><span class="p">,</span> <span class="mi">500</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;This page has been seen </span><span class="si">{</span><span class="n">page_views</span><span class="si">}</span><span class="s2"> times.&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@cache</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Redis</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&#34;REDIS_URL&#34;</span><span class="p">,</span> <span class="s2">&#34;redis://localhost:6379&#34;</span><span class="p">))</span>
</span></span></code></pre></div><p>通常使用环境变量来设置敏感数据，例如数据库 URL，因为它提供了额外级别的安全性和灵活性。在这种情况下，您的程序需要一个自定义的 <code>REDIS_URL</code> 变量。如果在给定环境中未指定该变量，则您将回退到默认主机和端口。</p>
<p>要使用自定义命令行参数扩展 <code>pytest</code> ，您必须编辑 <code>conftest.py</code> 并按以下方式连接到框架的参数解析器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/conftest.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">redis</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">page_tracker.app</span> <span class="kn">import</span> <span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">pytest_addoption</span><span class="p">(</span><span class="n">parser</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">parser</span><span class="o">.</span><span class="n">addoption</span><span class="p">(</span><span class="s2">&#34;--flask-url&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">parser</span><span class="o">.</span><span class="n">addoption</span><span class="p">(</span><span class="s2">&#34;--redis-url&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&#34;session&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">flask_url</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&#34;--flask-url&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&#34;session&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis_url</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&#34;--redis-url&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">http_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&#34;module&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis_client</span><span class="p">(</span><span class="n">redis_url</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">redis_url</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">redis</span><span class="o">.</span><span class="n">Redis</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span><span class="n">redis_url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">redis</span><span class="o">.</span><span class="n">Redis</span><span class="p">()</span>
</span></span></code></pre></div><p>您使用类似于 Python 的 <code>argparse</code> 模块的语法定义两个可选参数， <code>--flask-url</code> 和 <code>--redis-url</code> 。然后，您将这些参数包装在会话范围的固定装置中，您将能够将其注入到您的测试函数和其他固定装置中。具体来说，您现有的 <code>redis_client()</code> fixture 现在可以利用可选的 Redis URL。</p>
<blockquote>
<p>注意：因为您的端到端测试和集成测试依赖于相同的 <code>redis_client()</code> fixture，所以您可以通过在两种类型的测试中指定 <code>--redis-url</code> 选项来连接到远程 Redis 服务器。</p>
</blockquote>
<p>这是通过指定 Flask Web 服务器和相应的 Redis 服务器的 URL 来使用 <code>pytest</code> 运行端到端测试的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest -v test/e2e/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --flask-url http://127.0.0.1:5000 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --redis-url redis://127.0.0.1:6379
</span></span></code></pre></div><p>在这种情况下，您可以通过本地主机 ( <code>127.0.0.1</code> ) 访问 Flask 和 Redis，但您的应用程序可能会部署到由多台远程计算机组成的地理分布式环境中。当你在本地执行此命令时，确保 Redis 正在运行并首先单独启动你的 Flask 服务器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ docker start redis-server
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ flask --app page_tracker.app run
</span></span></code></pre></div><p>为了提高代码质量，如果您有能力，可以不断向您的应用程序添加更多类型的测试。不过，这通常需要一个全职软件质量保证工程师团队。另一方面，执行代码审查或其他类型的静态代码分析是相当容易实现的，可以发现许多令人惊讶的问题。您现在将查看此过程。</p>
<h3 id="执行静态代码分析和安全扫描">执行静态代码分析和安全扫描</h3>
<p>现在您的应用程序已按预期运行，是时候在不执行底层代码的情况下执行静态代码分析了。这是软件开发行业的一种常见做法，可帮助开发人员识别其代码中的潜在软件缺陷和安全风险。</p>
<p>虽然静态分析的某些步骤可以自动完成，但其他步骤通常需要手动完成，例如同行评审。</p>
<p>您将使用以下自动化工具，因此请将它们作为可选依赖项添加到您的 <code>pyproject.toml</code> 文件中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;bandit&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;black&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;flake8&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;isort&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pylint&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest-timeout&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;requests&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>之后不要忘记重新安装并固定您的依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;.[dev]&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip freeze --exclude-editable &gt; constraints.txt
</span></span></code></pre></div><p>这会将一些命令行实用工具带入您的虚拟环境。首先，您应该通过一致地格式化代码、对 <code>import</code> 语句进行排序并检查 PEP 8 合规性来清理代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m black src/ --check
</span></span><span class="line"><span class="cl">would reformat /home/realpython/page-tracker/src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Oh no! 💥 💔 💥
</span></span><span class="line"><span class="cl"><span class="m">1</span> file would be reformatted, <span class="m">1</span> file would be left unchanged.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m isort src/ --check
</span></span><span class="line"><span class="cl">ERROR: /home/.../app.py Imports are incorrectly sorted and/or formatted.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m flake8 src/
</span></span><span class="line"><span class="cl">src/page_tracker/app.py:23:1: E302 expected <span class="m">2</span> blank lines, found <span class="m">1</span>
</span></span></code></pre></div><p>您使用 <code>black</code> 标记代码中的任何格式不一致，使用 <code>isort</code> 确保您的 <code>import</code> 语句根据官方建议保持组织，使用 <code>flake8</code> 检查任何其他 PEP 8 样式违规。</p>
<p>如果您在运行这些工具后没有看到任何输出，则意味着没有什么可以修复的。另一方面，如果出现警告或错误，那么您可以手动更正任何报告的问题，或者让这些工具在您删除 <code>--check</code> 标志时自动执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m black src/
</span></span><span class="line"><span class="cl">reformatted /home/realpython/page-tracker/src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">All <span class="k">done</span>! ✨ 🍰 ✨
</span></span><span class="line"><span class="cl"><span class="m">1</span> file reformatted, <span class="m">1</span> file left unchanged.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m isort src/
</span></span><span class="line"><span class="cl">Fixing /home/realpython/page-tracker/src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m flake8 src/
</span></span></code></pre></div><p>如果没有 <code>--check</code> 标志， <code>black</code> 和 <code>isort</code> 都会继续并在不询问的情况下重新格式化受影响的文件。运行这两个命令还解决了 PEP 8 合规性问题，因为 <code>flake8</code> 不再返回任何样式违规。</p>
<blockquote>
<p>注意：遵循整个团队的通用代码风格约定有助于保持代码整洁。这样，当一个人更新源文件时，团队成员就不必对不相关代码部分（例如空格）的更改进行分类。</p>
</blockquote>
<p>一旦一切都干净了，您就可以对代码进行 lint 以查找潜在的代码异味或改进它的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pylint src/
</span></span></code></pre></div><p>当您针对 Web 应用程序的源代码运行 <code>pylint</code> 时，它可能会开始抱怨或多或少有用的东西。它通常发出属于几个类别的消息，包括：</p>
<ul>
<li><strong>E:</strong> Errors</li>
<li><strong>W:</strong> Warnings</li>
<li><strong>C:</strong> 违反公约</li>
<li><strong>R:</strong> 重构建议</li>
</ul>
<p>每条评论都有一个唯一的标识符，例如 <code>C0116</code> ，如果您觉得它没有帮助，您可以将其隐藏。您可以在全局配置文件中包含抑制的标识符以获得永久效果，或者使用命令行开关忽略给定运行中的某些错误。</p>
<p>您还可以在给定行上添加特殊格式的 Python 注释以说明特殊情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span><span class="p">,</span> <span class="n">RedisError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@app.get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">page_views</span> <span class="o">=</span> <span class="n">redis</span><span class="p">()</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="n">RedisError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&#34;Redis error&#34;</span><span class="p">)</span>  <span class="c1"># pylint: disable=E1101</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;Sorry, something went wrong </span><span class="se">\N{pensive face}</span><span class="s2">&#34;</span><span class="p">,</span> <span class="mi">500</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;This page has been seen </span><span class="si">{</span><span class="n">page_views</span><span class="si">}</span><span class="s2"> times.&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@cache</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Redis</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&#34;REDIS_URL&#34;</span><span class="p">,</span> <span class="s2">&#34;redis://localhost:6379&#34;</span><span class="p">))</span>
</span></span></code></pre></div><p>在这种情况下，您告诉 <code>pylint</code> 忽略错误 E1101 的特定实例，而不是完全抑制它。这是一个误报，因为 <code>.logger</code> 是 Flask 在运行时生成的动态属性，在静态分析过程中不可用。</p>
<blockquote>
<p>注意：如果您打算使用 <code>pylint</code> 作为自动化持续集成管道的一部分，那么您可能需要指定它何时应该退出并显示错误代码，这通常会停止管道的后续步骤。例如，您可以将其配置为始终返回中性退出代码零：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pylint src/ --exit-zero
</span></span></code></pre></div><p>这永远不会停止管道运行，即使 <code>pylint</code> 在代码中发现一些问题。或者，使用 <code>--fail-under</code> ，您可以指定任意分数阈值， <code>pylint</code> 将在该阈值时退出并显示错误代码。</p>
</blockquote>
<p>您会注意到 <code>pylint</code> 为您的代码打分并对其进行跟踪。当您以某种方式解决问题并再次运行该工具时，它会报告一个新分数并告诉您它改善或恶化了多少。使用您的最佳判断来决定 <code>pylint</code> 报告的问题是否值得修复。</p>
<p>最后，无意中通过源代码泄露敏感数据或暴露其他安全漏洞的情况非常普遍。它甚至发生在最好的软件工程师身上。最近，GitHub 在一个公共存储库中<a href="https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/#what-happened-and-what-actions-have-we-taken">暴露了它的私钥</a>，这可能让攻击者冒充这个巨头。为了降低此类事件的风险，您应该在将源代码部署到任何地方之前对其进行安全或漏洞扫描。</p>
<p>要扫描您的代码，您可以使用 <a href="https://bandit.readthedocs.io/en/latest/">bandit</a> ，它是您之前作为可选依赖项安装的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m bandit -r src/
</span></span></code></pre></div><p>当您指定文件夹路径而不是文件路径时，还必须包含 <code>-r</code> 标志以递归扫描它。此时， <code>bandit</code> 应该不会在您的代码中发现任何问题。但是，如果您在 Flask 应用程序底部添加以下两行后再次运行它，那么该工具将报告不同严重级别的问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s2">&#34;0.0.0.0&#34;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span></code></pre></div><p>这种 <a href="https://realpython.com/if-name-main-python/">name-main 惯用语</a>是许多 Flask 应用程序中常见的模式，因为它使开发更方便，让您直接运行 Python 模块。另一方面，它暴露了 Flask 的调试器，允许执行任意代码，并通过地址 <code>0.0.0.0</code> 绑定到所有网络接口，为公共流量打开您的服务。</p>
<p>因此，为了确保您的 Flask 应用程序是安全的，您应该始终在将代码部署到生产环境之前运行 <code>bandit</code> 或类似工具。</p>
<p>好的。您的 Web 应用程序包含单元、集成和端到端测试。这意味着许多自动化工具已经静态分析和修改了它的源代码。</p>
<p>接下来，您将继续通过将应用程序包装在 Docker 容器中来实现持续集成，这样您就可以将整个项目部署到远程环境或忠实地将其复制到本地计算机上。</p>
<h2 id="将您的-flask-web-应用程序-docker-化">将您的 Flask Web 应用程序 Docker 化</h2>
<p>在本节中，您将以 Docker 容器的形式运行您的页面跟踪器 Web 应用程序，该容器可以与在另一个容器中运行的 Redis 通信。这样的设置对于开发和测试以及将应用程序部署到远程环境很有用。</p>
<p>即使您的计算机上没有安装 Python 或 Redis，您仍然可以通过 Docker 运行您的项目。</p>
<h3 id="理解-docker-术语">理解 Docker 术语</h3>
<p>对应用程序进行 Docker 化涉及创建 Dockerfile，它是对环境所需状态的声明性描述。它为运行时环境、配置以及运行应用程序所需的所有依赖项和库提供模板。</p>
<p>要为您的应用程序注入活力，您必须根据该描述构建一个 Docker 镜像。您可以将 Docker 镜像视为操作系统在给定时间的快照。当您与世界或公司内部共享您的 Docker 镜像时，其他人可以重现与您完全相同的环境并运行相同的应用程序。</p>
<p>这回避了经典，但它适用于我的机器问题。</p>
<p>Docker 镜像是 Docker 容器的蓝图。每个 Docker 容器都是 Docker 镜像的一个实例。一个容器有独立的状态和资源，包括它自己的文件系统、环境变量和网络接口。单个 Docker 容器通常运行单个进程，使其成为托管特定<a href="https://realpython.com/python-microservices-grpc/">微服务</a>的理想选择。</p>
<p>通过添加更多容器，您可以临时扩展一个或多个微服务以处理流量高峰，例如，这在假期期间可能很常见。但是，您的微服务必须架构良好并保持无状态才能使其有效。</p>
<blockquote>
<p>注意：Docker 容器类似于 Vagrant 或 VirtualBox 等虚拟机，但更轻巧且启动速度更快。因此，您可以同时在主机上运行比虚拟机更多的容器。</p>
<p>这样做的原因是容器的开销较小，因为它们共享操作系统的内核，而虚拟机运行在模拟完整硬件堆栈的管理程序上。另一方面，容器不那么安全，它们也不提供与虚拟机相同级别的隔离。</p>
</blockquote>
<p>典型的应用程序包括在隔离的 Docker 容器中运行的多个服务，这些容器可以相互通信。您的页面跟踪器应用程序有以下两个：</p>
<ol>
<li>Web service</li>
<li>Redis service</li>
</ol>
<p>您已经知道如何通过 Docker 运行 Redis。现在，是时候将您的 Flask Web 应用程序沙盒化到 Docker 容器中，以简化这两种服务的开发和部署过程。</p>
<h3 id="了解-dockerfile-的剖析">了解 Dockerfile 的剖析</h3>
<p>首先，您将定义一个适用于开发阶段的相对较短的 Dockerfile。在项目根文件夹中创建一个名为 <code>Dockerfile</code> 的文件，该文件与文件层次结构中的 <code>src/</code> 子文件夹和 <code>pyproject.toml</code> 配置文件处于同一级别：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">├── Dockerfile
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>您可以随意命名此文件，但坚持默认命名约定将使您不必在每次构建镜像时都指定文件名。 Docker 期望的默认文件名是 <code>Dockerfile</code> ，没有文件扩展名。请注意，它以大写字母 <code>D</code> 开头。</p>
<p>Dockerfile 是一个纯文本文档，其中列出了组装镜像所需的步骤。它遵循特定格式，定义了一套固定的说明供您使用。</p>
<blockquote>
<p>注意：您必须将 Dockerfile 中的每条指令放在单独的一行中，但看到非常长的行被行连续字符 ( <code>\</code> ) 多次打断的情况并不少见。事实上，通常需要在一行中塞入多个操作，以利用您现在将要了解的缓存机制。</p>
</blockquote>
<p>当您从 Dockerfile 构建镜像时，您依赖于一系列层。每条指令都会在前一层之上创建一个只读层，封装对镜像底层文件系统的一些修改。图层具有全局唯一标识符，这允许 Docker 将图层存储在缓存中。这有两个主要优点：</p>
<ul>
<li>速度：Docker 可以跳过自上次构建以来未更改的层，而是从缓存中加载它们，从而显着加快镜像构建速度。</li>
<li>大小：多个镜像可以共享公共图层，从而减小它们各自的大小。除此之外，层数越少，镜像尺寸越小。</li>
</ul>
<p>现在您已经了解了 Dockerfile 的这种分层结构，您可以开始向其中添加指令，同时了解创建高效 Docker 镜像的最佳实践。</p>
<h3 id="选择基础-docker-镜像">选择基础 Docker 镜像</h3>
<p>每个 Dockerfile 中的第一条指令 <code>FROM</code> 必须始终定义用于构建新镜像的基础镜像。这意味着您不必从头开始，而是可以选择一个已经构建的合适镜像。例如，您可以使用 Python 解释器附带的镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span></code></pre></div><p>在这里，您使用名为 <code>python</code> 的官方 Python 镜像，它托管在 Docker Hub 上。官方镜像由相应语言或技术的官方维护者构建和维护。它们不属于 Docker Hub 上的任何特定用户或团队，但在全局命名空间中可用，隐式称为 <code>library/</code> ，而不是更专业的变体，如 <code>circleci/python</code> 。</p>
<p>您还可以在冒号 ( <code>:</code> ) 后指定一个可选的标签或标签名称，以缩小基本镜像的特定版本。您可以通过单击相应 Docker Hub 页面上的“标签”选项卡来浏览给定 Docker 镜像的所有可用标签。</p>
<p>注意：标签不是强制性的，但将它们包含在 <code>FROM</code> 指令中被认为是最佳实践。您应该尽可能具体，以避免不必要的意外。如果您省略该标记，那么 Docker 将拉取一个标记为 <code>latest</code> 的镜像，其中可能包含不合适的操作系统或影响您的应用程序的运行时意外更改。</p>
<p>标签 <code>3.11.2-slim-bullseye</code> 表示您的基础镜像将是 Debian Bullseye 的精简变体，仅包含基本要素，让您稍后可以根据需要安装任何其他软件包。这减小了镜像的大小并加快了下载时间。此镜像的常规变体和超薄变体之间的大小差异高达八百兆字节！</p>
<p>该标记还表明您的基础镜像将随已安装的 Python 3.11.2 一起提供，因此您可以立即开始使用它。</p>
<p>在拉取基础镜像后，您可能想要立即执行的下一个任务是使用最新的安全更新和错误修复对其进行修补，这些更新和错误修复可能是自镜像在 Docker Hub 上发布以来发布的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span></code></pre></div><p>在 Debian 中，您可以使用 <code>apt-get</code> 命令获取最新的软件包列表并升级任何有可用更新的软件包。请注意，这两个命令都作为一个 <code>RUN</code> 指令的一部分执行，以最大限度地减少文件系统中的层数，从而避免占用过多的磁盘空间。</p>
<blockquote>
<p>注意：Dockerfile 中指令的顺序很重要，因为它会影响构建镜像所需的时间。</p>
<p>特别是，您应该将其层经常更改的指令放在 Dockerfile 的底部，因为它们最有可能使缓存中的所有后续层无效。</p>
</blockquote>
<p>好的。您已经选择了基本镜像并安装了最新的安全更新。您几乎已经准备好设置您的 Flask 应用程序，但还有几个步骤。</p>
<h3 id="隔离你的-docker-镜像">隔离你的 Docker 镜像</h3>
<p>使用 Dockerfiles 时的另一个好习惯是，一旦不再需要它们，就创建并切换到没有管理权限的普通用户。默认情况下，Docker 以超级用户身份运行您的命令，恶意攻击者可以利用它来不受限制地访问您的主机系统。是的，Docker 提供了对容器和主机的根级访问权限！</p>
<p>以下是避免这种潜在安全风险的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Dockerfile</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">FROM</span> <span class="n">python</span><span class="p">:</span><span class="mf">3.11.2</span><span class="o">-</span><span class="n">slim</span><span class="o">-</span><span class="n">bullseye</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">&amp;&amp;</span> \
</span></span><span class="line"><span class="cl">    <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">upgrade</span> <span class="o">--</span><span class="n">yes</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RUN</span> <span class="n">useradd</span> <span class="o">--</span><span class="n">create</span><span class="o">-</span><span class="n">home</span> <span class="n">realpython</span>
</span></span><span class="line"><span class="cl"><span class="n">USER</span> <span class="n">realpython</span>
</span></span><span class="line"><span class="cl"><span class="n">WORKDIR</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">realpython</span>
</span></span></code></pre></div><p>您创建一个名为 <code>realpython</code> 的新用户，并告诉 Docker 从现在起在 Dockerfile 中使用该用户。您还将当前工作目录设置为此用户的主目录，这样您就不必在后面的命令中明确指定完整的文件路径。</p>
<p>即使您的 Docker 容器将运行单个 Flask 应用程序，也请考虑在容器本身内部设置一个专用的虚拟环境。虽然您无需担心将多个 Python 项目彼此隔离，并且 Docker 为您的主机提供了一个合理的隔离层，但您仍然存在干扰容器自身系统工具的风险。</p>
<p>不幸的是，许多 Linux 发行版都依赖于全局 Python 安装才能顺利运行。如果您开始将包直接安装到全局 Python 环境中，那么您就为潜在的版本冲突打开了大门。这甚至可能导致破坏您的系统。</p>
<blockquote>
<p>注意：如果您仍然不相信在 Docker 容器内创建虚拟环境，那么这条警告消息可能会改变您的想法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">WARNING: Running pip as the <span class="s1">&#39;root&#39;</span> user can result in broken permissions
</span></span><span class="line"><span class="cl">and conflicting behaviour with the system package manager. It is
</span></span><span class="line"><span class="cl">⮑recommended to use a virtual environment instead:
</span></span><span class="line"><span class="cl">⮑https://pip.pypa.io/warnings/venv
</span></span></code></pre></div><p>在 Debian 或 Ubuntu 等衍生发行版上尝试使用系统的全局 <code>pip</code> 命令安装 Python 包后，您可能会看到这一点。</p>
</blockquote>
<p>在 Docker 镜像中创建和激活虚拟环境的最可靠方法是直接修改其 <code>PATH</code> 环境变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span></code></pre></div><p>首先，定义一个辅助变量 <code>VIRTUALENV</code> ，其中包含项目虚拟环境的路径，然后使用 Python 的 <code>venv</code> 模块在那里创建该环境。但是，不是使用 shell 脚本激活新环境，而是通过覆盖 <code>python</code> 可执行文件的路径来更新 <code>PATH</code> 变量。</p>
<p>为什么？这是必要的，因为以通常的方式激活您的环境只是暂时的，不会影响从您的镜像派生的 Docker 容器。此外，如果您使用 Dockerfile 的 <code>RUN</code> 指令激活虚拟环境，那么它只会持续到 Dockerfile 中的下一条指令，因为每条指令都会启动一个新的 shell 会话。</p>
<p>一旦你有了项目的虚拟环境，你就可以安装必要的依赖项。</p>
<h3 id="缓存你的项目依赖">缓存你的项目依赖</h3>
<p>与在主机本地工作相比，在 Dockerfile 中安装依赖项看起来略有不同。通常，您会安装依赖项，然后立即安装 Python 包。</p>
<p>相比之下，当您构建 Docker 镜像时，值得将该过程分为两个步骤以利用层缓存，从而减少构建镜像所需的总时间。</p>
<p>首先， <code>COPY</code> 将带有项目元数据的两个文件从您的主机导入到 Docker 镜像中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython pyproject.toml constraints.txt ./<span class="err">
</span></span></span></code></pre></div><p>您只需将包含有关项目依赖项信息的 <code>pyproject.toml</code> 和 <code>constraints.txt</code> 文件复制到 Docker 镜像中 <code>realpython</code> 用户的主目录中。默认情况下，文件归超级用户所有，因此您可能希望使用 <code>--chown</code> 将其所有者更改为您之前创建的普通用户。 <code>--chown</code> 选项类似于 <code>chown</code> 命令，它代表更改所有者。</p>
<p>您可以在网上找到的许多 Dockerfile 示例会一次性复制所有内容，但那很浪费！</p>
<p>可能有大量额外文件，例如包含项目整个历史的本地 Git 存储库、代码编辑器设置或项目根文件夹中的其他临时文件。</p>
<p>它们不仅会使生成的镜像膨胀，而且还会增加过早使 Docker 层缓存失效的可能性。</p>
<blockquote>
<p>注意：您应该只复制您目前需要的单个文件到您的 Dockerfile 中。否则，即使是不相关文件中的最细微变化也会导致剩余图层重建。或者，您可以定义一个 <code>.dockerignore</code> 文件，其工作方式与 <code>.gitignore</code> 副本类似，但明确说明要复制的内容更安全。</p>
</blockquote>
<p>另一个容易遗漏的难题是当您在尝试安装项目依赖项之前忘记升级 <code>pip</code> 本身。在极少数情况下， <code>pip</code> 的旧版本实际上可以阻止安装其他软件包的最新版本！在您的情况下，还值得升级 <code>setuptools</code> ，您将其用作构建后端，以获取最新的安全补丁。</p>
<p>您可以将以下两个命令组合在一条 <code>RUN</code> 指令中以安装您的依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython pyproject.toml constraints.txt ./<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install --upgrade pip setuptools <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pip install --no-cache-dir -c constraints.txt <span class="s2">&#34;.[dev]&#34;</span><span class="err">
</span></span></span></code></pre></div><p>您将 <code>pip</code> 和 <code>setuptools</code> 升级到最新版本。然后，安装项目所需的第三方库，包括用于开发的可选依赖项。您限制它们的版本以确保一致的环境，并告诉 <code>pip</code> 使用 <code>--no-cache-dir</code> 禁用缓存。您在虚拟环境之外不需要这些包，因此无需缓存它们。这样，您就可以使 Docker 镜像更小。</p>
<blockquote>
<p>注意：因为您安装了依赖项而没有在 Docker 镜像中安装 <code>page-tracker</code> 包，所以它们将保留在缓存层中。因此，对源代码的任何更改都不需要重新安装这些依赖项。</p>
</blockquote>
<p>您的 Dockerfile 正在增长并变得越来越复杂，但请不要担心。只需要完成几个步骤，就快完成了。</p>
<h3 id="作为构建过程的一部分运行测试">作为构建过程的一部分运行测试</h3>
<p>最后，是时候将您的源代码复制到 Docker 镜像中，并与 linters 和其他静态分析工具一起运行您的测试了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython pyproject.toml constraints.txt ./<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install --upgrade pip setuptools <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pip install --no-cache-dir -c constraints.txt <span class="s2">&#34;.[dev]&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython src/ src/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython test/ test/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install . -c constraints.txt <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pytest test/unit/ <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m flake8 src/ <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m isort src/ --check <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m black src/ --check --quiet <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pylint src/ --disable<span class="o">=</span>C0114,C0116,R1705 <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m bandit -r src/ --quiet<span class="err">
</span></span></span></code></pre></div><p>从主机复制 <code>src/</code> 和 <code>test/</code> 文件夹后，将 <code>page-tracker</code> 包安装到虚拟环境中。通过将自动化测试工具融入构建过程，您可以确保如果其中任何一个工具返回非零退出状态代码，则构建您的 Docker 镜像将失败。这正是您在实施持续集成管道时想要的。</p>
<p>请注意，您必须禁用严重性低的 <code>pylint</code> 问题 C0114 、 C0116 和 R1705 ，它们现在并不重要。否则，它们会阻止您的 Docker 镜像成功构建。</p>
<p>将各个命令组合在一个 <code>RUN</code> 指令中的原因是为了减少要缓存的层数。请记住，您拥有的层越多，生成的 Docker 镜像就越大。</p>
<blockquote>
<p>注意：此时，您无法执行需要 Redis 的集成或端到端测试，因为您的 Docker 镜像只涉及 Flask 应用程序。在将应用程序部署到某个环境后，您将能够执行它们。</p>
</blockquote>
<p>当所有测试都通过并且没有任何静态分析工具报告任何问题时，您的 Docker 镜像就差不多完成了。但是，当您从镜像创建新容器时，您仍然需要告诉 Docker 要运行什么命令。</p>
<h3 id="指定要在-docker-容器中运行的命令">指定要在 Docker 容器中运行的命令</h3>
<p>最后一步是指定要在从 Docker 镜像派生的每个新 Docker 容器中执行的命令。在此阶段，您可以在 Flask 的内置开发服务器上启动您的 Web 应用程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython pyproject.toml constraints.txt ./<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install --upgrade pip setuptools <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pip install --no-cache-dir -c constraints.txt <span class="s2">&#34;.[dev]&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython src/ src/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython test/ test/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install . -c constraints.txt <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pytest test/unit/ <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m flake8 src/ <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m isort src/ --check <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m black src/ --check --quiet <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pylint src/ --disable<span class="o">=</span>C0114,C0116,R1705 <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m bandit -r src/ --quiet<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="o">[</span><span class="s2">&#34;flask&#34;</span>, <span class="s2">&#34;--app&#34;</span>, <span class="s2">&#34;page_tracker.app&#34;</span>, <span class="s2">&#34;run&#34;</span>, <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>     <span class="s2">&#34;--host&#34;</span>, <span class="s2">&#34;0.0.0.0&#34;</span>, <span class="s2">&#34;--port&#34;</span>, <span class="s2">&#34;5000&#34;</span><span class="o">]</span><span class="err">
</span></span></span></code></pre></div><p>在这里，您使用 <code>CMD</code> 指令的三种形式之一，它类似于 Python 的 <code>subprocess.run()</code> 函数的语法。请注意，您必须将主机绑定到 <code>0.0.0.0</code> 地址，以便从 Docker 容器外部访问您的应用程序。</p>
<p>您现在可以基于现有的 Dockerfile 构建 Docker 镜像，并开始运行从中派生的 Docker 容器。以下命令会将您的 Dockerfile 转换为名为 <code>page-tracker</code> 的 Docker 镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker build -t page-tracker .
</span></span></code></pre></div><p>它将在当前工作目录中查找 Dockerfile，用点 ( <code>.</code> ) 表示，并使用默认标签 <code>latest</code> 标记生成的镜像。因此，完整的镜像名称将是 <code>page-tracker:latest</code> 。</p>
<p>不幸的是，您的镜像目前包含很多杂物，例如您在生产中永远不需要的源代码、测试和 linter。</p>
<p>它们会增加镜像的大小，使下载和部署速度变慢，如果您没有正确维护它们，它们还会导致安全漏洞。此外，这些额外的组件可能会在排除错误时引起问题。</p>
<p>幸运的是，有一种更好的方法来组织您的 Dockerfile，允许您分多个阶段构建一个镜像，您现在将探索它。</p>
<h3 id="为多阶段构建重新组织-dockerfile">为多阶段构建重新组织 Dockerfile</h3>
<p>到目前为止，您创建的 Dockerfile 相当简单，应该适合开发。保留它，因为稍后您将需要它来使用 Docker Compose 运行端到端测试。您现在可以复制此文件并为其指定一个不同的名称。例如，您可以将 <code>.dev</code> 后缀附加到两个副本之一：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">├── Dockerfile
</span></span><span class="line"><span class="cl">├── Dockerfile.dev
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>现在，编辑名为 <code>Dockerfile</code> 的文件并在将构建过程分解为多个阶段时保持打开状态。</p>
<blockquote>
<p>注意：要在构建镜像时指定自定义文件名而不是默认的 <code>Dockerfile</code> ，请使用 <code>-f</code> 或 <code>--file</code> 选项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker build -f Dockerfile.dev -t page-tracker .
</span></span></code></pre></div><p>这个文件名可以是任何你想要的。只需确保在 <code>docker build</code> 命令中正确引用它即可。</p>
</blockquote>
<p>多阶段构建背后的想法是将 Dockerfile 划分为多个阶段，每个阶段都可以基于完全不同的镜像。当您的应用程序的开发环境和运行时环境不同时，这尤其有用。</p>
<p>例如，您可以在仅用于构建和测试应用程序的临时镜像中安装必要的构建工具，然后将生成的可执行文件复制到最终镜像中。</p>
<p>多阶段构建可以使您的镜像更小、更高效。这是使用当前 Dockerfile 构建的同一镜像与您将要编写的镜像的比较：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker images
</span></span><span class="line"><span class="cl">REPOSITORY     TAG       IMAGE ID       CREATED          SIZE
</span></span><span class="line"><span class="cl">page-tracker   prod      9cb2e3233522   <span class="m">5</span> minutes ago    204MB
</span></span><span class="line"><span class="cl">page-tracker   dev       f9918cb213dc   <span class="m">5</span> minutes ago    244MB
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span></code></pre></div><p>在这种情况下，大小差异并不显着，但当您有多个镜像要管理和移动时，它会迅速增加。</p>
<p>Dockerfile 中的每个阶段都以其自己的 <code>FROM</code> 指令开始，因此您将有两个。第一个阶段看起来与您当前的 Dockerfile 几乎完全相同，除了您将为这个阶段命名 <code>builder</code> ，您可以稍后参考：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"># Dockerfile
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gd">-FROM python:3.11.2-slim-bullseye
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+FROM python:3.11.2-slim-bullseye AS builder
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>
</span></span><span class="line"><span class="cl"> RUN apt-get update &amp;&amp; \
</span></span><span class="line"><span class="cl">     apt-get upgrade --yes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> RUN useradd --create-home realpython
</span></span><span class="line"><span class="cl"> USER realpython
</span></span><span class="line"><span class="cl"> WORKDIR /home/realpython
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ENV VIRTUALENV=/home/realpython/venv
</span></span><span class="line"><span class="cl"> RUN python3 -m venv $VIRTUALENV
</span></span><span class="line"><span class="cl"> ENV PATH=&#34;$VIRTUALENV/bin:$PATH&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> COPY --chown=realpython pyproject.toml constraints.txt ./
</span></span><span class="line"><span class="cl"> RUN python -m pip install --upgrade pip setuptools &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m pip install --no-cache-dir -c constraints.txt &#34;.[dev]&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> COPY --chown=realpython src/ src/
</span></span><span class="line"><span class="cl"> COPY --chown=realpython test/ test/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> RUN python -m pip install . -c constraints.txt &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m pytest test/unit/ &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m flake8 src/ &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m isort src/ --check &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m black src/ --check --quiet &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m pylint src/ --disable=C0114,C0116,R1705 &amp;&amp; \
</span></span><span class="line"><span class="cl"><span class="gd">-    python -m bandit -r src/ --quiet
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+    python -m bandit -r src/ --quiet &amp;&amp; \
</span></span></span><span class="line"><span class="cl"><span class="gi">+    python -m pip wheel --wheel-dir dist/ . -c constraints.txt
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>
</span></span><span class="line"><span class="cl"><span class="gd">-CMD [&#34;flask&#34;, &#34;--app&#34;, &#34;page_tracker.app&#34;, &#34;run&#34;, \
</span></span></span><span class="line"><span class="cl"><span class="gd">-     &#34;--host&#34;, &#34;0.0.0.0&#34;, &#34;--port&#34;, &#34;5000&#34;]
</span></span></span></code></pre></div><p>因为您要将打包的页面跟踪器应用程序从一个镜像传输到另一个镜像，所以您必须添加使用 Python wheel 格式构建分发包的额外步骤。 <code>pip wheel</code> 命令将在 <code>dist/</code> 子文件夹中创建一个名为 <code>page_tracker-1.0.0-py3-none-any.whl</code> 的文件。您还可以从此阶段删除 <code>CMD</code> 指令，因为它将成为下一阶段的一部分。</p>
<p>第二个也是最后一个阶段，隐式命名为 <code>stage-1</code> ，看起来有点重复，因为它基于相同的镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye AS builder</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># ...</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>builder /home/realpython/dist/page_tracker*.whl /home/realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install --upgrade pip setuptools <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pip install --no-cache-dir page_tracker*.whl<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="o">[</span><span class="s2">&#34;flask&#34;</span>, <span class="s2">&#34;--app&#34;</span>, <span class="s2">&#34;page_tracker.app&#34;</span>, <span class="s2">&#34;run&#34;</span>, <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>     <span class="s2">&#34;--host&#34;</span>, <span class="s2">&#34;0.0.0.0&#34;</span>, <span class="s2">&#34;--port&#34;</span>, <span class="s2">&#34;5000&#34;</span><span class="o">]</span><span class="err">
</span></span></span></code></pre></div><p>您首先按照熟悉的步骤升级系统包、创建用户和创建虚拟环境。然后，突出显示的行负责从 <code>builder</code> 阶段复制 wheel 文件。你像以前一样用 <code>pip</code> 安装它。最后，您添加 <code>CMD</code> 指令以使用 Flask 启动您的 Web 应用程序。</p>
<p>当您使用这样的多阶段 Dockerfile 构建镜像时，您会注意到第一阶段需要更长的时间才能完成，因为它必须安装所有依赖项、运行测试并创建 wheel 文件。</p>
<p>但是，构建第二阶段会快很多，因为它只需要复制并安装完成的 wheel 文件。另外请注意， <code>builder</code> 阶段是临时的，因此之后不会在您的 Docker 镜像中留下任何痕迹。</p>
<p>好的。你终于准备好构建你的多阶段 Docker 镜像了！</p>
<h3 id="构建和版本控制你的-docker-镜像">构建和版本控制你的 Docker 镜像</h3>
<p>在构建镜像之前，强烈建议您为 Docker 镜像选择一个版本控制方案，并始终使用唯一标签对其进行标记。这样，您就会知道在任何给定环境中部署了什么，并能够在需要时回滚到之前的稳定版本。</p>
<p>对 Docker 镜像进行版本控制有几种不同的策略。例如，一些流行的包括：</p>
<ul>
<li>语义版本控制使用以点分隔的三个数字来指示主要版本、次要版本和补丁版本。</li>
<li>Git 提交哈希使用绑定到镜像中源代码的 Git 提交的 SHA-1 哈希。</li>
<li>时间戳使用时间信息（例如 Unix 时间）来指示镜像的构建时间。</li>
</ul>
<p>没有什么能阻止您结合其中的一些策略来创建一个有效的版本控制系统，该系统将帮助您跟踪镜像中的更改。</p>
<p>在本教程中，您将坚持使用 Git 提交哈希方法，因为它可以确保您的 Docker 镜像的标签是唯一且不可变的。花点时间在您的 <code>page-tracker/</code> 文件夹中初始化一个本地 Git 存储库，并使用与您的工作环境相关的文件模式定义一个 <code>.gitignore</code> 。您可以通过使用 <code>pwd</code> 命令打印您的工作目录来仔细检查您是否在正确的文件夹中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">pwd</span>
</span></span><span class="line"><span class="cl">/home/realpython/page-tracker
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git init
</span></span><span class="line"><span class="cl">Initialized empty Git repository in /home/realpython/page-tracker/.git/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ curl -sL https://www.gitignore.io/api/python,pycharm+all &gt; .gitignore
</span></span></code></pre></div><p>在这里，您使用 <code>curl</code> 从 gitignore.io 下载内容，请求 Git 从跟踪中排除 Python 和 PyCharm 相关的文件模式。 <code>-L</code> 标志是跟随重定向所必需的，因为该网站最近移动到具有更长域的不同地址。或者，您可以从 GitHub 的 <code>gitignore</code> 存储库中获取其中一个模板，某些代码编辑器会使用该模板。</p>
<p>初始化本地 Git 存储库后，您可以进行第一次提交并获取相应的哈希值，例如，使用 <code>git rev-parse</code> 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git add .
</span></span><span class="line"><span class="cl">$ git commit -m <span class="s2">&#34;Initial commit&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>master <span class="o">(</span>root-commit<span class="o">)</span> dde1dc9<span class="o">]</span> Initial commit
</span></span><span class="line"><span class="cl"> <span class="m">11</span> files changed, <span class="m">535</span> insertions<span class="o">(</span>+<span class="o">)</span>
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> .gitignore
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> Dockerfile
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> Dockerfile.dev
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> constraints.txt
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> pyproject.toml
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> src/page_tracker/__init__.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> src/page_tracker/app.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> test/conftest.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> test/e2e/test_app_redis_http.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> test/integration/test_app_redis.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> test/unit/test_app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git rev-parse HEAD
</span></span><span class="line"><span class="cl">dde1dc9303a2a9f414d470d501572bdac29e4075
</span></span></code></pre></div><p>如果你不喜欢长输出，那么你可以在命令中添加 <code>--short</code> 标志，这将为你提供相同提交哈希的缩写版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git rev-parse --short HEAD
</span></span><span class="line"><span class="cl">dde1dc9
</span></span></code></pre></div><p>默认情况下，它将返回可以唯一标识该特定提交而不会产生歧义的最短前缀。</p>
<p>现在您已经有了 Git 提交哈希，您可以将它用作 Docker 镜像的标签。要构建镜像，请在指定 <code>-t</code> 或 <code>--tag</code> 选项的同时运行 <code>docker build</code> 命令，以便为新镜像添加标签。尾随点表示您当前的工作目录是查找 Dockerfile 的位置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker build -t page-tracker:<span class="k">$(</span>git rev-parse --short HEAD<span class="k">)</span> .
</span></span></code></pre></div><p>冒号之前的第一部分 <code>page-tracker</code> 是您的 Docker 镜像的助记名称。请注意，在现实生活中，您可能会附加某种后缀来传达此服务的角色。例如，因为这是一个 Flask 网络应用程序，您可以将镜像命名为 <code>page-tracker-web</code> 或类似的名称。冒号后面的是实际标记，在本例中，它是当前提交的 Git 提交哈希。</p>
<p>如果您之前构建 Docker 镜像时没有给它明确的标签，或者如果您以其他方式标记它，那么您可能会注意到现在构建它只需要几分之一秒！</p>
<p>那是因为 Docker 缓存了每个文件系统层，只要项目中的重要文件没有更改，就不需要重建这些层。</p>
<p>另一点值得注意的是，在表面之下，Docker 仅存储您的镜像的一个副本。它有一个唯一的标识符，例如 <code>9cb2e3233522</code> ，多个标签可以引用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker images
</span></span><span class="line"><span class="cl">REPOSITORY     TAG                    IMAGE ID       CREATED       SIZE
</span></span><span class="line"><span class="cl">page-tracker   dde1dc9                9cb2e3233522   <span class="m">1</span> hour ago    204MB
</span></span><span class="line"><span class="cl">page-tracker   prod                   9cb2e3233522   <span class="m">1</span> hour ago    204MB
</span></span><span class="line"><span class="cl">page-tracker   dev                    f9918cb213dc   <span class="m">1</span> hour ago    244MB
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span></code></pre></div><p>这就是标记 Docker 镜像的力量。它允许您使用不同的标签引用同一镜像，例如 <code>page-tracker:prod</code> 或 <code>page-tracker:dde1dc9</code> ，同时保留唯一标识。每个标签都包含存储库名称（您将在下一节中了解）和一个特定的标签名称。</p>
<p>您现在可以使用您从 Dockerfile 构建的闪亮的新 Docker 镜像来启动一个成熟的 Docker 容器。具体来说，您可以在笔记本电脑或支持 Docker 的远程基于云的服务器上本地运行容器。</p>
<p>这可能是您进行端到端测试的唯一方法。</p>
<p>但是如何将容器放到远程环境中呢？你会在下一节中找到答案。</p>
<h3 id="将镜像推送到-docker-registry">将镜像推送到 Docker Registry</h3>
<p>当您与他人协作处理一段代码时，您通常会使用 Git 等版本控制来跟踪所有相关人员所做的所有更改。虽然 Git 本身是一个分布式版本控制系统，允许您集成任何两个人之间的贡献，但它缺乏集中托管服务来促进多方之间的同时协作。这就是为什么大多数人选择 GitHub 或竞争对手的原因。</p>
<p>GitHub 是您通常上传源代码的地方，而 Docker Registry 是存储构建的 Docker 镜像的常用位置。从事商业产品的公司将希望在私有云或本地建立自己的 Docker Registry，以获得额外级别的控制和安全性。许多流行的云提供商以托管服务的形式提供高度安全的 Docker 注册表。</p>
<p>您也可以使用私有注册表，例如，通过 Docker 运行开源分发容器。</p>
<p>或者，如果这太麻烦，那么您会很高兴得知 Docker Hub 提供了一个安全的托管注册表，您可以开始免费使用它。虽然免费层为您提供了无限数量的公共存储库，但您将只有一个私有存储库，并且对外界不可见。考虑到您不必支付一分钱，这对于个人或业余爱好项目来说是一笔不错的交易。</p>
<blockquote>
<p>注意：您的 Docker Hub 帐户上的存储库是用户可以上传或下载的 Docker 镜像的集合。每个存储库可以包含同一镜像的多个标记版本。</p>
<p>在这方面，Docker Hub 存储库类似于 GitHub 存储库，但专门用于 Docker 镜像而不是代码。私有存储库允许您仅允许授权用户访问，而公共存储库可供所有人使用。</p>
</blockquote>
<p>为什么要使用 Docker Registry？</p>
<p>好吧，您不必这样做，但它有助于在整个组织内共享 Docker 镜像或设置持续集成管道。例如，将提交推送到 GitHub 或其他源代码修订系统可以通过自动构建功能启动构建过程。反过来，注册中心会宣布新的 Docker 镜像已成功构建或使用 webhook 开始部署到远程环境以进行进一步测试。</p>
<p>如果还没有，请立即在 Docker Hub 上注册一个帐户。请注意，除了电子邮件地址和密码外，您还需要提供唯一的用户名，就像在 GitHub 上一样：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/docker_hub.912fd6ac373d.png" alt="img"  />
</p>
<p>选择一个好记的用户名至关重要，因为它将成为您在 Docker Hub 上的独特句柄。为了避免不同用户拥有的镜像之间的名称冲突，Docker Hub 通过用户名和存储库名称的组合来识别每个存储库。</p>
<p>例如，如果您的用户名是 <code>realpython</code> ，那么您的一个存储库可以由字符串 <code>realpython/page-tracker</code> 标识，它类似于 GitHub 上存储库的名称。</p>
<p>在 Web 浏览器中注册并登录到您的新 Docker Hub 帐户后，您应该做的第一件事是为您的镜像创建一个存储库。单击“创建存储库”磁贴或转到顶部导航栏中的“存储库”选项卡，然后单击“创建存储库”按钮。然后，将您的存储库命名为 <code>page-tracker</code> ，如果需要，请为其提供有意义的描述，然后选择 Private 选项以使其仅对您可见：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/docker_hub2.359dd2359251.png" alt="img"  />
</p>
<p>之后，您将看到带有终端命令的说明，这些命令将允许您将 Docker 镜像推送到您的存储库。但首先，您必须从命令行登录 Docker Hub，提供您的用户名和密码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker login -u realpython
</span></span><span class="line"><span class="cl">Password:
</span></span></code></pre></div><p>即使您打算仅使用公共存储库，也需要使用 <code>docker login</code> 进行身份验证。</p>
<blockquote>
<p>注意：如果您在 Docker Hub 帐户的安全设置中启用了双因素身份验证，那么您将需要生成一个具有适当权限的访问令牌，以便在命令行中使用 <code>docker</code> 登录。当它要求您输入密码时，只需提供您的令牌即可。</p>
<p>否则，如果您没有配置双因素身份验证，那么您将能够使用您的 Docker Hub 密码登录。尽管如此，如文档所述，仍然值得生成一个令牌以获得更好的安全性。</p>
</blockquote>
<p>当你使用 Git 将代码推送到远程存储库时，你必须首先从某个地方克隆它或手动设置默认源，它配置本地存储库的元数据。</p>
<p>相比之下，使用 Docker Hub 或任何其他 Docker 注册表，将本地镜像映射到远程镜像的过程有点不同——您使用标记。具体来说，您使用 Docker Hub 的用户名和存储库名称作为前缀来标记构建的镜像。</p>
<p>首先，您必须提供要发布的本地 Docker 镜像的源标签，例如 <code>page-tracker:dde1dc9</code> 。要找到您刚刚构建的 <code>page-tracker</code> 镜像的确切标签，请检查您当前的 Git 提交哈希或列出您现有的 <code>docker images</code> 。</p>
<p>一旦知道如何标记镜像，就可以使用相同的提交哈希来构建目标标签，该标签将在 Docker 注册表中标识您的存储库。请记住在创建新标签之前将 <code>realpython</code> 替换为您自己的 Docker Hub 用户名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker tag page-tracker:dde1dc9 realpython/page-tracker:dde1dc9
</span></span></code></pre></div><p>这会将新标签 <code>realpython/page-tracker:dde1dc9</code> 添加到标记为 <code>page-tracker:dde1dc9</code> 的本地镜像。目标标签的完整形式如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">registry/username/repository:tag
</span></span></code></pre></div><p>当你想推送到默认的 Docker Hub 时，可以省略注册表部分。否则，它可以是域地址，例如 <code>docker.io</code> ，或带有私有注册表实例的可选端口号的 IP 地址。用户名和存储库必须与您在 Docker Hub 或您使用的任何注册表上创建的用户名和存储库相对应。如果您不提供标签，那么 Docker 将隐式应用标签 <code>latest</code> ，这可能是未定义的。</p>
<p>您可以使用多个标签来标记同一镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker tag page-tracker:dde1dc9 realpython/page-tracker:latest
</span></span></code></pre></div><p>正确标记镜像后，您可以使用 <code>docker push</code> 将它们发送到所需的注册表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker push realpython/page-tracker:dde1dc9
</span></span><span class="line"><span class="cl">$ docker push realpython/page-tracker:latest
</span></span></code></pre></div><p>不要担心发送相同的镜像两次。 Docker 足够聪明，可以知道您之前何时推送过镜像，如果它在注册表中检测到该镜像，则只会传输必要的元数据。</p>
<p>当您在 Docker Hub 上刷新您的配置文件时，它应该反映您刚刚推送到存储库中的两个标签：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/docker_hub3.69a099d38e54.png" alt="Tagged Docker Images on Docker Hub"  />
</p>
<p>现在，当您将协作者添加到您的私有存储库时，他们将能够推送或拉取镜像。请记住，这需要在 Docker Hub 上升级订阅计划。</p>
<p>另一种方法是生成一个对所有存储库具有只读权限的访问令牌，或者创建一个公共存储库。</p>
<p>好的。终于到了通过在 Docker 容器中运行您的 dockerized Flask web 应用程序的机会了。</p>
<h3 id="运行一个-docker-容器">运行一个 Docker 容器</h3>
<p>如果你从一个干净的 Docker 环境开始，也许在另一台计算机上，那么你可以通过从 Docker Hub 拉取它来下载你的镜像，只要你有读取该存储库的权限：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker pull realpython/page-tracker
</span></span><span class="line"><span class="cl">Using default tag: latest
</span></span><span class="line"><span class="cl">latest: Pulling from realpython/page-tracker
</span></span><span class="line"><span class="cl">f1f26f570256: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">2d2b01660885: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">e4e8e4c0b0e1: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">1ba60f086308: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">3c2fccf90be1: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">15e9066b1610: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">e8271c9a01cc: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">4f4fb700ef54: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">bb211d339643: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">8690f9a37c37: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">7404f1e120d1: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">Digest: sha256:cc6fe40a1ac73e6378d0660bf386a1599880a30e422dc061680769bc4d501164
</span></span><span class="line"><span class="cl">Status: Downloaded newer image <span class="k">for</span> realpython/page-tracker:latest
</span></span><span class="line"><span class="cl">docker.io/realpython/page-tracker:latest
</span></span></code></pre></div><p>由于您没有为镜像指定任何标签，因此 Docker 会拉取标记为 <code>latest</code> 的标签。请注意，输出还包括镜像各个层的标识符，对应于用于构建该镜像的原始 Dockerfile 中的 11 条指令。</p>
<p>不过，您不必手动拉取镜像，因为 Docker 会在您第一次尝试运行它们时为您完成。如果指定的镜像已经在缓存中，那么一个新的容器将立即启动，而不会等到下载完成。</p>
<p>下面是基于新镜像运行新 Docker 容器的命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -p 80:5000 --name web-service realpython/page-tracker
</span></span><span class="line"><span class="cl"> * Serving Flask app <span class="s1">&#39;page_tracker.app&#39;</span>
</span></span><span class="line"><span class="cl"> * Debug mode: off
</span></span><span class="line"><span class="cl">WARNING: This is a development server. Do not use it in a production
</span></span><span class="line"><span class="cl">⮑ deployment. Use a production WSGI server instead.
</span></span><span class="line"><span class="cl"> * Running on all addresses <span class="o">(</span>0.0.0.0<span class="o">)</span>
</span></span><span class="line"><span class="cl"> * Running on http://127.0.0.1:5000
</span></span><span class="line"><span class="cl"> * Running on http://172.17.0.3:5000
</span></span><span class="line"><span class="cl">Press CTRL+C to quit
</span></span></code></pre></div><p>当您在本地开发项目时，使用端口转发通过主机的 localhost 访问 Web 服务器通常很方便。在这种情况下， <code>-p</code> 选项可让您导航到地址 <code>http://localhost:80</code> 或只是 <code>http://localhost</code> ，而无需知道正在运行的 Docker 容器的确切 IP 地址。端口 <code>80</code> 是 HTTP 协议的默认端口，这意味着您可以在 Web 浏览器中键入地址时省略它。</p>
<p>此外，此端口映射将确保在 <code>http://localhost:5000</code> 处没有网络端口冲突，以防您没有停止本地 Flask 实例。请记住，您之前启动了一个来执行端到端测试。如果进程仍在后台某处运行，它将占用 Flask 的默认端口 <code>5000</code> 。</p>
<blockquote>
<p>注意：为您的 Docker 容器提供一个描述性名称也很有用，例如 <code>web-service</code> ，这样您就可以通过名称重新启动或删除它，而无需查找相应的容器标识符。如果你不这样做，那么 Docker 会给你的容器一个愚蠢的名字，比如随机选择的 <code>admiring_jang</code> 或 <code>frosty_almeida</code> 。</p>
<p>如果您不想手动操作，请考虑添加 <code>--rm</code> 标志以在容器停止时自动删除它。</p>
</blockquote>
<p>正如您在上面的输出中看到的，Flask 服务器正在其容器内的所有网络接口 ( <code>0.0.0.0</code> ) 上运行，正如您在 Dockerfile 的 <code>CMD</code> 层中指示的那样。</p>
<p>继续并在您的 Web 浏览器中访问地址 <code>http://localhost</code> 或使用 <code>curl</code> 之类的命令行工具来访问 dockerized 页面跟踪器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ curl http://localhost
</span></span><span class="line"><span class="cl">Sorry, something went wrong 😔
</span></span></code></pre></div><p>由于 Redis 连接失败，您将看到预期的错误消息，但至少您可以访问在 Docker 容器中运行的 Flask 应用程序。要修复错误，您需要通过传递给 <code>web-service</code> 容器的环境变量指定正确的 Redis URL。</p>
<p>现在通过按键盘上的 Ctrl+C 或 Cmd+C 停止该容器。然后，找到容器的标识符并删除关联的容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker ps -a
</span></span><span class="line"><span class="cl">CONTAINER ID   IMAGE                     COMMAND                  CREATED
</span></span><span class="line"><span class="cl">dd446a1b72a7   realpython/page-tracker   <span class="s2">&#34;flask --app page_tr…&#34;</span>   <span class="m">1</span> minute ago
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker rm dd446a1b72a7
</span></span></code></pre></div><p><code>-a</code> 标志确保显示所有容器，包括已停止的容器。否则，你不会看到你的。</p>
<p>通过 Docker 将 Flask Web 应用程序连接到 Redis 的正确方法是创建专用虚拟网络。首先，列出可用网络以检查您是否已经创建了 <code>page-tracker-network</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network ls
</span></span><span class="line"><span class="cl">NETWORK ID     NAME                   DRIVER    SCOPE
</span></span><span class="line"><span class="cl">46e9ff2ec568   bridge                 bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">4795b850cb58   host                   host      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">f8f99d305c5e   none                   null      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">84b134794660   page-tracker-network   bridge    <span class="nb">local</span>
</span></span></code></pre></div><p>如果它不存在，那么您现在可以通过发出以下命令来创建一个：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network create page-tracker-network
</span></span></code></pre></div><p>以类似的方式，您可以为 Redis 服务器创建一个卷，以将其数据持久存储在您的主机上。这样，您可以重新启动甚至删除并从头开始创建一个新容器，Redis 将可以访问其之前的状态。这是使用 Docker 创建命名卷的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker volume create redis-volume
</span></span></code></pre></div><p>接下来，停止并移除任何可能挂起的 Redis 容器，然后启动一个新容器。这一次，您将容器连接到 <code>page-tracker-network</code> 并将其 <code>/data</code> 文件夹绑定到您刚刚创建的名为 <code>redis-volume</code> 的卷：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             -v redis-volume:/data <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --network page-tracker-network <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --name redis-service <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             redis:7.0.10-bullseye
</span></span></code></pre></div><p>当您在 GitHub 上查看 Redis 的官方 Docker 镜像时，您会看到一个在 <code>/data</code> 文件夹中定义挂载点的层。 Redis 会不时地将其状态转储到该文件夹中。通过将目录从您的主机挂载到此挂载点，即使容器重新启动，您也可以保持状态。</p>
<p>通过给你的容器一个描述性的名称， <code>redis-service</code> ，你将能够从同一网络上的另一个容器连接到它。就是这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             -p 80:5000 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             -e <span class="nv">REDIS_URL</span><span class="o">=</span>redis://redis-service:6379 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --network page-tracker-network <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --name web-service <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             realpython/page-tracker
</span></span></code></pre></div><p>您启动一个从 <code>page-tracker</code> 镜像派生的新容器，其中包含相当多的参数。以下是上述 <code>docker run</code> 命令中各个标志和选项的快速细分：</p>
<ul>
<li><code>-d</code> ：在后台运行容器，与终端分离。这意味着您将看不到 Flask 服务器的任何输出，并且您将无法再使用 Ctrl+C 或 Cmd+C 停止容器。</li>
<li><code>-p 80:5000</code> ：将容器的端口 <code>5000</code> 暴露在主机的端口 <code>80</code> 上，这样你就可以通过本地主机访问你的web应用程序。</li>
<li><code>-e REDIS_URL=...</code> : 将容器的环境变量设置为在同一网络上的另一个容器中运行的 Redis 服务器的地址。</li>
<li><code>--network page-tracker-network</code> : 指定容器使用的虚拟网络。这将允许同一网络上的其他容器通过抽象名称而不是 IP 地址与该容器通信。</li>
<li><code>--name web-service</code> : 为容器分配一个有意义的名称，这样更容易从 Docker 命令中引用容器。</li>
</ul>
<p>现在，当您在 Web 浏览器或终端中访问 Flask Web 应用程序时，您应该观察到正确的行为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ curl http://localhost
</span></span><span class="line"><span class="cl">This page has been seen <span class="m">1</span> times.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ curl http://localhost
</span></span><span class="line"><span class="cl">This page has been seen <span class="m">2</span> times.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ curl http://localhost
</span></span><span class="line"><span class="cl">This page has been seen <span class="m">3</span> times.
</span></span></code></pre></div><p>每次发送请求时，服务器都会以不同数量的页面浏览量进行响应。请注意，您正在通过本地主机访问服务器。如果您在 <code>web-service</code> 之前启动了 <code>redis-service</code> ，那么容器的 IP 地址可能已更改。</p>
<p>哇！光是启动和运行两项服务就需要做大量工作。如您所见，手动管理 Docker 镜像、容器、卷、网络、端口和环境变量会让人感到不知所措。而这只是表面现象！</p>
<p>想象一下，管理一个包含数十种服务的复杂应用程序需要付出多少努力，其中包括生产就绪监控、负载平衡、自动缩放等。</p>
<p>幸运的是，有更好的方法可以达到同样的效果。在下一节中，您将研究 Docker 之上的一个方便的抽象层，让您在定义持续集成管道之前使用单个命令编排这两种服务。</p>
<h2 id="使用-docker-compose-编排容器">使用 Docker Compose 编排容器</h2>
<p>大多数现实世界的应用程序由多个组件组成，这些组件自然会转化为 Docker 容器。例如，一个涉及更多的 Web 应用程序可能具有以下内容：</p>
<ul>
<li><strong>Back end:</strong> <a href="https://realpython.com/learning-paths/django-web-development/">Django</a>, <a href="https://realpython.com/fastapi-python-web-apis/">FastAPI</a>, <a href="https://realpython.com/learning-paths/flask-by-example/">Flask</a></li>
<li><strong>Front end:</strong> <a href="https://realpython.com/flask-by-example-integrating-flask-and-angularjs/">Angular</a>, <a href="https://realpython.com/the-ultimate-flask-front-end/#react-explained">React</a>, <a href="https://realpython.com/python-django-blog/#step-5-set-up-vuejs">Vue</a></li>
<li><strong>Cache:</strong> Couchbase, <a href="https://realpython.com/python-memcache-efficient-caching/">Memcached</a>, <a href="https://realpython.com/python-redis/">Redis</a></li>
<li><strong>Queue:</strong> ActiveMQ, <a href="https://realpython.com/queue-in-python/#apache-kafka-kafka-python3">Kafka</a>, <a href="https://realpython.com/queue-in-python/#rabbitmq-pika">RabbitMQ</a></li>
<li><strong>Database:</strong> <a href="https://realpython.com/python-mysql/">MySQL</a>, <a href="https://realpython.com/python-sql-libraries/#postgresql">PostgreSQL</a>, <a href="https://realpython.com/python-sqlite-sqlalchemy/">SQLite</a></li>
</ul>
<p>更大的应用程序可能会选择将其后端或前端组件细分为更多的微服务，负责身份验证、用户管理、订单处理、支付或消息传递等。</p>
<p>为了帮助管理并在某种程度上编排此类应用程序的多个 Docker 容器，您可以使用 Docker Compose。它是一种在 Docker 之上运行的工具，可简化运行多容器 Docker 应用程序。 Docker Compose 允许您根据相互依赖的服务及其配置和要求来定义您的应用程序。然后它将协调它们并将它们作为一个连贯的应用程序运行。</p>
<blockquote>
<p>注意：容器编排自动化分布式应用程序的部署、扩展和配置管理。虽然 Docker Compose 可以帮助进行基本形式的编排，但您最好在更复杂的大型系统中使用 Kubernetes 等工具。</p>
</blockquote>
<p>您将使用 Docker Compose 以声明方式描述您的多容器页面跟踪器应用程序，以及它的服务、网络和卷，使用单个配置文件。通过这样做，您将能够跟踪更改并将您的应用程序部署到任何环境。</p>
<p>不过，在深入研究之前，请确保您的计算机上安装了 Docker Compose。</p>
<h3 id="在您的计算机上设置-docker-compose">在您的计算机上设置 Docker Compose</h3>
<p>如果您按照有关设置 Docker Desktop 的说明进行操作，那么您应该已经安装了 Docker Compose。在您的终端中运行以下命令以确认这一点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose version
</span></span><span class="line"><span class="cl">Docker Compose version v2.17.2
</span></span></code></pre></div><p>使用捆绑了 Docker Compose 和一些其他组件的 Docker Desktop，目前是在 macOS 和 Windows 上获取 Docker Compose 的推荐方式。如果您使用的是 Linux，那么您可以尝试通过手动安装 Compose 插件或从您的发行版的软件包存储库安装替代路径。不幸的是，此方法可能不适用于最新和推荐的 Docker Compose 版本。</p>
<blockquote>
<p>注意：在过去，Docker Compose 是一个独立于 Docker 单独维护的项目。它最初是作为 Python 脚本实现的，最终被重写为 Go。</p>
<p>要使用 Docker Compose，您必须在命令行中调用 <code>docker-compose</code> （带连字符）可执行文件。但是，它现在已集成到 Docker 平台中，因此您可以将 Docker Compose 作为 <code>docker compose</code> 插件调用。这两个命令的工作原理应该相同，因为该插件是一种直接替代品。</p>
</blockquote>
<p>一旦您确认 Docker Compose 在您的终端中可用，您就可以开始了！</p>
<h3 id="定义多容器-docker-应用程序">定义多容器 Docker 应用程序</h3>
<p>由于您将定义一个多容器 Docker 应用程序，该应用程序可能会在未来增长以包含更多服务，因此有必要重新安排项目中的文件夹结构。在项目根文件夹中创建一个名为 <code>web/</code> 的新子文件夹，您将在其中存储与 Flask Web 服务相关的所有文件。</p>
<p>您的虚拟环境也属于这个新的子文件夹，因为其他服务可能是用完全外国的编程语言（如 C++ 或 Java）实现的。不幸的是，移动 <code>venv/</code> 文件夹可能会破坏相应激活脚本中硬编码的绝对路径。因此，移除旧的虚拟环境并在 <code>web/</code> 子文件夹中创建一个新的虚拟环境以确保安全：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; deactivate
</span></span><span class="line"><span class="cl">PS&gt; <span class="nb">cd</span> page-tracker<span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>PS&gt; rmdir venv<span class="se">\ </span>/s
</span></span><span class="line"><span class="cl">PS&gt; python -m venv web<span class="se">\v</span>env<span class="se">\ </span>--prompt page-tracker
</span></span><span class="line"><span class="cl">PS&gt; web<span class="se">\v</span>env<span class="se">\S</span>cripts<span class="se">\a</span>ctivate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; python -m pip install --upgrade pip
</span></span></code></pre></div><p>Linux + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ deactivate
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> page-tracker/
</span></span><span class="line"><span class="cl">$ rm -rf venv/
</span></span><span class="line"><span class="cl">$ python3 -m venv web/venv/ --prompt page-tracker
</span></span><span class="line"><span class="cl">$ <span class="nb">source</span> web/venv/bin/activate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --upgrade pip
</span></span></code></pre></div><p>然后，将 Flask 应用程序移动到新的 <code>web/</code> 子文件夹，只留下 <code>.git/</code> 文件夹、 <code>.gitignore</code> 和任何其他与编辑器相关的配置文件。您可以将它们保存在项目根文件夹中，因为它们对项目中所有可能的服务都是通用的。之后，您的项目结构应如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── web/
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── src/
</span></span><span class="line"><span class="cl">│   │   └── page_tracker/
</span></span><span class="line"><span class="cl">│   │       ├── __init__.py
</span></span><span class="line"><span class="cl">│   │       └── app.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── test/
</span></span><span class="line"><span class="cl">│   │   ├── e2e/
</span></span><span class="line"><span class="cl">│   │   │   └── test_app_redis_http.py
</span></span><span class="line"><span class="cl">│   │   │
</span></span><span class="line"><span class="cl">│   │   ├── integration/
</span></span><span class="line"><span class="cl">│   │   │   └── test_app_redis.py
</span></span><span class="line"><span class="cl">│   │   │
</span></span><span class="line"><span class="cl">│   │   ├── unit/
</span></span><span class="line"><span class="cl">│   │   │   └── test_app.py
</span></span><span class="line"><span class="cl">│   │   │
</span></span><span class="line"><span class="cl">│   │   └── conftest.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── venv/
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── constraints.txt
</span></span><span class="line"><span class="cl">│   ├── Dockerfile
</span></span><span class="line"><span class="cl">│   ├── Dockerfile.dev
</span></span><span class="line"><span class="cl">│   └── pyproject.toml
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .git/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .gitignore
</span></span><span class="line"><span class="cl">└── docker-compose.yml
</span></span></code></pre></div><p>上面文件树的一个新添加是位于顶层的 <code>docker-compose.yml</code> 文件，您现在将编写该文件。</p>
<p>Docker Compose 使用 YAML 格式以声明方式描述应用程序的服务，这些服务将成为 Docker 容器、它们的网络、卷、端口映射、环境变量等。</p>
<p>以前，您必须手动定义应用程序架构的每一部分，但使用 Docker Compose，您可以在一个文件中定义所有内容。该工具甚至可以为您拉取或构建镜像！</p>
<blockquote>
<p>注意：如果您以前从未使用过 YAML，但熟悉 JSON，那么它的语法应该很熟悉，因为 YAML 是 JSON 的超集。查看 YAML：Python 中丢失的电池了解更多详细信息。</p>
</blockquote>
<p>Docker Compose 文件是您定义服务、网络和卷的地方。这是完整的 <code>docker-compose.yml</code> 文件，它反映了您在前面部分中为页面跟踪器应用程序手动定义的所有内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># docker-compose.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis:7.0.10-bullseye&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;redis-volume:/data&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">web-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;80:5000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">backend-network</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-volume</span><span class="p">:</span><span class="w">
</span></span></span></code></pre></div><p>你现在要逐行剖析它：</p>
<ul>
<li>第 3 行标志着两个服务 <code>redis-service</code> 和 <code>web-service</code> 声明的开始，它们包含一个多容器 Docker 应用程序。请注意，您可以扩展每个服务，因此 Docker 容器的实际数量可能大于此处声明的服务数量。</li>
<li>第 4 行到第 9 行定义了 <code>redis-service</code> 的配置，包括要运行的 Docker 镜像、要连接的网络以及要挂载的卷。</li>
<li>第 10 到 19 行通过指定包含要构建的 Dockerfile 的文件夹、要公开的端口、要设置的环境变量以及要连接的网络来配置 <code>web-service</code> 。 <code>depends_on</code> 语句要求 <code>redis-service</code> 在 <code>web-service</code> 开始之前可用。</li>
<li>第 21 和 22 行为您的两个服务定义了一个虚拟网络。此声明并非绝对必要，因为 Docker Compose 会自动创建容器并将其连接到新网络。但是，如果需要，显式网络声明可以让您更好地控制其设置和地址范围。</li>
<li>第 24 和 25 行为您的 Redis 服务器定义了一个持久卷。</li>
</ul>
<p>上面配置文件中的一些值被引用，而另一些则没有。这是针对旧 YAML 格式规范中已知怪癖的预防措施，该规范将某些字符视为特殊字符，如果它们出现在未加引号的字符串中。例如，冒号 ( <code>:</code> ) 可以使一些 YAML 解析器将文字解释为六十进制数字而不是字符串。</p>
<blockquote>
<p>注意：此文件符合最新和推荐的 Compose 规范，该规范不再需要顶级 <code>version</code> 字段，而早期的模式版本需要。阅读官方文档中的 Compose 文件版本控制以了解更多信息。</p>
</blockquote>
<p>停止任何可能仍在运行的与您的项目相关的 Docker 容器，并立即删除它们的关联资源：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker stop -t <span class="m">0</span> web-service redis-service
</span></span><span class="line"><span class="cl">$ docker container rm web-service redis-service
</span></span><span class="line"><span class="cl">$ docker network rm page-tracker-network
</span></span><span class="line"><span class="cl">$ docker volume rm redis-volume
</span></span></code></pre></div><p>这将删除您之前创建的两个容器、一个网络和一个卷。请注意，您可以将 <code>docker container rm</code> 命令缩写为更短的 <code>docker rm</code> 别名。</p>
<p>要优雅地删除容器，您应该首先停止它。默认情况下， <code>docker stop</code> 命令将在终止容器之前等待十秒钟，使其有足够的时间在退出之前执行任何必要的清理操作。因为您的 Flask 应用程序在停止运行后不需要做任何事情，您可以使用 <code>-t</code> 选项将此超时设置为零秒，这将立即终止列出的容器。</p>
<p>要删除所有关联的 Docker 镜像标签，您必须首先找到它们的公共标识符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker images
</span></span><span class="line"><span class="cl">REPOSITORY                TAG              IMAGE ID       CREATED      SIZE
</span></span><span class="line"><span class="cl">page-tracker              dde1dc9          9cb2e3233522   <span class="m">1</span> hour ago   204MB
</span></span><span class="line"><span class="cl">page-tracker              latest           9cb2e3233522   <span class="m">1</span> hour ago   204MB
</span></span><span class="line"><span class="cl">realpython/page-tracker   dde1dc9          9cb2e3233522   <span class="m">1</span> hour ago   204MB
</span></span><span class="line"><span class="cl">realpython/page-tracker   latest           9cb2e3233522   <span class="m">1</span> hour ago   204MB
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span></code></pre></div><p>在这种情况下， <code>page-tracker</code> 镜像的所有标签共有的短 ID 等于 <code>9cb2e3233522</code> ，您可以使用它来取消标记和删除底层 Docker 镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker rmi -f 9cb2e3233522
</span></span><span class="line"><span class="cl">Untagged: page-tracker:dde1dc9
</span></span><span class="line"><span class="cl">Untagged: page-tracker:latest
</span></span><span class="line"><span class="cl">Untagged: realpython/page-tracker:dde1dc9
</span></span><span class="line"><span class="cl">Untagged: realpython/page-tracker:latest
</span></span><span class="line"><span class="cl">Deleted: sha256:9cb2e3233522e020c366880867980232d747c4c99a1f60a61b9bece40...
</span></span></code></pre></div><p><code>docker rmi</code> 命令是 <code>docker image rm</code> 和 <code>docker image remove</code> 的别名。</p>
<blockquote>
<p>注意：如果你想从头开始使用全新的 Docker 环境，并且不介意丢失数据，那么你可以使用以下命令修剪所有系统资源：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker system prune --all --volumes
</span></span></code></pre></div><p>警告！这将删除您到目前为止使用 Docker 创建的所有内容，包括可能在本教程之外创建的资源，因此请谨慎操作。</p>
</blockquote>
<p>确认删除 Docker 资源后，您可以通过一条指令立即恢复您的页面跟踪器应用程序。在与 <code>docker-comopse.yml</code> 文件相同的文件夹中发出以下命令以避免指定其路径：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose up -d
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 4/4
</span></span><span class="line"><span class="cl"> ⠿ Network page-tracker_backend-network    Created                      0.1s
</span></span><span class="line"><span class="cl"> ⠿ Volume <span class="s2">&#34;page-tracker_redis-volume&#34;</span>      Created                      0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Started                      1.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Started                      1.3s
</span></span></code></pre></div><p>第一次运行此命令时，可能需要更长的时间，因为 Docker Compose 必须从 Docker Hub 下载 Redis 镜像并再次从 Dockerfile 构建另一个镜像。但在那之后，它应该感觉几乎是瞬间的。</p>
<p>您可以在上面的输出中看到 Docker Compose 创建了请求的网络、卷和两个容器。请注意，它始终在此类资源名称前加上您的 Docker Compose 项目名称前缀，该名称默认为包含您的 <code>docker-compose.yml</code> 文件的文件夹名称。在这种情况下，项目名称是 <code>page-tracker</code> 。此功能有助于防止不同 Docker Compose 项目的资源名称发生冲突。</p>
<p>此外，如果您想启动同一服务的多个副本，Docker Compose 会将连续的数字附加到您的容器名称中。</p>
<p>Docker Compose 插件提供了几个有用的命令来管理您的多容器应用程序。这里只是其中的几个：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose ps
</span></span><span class="line"><span class="cl">NAME                           COMMAND                  SERVICE        ...
</span></span><span class="line"><span class="cl">page-tracker-redis-service-1   <span class="s2">&#34;docker-entrypoint.s…&#34;</span>   redis-service  ...
</span></span><span class="line"><span class="cl">page-tracker-web-service-1     <span class="s2">&#34;flask --app page_tr…&#34;</span>   web-service    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose logs --follow
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span><span class="line"><span class="cl">page-tracker-web-service-1    <span class="p">|</span>  * Running on all addresses <span class="o">(</span>0.0.0.0<span class="o">)</span>
</span></span><span class="line"><span class="cl">page-tracker-web-service-1    <span class="p">|</span>  * Running on http://127.0.0.1:5000
</span></span><span class="line"><span class="cl">page-tracker-web-service-1    <span class="p">|</span>  * Running on http://172.20.0.3:5000
</span></span><span class="line"><span class="cl">page-tracker-web-service-1    <span class="p">|</span> Press CTRL+C to quit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose stop
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/2
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Stopped                     10.3s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Stopped                      0.4s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose restart
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/2
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Started                      0.4s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Started                      0.5s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose down --volumes
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 4/4
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Removed                      6.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Removed                      0.4s
</span></span><span class="line"><span class="cl"> ⠿ Volume page-tracker_redis-volume        Removed                      0.0s
</span></span><span class="line"><span class="cl"> ⠿ Network page-tracker_backend-network    Removed                      0.1s
</span></span></code></pre></div><p>例如，您可以列出 Docker Compose 项目中的容器而不显示任何其他容器。使用相关命令，您可以查看它们的实时输出、停止、启动和重新启动它们。</p>
<p>完成项目后，您可以将其拆除，Docker Compose 将删除关联的容器和网络。但是，它不会触及持久数据存储，除非您使用 <code>--volumes</code> 标志明确请求。</p>
<p>您可能已经在日志中注意到一件事，Flask 已经抱怨了很长时间，那就是使用其不安全、低效且不稳定的开发 Web 服务器来运行您的应用程序。您现在将使用 Docker Compose 来解决这个问题。</p>
<h3 id="将-flask-的开发-web-服务器替换为-gunicorn">将 Flask 的开发 Web 服务器替换为 Gunicorn</h3>
<p>Docker 允许您在运行新容器时覆盖 Dockerfile 中列出的默认命令或入口点。例如， <code>redis</code> 镜像中的默认命令启动 Redis 服务器。但是，您之前使用相同的镜像在另一个容器中启动 <code>redis-cli</code> 。同样，您可以在 <code>docker-compose.yml</code> 文件中为您的 Docker 镜像指定自定义命令。您将使用此功能通过生产级 Web 服务器运行 Flask。</p>
<blockquote>
<p>注意：有时，您想要调查现有容器。要在正在运行的容器中运行命令而不是启动新容器，可以使用 <code>docker exec</code> 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker <span class="nb">exec</span> -it -u root page-tracker-web-service-1 /bin/bash
</span></span><span class="line"><span class="cl">root@6e23f154a5b9:/home/realpython#
</span></span></code></pre></div><p>通过运行 Bash 可执行文件 <code>/bin/bash</code> 并使用 <code>-u</code> 选项指定用户，您可以有效地访问容器，就像通过 SSH 登录远程服务器一样。 <code>-it</code> 标志是运行交互式终端会话所必需的。否则，该命令将立即退出。</p>
</blockquote>
<p>有几个选项可以替换 Flask 的内置开发 Web 服务器，官方文档在部署到生产时推荐使用这些选项。最受欢迎的选择之一是 Gunicorn (Green Unicorn)，它是 Web 服务器网关接口 (WSGI) 协议的纯 Python 实现。要开始使用它，您必须将 <code>gunicorn</code> 包添加为项目中的另一个依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># web/pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;gunicorn&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;bandit&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;black&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;flake8&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;isort&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pylint&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest-timeout&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;requests&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>请注意，您将 <code>gunicorn</code> 添加到常规依赖项列表中，因为它将成为您应用程序不可或缺的一部分。您希望在构建最终 Docker 镜像后它可用。</p>
<p>像往常一样，在本地重新安装您的 <code>page-tracker</code> 包并将其依赖项固定在约束文件中。请记住，您可能需要先激活您的虚拟环境，因为您之前在 <code>web/</code> 子文件夹中重新创建了它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;web/[dev]&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip freeze --exclude-editable &gt; web/constraints.txt
</span></span></code></pre></div><p>请注意，当您从项目的根文件夹中执行这些命令时，它们看起来会略有不同。在这种情况下，您必须将指示当前工作目录的点 ( <code>.</code> ) 替换为您的 <code>web/</code> 子文件夹的路径。</p>
<p>现在您已经安装了 Gunicorn，您可以开始使用它了。通过在 <code>web-service</code> 键下添加新的 <code>command</code> 属性来修改 <code>docker-compose.yml</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># docker-compose.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis:7.0.10-bullseye&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;redis-volume:/data&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">web-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;80:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;gunicorn page_tracker.app:app --bind 0.0.0.0:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">backend-network</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-volume</span><span class="p">:</span><span class="w">
</span></span></span></code></pre></div><p>此命令将优先于 Dockerfile 的默认命令，后者依赖于 Flask 的开发服务器。从现在开始，Docker Compose 将改为使用 Gunicorn 运行您的 Web 应用程序。为了显示差异，您将在端口 <code>8000</code> 而不是 <code>5000</code> 上运行服务器，因此您还更改了端口映射。</p>
<p>通过在主机上公开端口 <code>80</code> ，您仍然可以在不指定端口号的情况下访问 <code>http://localhost</code> 上的应用程序。</p>
<p>不要忘记提交更改以将您的工作保存在本地 Git 存储库中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git add .
</span></span><span class="line"><span class="cl">$ git commit -m <span class="s2">&#34;Refactor folders and add Docker Compose&#34;</span>
</span></span></code></pre></div><p>进行小而频繁的提交总是一个好主意，这样您就可以随着时间的推移跟踪增量更改并更好地了解您的工作历史。如果您不确定如何描述您的提交，请尝试解释为什么您进行了特定更改，因为 Git 已经跟踪更改的内容。</p>
<p>好的。如果您现在尝试重新启动 Docker Compose 应用程序，那么它将失败，因为 Docker 在容器启动期间找不到请求的 <code>gunicorn</code> 可执行文件。您已经添加了您之前构建的 Docker 镜像中缺少的额外依赖项。因此，你必须告诉 Docker Compose 重建你的镜像。您可以使用以下任一命令执行此操作：</p>
<ul>
<li>docker compose build</li>
<li>docker compose up &ndash;build</li>
</ul>
<p>在第一种情况下，您会明确告诉 Docker 预先构建镜像。每当您更改项目依赖项或 Dockerfile 时，您都必须再次运行 <code>docker compose build</code> 以应用这些更改。</p>
<p>在第二种情况下， <code>docker compose up --build</code> 将指示 Docker 在每次启动容器时即时构建镜像。如果您试图快速迭代对源代码或 Dockerfile 的更改，这将特别有用。</p>
<p>无论哪种方式，这两个命令都应该在启动相应容器之前在任何受影响的 Docker 镜像中成功构建修改后的层。然后，您可以放心，当您的 Docker Compose 应用程序再次启动时，所有依赖项都将可用。</p>
<p>继续并立即运行这些命令之一。</p>
<p>因为您了解如何使用 Docker Compose 来管理应用程序的服务，所以您现在可以了解如何在接近生产的环境中运行端到端测试。</p>
<h3 id="针对服务运行端到端测试">针对服务运行端到端测试</h3>
<p>在第一次尝试中，您将从主机本地执行端到端测试。请注意，必须可以从您的本地网络访问所有必要的服务才能使其正常工作。</p>
<p>虽然这并不理想，因为您不想向公众公开任何敏感服务（如数据库），但稍后您将了解更好的方法。同时，您可以更新您的 <code>docker-compose.yml</code> 配置以转发 Redis 端口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># docker-compose.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis:7.0.10-bullseye&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;6379:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;redis-volume:/data&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">web-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;80:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;gunicorn page_tracker.app:app --bind 0.0.0.0:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">backend-network</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-volume</span><span class="p">:</span><span class="w">
</span></span></span></code></pre></div><p>如果您有一个用于 <code>redis-service</code> 的现有 Docker 容器，那么您需要先删除该容器，即使它当前已停止，以反映新的端口转发规则。幸运的是，Docker Compose 会自动检测 <code>docker-compose.yml</code> 文件中的更改，并在您发出 <code>docker compose up</code> 命令时根据需要重新创建容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose up -d
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/2
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Started                      1.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Started                      1.2s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose ps
</span></span><span class="line"><span class="cl">NAME                           ...   PORTS
</span></span><span class="line"><span class="cl">page-tracker-redis-service-1   ...   0.0.0.0:6379-&gt;6379/tcp
</span></span><span class="line"><span class="cl">page-tracker-web-service-1     ...   0.0.0.0:80-&gt;8000/tcp
</span></span></code></pre></div><p>列出新容器后，您应该会看到 Redis 容器上的端口 <code>6379</code> 被转发到主机。有了这个，您现在可以使用安装在开发机器上的虚拟环境中的 <code>pytest</code> 运行端到端测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest web/test/e2e/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --flask-url http://localhost <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --redis-url redis://localhost:6379
</span></span></code></pre></div><p>由于端口映射，您可以使用 localhost 连接到容器，而无需知道它们各自的 IP 地址。</p>
<blockquote>
<p>注意：如果您的测试成功，那么它将覆盖 Redis 中的页面浏览量。根据经验，您永远不应该在带有客户数据的实时环境中运行测试，以避免破坏它。通常建议使用带有虚假或匿名数据的暂存或认证环境来安全地执行全面的端到端测试。</p>
</blockquote>
<p>要模拟故障，您可以在测试执行期间暂时暂停容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose pause
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/0
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Paused                       0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Paused                       0.0s
</span></span></code></pre></div><p>这将使 Redis 和您的 Flask 应用程序无法再访问。与停止容器不同，暂停它不会终止底层进程，因此暂停会保持容器的状态并导致更快的恢复。</p>
<p>之后不要忘记取消暂停容器以避免以后出现错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose unpause
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/0
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Unpaused                     0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Unpaused                     0.0s
</span></span></code></pre></div><p>或者，您可以从同一网络上的另一个容器运行它，而不是在本地针对公开服务运行端到端测试。您可以手动制作这样的容器。</p>
<p>然而，最近版本的 Docker Compose 提供了一个更优雅的解决方案，它允许您有条件地运行服务的子集。为此，您可以将所需的服务分配给可按需激活的自定义配置文件。</p>
<p>首先，打开你的 <code>docker-compose.yml</code> 文件并从 Redis 中删除端口转发，因为你不想再将它暴露给外界。然后，基于您的旧 <code>Dockerfile.dev</code> 添加一个新服务，它捆绑了测试框架、测试装置和您的测试代码。您将使用相应的 Docker 镜像来执行端到端测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="w"> </span><span class="c"># docker-compose.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis:7.0.10-bullseye&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;redis-volume:/data&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">web-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;80:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;gunicorn page_tracker.app:app --bind 0.0.0.0:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">test-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">profiles</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">testing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">context</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">dockerfile</span><span class="p">:</span><span class="w"> </span><span class="l">Dockerfile.dev</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">FLASK_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;http://web-service:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">web-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="p">&gt;</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">      sh -c &#39;python -m pytest test/e2e/ -vv
</span></span></span><span class="line"><span class="cl"><span class="sd">      --redis-url $$REDIS_URL
</span></span></span><span class="line"><span class="cl"><span class="sd">      --flask-url $$FLASK_URL&#39;</span><span class="w">      
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">backend-network</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-volume</span><span class="p">:</span><span class="w">
</span></span></span></code></pre></div><p><code>docker-compose.yml</code> 文件的大部分内容保持不变，因此您可以将注意力集中在突出显示的行上：</p>
<ul>
<li>
<p>第 22 行定义了您的新服务将属于的配置文件列表。只有一个配置文件，称为 <code>testing</code> ，您将启用它来运行测试。</p>
</li>
<li>
<p>第 24 到 26 行指定包含要构建的 Dockerfile 的目录的路径。由于该文件有一个非标准名称，您需要明确提供它。</p>
</li>
<li>
<p>第 27 到 29 行定义了两个环境变量，您的测试将使用它们连接到在 Gunicorn 服务器后面运行的 Redis 和 Flask。请注意，您使用 Docker Compose 服务名称作为主机名。</p>
</li>
<li>
<p>第 30 和 31 行将服务连接到与其他两个服务相同的网络。</p>
</li>
<li>
<p>第 32 到 34 行确保 Redis 和 Flask 在端到端测试之前启动。</p>
</li>
<li>
<p>第 35 到 38 行定义了在服务启动时运行的命令。请注意，您使用 YAML 的多行文字折叠 ( <code>&gt;</code> ) 以更具可读性的方式格式化长 shell 命令。</p>
</li>
</ul>
<p>因为 Docker Compose 可以访问您主机的 shell，所以它会尝试插入对环境变量的任何引用，例如 <code>$REDIS_URL</code> 或 <code>$FLASK_URL</code> ，一旦文件被解析，就会出现在您的 <code>docker-compose.yml</code> 中。不幸的是，这些变量很可能尚未定义。您通过服务的 <code>environment</code> 部分指定它们，这意味着您的容器稍后将获取这些变量。</p>
<p>要禁用 Docker Compose 过早替换环境变量，您可以使用两个美元符号 ( <code>$$</code> ) 转义美元符号。这反过来会在将在生成的容器中执行的命令中生成文字字符串 <code>$REDIS_URL</code> 和 <code>$FLASK_URL</code> 。要在容器启动时插入这些变量，您必须将整个命令用单引号 ( <code>'</code> ) 括起来，并将其传递给 shell ( <code>sh</code> )。</p>
<p>当您使用 Docker Compose 启动多容器应用程序时，只有不属于任何配置文件的核心服务会启动。如果您还希望启动分配给一个或多个配置文件的服务，则必须使用 <code>--profile</code> 选项列出这些配置文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose --profile testing up -d
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 3/3
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Running                      0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Running                      0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-test-service-1   Started                      0.6s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose ps -a
</span></span><span class="line"><span class="cl">NAME                           ...   SERVICE             STATUS       ...
</span></span><span class="line"><span class="cl">page-tracker-redis-service-1   ...   redis-service       running      ...
</span></span><span class="line"><span class="cl">page-tracker-test-service-1    ...   test-service        exited <span class="o">(</span>0<span class="o">)</span>   ...
</span></span><span class="line"><span class="cl">page-tracker-web-service-1     ...   web-service         running      ...
</span></span></code></pre></div><p>请注意，这是 <code>docker compose</code> 命令的一个选项，而不是它的 <code>up</code> 子命令，因此请注意参数顺序。输出显示启动了一个额外的服务，但是当您调查它时，您会注意到 <code>test-service</code> 以成功状态零快速退出。</p>
<p>要显示有关此服务的更多信息，您可以查看其日志：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose logs test-service
</span></span><span class="line"><span class="cl"><span class="o">=============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">==========================</span>
</span></span><span class="line"><span class="cl">platform linux -- Python 3.11.2, pytest-7.2.2, pluggy-1.0.0 -- /home/realp..
</span></span><span class="line"><span class="cl">cachedir: .pytest_cache
</span></span><span class="line"><span class="cl">rootdir: /home/realpython
</span></span><span class="line"><span class="cl">plugins: timeout-2.1.0
</span></span><span class="line"><span class="cl">collecting ... collected <span class="m">1</span> item
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">test/e2e/test_app_redis_http.py::test_should_update_redis ... PASSED <span class="o">[</span>100%<span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">==============================</span> <span class="m">1</span> passed in 0.10s <span class="o">===========================</span>
</span></span></code></pre></div><p>这将向您显示有关该服务的详细信息，包括 <code>pytest</code> 报告形式的测试结果，以及可能发生的任何错误。在这种情况下，测试成功通过。请注意，为简洁起见，对上面的输出进行了编辑。</p>
<p>到目前为止，您已经使用 Git 对源代码进行了版本控制。您自动化了各种级别的测试并使用 Docker 构建了您的应用程序。最后，您使用 Docker Compose 编排了多个容器。</p>
<p>此时，您已准备好继续下一步，即使用 Docker 构建持续集成管道。</p>
<h2 id="定义一个基于-docker-的持续集成管道">定义一个基于 Docker 的持续集成管道</h2>
<p>持续集成 (CI) 的目标是通过尽可能频繁地集成团队中多个开发人员的代码更改来实现更快、更可预测的软件发布。</p>
<p>在过去，集成是一项重大任务，通常需要数周甚至数月才能完成，有时还需要专门的集成工程师团队。</p>
<p>这种方法的问题是团队中的每个人都在自己的项目副本上工作。集成阶段延迟的时间越长，项目的不同版本就越有可能出现分歧，从而难以将它们结合起来。</p>
<p>在某些情况下，集成可能比项目的实际开发花费更多的时间！</p>
<p>连续这个词意味着集成应该经常进行，以最小化更改的范围并降低将缺陷引入代码库的风险。团队每天至少整合一次开发人员的工作，最好是一天多次，这已成为标准做法。</p>
<p>为了使这成为可能，持续集成需要构建和测试自动化以及具有相对较小功能的短期代码分支来实现。功能切换可以帮助实现需要更长时间开发的更大功能。此外，在尝试集成更改失败后修复失败的构建应该是团队的优先事项，以保持流程真正连续。</p>
<p>要在您的项目中引入持续集成，您需要以下元素：</p>
<ul>
<li>版本控制系统</li>
<li>分支策略</li>
<li>自动构建</li>
<li>自动化测试</li>
<li>持续集成服务器</li>
<li>频繁集成</li>
</ul>
<p>像 Git 这样的版本控制系统允许多人同时处理同一段代码。根据您的团队结构、经验和其他因素，您可以选择不同的源代码控制分支模型，也称为工作流。一些最受欢迎的包括：</p>
<ul>
<li><a href="https://trunkbaseddevelopment.com/">Trunk-Based Development</a></li>
<li><a href="https://docs.github.com/en/get-started/quickstart/github-flow">GitHub Flow</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow">Forking Workflow</a></li>
<li><a href="https://martinfowler.com/articles/branching-patterns.html#release-branch">Release Branching</a></li>
<li><a href="https://nvie.com/posts/a-successful-git-branching-model/">Git Flow</a></li>
</ul>
<p>各有利弊，适用于不同的场景。例如，分叉策略在开源项目中运作良好，因为它允许任何人在没有特别许可的情况下做出贡献。在本教程中，您将使用称为 GitHub Flow 的流行功能分支工作流程。它只有一个长期存在的主线或主干，传统上称为 master 分支，您可以从中分支出几个短期存在的功能分支。</p>
<blockquote>
<p>注意：尽管使用术语 <code>master</code> 来指代主分支的传统由来已久，但 GitHub 最近宣布将其默认分支名称更改为 <code>main</code> 以更好地反映其目的并避免冒犯性语言。</p>
<p>同时，当您初始化一个新的存储库时，Git 会继续使用 <code>master</code> ，这在您尝试同步本地和远程存储库时偶尔会出现问题。因此，您将坚持在本教程中使用 <code>master</code> 来保持简单，但如果您想更改默认分支名称，请随时采取额外的步骤。您可以在 GitHub 存储库设置中调整默认分支名称。</p>
</blockquote>
<p>虽然您会发现几种不同的方法来实现与 GitHub Flow 的持续集成，但这些是您将针对 Docker 应用程序遵循的步骤：</p>
<ul>
<li>将最新版本的主线获取到您的计算机。</li>
<li>从主线创建一个功能分支。</li>
<li>打开拉取请求以从其他人那里获得早期反馈。</li>
<li>继续在你的功能分支上工作。</li>
<li>经常获取主线，将其合并到您的功能分支并在本地解决任何潜在的冲突。</li>
<li>在本地分支上构建、lint 和测试代码。</li>
<li>只要本地构建和测试成功，就推送您的更改。</li>
<li>每次推送时，检查针对您的功能分支在 CI 服务器上运行的自动化测试。</li>
<li>在再次推送代码之前，在本地重现并修复任何已识别的问题。</li>
<li>完成并通过所有测试后，请求一名或多名同事审查您的更改。</li>
<li>应用他们的反馈，直到审阅者批准您的更新并且所有测试在推送您的最新更改后通过 CI 服务器。</li>
<li>通过将功能分支合并到主线来关闭拉取请求。</li>
<li>对照主线检查 CI 服务器上运行的自动化测试，并集成功能分支的更改。</li>
<li>调查并修复可能发现的任何问题，例如，由于在您上次推送和合并之间其他人向主线引入了新更新。</li>
</ul>
<p>此列表非常全面，但没有适合所有人的单一持续集成流程。您甚至可以比这更彻底，例如，使用 Terraform 或 GitHub Codespaces 提供专用的暂存环境，并将您的功能分支部署到云中，以便在关闭拉取请求之前进行额外的手动测试。但是，为每个拉取请求启动一个新环境可能不符合成本效益。</p>
<blockquote>
<p>注意：软件工程团队通常将持续集成与持续交付结合起来，形成一个称为 CI/CD 的流程。持续交付是持续集成的扩展，它增加了额外的步骤来将经过验证和集成的构建部署到生产环境。</p>
<p>虽然持续交付提供了将构建自动部署到生产环境的技术手段，但它仍然需要业务决策和手动触发。</p>
<p>不要混淆持续交付和持续部署，后者是一个完全自动化的过程，无需人工干预即可将应用程序部署到生产环境。在持续部署中，一旦你推送代码，它就会被测试并集成到主线中，然后最终进入生产环境。</p>
<p>但是，要成功做到这一点，您需要广泛的测试范围和对自动化过程的信任。</p>
</blockquote>
<p>值得强调的重要一点是涉及的测试量。您应该在本地和持续集成服务器上测试您的功能分支，然后针对集成主线再次运行测试。</p>
<p>这是为了确保您的功能正常工作并且不会破坏主线。</p>
<p>您有许多选项可以为您的 Docker 应用程序设置持续集成服务器，包括在线和自托管。流行的选择包括 CircleCI、Jenkins 和 Travis。在本教程中，您将使用 GitHub Actions，这是 GitHub 提供的免费 CI 解决方案。</p>
<h3 id="将代码推送到-github-存储库">将代码推送到 GitHub 存储库</h3>
<p>要利用 GitHub Actions，您必须首先在 GitHub 上创建一个存储库。如果您还没有帐户，请注册，然后登录并创建一个名为 <code>page-tracker</code> 的新存储库。</p>
<p>公共存储库可以无限制地使用 GitHub Actions，而私有存储库每月可在免费层获得 2000 分钟和 500 兆字节的存储空间。</p>
<p>但是，在 Windows 上运行的作业将消耗比在 Linux 上多一倍的分钟数，而在 macOS 上运行的作业将消耗十倍的分钟数！您可以在官方文档中找到有关 GitHub Actions 计费的更多详细信息。</p>
<p>稍后，您将启用分支保护规则，该规则目前仅适用于免费层的公共存储库，因此最好现在就创建一个公共存储库。</p>
<p>保留建议的默认值而不使用 GitHub 的占位符文件初始化新存储库，因为您将推送现有项目。接下来，转到终端并将工作目录更改为您的 <code>page-tracker</code> 项目所在的位置。它应该已经初始化了一个本地 Git 存储库，稍后您将连接到 GitHub。但首先，将所有未决更改提交到本地存储库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">Changes not staged <span class="k">for</span> commit:
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span class="o">)</span>
</span></span><span class="line"><span class="cl">        modified:   docker-compose.yml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">no changes added to commit <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> and/or <span class="s2">&#34;git commit -a&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git commit -am <span class="s2">&#34;Add a test-service to Docker Compose&#34;</span>
</span></span></code></pre></div><p>在提交任何更改之前检查存储库的状态始终是个好主意。您现在可以使用以下两个命令将本地存储库连接到 GitHub：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git remote add origin git@github.com:realpython/page-tracker.git
</span></span><span class="line"><span class="cl">$ git push -u origin master
</span></span></code></pre></div><p>确保将 <code>realpython</code> 替换为您的 GitHub 用户名。第一个命令会将您刚刚创建的 GitHub 上的远程存储库添加到您在 <code>origin</code> 别名下的本地副本。第二个命令会将本地存储库的内容推送到 GitHub。</p>
<p>之后您可以使用您的 GitHub 存储库刷新网页以确认您的文件已成功发送。当您这样做时，您将准备好使用 GitHub Actions 为您的 Docker 应用程序构建持续集成工作流程！</p>
<h3 id="学习-github-actions">学习 GitHub Actions</h3>
<p>首先，熟悉一些新术语会有所帮助。 GitHub Actions 允许您指定一个或多个由特定事件触发的工作流程，例如将代码推送到分支或打开新的拉取请求。每个工作流都可以定义许多由步骤组成的作业，这些作业将在运行器上执行。有两种类型的跑步者：</p>
<ul>
<li>GitHub 托管的运行器：Ubuntu Linux、Windows、macOS</li>
<li>自托管运行器：您拥有和维护的本地服务器</li>
</ul>
<p>在本教程中，您将只使用 GitHub 提供的最新 Ubuntu Linux 运行器。请注意，可以在多个运行器上执行相同的作业，例如检查跨平台兼容性。</p>
<p>除非您另有说明，否则一个工作流程中的作业将在不同的运行器上并行运行，这对于加快构建速度很有用。同时，您可以使一项工作依赖于其他工作。</p>
<p>使用 GitHub Actions 减少构建时间的另一种方法是启用工作流依赖缓存。</p>
<p>作业的每个步骤都由一个动作实现，该动作可以是：</p>
<ul>
<li>自定义 shell 命令或脚本</li>
<li>在另一个 GitHub 存储库中定义的 GitHub 操作</li>
</ul>
<p>有许多预定义的 GitHub 操作，您可以在 GitHub Marketplace 上浏览和查找。社区提供并维护它们。例如，有一个用于在 GitHub 上构建和推送 Docker 组织拥有的 Docker 镜像。由于有许多相互竞争的插件，有时有不止一种方法可以使用 GitHub Actions 达到预期的结果。</p>
<p>与如今与 DevOps 相关的许多工具一样，GitHub 使用 YAML 格式来配置工作流。它会在您的存储库的根文件夹中寻找一个特殊的 <code>.github/workflows/</code> 文件夹，您可以在其中放置多个 YAML 文件，每个文件对应一个不同的工作流程。此外，您可以在其中包含其他文件，例如要在运行器上执行的配置文件或自定义脚本。</p>
<p>您只会为持续集成定义一个工作流程，因此请继续创建必要的文件夹结构，其中包含一个名为 <code>ci.yml</code> 的文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── web/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .git/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .github/
</span></span><span class="line"><span class="cl">│   └── workflows/
</span></span><span class="line"><span class="cl">│       └── ci.yml
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .gitignore
</span></span><span class="line"><span class="cl">└── docker-compose.yml
</span></span></code></pre></div><p>尽管您可以使用任何您喜欢的代码编辑器为 GitHub Actions 编写工作流文件，但在这种情况下请考虑使用 GitHub 的基于 Web 的编辑器。它不仅提供通用的 YAML 语法突出显示，还提供架构验证和对可用 GitHub Actions 属性的智能建议。因此，您可以先将代码推送到 GitHub，然后使用内置编辑器直接在那里编辑您的 <code>ci.yml</code> 文件。</p>
<p>要打开 GitHub 内置的编辑器，请将 Web 浏览器导航到 <code>ci.yml</code> 文件，然后按 E 或单击铅笔图标。您现在可以开始编写 GitHub Actions 工作流文件。</p>
<h3 id="使用-github-actions-创建工作流">使用 GitHub Actions 创建工作流</h3>
<p>在编辑 <code>ci.yml</code> 文件时，为新工作流指定一个描述性名称并定义应触发它的事件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># .github/workflows/ci.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Continuous Integration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span></code></pre></div><p>将触发此工作流的两个事件是：</p>
<ol>
<li>打开或更改针对 <code>master</code> 分支的拉取请求</li>
<li>推送代码或将分支合并到 <code>master</code> 分支</li>
</ol>
<p>除了分支名称之外，您还可以为每个事件添加更多属性以缩小触发条件。例如，您可以提供充当正过滤器的文件路径模式，该模式仅在某些文件发生更改时才运行工作流。</p>
<p>毕竟，您可能不想在编辑 README 文件或更新文档后运行整个持续集成工作流程。不管怎样，你现在会让事情保持简单。</p>
<p>您的持续集成工作流程的工作是构建 Docker 镜像，使用 Docker Compose 运行端到端测试，如果一切顺利，将构建的镜像推送到 Docker Hub。</p>
<p>感谢您全面的 Dockerfile，将单元测试、各种静态代码分析工具和安全扫描集成到一个命令中。因此，您无需为 CI 工作流程编写大量 YAML。</p>
<p>GitHub Action 工作流中的几乎每项工作都是从从 GitHub 存储库中检出代码开始的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># .github/workflows/ci.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Continuous Integration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">build</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build Docker image and run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Checkout code from GitHub</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v3</span><span class="w">
</span></span></span></code></pre></div><p>您指定一个标识为 <code>build</code> 的作业，它将在 GitHub 提供的最新 Ubuntu 运行器上运行。它的第一步是使用 <code>actions/checkout</code> GitHub 操作检查触发工作流的单个提交。因为 GitHub Actions 实际上是伪装的 GitHub 存储库，所以您可以在 at 符号 ( <code>@</code> ) 后提供 Git 标记或提交哈希以选择特定版本的操作。</p>
<p>作为持续集成管道的下一步，您希望在通过 Docker Compose 执行端到端测试之前为您的 Web 和测试服务构建 Docker 镜像。这次您将在运行器上运行一个 shell 命令，而不是使用现有的操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># .github/workflows/ci.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Continuous Integration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">build</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build Docker image and run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Checkout code from GitHub</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="p">&gt;</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">          docker compose --profile testing up
</span></span></span><span class="line"><span class="cl"><span class="sd">          --build
</span></span></span><span class="line"><span class="cl"><span class="sd">          --exit-code-from test-service</span><span class="w">          
</span></span></span></code></pre></div><p>这两个步骤将始终运行以响应文件顶部列出的事件，即打开拉取请求或将功能分支合并到主线中。</p>
<p>此外，在成功将分支合并到主线后，当所有测试都通过时，您需要将新的 Docker 镜像推送到 Docker Hub。因此，只有当 <code>push</code> 事件触发您的工作流程时，您才会有条件地运行后续步骤。</p>
<p>但是，如何使用 GitHub Actions 安全访问 Docker Hub 而不会泄露您的秘密？你现在就会知道了。</p>
<h3 id="通过-github-actions-secrets-访问-docker-hub">通过 GitHub Actions Secrets 访问 Docker Hub</h3>
<p>早些时候，当您将其中一个 Docker 镜像从终端推送到 Docker Registry 时，您必须通过调用 <code>docker login</code> 并提供您的用户名和密码来登录 Docker Hub。此外，如果启用双因素身份验证，则必须生成具有足够权限的个人访问令牌并提供它而不是密码。</p>
<p>从自动化工作流程推送镜像的步骤相似，因此您必须先进行身份验证。您可以使用 shell 命令或预定义的 GitHub 操作来执行此操作，例如 <code>docker/login-action</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># .github/workflows/ci.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Continuous Integration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">build</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build Docker image and run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Checkout code from GitHub</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="p">&gt;</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">          docker compose --profile testing up
</span></span></span><span class="line"><span class="cl"><span class="sd">          --build
</span></span></span><span class="line"><span class="cl"><span class="sd">          --exit-code-from test-service</span><span class="w">          
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Login to Docker Hub</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">docker/login-action@v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">if</span><span class="p">:</span><span class="w"> </span><span class="l">${{ github.event_name == &#39;push&#39; }}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">username</span><span class="p">:</span><span class="w"> </span><span class="l">${{ secrets.DOCKERHUB_USERNAME }}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">password</span><span class="p">:</span><span class="w"> </span><span class="l">${{ secrets.DOCKERHUB_TOKEN }}</span><span class="w">
</span></span></span></code></pre></div><p>您有条件地运行此步骤，方法是使用包含在美元符号和双大括号中的 JavaScript 表达式从 <code>github</code> 上下文获取事件类型。然后，您通过另一个预定义的 <code>secrets</code> 上下文和您现在将要定义的两个自定义常量提供您的秘密 Docker Hub 凭据。</p>
<p>通过单击顶部工具栏中带有齿轮图标的选项卡打开 GitHub 存储库的设置，找到并展开安全部分下的秘密和变量，然后单击操作。这将带您进入一个面板，您可以在该面板中为 GitHub Actions 运行器定义环境变量和加密机密。现在，指定您的 <code>DOCKERHUB_USERNAME</code> 和 <code>DOCKERHUB_TOKEN</code> 机密：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/secrets.b7e62f0e5830.png" alt="GitHub Actions Repository Secrets"  />
</p>
<p>请注意，这些秘密是加密的，GitHub 不会再次向您显示它们，因此请确保将它们保存在安全的地方。但是，如果您足够努力，那么您将能够恢复它们——例如，通过您工作流程中的 shell 命令。</p>
<p>当您将功能分支合并到主线时，此操作也会有条件地运行。在 <code>with</code> 部分，您指定 Dockerfile 的路径，请求推送镜像的操作，并列出镜像的标签。请注意，您再次使用 <code>github</code> 上下文来获取当前提交的哈希值，尽管是长格式。</p>
<blockquote>
<p>注意：GitHub Packages 是集成到 GitHub 中的另一项服务。它可以作为 Docker Hub 的替代品。它支持各种包类型，包括 Docker 镜像，让您可以将源代码和二进制包存储在一个地方。 <code>docker/build-push-action</code> 可以利用您的 GitHub 令牌推送到 GitHub Packages。</p>
</blockquote>
<p>此时，您的持续集成工作流已配置完毕并准备就绪。如果您还没有使用 GitHub 内置的代码编辑器，那么请记住提交并推送您的本地存储库以使更改生效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">Untracked files:
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git add &lt;file&gt;...&#34;</span> to include in what will be committed<span class="o">)</span>
</span></span><span class="line"><span class="cl">        .github/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">nothing added to commit but untracked files present <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> to track<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git add .github/
</span></span><span class="line"><span class="cl">$ git commit -m <span class="s2">&#34;Add a continuous integration workflow&#34;</span>
</span></span><span class="line"><span class="cl">$ git push
</span></span></code></pre></div><p>在下一节中，您将启用一些分支保护规则以防止任何人将他们的代码直接推送到 <code>master</code> 分支。因此，工作流中的 <code>push</code> 事件将仅适用于通过拉取请求将功能分支合并到主线中。</p>
<h3 id="启用分支保护规则">启用分支保护规则</h3>
<p>再次转到存储库的设置，单击代码和自动化部分下的分支，然后单击标记为添加分支保护规则的按钮。然后，在 Branch name pattern 字段中输入您的主线名称。如果您遵循本教程中使用的命名约定，则应在输入字段中键入 <code>master</code> ：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/rule_master.8167b2b061aa.png" alt="GitHub Repository&amp;rsquo;s Protected Branch"  />
</p>
<p>接下来，启用其正下方的一个选项，该选项显示 Require a pull request before merging。这将自动需要至少一位审阅者的批准。如果您在 GitHub 上没有其他帐户，您可以暂时取消选中此选项。否则，如果没有其他人批准，您将无法合并您的拉取请求：<img loading="lazy" src="https://files.realpython.com/media/rule_approvals.4cc8505f0715.png" alt="Require a Pull Request Before Merging"  />
</p>
<p>向下滚动一点后，您会看到一个选项，上面写着 Require status checks to pass before merging。选择它以显示更多选项。当你这样做时，检查另一个选项 Require branches to be update before merging，这将防止在你的 <code>master</code> 分支有新提交时关闭拉取请求。最后，在下面的搜索框中输入您的工作名称 <code>build</code> ：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/rule_status_check.6e4a5e464e77.png" alt="Require Status Checks to Pass Before Merging"  />
</p>
<p>现在，每个拉取请求都需要在允许合并之前通过端到端测试。</p>
<p>要在不允许管理员和其他具有提升权限的用户绕过这些规则的情况下强制执行这些规则，您可以在底部选择一个标记为不允许绕过上述设置的选项：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/rule_dont_allow.3a38d146c315.png" alt="Don&amp;rsquo;t Allow Bypassing the Above Settings"  />
</p>
<p>好的。一切就绪！如何使用您的 Docker 应用程序来测试您的持续集成工作流程？</p>
<h3 id="集成来自功能分支的更改">集成来自功能分支的更改</h3>
<p>遵循本教程前面概述的基于 Docker 的持续集成管道。首先创建一个单独的功能分支，以破坏测试的方式修改代码，提交更改并将它们推送到 GitHub：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">PS&gt; git checkout -b feature/replace-emoji-face
</span></span><span class="line"><span class="cl">Switched to a new branch <span class="s1">&#39;feature/replace-emoji-face&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PS&gt; <span class="nb">cd</span> web<span class="se">\s</span>rc<span class="se">\p</span>age_tracker
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PS&gt; <span class="o">(</span>Get-Content app.py<span class="o">)</span>.replace<span class="o">(</span><span class="s1">&#39;pensive&#39;</span>, <span class="s1">&#39;thinking&#39;</span><span class="o">)</span> <span class="p">|</span> Set-Content app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PS&gt; git commit -am <span class="s2">&#34;Replace the emoji in an error message&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>feature/replace-emoji-face 9225d18<span class="o">]</span> Replace the emoji in an error message
</span></span><span class="line"><span class="cl"> <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>, <span class="m">1</span> deletion<span class="o">(</span>-<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PS&gt; git push --set-upstream origin feature/replace-emoji-face
</span></span><span class="line"><span class="cl">⋮
</span></span><span class="line"><span class="cl">remote: Create a pull request <span class="k">for</span> <span class="s1">&#39;feature/replace-emoji-face&#39;</span> on GitHub...
</span></span><span class="line"><span class="cl">remote:      https://github.com/realpython/page-tracker/pull/new/feature...
</span></span></code></pre></div><p>Linx + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git checkout -b feature/replace-emoji-face
</span></span><span class="line"><span class="cl">Switched to a new branch <span class="s1">&#39;feature/replace-emoji-face&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ sed -i <span class="s1">&#39;s/pensive/thinking/g&#39;</span> web/src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git commit -am <span class="s2">&#34;Replace the emoji in an error message&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>feature/replace-emoji-face 9225d18<span class="o">]</span> Replace the emoji in an error message
</span></span><span class="line"><span class="cl"> <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>, <span class="m">1</span> deletion<span class="o">(</span>-<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git push --set-upstream origin feature/replace-emoji-face
</span></span><span class="line"><span class="cl">⋮
</span></span><span class="line"><span class="cl">remote: Create a pull request <span class="k">for</span> <span class="s1">&#39;feature/replace-emoji-face&#39;</span> on GitHub...
</span></span><span class="line"><span class="cl">remote:      https://github.com/realpython/page-tracker/pull/new/feature...
</span></span><span class="line"><span class="cl">⋮
</span></span></code></pre></div><p>您创建并切换到一个名为 <code>feature/replace-emoji-face</code> 的新本地分支，然后将错误消息中的表情符号从沉思脸更改为思考脸，而不更新相应的单元测试。将分支提交并推送到 GitHub 后，您可以通过突出显示行中的链接从您的功能分支打开一个新的拉取请求到 <code>master</code> 。只要您这样做，您的持续集成工作流程就会启动。</p>
<p>当 GitHub Actions 运行器完成其工作时，由于检查失败，您将无法合并您的分支：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/failed_pr2.e4e611e3f3cf.png" alt="GitHub Status Check Failed With a Conflict"  />
</p>
<p>在这种情况下，您只有一个检查对应于工作流中的 <code>build</code> 作业，您在上一节中将其配置为分支保护规则之一。您可以单击右侧的 Details 链接来调查失败检查的日志，并且您可以选择以调试模式重新运行相应的作业以收集更多数据。</p>
<p>此外，上面的屏幕截图描述了您的功能分支和目标主线之间的假设冲突。这表明其他人修改了与您相同的文件，并且他们在您修改表情符号时成功地将他们的更改与 <code>master</code> 分支集成。</p>
<p>没有自动解决此类冲突的方法，因为它涉及理解代码的逻辑并做出关于保留哪些更改以及丢弃哪些更改的主观决定。</p>
<p>解决此冲突的唯一方法是将更新后的主线合并到您本地的功能分支中，并手动整合冲突的更改。</p>
<p>即使没有任何冲突，如果主线在您的功能分支之前有几个提交，那么无论测试结果如何，您仍然必须将 <code>master</code> 中的最新更改合并到您的分支中。这是因为您之前制定的另一个分支保护规则：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/pr_update2.f48575db3caa.png" alt="GitHub Status Check Passed With an Outdated Branch"  />
</p>
<p>合并拉取请求按钮将保持灰色和禁用状态，直到您采取措施解决所有这些问题。</p>
<p>在现实生活中，您现在应该获取最新的 <code>master</code> 并将其合并到您的功能分支，必要时解决任何冲突。然后，您将更新代码以使所有测试再次通过。返回代码编辑器并使用预期的表情符号修复失败的单元测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"> # web/test/unit/test_app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> @unittest.mock.patch(&#34;page_tracker.app.redis&#34;)
</span></span><span class="line"><span class="cl"> def test_should_handle_redis_connection_error(mock_redis, http_client):
</span></span><span class="line"><span class="cl">     # Given
</span></span><span class="line"><span class="cl">     mock_redis.return_value.incr.side_effect = ConnectionError
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     # When
</span></span><span class="line"><span class="cl">     response = http_client.get(&#34;/&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     # Then
</span></span><span class="line"><span class="cl">     assert response.status_code == 500
</span></span><span class="line"><span class="cl"><span class="gd">-    assert response.text == &#34;Sorry, something went wrong \N{pensive face}&#34;
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+    assert response.text == &#34;Sorry, something went wrong \N{thinking face}&#34;
</span></span></span></code></pre></div><p>在本地运行测试并对代码的正确性获得信心后，在同一分支上再次提交并将其推送到 GitHub。在这样做之前，值得仔细检查当前分支：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git branch
</span></span><span class="line"><span class="cl">* feature/replace-emoji-face
</span></span><span class="line"><span class="cl">  master
</span></span><span class="line"><span class="cl">$ git add web/test/unit/test_app.py
</span></span><span class="line"><span class="cl">$ git commit -m <span class="s2">&#34;Fix the failing unit test&#34;</span>
</span></span><span class="line"><span class="cl">$ git push
</span></span></code></pre></div><p>拉取请求应该接受您的更改并开始另一个 CI 构建。一旦满足所有保护规则，您最终可以通过单击绿色按钮将您的功能分支合并到受保护的主线中：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/pr_success.0d326c26e9ad.png" alt="GitHub Status Checks Passed"  />
</p>
<p>请注意，合并将触发针对 <code>master</code> 分支的另一个 CI 构建，以测试您的更改是否与代码库的其余部分很好地集成。事情总是有可能出错。另一方面，如果 CI 构建成功，则工作流将标记并将镜像推送到您的 Docker Hub 存储库：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/docker_hub_push.93959f48b437.png" alt="Docker Image Tagged and Pushed By a GitHub Action"  />
</p>
<p>每次 CI 工作流成功时，推送的 Docker 镜像都会被标记为当前 Git 提交哈希和标签 <code>latest</code> 。</p>
<p>恭喜！关于使用 Docker 和朋友构建持续集成管道的整个教程到此结束。给自己当之无愧的表扬，因为这绝非易事！</p>
<h2 id="后续步骤">后续步骤</h2>
<p>您总是可以做很多事情来改进和微调现有的持续集成流程。尽管这是关于构建强大的 CI 管道的详尽且实用的教程，但您只是触及了皮毛！</p>
<p>以下是一些供您考虑的想法：</p>
<ul>
<li>
<p>自动部署到云以实现持续交付。</p>
</li>
<li>
<p>通过全流程自动化转向持续部署。</p>
</li>
<li>
<p>引入负载均衡器和服务副本以获得更好的可扩展性。</p>
</li>
<li>
<p>使用身份验证令牌保护敏感数据存储。</p>
</li>
<li>
<p>配置服务的持久日志记录和监控。</p>
</li>
<li>
<p>实施蓝绿部署以实现零停机。</p>
</li>
<li>
<p>添加功能切换以试验金丝雀发布和 A/B 测试。</p>
</li>
</ul>
<p>通过本教程，您已经为入门打下了良好的基础。您当然可以从这里开始构建一个充分自动化和生产就绪的持续集成系统，利用 Docker 和朋友的力量。</p>
<h2 id="总结">总结</h2>
<p>您现在对如何在容器化环境中构建、部署和管理多容器 Web 应用程序有了深入的了解。您介绍了挂接到 Redis 服务器的 Flask Web 应用程序的开发、测试、保护、码头化和编排。</p>
<p>您还了解了如何使用 Docker、GitHub Actions 和各种其他工具定义持续集成管道。</p>
<p><strong>在本教程中，您已经：</strong></p>
<ul>
<li>在 Docker 容器中本地运行 Redis 服务器</li>
<li>Docker编排 一个用 Flask 编写的 Python Web 应用程序</li>
<li>构建 Docker 镜像并将它们推送到 Docker Hub 注册表</li>
<li>使用 Docker Compose 编排多容器应用程序</li>
<li>在任何地方复制类似生产的基础设施</li>
<li>使用 GitHub Actions 定义持续集成工作流程</li>
</ul>
<p>您准备好构建自己的持续集成管道了吗？在评论中让大家知道！</p>
<blockquote>
<p>免费下载：单击<a href="https://realpython.com/bonus/docker-continuous-integration-code/">此处</a>下载您的 Flask 应用程序和相关资源，以便您可以使用 Docker 定义持续集成管道。</p>
</blockquote>
<p>原文链接：<a href="https://realpython.com/docker-continuous-integration/">Build Robust Continuous Integration With Docker and Friends </a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-16｜《灌篮高手》电影、《春山如笑》话剧</title>
      <link>https://blog.chensoul.com/posts/2023/04/25/weekly_review_16/</link>
      <pubDate>Tue, 25 Apr 2023 08:30:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/25/weekly_review_16/</guid>
      <description>前言 本篇是对 2023-04-17 到 2023-04-23 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这周的工作，手上累积了三个迭代版本，因为临近五一</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-01.png" alt="weekly-review-16-01"  />
</p>
<p>本篇是对 <code>2023-04-17</code> 到 <code>2023-04-23</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这周的工作，手上累积了三个迭代版本，因为临近五一及其他原因，短期内无法发布上线。开发过程中，想着这些版本都会一个个上线，所以三个版本之间合并了代码，存在了依赖关系。以后，还是需要小版本迭代、上一个版本发布之后再从 main 分支合并代码。</p>
<p>这周先后看了《灌篮高手》电影、《春山如笑》话剧，体验了两种艺术表现形式，都让人失望。</p>
<p>利用空余时间，将 n8n 进行了调整，只将我在豆瓣、github、spotify、blog、strava上的活动同步到telegram，而直接不同步到 memos，单独创建一个 workflow 将 telegram 同步到 memos。这样 telegram 是一个对外分享的频道，而 memos 可以分享一些个人的心情或者说说。另外，为了减少对大家的干扰，不再将 rss 订阅内容同步到我的 <a href="https://t.me/chensoul_share">telegram 频道</a>。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-16.png" alt="weekly-review-16-16"  />
</p>
<h2 id="灌篮高手">灌篮高手</h2>
<p>4月20日，灌篮高手国内上映，抽时间下班和老婆去看了这场电影。看完之后发了一个朋友圈：</p>
<blockquote>
<p>两个小时的电影，一场篮球比赛，尽是回忆，留下的是半亩良田半亩差评</p>
</blockquote>
<p>这就是我对这个电影的评价。因为情怀而去看了这部电影，却被情怀出卖了，这年头情怀不值钱了么？整部电影以宫城良田为视角，不停的回忆，四十分钟的比赛节奏不停的中断。很多片段都是动画里的内容，没有多少新内容。流川枫的刻画太少、樱木花道还是那样勇猛、晴子就没出现几次。。。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-11.jpeg" alt="weekly-review-16-11"  />
</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-12.jpeg" alt="weekly-review-16-12"  />
</p>
<h2 id="看话剧">看话剧</h2>
<p>周六去中南剧场看了一个话剧《春山如笑》，这是第一次看话剧，第一次接触话剧这个艺术表现形式。相比较于电影，我还是更喜欢看电影。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-13.jpeg" alt="weekly-review-16-13"  />
</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-14.jpeg" alt="weekly-review-16-14"  />
</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-15.jpeg" alt="weekly-review-16-15"  />
</p>
<h2 id="理财">理财</h2>
<p>这周总计支出 292.5 元，明细如下：</p>
<ul>
<li>4月21日：59元，和同事一起吃饭</li>
<li>4月22日：232元，周末买菜做饭，买水果</li>
<li>4月24日：1.5元，跑步小腿抽筋，骑共享单车回公司</li>
</ul>
<p>四月累计支出共 2417 元，其中餐饮和购物占了一半。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-09.jpeg" alt="weekly-review-16-09" style="width:50%;" />
<h2 id="健身">健身</h2>
<p>每天走一万步，这周完成了目标。以后每天跑步的话，这个目标就很容易达成了，甚至这个目标会换成每天跑步。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-10.jpeg" alt="weekly-review-16-10" style="width:50%;" />
<p>从 strava 的训练日志，可以看到本周运动记录如下：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-07.png" alt="weekly-review-16-07"  />
</p>
<p>从 strava 的训练日历，可以看到截至24日，本月运动了20天，23次，一共跑步了100公里。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-08.png" alt="weekly-review-16-08"  />
</p>
<h2 id="工作">工作</h2>
<h3 id="effective-java-3-笔记">Effective Java 3 笔记</h3>
<p>请参考《<a href="https://blog.chensoul.com/posts/2023/04/24/avoid-creating-unnecessary-objects/">《Effective Java 3》笔记：避免创建不必要的对象</a>》。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-02.png" alt="weekly-review-16-02"  />
</p>
<p>上面这个图是使用 <a href="https://shots.so/">Shots</a>  制作的，它是免费的，可以制作好看的图片，强烈推荐使用。</p>
<h2 id="本周分享">本周分享</h2>
<p>虽然大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。</p>
<h3 id="一些文章">一些文章</h3>
<ul>
<li><a href="https://www.skyue.com/23042217.html">使用 Python 实现 RSS 转 Newsletter</a></li>
<li><a href="https://www.bilibili.com/read/cv23249529">5种微服务注册中心该如何选型？</a></li>
<li><a href="https://allisonseboldt.com/5-years-of-indie-hacking/">5 Years of Indie Hacking</a></li>
<li><a href="https://feizhaojun.com/?p=3832">一个技术精致的网站：接口设计和图片加载</a></li>
<li><a href="https://newzone.top/posts/2022-11-03-ffmpeg_screen_recording.html">抛弃又贵又难用的录屏软件，3 分钟入门 FFmpeg</a></li>
<li><a href="http://weishu.me/2021/09/26/start-to-use-Rust/">开始学习和使用 Rust</a></li>
</ul>
<h3 id="一些工具">一些工具</h3>
<ul>
<li>
<p><a href="https://www.enhanceai.dev/">EnhanceAI</a> 使用一行代码为网站的输入框增加上 AI 能力。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-03.png" alt="weekly-review-16-03"  />
</p>
</li>
<li>
<p><a href="https://avatarmaker.com/">Avatar Maker</a> 一款在线 2D 动漫头像生成器，效果比较偏美漫风格。针对于半身头像的一些特征，提供了丰富的选项。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-04.png" alt="weekly-review-16-04"  />
</p>
</li>
<li>
<p><a href="https://markflow.app/">Markflow</a> 网页元素快速拷贝的工具，支持复制粘贴到 Figma，React，Html 里。这个网页中可以试用，Inspector 的效果还是很不错的。就是 Free Plan 每个月只能拷贝 5 个 elements 有点过于没诚意。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-05.png" alt="weekly-review-16-05"  />
</p>
</li>
<li>
<p><a href="https://shots.so/">Shots</a> 一款在线 Mockup 工具，能非常快速的做出套壳的效果图，内置的模版很多，样式调整的颗粒度也很细。适合独立开发快速出图。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-16-06.png" alt="weekly-review-16-06"  />
</p>
</li>
</ul>
<h3 id="本周嘀咕">本周嘀咕</h3>
<p>其实，大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道或者我的 <a href="https://memos.chensoul.com/">memos</a> 中，如果有一个脚本可以读取 Telegram 或者 memos 接口获取上周的分享记录，则可以自动化生成分享内容了。于是，花了一点时间写了一个 python 脚本 <a href="https://github.com/chensoul/chensoul.github.io/blob/main/fetch_memos.py">fetch_memos.py</a> 来读取 memos 接口。</p>
<p>获取到的内容如下：</p>
<ul>
<li><strong>2023-04-21 08:31:23</strong> 📺 看过灌篮高手 <code>#douban</code> <code>#watched</code>   <a href="http://movie.douban.com/subject/35315950/">查看链接</a></li>
<li><strong>2023-04-18 20:33:47</strong> 📺 看过龙马精神 <code>#douban</code> <code>#watched</code>  <a href="http://movie.douban.com/subject/35595615/">查看链接</a></li>
<li><strong>2023-04-18 20:33:47</strong> 📖 最近在读Rust权威指南 <code>#douban</code> <code>#reading</code>  <a href="https://book.douban.com/subject/35081743/">查看链接</a></li>
<li><strong>2023-04-18 20:33:47</strong> 📖 最近在读Python编程 <code>#douban</code> <code>#reading</code>  <a href="https://book.douban.com/subject/35196328/">查看链接</a></li>
<li><strong>2023-04-18 20:33:47</strong> 📖 最近在读Python工匠 <code>#douban</code> <code>#reading</code>  <a href="https://book.douban.com/subject/35723705/">查看链接</a></li>
<li><strong>2023-04-18 18:40:50</strong> 📝 周报-15｜Umami升级到2.0、汉街蜡像馆、使用Strava跑步 <code>#blog</code>   <a href="https://blog.chensoul.com/posts/2023/04/18/weekly_review_15/">查看链接</a></li>
<li><strong>2023-04-17 17:48:43</strong> 🌟 chensoul starred chensoul/chensoul.github.io <code>#github</code> <code>#star</code>  <a href="https://github.com/chensoul/chensoul.github.io">查看链接</a></li>
<li><strong>2023-04-17 17:10:45</strong> 📝 《Effective Java 3》笔记：使用私有构造函数或枚举类型创建单例 <code>#blog</code>   <a href="https://blog.chensoul.com/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/">查看链接</a></li>
</ul>
<p>后续的想法：对上面内容进行分类，比如，将带有豆瓣、Github、Strava、Spotfy、Blog标签的内容，归纳为我最近的活动；将带有 tool、skill 等标签其他内容归纳为我的分享（技术相关）；将其他内容归纳为我发表的说说。</p>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-8｜内存泄漏、公司裁员、练车</title>
      <link>https://blog.chensoul.com/posts/2023/02/27/weekly_review_8/</link>
      <pubDate>Mon, 27 Feb 2023 08:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/02/27/weekly_review_8/</guid>
      <description>前言 本篇是对 2023-02-20 到 2023-02-26 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这篇周报又是在地铁上完成编写的。回顾这一周的工作</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-02-20</code> 到 <code>2023-02-26</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这篇周报又是在地铁上完成编写的。回顾这一周的工作，还是项目测试、修复 bug 和准备上线发布。平静的工作节奏因为突如其来的裁员消息而变得内卷起来，大家下班的时间都纷纷往后移到了20 点左右。周末的时候，还是练车，从汉口开车到新洲。刚开始有点不敢，后来还是鼓起勇气，平安的到达。</p>
<h2 id="工作">工作</h2>
<h3 id="内存泄漏">内存泄漏</h3>
<p>这周线上环境，出现了告警，提示 jvm 出现了 full gc。于是赶紧 dump 内存进行分析查找原因。顺便整理了内存相关的知识。</p>
<p><strong>什么是内存泄漏？</strong></p>
<p>这个问题直接问 chatgpt：</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-08-01.png" alt="weekly-review-08-01"  />
</p>
<p>内存泄漏（Memory Leak）是指在程序中动态分配的内存由于某些原因程序未能释放或无法释放，导致系统内存的实际可用空间不断减少的现象。内存泄漏的发生会导致程序占用的内存越来越多，最终导致程序崩溃或系统变慢。</p>
<p>在Java中，程序员通常使用new运算符在堆上分配内存，这些内存不再使用时必须释放，否则就会出现内存泄漏。下面是一些常见的Java内存泄漏的情况：</p>
<ol>
<li>对象持有过多的引用</li>
</ol>
<p>当一个对象持有其他对象的引用时，这些对象就不能被垃圾收集器回收，导致内存泄漏。比如，一个静态集合（如Map、List）持有了大量对象的引用，但是这些对象已经不再需要了，却因为集合中仍然持有这些对象的引用，导致这些对象无法被回收，造成内存泄漏。</p>
<ol start="2">
<li>长时间持有对象锁</li>
</ol>
<p>在Java中，如果一个线程获取了一个对象的锁，但是在释放锁之前发生了异常，那么这个锁就不会被释放，从而导致内存泄漏。这种情况特别容易发生在synchronized块中。</p>
<ol start="3">
<li>不正确的缓存使用</li>
</ol>
<p>如果程序员不正确地使用缓存，就会导致内存泄漏。比如，如果使用一个静态Map来缓存对象，但是不从Map中删除对象，那么这些对象就会一直存在于内存中，造成内存泄漏。</p>
<ol start="4">
<li>大量创建临时对象</li>
</ol>
<p>如果程序频繁地创建临时对象，而这些对象又没有被及时清除，就会导致内存泄漏。比如，在循环中创建大量的字符串对象，但是没有及时清除，就会导致内存泄漏。</p>
<p>为了避免内存泄漏，Java程序员可以使用一些技术来优化程序，比如使用缓存池、避免使用不必要的静态变量、使用finalize()方法释放资源等等。</p>
<p><strong>如何排查内存泄漏？</strong></p>
<ul>
<li>
<p>内存分析工具：内存分析工具可以帮助您找到哪些对象占用了大量的内存。一些常用的内存分析工具包括：Eclipse MAT、VisualVM 和 YourKit。这些工具可以帮助您分析内存快照、查找内存泄漏并确定导致内存泄漏的代码位置。</p>
</li>
<li>
<p>堆转储文件：堆转储文件是一个包含了 JVM 堆中所有对象的快照。您可以使用以下命令生成一个堆转储文件：jmap -dump:format=b,file=heap.bin <PID>，其中<PID>是您的 Java 应用程序的进程 ID。然后，您可以使用内存分析工具来分析该文件。</p>
</li>
<li>
<p>代码审查：在编写代码时，您可以使用一些技巧来避免内存泄漏。例如，您应该确保正确地关闭流和数据库连接，避免在循环中创建对象，以及使用软引用或弱引用来存储缓存数据等。通过仔细审查代码并识别可能导致内存泄漏的部分，可以避免这些问题在运行时发生。</p>
</li>
<li>
<p>监视工具：JVM 提供了一些监视工具，例如 jstat 和 jconsole，可以用于监视 JVM 的内存使用情况。通过监视这些指标，您可以识别是否存在内存泄漏的迹象。</p>
</li>
<li>
<p>代码注入：在您的应用程序中，您可以注入一些代码，例如使用 JMX、AOP 等，以便您可以实时监视内存使用情况，并记录任何内存泄漏迹象。</p>
</li>
</ul>
<p>参考文章</p>
<ul>
<li>
<p><a href="https://www.cnblogs.com/rude3knife/p/13570423.html">一次完整的JVM堆外内存泄漏故障排查记录</a></p>
</li>
<li>
<p><a href="https://droidyue.com/blog/2015/11/28/article-java-8-lambdas-a-peek-under-the-hood">深入探索Java 8 Lambda表达式</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/weixin_34722015/article/details/114815917">java lambda表达式内存泄露_浅谈Java内存泄露</a></p>
</li>
</ul>
<h3 id="裁员">裁员</h3>
<p>去年公司就在裁员，陆陆续续裁了几次，每次都是裁两三个，动作都不大，但是很高效。因为部门人数就在五十左右，所以谁没来上班，都能很快察觉。</p>
<p>公司要在六月份上市，上市之前要使财报好看，就要开源节流、降本增效。节约成本的一个方式就是裁员，据说这次裁员动作比以前都大都迅速，今天提出裁员人数，明天就要给出名单，月底就要走人。</p>
<p>现在还只是二月份，离六月还有三个月。谁也不知道，后面还会有什么更大的裁员动作。说不定哪天就空出一个工位，说不定哪天领导就换了人，说不定哪天部门就被拆散了。</p>
<p>互联网公司最大的变化就是变化。之前在阿里工作，公司的价值观里有一条就是拥抱变化。</p>
<p>拥抱变化的最好方式就是积极面对，主动加班，提高工作效率，增加工作产出。</p>
<h2 id="生活">生活</h2>
<h3 id="练车">练车</h3>
<p>这是买车之后的第二周，还是没有开车去上班。一是因为开车不过熟练，胆子小，不敢开得太快；二是公司楼下的停车位还没有办好。</p>
<p>周六本想叫朋友过来给我当陪练，后来因为要回新洲，就算了，还是自己开车，带着老婆回新洲。</p>
<p>老婆科目一考过了，后面因为工作原因就没去练车和考试。她坐副驾驶，一边剥豆子一边提醒我注意交通规则。</p>
<p>在老婆的坐镇之下，顺利的从汉口开车六十公里到达新洲，路上没有违反交通规则。</p>
<p>周六下午去看了一下潘塘花朝节，有点失望，没有想象中的热闹。可能因为这不是正宗的花朝节，正宗的应该是在旧街。</p>
<p>逛了一圈，买了两百菜刀、一个砧板、两颗果树、一盆墨兰花。</p>
<p>周六从新洲开回阳逻，周日又从阳逻开回老家去看父亲。买车后第一次回家，放了鞭炮🧨。</p>
<p>中午包饺子，吃完饭就去菜园收割青菜。农村对于城市里上班族来说，一大好处是，每次回家，都可以装满青菜带回城市。</p>
<p>下午，从老家驱车回阳逻再到汉口。在开车的过程中，发现和总结了一些问题。</p>
<p>之前开车，总是盯着仪表盘，看车速达到了多少。车速一到 70 多就下意识地松油门和踩刹车。现在开始把眼睛注意力放到前方，不去可以在意车速，只是当导航提示我超速的时候，我白降低一点速度。</p>
<p>在红绿灯之前，如果不转弯，不要提前换道或者超车，保持中间道路行驶即可。</p>
<h2 id="好物分享">好物分享</h2>
<p>虽然大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。</p>
<h3 id="一些文章">一些文章</h3>
<ul>
<li>
<p><a href="https://blog.baoshuo.ren/post/actions-ssl-cert/">使用 GitHub Actions 自动申请与部署 SSL 证书</a></p>
</li>
<li>
<p><a href="https://phind.com/">The AI search engine for developers</a></p>
</li>
<li>
<p><a href="https://magickpen.com/">用 AI 写文章</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/weixin_34722015/article/details/114815917">java lambda表达式内存泄露_浅谈Java内存泄露</a></p>
</li>
<li>
<p><a href="https://kenengba.com/post/3769.html">在家躺着拿工资，是挺过意不去的</a></p>
</li>
<li>
<p><a href="https://blog.mikeoperfect.com/posts/11517/">车辆违章和交通事故处理流程</a></p>
</li>
<li>
<p><a href="https://blog.alswl.com/2020/03/before-code-review/">浅谈 Code Review 之事前准备</a></p>
</li>
</ul>
<h3 id="一些工具">一些工具</h3>
<h4 id="1raycasthttpswwwraycastcom">1、<a href="https://www.raycast.com/">Raycast</a></h4>
<p>Raycast是一款想要取代 Spotlight 的快捷启动器，通过 Mac 上面的一些组合键来为让你完成在 Mac 上面的快捷启动，提高你日常当中在 Mac 上面的操作效率，如果以 macOS 系统版本风格来比喻的话，Alfred 的 UI 风格应该能匹配几年前的 macOS 吧，而 Raycast 却是能够驾驭 macOS Big Sur 全新的视觉风格。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-08-02.png" alt="weekly-review-08-02"  />
</p>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-7｜练车、博客优化、注册ChatGPT账号</title>
      <link>https://blog.chensoul.com/posts/2023/02/21/weekly_review_7/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/02/21/weekly_review_7/</guid>
      <description>前言 本篇是对 2023-02-13 到 2023-02-19 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 练车 这周末开始练车，周六是第一次开自己的车，简单</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-02-13</code> 到 <code>2023-02-19</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<h2 id="练车">练车</h2>
<p>这周末开始练车，周六是第一次开自己的车，简单试驾了一样；周日则开了一百多公里，具体行程是从阳逻到新洲，从新洲单汉口，从汉口到光谷，从光谷回汉口。</p>
<p>这途中走了江北快速公路、二环、二七长江大桥、东湖隧道，从白天开到晚上夜行，经历过堵车，路上看到车祸后的事故现场。</p>
<p>一天下来，总共开车有五个多小时，感觉开车好累。作为新手，开车的过程中要全神贯注，铭记开车最重要的是慢这一原则，速度不敢过快。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-07-06.webp" alt="weekly-review-06"  />
</p>
<p>回顾这一天的练车过程，发现自己存在以下问题：</p>
<ul>
<li>
<p>对汽车不熟悉，不清楚车内每个按钮有什么作用。</p>
</li>
<li>
<p>不敢开的太快，油门踩到六十公里之后，就下意识地松油门。整个行驶过程中，平均车速大概在二十多公里每小时。</p>
</li>
<li>
<p>对交规不熟悉，第一次用高德地图，不知道什么时候改该变道、什么时候该走中间道路。要变道时候，不够果敢，打了灯光之后，没有快速变道，甚至还降速，等后面车子，而后面车子也在等我。</p>
</li>
<li>
<p>对车距不敏感。行驶过程中，和左右车辆相隔距离多近，没有一个直观的感受。观察后视镜，后面车距多远，有时候也判断不准，导致自己变道犹豫不决，险些擦碰。</p>
</li>
<li>
<p>变道、转弯，有时候忘记打灯。转弯时候，方向盘动得太早，没有等车过斑马线再打方向盘。左转弯时候，没有转大弯，导致车子有一次擦到了左边的石墩子，幸好不是很严重。</p>
</li>
<li>
<p>倒车和侧方停车不够熟练。</p>
</li>
<li>
<p>对上班路线不熟悉，不知道怎么进入公司楼下停车场。</p>
</li>
</ul>
<p>基于以上表现，接下来一周还是坐地铁上班。目前来说还是更喜欢坐地铁上班，可以看视频听音频，可以查看 RSS   订阅文章，可以写周报，可以闭目养神。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-07-07.png" alt="weekly-review-07"  />
</p>
<p>老婆给我买的实习期贴牌到了，后面司机看到这么可爱的牌子，估计以为是个妹子在开车吧，应该会喇叭下留情了吧😄。</p>
<p>接下来的周末，还要继续练车，和车子培养感情，从内到外熟悉车子，熟悉上班路线和交通规则，提高行驶速度。加油💪🏻！</p>
<h2 id="博客优化">博客优化</h2>
<p>这周重新对博客进行了优化，主要包括以下几个方面：</p>
<h3 id="1优化页面加载速度">1、优化页面加载速度</h3>
<p>每次打开博客首页，感觉页面加载有点慢，故想加快博客打开速度，第一个想到的是减少博客加载资源的次数，也就是去掉一些飞必须的 css 和 javascript 引用；其次，是对 css 进行压缩。</p>
<ul>
<li>去掉对 font-awesome css 的引用。这个对博客来说可有可无，所以直接去掉。</li>
<li>去掉对 jquery、bootstrap js 的引用。同样也不是必须的，自定义的 javascript 直接使用原生的操作就行。</li>
<li>移除未使用的 css。想参考这篇文章 <a href="https://dujun.io/cleancss-remove-unused-css.html">CleanCSS - 移除未使用的 CSS 代码</a>，对 css 进行瘦身，无奈文章中的服务器出现故障，无法访问服务。故，暂时搁浅。</li>
</ul>
<h3 id="2修改网站字体">2、修改网站字体</h3>
<p>参考这篇文章 <a href="https://www.albertaz.com/blog/web-font-best-practice">字体漫谈-网站字体最佳实践</a> 引入 open-sans 字体：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;preload&#34;</span> <span class="na">as</span><span class="o">=</span><span class="s">&#34;font&#34;</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;font/woff2&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/css/font/open-sans.css&#34;</span> <span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span>  <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/css/font/open-sans.css&#34;</span>  <span class="na">media</span><span class="o">=</span><span class="s">&#34;print&#34;</span> <span class="na">onload</span><span class="o">=</span><span class="s">&#34;this.media=&#39;all&#39;&#34;</span> <span class="p">/&gt;</span>
</span></span></code></pre></div><p>并修改网站 font-family 如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-css" data-lang="css"><span class="line"><span class="cl"><span class="nt">body</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">font-family</span><span class="p">:</span> <span class="n">Open</span> <span class="n">Sans</span><span class="p">,</span><span class="n">system-ui</span><span class="p">,</span><span class="o">-</span><span class="n">apple-system</span><span class="p">,</span><span class="n">Arial</span><span class="p">,</span><span class="kc">sans-serif</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">word-break</span><span class="p">:</span> <span class="kc">break-word</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="3修改关于页面内容">3、修改关于页面内容</h3>
<p>参考这篇文章 <a href="https://rahuldkjain.github.io/gh-profile-readme-generator/">GitHub Profile README Generator</a>，对 GitHub <a href="https://github.com/chensoul/chensoul">首页</a> 进行改造，并通过 GitHub Action 同步到博客的 <a href="https://blog.chensoul.com/about/">关于</a> 页面。</p>
<h3 id="4dns-解析迁移到-cloudflare">4、dns 解析迁移到 cloudflare</h3>
<p>将 dns 解析从 AWS 迁移到 cloudflare，并开启 CDN 缓存。</p>
<h3 id="5博客测速">5、博客测速</h3>
<p>以上优化完成之后，在 <a href="https://pagespeed.web.dev/">PageSpeed Insights</a> 网站上对博客首页加载速度进行了测速。移动端测试结果为 93 分，如下图：</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-07-01.png" alt="weekly-review-07-01"  />
</p>
<p>影响评分的原因在于：</p>
<ul>
<li>First Contentful Paint (3G)</li>
<li>加载的 <a href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">bootstrap.min.css</a> 文件过大，包括了一些未使用的 CSS</li>
</ul>
<p>桌面端测试结果评分为 99 分：</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-07-02.png" alt="weekly-review-07-02"  />
</p>
<p>另外，试了一下使用 chatgpt 来给出网站优化建议，回答如下：</p>
<h2 id="n8n-调整">n8n 调整</h2>
<p>新增了 3 个 workflow：</p>
<ul>
<li>
<p>定时获取 <a href="https://www.bitstamp.net/api/v2/ticker/btcusd">BTC 价格</a>，并发送到 <a href="https://t.me/chensoul_share">我的电报群组</a></p>
</li>
<li>
<p>定时获取 spotify 喜欢列表，并发送到电报和 memos</p>
</li>
<li>
<p>每天早上 7 点，发送天气预报给微信</p>
</li>
</ul>
<p>修改了以下 workflow：</p>
<ul>
<li>将豆瓣最近动态同步到电报群组以及 <a href="https://memos.chensoul.com/">memos</a></li>
<li>将 GitHub 最近动态同步到电报群组以及  <a href="https://memos.chensoul.com/">memos</a></li>
<li>将 <a href="https://blog.chensoul.com/index.xml">博客 RSS</a> 同步到电报群组以及  <a href="https://memos.chensoul.com/">memos</a></li>
</ul>
<p>此外，在苹果手机上添加了两个捷径：</p>
<ul>
<li><a href="https://sharecuts.cn/shortcut/12640">捷径一</a>：调用 memos API 创建 memos</li>
<li><a href="https://www.icloud.com/shortcuts/d990253f43e148469af5e85c296961cf">捷径二</a>：对网站通过 RSSBud 获取 RSS 订阅地址并发送到电报的 flowerrss 机器人进行订阅</li>
</ul>
<h2 id="chatgpt-注册账号">ChatGPT 注册账号</h2>
<p>参考 <a href="https://sms-activate.org/cn/info/ChatGPT">注册ChatGPT详细指南</a> 注册账号，我在 sms-activate 网站是购买的巴西的手机号来接验证码。</p>
<p>解决地区受限问题：在浏览器地址栏里输入 <code>javascript:</code>，然后粘贴下面代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">removeItem</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">).</span><span class="nx">find</span><span class="p">(</span><span class="nx">i</span><span class="p">=&gt;</span><span class="nx">i</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s1">&#39;@@auth0spajs&#39;</span><span class="p">)))</span>
</span></span></code></pre></div><blockquote>
<p>如果还是无效，则清理浏览器 cookie 和 session，再刷新页面。</p>
</blockquote>
<p>账号创建成功之后，创建了几个 chat：</p>
<ul>
<li>『文案小助手』：在今后的会话里，你都将扮演我的文案纠错润色助理，并综合给出优化后的版本。</li>
<li>『专业后端开发老师』：在今后的对话里，你是一个专业的后端语言开发者老师，会回答我所有关于后端开发相关的问题，尤其是 Java、Pyhon、Go 语言，同时也包括 Shell 脚本、Makefile、Docker、K8S 等运维部署相关的疑问，每次都会给出代码示例，不需要我再额外提醒。</li>
<li>『专业前端开发老师』：在今后的对话里，你是一个专业的前端开发者老师，会回答我所有关于前端语言开发相关的问题，尤其是 TypeScript、React、Vuejs、CSS、Html 和 Nextjs，每次都会给出代码示例，不需要我再额外提醒。</li>
<li>『个人搜索引擎』：在今后的会话里，请你扮演我的专业搜索引擎，为我搜索查阅相关问题的答案和信息，每个问题尽量给出链接和出处，不需要我额外再说明。</li>
</ul>
<p>点击 <a href="https://platform.openai.com/account/api-keys">链接</a>，可以创建应用。给飞书用户准备的 ChatGPT 机器人，参看 <a href="https://github.com/bestony/ChatGPT-Feishu">ChatGPT-Feishu</a>。</p>
<h1 id="-好物分享">💻 好物分享</h1>
<h3 id="一些文章">一些文章</h3>
<ul>
<li>
<p>技术类：</p>
<ul>
<li>
<p><a href="https://writings.stephenwolfram.com/2019/02/seeking-the-productive-life-some-details-of-my-personal-infrastructure/">我的个人 IT 基础设施（英文）</a></p>
</li>
<li>
<p><a href="https://arun.is/blog/desk-setup/">打造我的家庭办公环境（英文）</a></p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/2022/01/weekly-issue-191.html">科技爱好者周刊（第 191 期）：一个程序员的财务独立之路</a></p>
</li>
<li>
<p><a href="https://www.zlovezl.cn/articles/programming-is-still-hard-after-14-years/">入行 14 年，我还是觉得编程很难</a></p>
</li>
<li>
<p><a href="https://www.piglei.com/articles/how-to-design-config-file-for-software/">设计服务端软件配置的 4 条建议</a></p>
</li>
</ul>
</li>
<li>
<p>非技术类：</p>
<ul>
<li>
<p><a href="https://tingtalk.me/health/">除了健康，都是小事</a></p>
</li>
<li>
<p><a href="https://tingtalk.me/driving-test/">驾考指南</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="一些工具">一些工具</h3>
<h4 id="1亲戚关系计算器httpspasser-bycomrelationshipvue">1、<a href="https://passer-by.com/relationship/vue/#/">亲戚关系计算器</a></h4>
<h4 id="2imageoptimhttpsimageoptimcommac">2、<a href="https://imageoptim.com/mac">ImageOptim</a></h4>
<p>开源图片压缩软件：一款 Mac 小工具，可以方便的进行图片压缩，支持多格式、批量处理。值得注意的是，它压缩之后的图片会覆盖之前的图片。使用了这个工具之后，我就把  TinyPNG4Mac 卸载了。</p>
<h4 id="3沉浸式双语网页翻译扩展--immersive-translatehttpsimmersive-translateowenyoungcom">3、<a href="https://immersive-translate.owenyoung.com/">沉浸式双语网页翻译扩展 – immersive-translate</a></h4>
<p>强烈推荐这个网页翻译插件，和其他插件翻译整个页面相比，这个插件的优势是可以同时显示双语，中英文对照非常棒，是一个 <a href="https://github.com/immersive-translate/immersive-translate">开源</a> 的项目，完全免费使用。也支持 PDF，配合任何 <a href="https://epub-reader.online/">epub 在线阅读网站</a>对照翻译阅读书也非常方便。也支持了Deepl，腾讯翻译等等的翻译服务。开发者 <a href="https://twitter.com/OwenYoungZh">@OwenYoungZh</a></p>
<h4 id="4input-source-prohttpsinputsourceprozh-cn">4、<a href="https://inputsource.pro/zh-CN">Input Source Pro</a></h4>
<p>Input Source Pro 可以根据应用或是网站自动切换输入法，并且在切换窗口的时候还会贴心的提示当前的输入法是什么，比如设置 VSCode、iTerm、Xcode 默认为英文输入法，而笔记软件和企业微信默认为中文输入法，切换软件时再也不需要按 shift 键了！</p>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-3｜博客定制、VPS部署服务</title>
      <link>https://blog.chensoul.com/posts/2023/01/25/weekly_review_3/</link>
      <pubDate>Wed, 25 Jan 2023 09:47:03 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/01/25/weekly_review_3/</guid>
      <description>前言 本篇是对 2023-01-16 到 2023-01-22 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这是过年前的最后一周，上了三天班，请了两天假回去</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-01-16</code> 到 <code>2023-01-22</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这是过年前的最后一周，上了三天班，请了两天假回去准备年货、去亲戚家吃年饭。趁放假之前，继续对博客做了一些定制，也在我的 VPS 上通过 Docker 部署了一些服务。</p>
<h2 id="定制博客">定制博客</h2>
<p>基于 <a href="https://www.pseudoyu.com/">pseudoyu</a> 的博客和主题定制博客，发现并修复了bug，还做了一些改进，并在他的 github 提交 <a href="https://github.com/pseudoyu/pseudoyu/issues/2">issue</a> 和 merge request。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/github-issue-build-aboutme-py.png" alt="github-issue-build-aboutme-py" style="width: 80%"/>
<p>接着在他博客主页留言，几个来回下来，收获不少。一是解决了我提出的问题，二是给我分享了一个搬瓦工的 the plan 优惠码。这时候去看了下我原来的 vps 刚好还有一天要到期，就立即花了92 美元（原价是 99 美元）购买了一台 2G 内存托管在香港的服务器。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/vps-main-controlls.png" alt="vps-main-controlls"  />
</p>
<p>缘分就是这么奇妙，如果我不主动和这个博主联系，就不会知道搬瓦工还有这个优惠，就不会帮助我解决了博客定制过程中遇到的疑惑。</p>
<blockquote>
<p>当你想要什的时候，先给出去，你就会收获更。有舍才有得。</p>
</blockquote>
<h2 id="博客个人介绍">博客个人介绍</h2>
<p>我的博客源文件托管在 <a href="https://github.com/chensoul/chensoul.github.io">gihub</a>，在这个仓库可以看到我的一些个人介绍，当然，我的博客也有个人介绍（在<a href="https://blog.chensoul.com/about/">关于</a>页面），如果你仔细观察，可以发现他们基本上是一样的，这个是怎么实现的呢？</p>
<img src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/chensoul-github-io-readme.png" alt="chensoul-github-io-readme" style="width: 80%"/>
<p>首先，github 里面可以创建一个以 github 账号为名称的仓库，然后编辑好 README.md 文件，README.md 文件内容就会渲染成 html 显示到个人 github 主页。例如，我的 github 主页是 <a href="https://github.com/chensoul">https://github.com/chensoul</a>，我的个人仓库地址为 <a href="https://github.com/chensoul/chensoul">https://github.com/chensoul/chensoul</a>，这个仓库是通过 github actions 来构建 README.md，构建文件查看仓库的 workflows 文件，主要有两个文件：</p>
<ul>
<li>build.yml：周期性的调用 <a href="https://github.com/chensoul/chensoul/blob/main/build_readme.py">build_readme.py</a> 来生成 README.md 文件（包括：获取最近 5 篇博客文章、或者 豆瓣上最近 5 个电影书籍动态、获取 github 上发布的项目、显示 wakatime 报表）</li>
<li>waketime.yml：生成 wakatime-charts</li>
</ul>
<p>当 README.md 生成之后，只需要将该文件内容同步到博客的 about.md 文件即可。怎么实现呢？参考博客源文件里的 <a href="https://github.com/chensoul/chensoul.github.io/blob/main/build_about.py">build_about.py</a>。这样就可以实现一个自我介绍同步到多个平台（除了博客，还可以通过 api 接口同步到语雀等其他平台）。</p>
<h2 id="vps-上服务部署">vps 上服务部署</h2>
<p>购买了新的 VPS 之后，就将原来的 VPS 导出镜像，然后导入到新的 VPS，最后再安装了以下服务：</p>
<ul>
<li><a href="https://github.com/indes/flowerss-bot">flowerss-bot</a>：一个支持应用内阅读的 Telegram RSS Bot。</li>
<li><a href="https://n8n.io/">n8n</a>：一款开源的自动工作流服务，类似 IFTTT、Zapier，可以互联互通包括 GitHub、Dropbox、Google、NextCLoud、RSS、Slack、Telegram 在内的几十款在线服务。</li>
<li>memos：一个开源且免费的自托管知识库</li>
<li>cusdis：一个界面清爽、注重隐私的轻量级 (~5kb gzip) 评论系统，可以很方便地与 React、Vue 或其他博客系统结合，并且还提供了一个后台来管理所有的评论</li>
<li>umami：一个简单易用、自托管的开源网站访问流量<em>统计</em>分析工具</li>
<li>pgsql</li>
<li>uptime-kuma：一个开源免费的监控工具</li>
<li>rsshub：一个开源、简单易用、易于扩展的RSS 生成器，可以给任何奇奇怪怪的内容生成RSS 订阅源</li>
</ul>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/vps-docker-service.png" alt="vps-docker-service"  />
</p>
<p>通过 Docker 部署这些服务非常简单，主要是需要注意的一点是：将这些服务部署到同一个网路，这样各个服务之间可以互相通信。比如：很多服务都需要依赖数据库 postgresql，可以使用 docker-compose 来编排服务。安装部署过程参考：<a href="/posts/2023/01/25/notes-about-deploy-services-in-vps/">我的VPS服务部署记录</a></p>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-2｜博客重构</title>
      <link>https://blog.chensoul.com/posts/2023/01/15/weekly_review_2/</link>
      <pubDate>Sun, 15 Jan 2023 09:47:03 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/01/15/weekly_review_2/</guid>
      <description>前言 本篇是对 2023-01-09 到 2023-01-15 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这是年前倒数第二个工作周，工作上主要是完成项目一</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-01-09</code> 到 <code>2023-01-15</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这是年前倒数第二个工作周，工作上主要是完成项目一个版本的测试和发布。这个博客主要是分享一些技术相关笔记和个人的生活记录与思考，所以不会涉及具体的工作内容。</p>
<p>周三晚上是部门年会，领导提出了 2023 年收入 6.2 亿的目标，比 2022 年收入增长 140%。从公司领导层这乐观的年度规划，看得出来公司的发展属于上升趋势，同时意味着 2023 年又是忙碌和压力巨大的一年。</p>
<p>工作闲暇之余，看到了一些独立开发者的博客，并受他们博客文章的影响，立即决定重新捣鼓博客。于是，在一腔热情之下，花了三天时间重构了博客，也对博客以后的方向做了一些规划。</p>
<p>周末是过小年，小年伊始，年味渐浓。周六晚上，堂哥家吃年饭。周日中午，自己家吃年饭。这是新婚后第一次两边的家人一起吃年饭。虽然很早就确定了年饭时间大家都有时间的周末、预定了可以坐下 20 多人的大桌，但还是遗憾人没有到齐。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/new-year-dinner-20230115.png" alt="new-year-dinner-20230115"  />
</p>
<h2 id="博客重构">博客重构</h2>
<h3 id="博客主题">博客主题</h3>
<p>以前的博客主要是纯粹分享技术，很少有自己的思考，基本上就是代码比汉字要多不少。博客没有博主的思考，无法让读者认识、了解博主，并和博主产生深入的链接。这样的博客没有灵魂，就仅仅是一个纯分享的 wiki。</p>
<p>这次重新开始写博客之后，规划的博客主题是分享技术、记录生活、启发思考。技术上的文章，要有深度；生活的点滴，要有复盘；思考的内容，要有共鸣。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/blog-homepage-den-theme.png" alt="blog-homepage-den-theme"  />
</p>
<h3 id="博客规划">博客规划</h3>
<p>以前博客文章的分类有 java、database、devops、web，在删了一些文章之后，将博客的分类调整为想法（Ideas）、笔记（Notes）两类，后面再根据实际情况添加或者调整分类。</p>
<blockquote>
<p>健康，爱情和使命，按照这个顺序，其它的都不重要</p>
</blockquote>
<h3 id="文章链接">文章链接</h3>
<p>以前的博客链接格式是 <code>posts/:slug</code>，现在调整为 <code>posts/:year/:month/:day/:slug</code>。因为现在博客只有几篇文章，所以暂时不打算做原有链接路径到新路径的重定向工作。</p>
<h3 id="博客部署">博客部署</h3>
<p>目前有三种方案部署方案：</p>
<ul>
<li>github pages。国内访问速度受影响。</li>
<li>cloudflare pages。可以使用 cdn 加速。</li>
<li>Self hosted。需要购买云主机和手动运维。</li>
</ul>
<p>目前，是倾向于使用第二种方案。源码保存到 github 上，github actions 编译和部署静态文件到 cf-pages 分支，通过 cloudflare pages 链接 github 仓库、自动化部署静态文件并设置自定义域名 <code>blog.chensoul.com</code>。</p>
<h3 id="发布流程">发布流程</h3>
<p>本地编写 markdown 文件，图片保存到公有云，通过 git 提交到 github 仓库，使用 github actions 通过 n8n 自动发布到多平台，比如：公众号，语雀等。</p>
<h3 id="待办事项">待办事项</h3>
<p>本周对博客重构，计划完成以下功能：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 在不修改原主题的前提下，通过 git log 记录对主题的改动</li>
<li><input checked="" disabled="" type="checkbox"> 添加 <a href="https://cusdis.com/">Cusdis </a>评论系统</li>
<li><input checked="" disabled="" type="checkbox"> 添加 <a href="https://umami.is/">Umami</a> 统计分析</li>
<li><input checked="" disabled="" type="checkbox"> 添加 <a href="https://uptime.kuma.pet/">Kuma</a> 服务监控</li>
<li><input checked="" disabled="" type="checkbox"> 添加搜索、回到顶部功能</li>
<li><input checked="" disabled="" type="checkbox"> 使用 <a href="https://oss.console.aliyun.com/overview">阿里云对象存储</a> 作为图床</li>
<li><input disabled="" type="checkbox"> github actions 集成 <a href="https://n8n.io/">n8n</a></li>
<li><input disabled="" type="checkbox"> 域名 dns 解析迁移到 cloudflare</li>
</ul>
<p>以下是使用 kuma 监控我的 VPS 上的服务。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/chensoul-uptime.png" alt="chensoul-uptime"  />
</p>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-1｜开始写周报、冥想</title>
      <link>https://blog.chensoul.com/posts/2023/01/08/weekly_review_1/</link>
      <pubDate>Sun, 08 Jan 2023 09:47:03 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/01/08/weekly_review_1/</guid>
      <description>前言 本篇是对 2023-01-02 到 2023-01-08 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这是 2023 年的第一周，元旦放了三天假之后，就用投入了</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-01-02</code> 到 <code>2023-01-08</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这是 2023 年的第一周，元旦放了三天假之后，就用投入了工作之中。元旦已过，过年就没多远了，很多公司也开始准备年会了。因为疫情，这个年注定不好过。现在疫情放开，不知道有多少公司能够熬过这个年，进入百废待兴的节奏。</p>
<p>最近把 rss 阅读器又用起来，每天阅读订阅的未读文章，关注到好几个独立开发者。他们每周都在坚持写博客、分享技术文章。从他们的分享里面，可以看到他们有在做自己的 side projects，也有在开源项目提交代码。看着他们的 github 主页每天都有提交代码，再看看我的 github 主页很久没有提交过代码，顿感惭愧。目前，公司使用的是自建的 gitlab 仓库托管代码，很多代码不方便公开分享，自己夜很少花时间写一些小项目公开分享到 github。干脆就清理一些 github 长期没有维护的仓库，取关了一些好友，更新了 github 主页，最后看了一下粉丝还有 574 人，相对而言也是少的可怜🥺。</p>
<h2 id="开始写周报">开始写周报</h2>
<p>前段时间，开始尝试在 <a href="https://www.yuque.com/chensoul">语雀</a> 上每天写日记，写了几天之后，没有坚持下来。</p>
<img src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/yuque-life-note.png" alt="yuque-life-note" style="width: 50%"/>
<p>总结了一下，没有坚持下来的原因主要是在于每天没有积累足够的分享内容，也就是输入不够；另外，输出之后的反馈不够，这和观众流量有关。作为一个程序员，更喜欢自动化工作的快感和满足感。哟还是更倾向于将博客以 markdown 文件保存到本地或者 git 仓库，然后通过自动化脚本编译部署到多平台。在关注了一些独立开发者的博客之后，更是坚定了这种想法。于是有了这篇写周报的文章，以周为单位记录每一周的所看所思所感。</p>
<p>关于写博客的流程，电脑上使用 typora 编辑器有着很好的用户体验。如果也能在手机上用 markdown 写文章并提交到 github 上就更完美了。刚开始我使用的是 mweb 这个 app，最近在 ios 上又发现了 metion 这个 app 就可以支持和 git 同步。</p>
<img src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/ios-app-metion.png" alt="ios-app-metion" style="width: 50%"/>
<p>这篇文章就是通过 metion 编写和提交的。图片是本地上传的，图片名称应该是一串随机数，待文章发布之后，需要将图片重命名为有意义的名称，这样方便在图床里查阅和管理。</p>
<img src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/metion-writing-first-blog.png" alt="metion-writing-first-blog" style="width: 50%"/>
<p>关于图片的宽度设置，特别是竖形图，建议将宽度设置为一半。设置方法是：在 md 文件里使用 <code>img</code> 标签引入图片，这样就可以添加一个 <code>sytle=&quot;width: 50%&quot;</code> 来设置宽度。例如，上面图片就是这样设置的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/ios-app-metion.png&#34;</span> <span class="na">alt</span><span class="o">=</span><span class="s">&#34;ios-app-metion&#34;</span> <span class="na">style</span><span class="o">=</span><span class="s">&#34;width: 50%&#34;</span><span class="p">&gt;</span>
</span></span></code></pre></div><h2 id="内观冥想">内观冥想</h2>
<p>这个月参加了一个内观冥想 21 天训练营，每天早上 7 点到 8 点是上课时间，正好也是我上班时间。在听了几天课程并打卡之后，就放弃了。</p>
<p>21 天课程内容，每天的主题分别是：</p>
<ul>
<li>目标</li>
<li>计划</li>
<li>结果</li>
<li>比较</li>
<li>抱怨</li>
<li>后悔</li>
<li>他应该知道自己错了</li>
<li>不可能</li>
</ul>
<h3 id="目标">目标</h3>
<blockquote>
<p>今日内观冥想主题是目标</p>
<p>静静地放空自己，回想自己关注目标的记忆。好像自己曾经设立过很多目标，又好像什么都没有。目标是什么，好像描述不出来，又琢磨不透。</p>
<p>曾经立下的那些目标算是目标吗？他们可以实现吗？他们实现了吗？为什么没有实现呢？无志之人常立志，有志之人立常志。远的不说，先看看 2022 年实现了哪些目标。读书，是彻底放下了；健身，元旦前减到 130 斤的目标在 “阳康后不要剧烈运动” 的说辞下耽误了；定投，也是终止了；买车，车是消耗品；结婚，实现了。</p>
<p>算了下，实现了的目标也就是结婚了。少的可怜。为什么会这样呢？大抵是自己不够自律，没有持续的坚持，也没有及时的反思和调整。也就是自我察觉不够吧！或者说没有养成自我察觉的方法和习惯。这也就是为什么要参加 21 天内观训练营的原因吧。</p>
<p>一个人很难认清自身的局限性，很难扩大自己的认知，多与身边的人交流和学习，通过观他人，再来思自己，应该可以提升自己的察觉意识。</p>
</blockquote>
<h3 id="计划">计划</h3>
<blockquote>
<p>今日内观冥想主题是计划。</p>
<p>早上冥想是在地铁，冥想的时候放空自己，感受自己的思绪、情绪和身体的注意力。因为是站着，注意力一会儿在脚上，一会儿在手上，不能完全地放空自己。想必要是完全放松，估计就站不住了吧。</p>
<p>冥想地过程中，重要的是感受和观察。感受当下的感受，观察自己的观察，任有他们流动和发展。所谓没有绝对的对与错，冥想的过程中，重要的是作为一个旁观者，不要有过多的主观意识。</p>
</blockquote>
<h3 id="结果">结果</h3>
<blockquote>
<p>今天的内观冥想主题是结果。</p>
<p>把身体挂在钩子上，静静地观察和感受。一方面感受身体，一方面会思考自己对结果的理解。什么是结果？自己过去一年取得了什么样的结果？为什么没有取得？</p>
</blockquote>
<h3 id="比较">比较</h3>
<blockquote>
<p>今日内观冥想主题是比较。冥想时，观察自己的感受、情绪、想法，他们可能是任何样子的。不管是怎样的，他们都是正常的，都是他们本来的样子，也就是空性。</p>
<p>把比较这个念头挂起来，静静地看比较这两个字。然后开始觉察比较这两个字。这个时候，大脑开始在思考比较这个念头是什么。思绪在变化的时候，对对比较这个念头的感受也在变化。无论如何变化，自己都不要干预。当自己有了比较这个念头，自己的感受是失望的。失望自己不如别人，不如过去。失望过后，又不服气，又暗下决心要好好努力。这个过程中，我是我的主人，是我在有着各种各样的感受。如果我能控制自己的情绪，就能控制自己的行为。</p>
</blockquote>
<h3 id="抱怨">抱怨</h3>
<blockquote>
<p>今日冥想主题是抱怨。</p>
<p>生活中有什么抱怨的？抱怨又解决不了问题？问题又不是自己造成的，可能是别人造成的！别人的事情是别人的事情，自己的事情是自己造成。别人的事情，你管不了，你能管理的是你自己的。管好自己的心态情绪和行为，因为抱怨解决不了别人的问题，也解决不了自己的事情。甚至你的抱怨还会给别人带来负能量，给你们带来争吵，给自己带来蛮烦，给自己地能力和情绪带来消耗。与其消耗自己，还不如提升自己。有时候不要局限在自己的思维里，换个角度，提升格局，一切事情都不是事情了。这个世界哪有那么多所谓重要的事情。那些今天你看来很重要的事儿，在十年二十年之后，根本就不值得一提。所以很多时候，要用发展的眼光看问题。一切都会过去，一切都会好起来。当你这样想的时候，在你心里在你眼前，就没有什么烦恼了，也就不会抱怨了。</p>
</blockquote>
<h2 id="好物分享">好物分享</h2>
<p>几个截图软件：</p>
<ul>
<li>
<p><a href="https://immmmm.com/chrome-extensions-tinysnap/">TinySnap</a> Chrome 截图插件，支持设置背景</p>
</li>
<li>
<p>Snipaste 截图</p>
</li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>从零开始搭建个人博客</title>
      <link>https://blog.chensoul.com/posts/2021/09/09/build-personal-blog-from-zero/</link>
      <pubDate>Thu, 09 Sep 2021 18:14:34 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2021/09/09/build-personal-blog-from-zero/</guid>
      <description>从零开始搭建博客，包括注册域名、购买服务器、部署程序及网站配置和优化。 域名 搭建一个博客或者网站，需要有一个域名。那什么是域名呢？看看百度百科</description>
      <content:encoded><![CDATA[<p>从零开始搭建博客，包括注册域名、购买服务器、部署程序及网站配置和优化。</p>
<h2 id="域名">域名</h2>
<p>搭建一个博客或者网站，需要有一个域名。那什么是域名呢？看看百度百科上的解释：</p>
<blockquote>
<p><strong>域名</strong>（英语：<strong>Domain Name</strong>），又称<strong>网域</strong>，是由一串用点分隔的名字组成的<a href="https://baike.baidu.com/item/Internet">Internet</a>上某一台<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。</p>
<p>由于<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80/150859">IP地址</a>具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（<a href="https://baike.baidu.com/item/DNS">DNS</a>，Domain Name System）来将域名和<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>相互<a href="https://baike.baidu.com/item/%E6%98%A0%E5%B0%84/20402621">映射</a>，使人更方便地访问<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186">互联网</a>，而不用去记住能够被机器直接读取的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>数串。</p>
</blockquote>
<p>简单来说，IP地址可以标识一台计算机，但是不容易记忆，所以，设计出了域名。而域名就是标识因特网上的一台计算机，由网域名称系统DNS来完成域名和IP之间的映射。</p>
<p>如何注册域名？有很多网站提供域名注册服务，比如国内的：</p>
<ul>
<li><a href="https://www.alibabacloud.com/zh/domain">阿里云</a></li>
<li><a href="https://cloud.tencent.com/act/domainsales">腾讯云</a></li>
<li><a href="https://www.huaweicloud.com/">华为云</a></li>
</ul>
<p>国外的：</p>
<ul>
<li><a href="https://sg.godaddy.com/zh/offers/domain">GoDaddy</a></li>
<li><a href="https://www.namecheap.com/">Namecheap</a></li>
<li><a href="https://console.aws.amazon.com/route53/home?#DomainRegistration:">Amazon</a></li>
</ul>
<p>注册域名的建议：</p>
<ul>
<li>1、建议在正规、出名的网站注册域名，防止网站跑路。我曾经在一个小网站注册了一个域名，使用了几年之后，续期的时候，联系不上对方，导致无法使用该域名，甚至该域名被别人抢注册了。</li>
<li>2、在国内网站注册域名，都需要备案。如果不想备案，请在国外网站注册域名。我的域名 chensoul.com 就是在亚马逊上注册的。一是不想备案，二是对比了上面几个网站，发现亚马逊上的com域名价格相对便宜，所以一次性购买了5年。</li>
<li>3、建议优先注册com域名，域名尽可能的简短并且方便记忆。</li>
</ul>
<p>我曾经注册过的域名：</p>
<ul>
<li>javachen.com、javachen.space、javachen.xyz</li>
<li>huaiu.com</li>
</ul>
<h2 id="服务器">服务器</h2>
<p>注册了域名之后，需要一台服务器运行程序。服务器可以是一台物理机，比如你可以使用自己的电脑作为服务器；也可以是一台虚拟的云服务器，比如在云服务提供商购买一台独立的服务器；也可以使用第三方提供的服务器空间，比如Github上可以部署静态程序。不管哪种方式，服务器都需要有一个公网IP，这样才能在因特网上访问你服务器上部署的程序。有了服务器之后，就可以给服务器公网IP设置域名解析。</p>
<p>我的服务器是在<a href="https://bandwagonhost.com/aff.php?aff=58710">搬瓦工</a>购买的，一年49.99美元。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/bwg-plan.png" alt="bwg-plan"  />
</p>
<h2 id="程序">程序</h2>
<h3 id="安装hugo">安装Hugo</h3>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/hugo-logo.svg" alt="使用 Hugo 搭建博客"  />
</p>
<p>在 Mac 下安装 Hugo：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">brew install hugo
</span></span></code></pre></div><h3 id="新建站点">新建站点</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">hugo new site chensoul.github.io -y yaml
</span></span></code></pre></div><p>上述命令会生成一个名为 <code>chensoul.github.io</code> 的文件夹，下面对文件夹结构做个说明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ tree chensoul.github.io
</span></span><span class="line"><span class="cl">chensoul.github.io
</span></span><span class="line"><span class="cl">├── archetypes
</span></span><span class="line"><span class="cl">│   └── default.md
</span></span><span class="line"><span class="cl">├── config.yaml
</span></span><span class="line"><span class="cl">├── content
</span></span><span class="line"><span class="cl">├── data
</span></span><span class="line"><span class="cl">├── layouts
</span></span><span class="line"><span class="cl">├── static
</span></span><span class="line"><span class="cl">└── themes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">6</span> directories, <span class="m">2</span> files
</span></span></code></pre></div><p>新建的站点，还没有加入 Git 版本管理，进入到这个目录下，执行一下如下命令，完成 Git Repo 的初始化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">cd</span> chensoul.github.io
</span></span><span class="line"><span class="cl">git init .
</span></span></code></pre></div><p>新建站点后，我们开始添加主题。</p>
<h3 id="添加主题">添加主题</h3>
<p>在 Hugo 的官网上 <a href="https://themes.gohugo.io/">Hugo Themes</a> 有非常非常多的主题，可以根据自己的喜好选择一个主题。这里，我使用的是 hugo-theme-den 主题。</p>
<p>使用 git submodule&ndash;helper 下载主题到 theme 目录下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">git submodule--helper add https://github.com/shaform/hugo-theme-den themes/den --depth<span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">git submodule--helper update --init --recursive <span class="c1"># needed when you reclone your repo (submodules may not get cloned automatically)</span>
</span></span></code></pre></div><p>以后，当主题有更新时，执行下面命令更新：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git submodule update --remote --merge
</span></span></code></pre></div><p>如果遇到异常，可以参考<a href="https://xuzhijvn.github.io/zh-cn/posts/other/git-submodule-update-init-recursive/">文章</a>解决。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">fatal: remote error: upload-pack: not our ref fc7223ca00124e8f5b5b354457379071e2fd091b
</span></span></code></pre></div><h3 id="启动">启动</h3>
<p>启动预览：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">hugo server
</span></span></code></pre></div><p>默认是 <code>1313</code> 端口号，在浏览器中直接访问 http://localhost:1313/ 就可以访问到新建的博客了。</p>
<h2 id="定制化">定制化</h2>
<h3 id="站点信息">站点信息</h3>
<p>配置网站的基本信息，将 config.yaml 修改如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">baseURL: https://blog.chensoul.com/
</span></span><span class="line"><span class="cl">title: ChenSoul
</span></span><span class="line"><span class="cl">theme: den
</span></span><span class="line"><span class="cl">enableRobotsTXT: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">enableEmoji: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">hasCJKLanguage: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">preserveTaxonomyNames: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">rssLimit: <span class="m">100</span>
</span></span><span class="line"><span class="cl">page_view_conter: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">enableRelated: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Copyright, appears in the footer</span>
</span></span><span class="line"><span class="cl"><span class="c1"># copyright = &#34;&#34;             # default: author.name</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Pagination</span>
</span></span><span class="line"><span class="cl"><span class="c1"># number of entries per page for archives, tags and categories</span>
</span></span><span class="line"><span class="cl"><span class="c1"># since we don&#39;t have list view, recommend a large value</span>
</span></span><span class="line"><span class="cl">paginate: <span class="m">20</span>
</span></span><span class="line"><span class="cl">paginatePath: <span class="s2">&#34;page&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Syntax Hightlight</span>
</span></span><span class="line"><span class="cl">PygmentsCodeFences: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">PygmentsUseClasses: <span class="nb">true</span>    <span class="c1"># required for shhighlight shortcode</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># service plugins</span>
</span></span><span class="line"><span class="cl">disqusShortname: <span class="s2">&#34;&#34;</span>         <span class="c1"># disqus_shortname</span>
</span></span><span class="line"><span class="cl">googleAnalytics: <span class="s2">&#34;&#34;</span>         <span class="c1"># UA-XXXXXXXX-X</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># language support # en / zh / other... translations present in i18n/</span>
</span></span><span class="line"><span class="cl">defaultContentLanguage: <span class="s2">&#34;zh&#34;</span>           <span class="c1"># Default language to use</span>
</span></span><span class="line"><span class="cl">defaultContentLanguageInSubdir: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">permalinks:
</span></span><span class="line"><span class="cl">  posts: /posts/:slug/
</span></span><span class="line"><span class="cl">  categories: /categories/:slug/
</span></span><span class="line"><span class="cl">  tags: /tags/:slug/
</span></span><span class="line"><span class="cl">  pages: /:slug/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">author:
</span></span><span class="line"><span class="cl">  name: chensoul
</span></span><span class="line"><span class="cl">sitemap:
</span></span><span class="line"><span class="cl">  changefreq: weekly
</span></span><span class="line"><span class="cl">  priority: 0.5
</span></span><span class="line"><span class="cl">  filename: sitemap.xml
</span></span><span class="line"><span class="cl">params:
</span></span><span class="line"><span class="cl">  since: <span class="s2">&#34;2020&#34;</span>
</span></span><span class="line"><span class="cl">  rssFullContent: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">  keywords:
</span></span><span class="line"><span class="cl">    - devops
</span></span><span class="line"><span class="cl">    - programming
</span></span><span class="line"><span class="cl">  description: Programming <span class="p">|</span> Devops
</span></span><span class="line"><span class="cl">  logoTitle: ChenSoul
</span></span><span class="line"><span class="cl">  siteLogoImage: images/fly.png
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># headerTitle = &#34;chensoul&#34;                   # default: title</span>
</span></span><span class="line"><span class="cl">  headerImage: images/background.webp
</span></span><span class="line"><span class="cl">  showAuthorCard: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">  showMenuLanguages: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">  autoLoadComments: <span class="nb">false</span>
</span></span><span class="line"><span class="cl">  paginateOriginalStyle: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># The date format to use; for a list of valid formats, see https://gohugo.io/functions/format/</span>
</span></span><span class="line"><span class="cl">  dateFormatToUse: 2006-01-02
</span></span><span class="line"><span class="cl">  google_verification: <span class="s2">&#34;D8XBzUhT4irNUQLKut79HFni0v3Xow4FY-oxUcsUlVk&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># Link custom CSS and JS assets</span>
</span></span><span class="line"><span class="cl">  <span class="c1">#   (relative to /static/css and /static/js respectively)</span>
</span></span><span class="line"><span class="cl">  customCSS: <span class="o">[]</span>
</span></span><span class="line"><span class="cl">  customJS: <span class="o">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">markup:
</span></span><span class="line"><span class="cl">  goldmark:
</span></span><span class="line"><span class="cl">    renderer:
</span></span><span class="line"><span class="cl">      unsafe: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ------------------------------------- #</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ---- Related Articles --------------- #</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ------------------------------------- #</span>
</span></span><span class="line"><span class="cl">related:
</span></span><span class="line"><span class="cl">  <span class="c1"># Only include matches with rank &gt;= threshold. This is a normalized rank between 0 and 100.</span>
</span></span><span class="line"><span class="cl">  threshold: <span class="m">50</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># To get stable &#34;See also&#34; sections we, by default, exclude newer related pages.</span>
</span></span><span class="line"><span class="cl">  includeNewer: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># Will lower case keywords in both queries and in the indexes.</span>
</span></span><span class="line"><span class="cl">  toLower: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  indices:
</span></span><span class="line"><span class="cl">    - name: categories
</span></span><span class="line"><span class="cl">      weight: <span class="m">200</span>
</span></span><span class="line"><span class="cl">    - name: keywords
</span></span><span class="line"><span class="cl">      weight: <span class="m">150</span>
</span></span><span class="line"><span class="cl">    - name: tags
</span></span><span class="line"><span class="cl">      weight: <span class="m">100</span>
</span></span><span class="line"><span class="cl">languages:
</span></span><span class="line"><span class="cl">  zh:
</span></span><span class="line"><span class="cl">    languageCode: zh
</span></span><span class="line"><span class="cl">    languageName: 中文
</span></span><span class="line"><span class="cl">    contentDir: content
</span></span><span class="line"><span class="cl">    weight: <span class="m">1</span>
</span></span><span class="line"><span class="cl">    params:
</span></span><span class="line"><span class="cl">      description: Devops <span class="p">|</span> Programming
</span></span><span class="line"><span class="cl">    menu:
</span></span><span class="line"><span class="cl">      main:
</span></span><span class="line"><span class="cl">        - name: 思考
</span></span><span class="line"><span class="cl">          weight: <span class="m">10</span>
</span></span><span class="line"><span class="cl">          identifier: idea
</span></span><span class="line"><span class="cl">          url: categories/idea/
</span></span><span class="line"><span class="cl">      social:
</span></span><span class="line"><span class="cl">        - name: Telegram
</span></span><span class="line"><span class="cl">          weight: <span class="m">10</span>
</span></span><span class="line"><span class="cl">          identifier: telegram
</span></span><span class="line"><span class="cl">          url: https://t.me/chensoul_share
</span></span><span class="line"><span class="cl">        - name: Twitter
</span></span><span class="line"><span class="cl">          weight: <span class="m">20</span>
</span></span><span class="line"><span class="cl">          identifier: twitter
</span></span><span class="line"><span class="cl">          url: https://twitter.com/chensoul_eth
</span></span><span class="line"><span class="cl">        - name: BiliBili
</span></span><span class="line"><span class="cl">          weight: <span class="m">40</span>
</span></span><span class="line"><span class="cl">          identifier: bilibili
</span></span><span class="line"><span class="cl">          url: https://space.bilibili.com/699805065/
</span></span><span class="line"><span class="cl">      links:
</span></span><span class="line"><span class="cl">        - name: GitHub
</span></span><span class="line"><span class="cl">          weight: <span class="m">10</span>
</span></span><span class="line"><span class="cl">          identifier: github
</span></span><span class="line"><span class="cl">          url: https://github.com/chensoul
</span></span><span class="line"><span class="cl">        - name: Services
</span></span><span class="line"><span class="cl">          weight: <span class="m">20</span>
</span></span><span class="line"><span class="cl">          identifier: services-status
</span></span><span class="line"><span class="cl">          url: https://uptime.chensoul.com/status/services
</span></span><span class="line"><span class="cl">        - name: Analytics
</span></span><span class="line"><span class="cl">          weight: <span class="m">30</span>
</span></span><span class="line"><span class="cl">          identifier: chensoul-analytics
</span></span><span class="line"><span class="cl">          url: https://data.chensoul.com/share/8YKX7FUa/pseudoyu-blog
</span></span></code></pre></div><h2 id="部署">部署</h2>
<h3 id="github-actions部署">GitHub Actions部署</h3>
<p><strong>1、首先在github里创建一个仓库：chensoul.github.io</strong></p>
<p><strong>2、将本地文件提交到github</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">cd</span> chensoul.github.io
</span></span><span class="line"><span class="cl">git init .
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;# chensoul.github.io&#34;</span> &gt;&gt; README.md
</span></span><span class="line"><span class="cl">git remote add origin git@github.com:chensoul/chensoul.github.io.git
</span></span></code></pre></div><p><strong>3、将本地代码推送到仓库</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git commit -m <span class="s2">&#34;first commit&#34;</span>
</span></span><span class="line"><span class="cl">git push -u origin main
</span></span></code></pre></div><p><strong>4、创建 GitHub Actions 的 workflow</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkdir -p .github/workflows
</span></span><span class="line"><span class="cl">touch .github/workflows/gh-page.yml
</span></span></code></pre></div><p>gh-page.yml内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">github pages</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">workflow_dispatch</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">hugo</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">deploy</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-18.04</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">timeout-minutes</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Checkout</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">submodules</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="c"># Fetch Hugo themes (true OR recursive)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">fetch-depth</span><span class="p">:</span><span class="w"> </span><span class="m">0</span><span class="w">    </span><span class="c"># Fetch all history for .GitInfo and .Lastmod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Setup hugo</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">peaceiris/actions-hugo@v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">hugo-version</span><span class="p">:</span><span class="w"> </span><span class="l">latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">extended</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">hugo --minify</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Deploy</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">peaceiris/actions-gh-pages@v3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">github_token</span><span class="p">:</span><span class="w"> </span><span class="l">${{ secrets.GITHUB_TOKEN }}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">publish_branch</span><span class="p">:</span><span class="w"> </span><span class="l">gh-pages</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">publish_dir</span><span class="p">:</span><span class="w"> </span><span class="l">./public</span><span class="w">
</span></span></span></code></pre></div><p>上面的工作流是在 gh-pages 分支上触发，当有代码提交时候，会运行 hugo 命令生成静态文件（public目录），并且将他们推送到main分支。</p>
<p>所以，我们需要基于当前分支创建一个新分支 gh-pages ，并且推送到远程仓库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git branch gh-pages
</span></span><span class="line"><span class="cl">git checkout gh-pages
</span></span><span class="line"><span class="cl">git push origin gh-pages
</span></span></code></pre></div><p><strong>5、修改代码，推送到仓库，触发工作流</strong></p>
<p>在本地修改某个文件，提交代码，然后在 github <a href="https://github.com/chensoul/chensoul.github.io/actions">网站</a> 查看工作流</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git push origin gh-pages
</span></span></code></pre></div><p><strong>7、设置自定义域名</strong></p>
<p>参考<a href="https://docs.github.com/cn/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-a-subdomain">管理 GitHub Pages 站点的自定义域</a>，添加一个自定义域名：blog.chensoul.com：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/github-page-settings.png" alt="github-page-settings"  />
</p>
<p>或者，在仓库的 static 目录创建一个CNAME文件，内容为：blog.chensoul.com，然后，保存提交，Github Actions会将该文件推送到main分支。</p>
<p>然后，在亚马逊网站添加 <a href="https://console.aws.amazon.com/route53/v2/hostedzones#">CNAME记录</a>：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/amazon-dns-settings.png" alt="amazon-dns-settings"  />
</p>
<p>8、部署到 CloudFlare Pages</p>
<p>参考 <a href="https://hee.ink/p/%E4%BB%8E-github-pages-%E8%BF%81%E7%A7%BB%E5%88%B0-cloudflare-pages-%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/">从 GitHub Pages 迁移到 CloudFlare Pages 的体验与踩坑小记</a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
