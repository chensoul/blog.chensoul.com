<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>java | ChenSoul</title>
<meta name=keywords content><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/tags/java/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/tags/java/index.xml><meta name=twitter:title content="java | ChenSoul"><meta name=twitter:description content><meta property="og:title" content="java | ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/tags/java/"><meta property="og:site_name" content="ChenSoul"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-tags kind-term layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签 class=active>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><header class=page-header><h1>tag: java</h1><div class=inline-links><span><a href=https://blog.chensoul.cc/tags/java/index.xml target=_blank>RSS</a></span></div></header><article class="post-entry tag-entry"><header class=entry-header><h2>2023-12-19｜Spring Security OAuth2配置JWT、Github Actions配置代码扫描</h2></header><section class=entry-content><p>Today I Learned. 今天分享内容：Spring Security OAuth2 配置JWT、Github Actions配置代码扫描，另外，修改了 spring-security-oauth2-legacy 仓库，支持授权认证中心的多种配置方式（jdbc、内存、redis、jwt）、资源中心的多种配置方式（jwt、jdbc、redis、remote、jwk-set-uri）。
Spring Security OAuth2 配置JWT 使用 Spring Security 实现OAuth2 配置 JWT 非对称加密时， JwtAccessTokenConverter 设置生成私钥签名和公钥验证器（可省略）。
@Bean public JwtAccessTokenConverter jwtAccessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); // 设置私钥签名 converter.setSigner(new RsaSigner((RSAPrivateKey) new RSA("privateKey", null).getPrivateKey())); // 设置公钥验证器，可省略 converter.setVerifier(new RsaVerifier((RSAPublicKey) new RSA(null, "publicKey").getPublicKey())); return jwtAccessTokenConverter; } 注意：这里使用了 Hutool 的 RSA 从字符串生成 PrivateKey 和 PublicKey
去掉对 Hutool 的依赖，则可以使用自己实现的 RSAUtil 类：
public class RSAUtil { public static final String ALGORITHM_KEY = "RSA"; @SneakyThrows public static PrivateKey getPrivateKeyFromString(String privateKeyStr) { byte[] privateKeyBytes = Base64.getDecoder().decode(privateKeyStr.replaceAll("\n", "")); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes); KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_KEY); return keyFactory.generatePrivate(keySpec); } @SneakyThrows public static PublicKey getPublicKeyFromString(String publicKeyStr) { byte[] publicKeyBytes = Base64....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-12-19</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/github/>github</a><a href=https://blog.chensoul.cc/tags/spring-security/>spring security</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to 2023-12-19｜Spring Security OAuth2配置JWT、Github Actions配置代码扫描" href=https://blog.chensoul.cc/posts/2023/12/19/til/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>2023-12-18｜使用Spring Security实现OAuth2授权和认证</h2></header><section class=entry-content><p>Today I Learned. 今天分享内容：使用Spring Security实现OAuth2授权和认证。
最近在开发 Spring Cloud 微服务时，需要对 OAuth2 的异常处理进行定制，从网上搜到一个 github 仓库：oauth2。这篇仓库的代码实现了 OAuth2 的四种授权模式、I18N 国际化、异常处理、JWT Token，我 fork 了一份代码，做了一些改动，去掉了 webflux、eureka 相关代码。
代码仓库地址：https://github.com/chensoul/spring-security-oauth2-legacy，相关依赖的版本：
spring-boot: 2.7.18 org.springframework.security.oauth:spring-security-oauth2-autoconfigure: 2.6.8 org.springframework.security.oauth:spring-security-oauth2: 2.5.2.RELEASE org.springframework.security:spring-security-jwt 1.1.1.RELEASE 特性 统一异常处理 参考spring security的 ExceptionTranslationFilter 类
异常处理类 AccessDeniedHandler AuthenticationEntryPoint jwt key生成 生成 JKS 文件 keytool -genkeypair -alias myalias -storetype PKCS12 -keyalg RSA -keypass mypass -keystore mykeystore.jks -storepass mypass -validity 3650 导出公钥 # 保存为 public.cer 文件： keytool -exportcert -alias myalias -storepass mypass -keystore mykeystore.jks -file public.cer # 保存为 public.key 文件 keytool -list -rfc --keystore mykeystore.jks -storepass mypass | openssl x509 -inform pem -pubkey > public.key 导出私钥，将其保存为 private.key 文件： keytool -importkeystore -srckeystore mykeystore....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-12-18</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/spring-security/>spring security</a><a href=https://blog.chensoul.cc/tags/oauth2/>oauth2</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to 2023-12-18｜使用Spring Security实现OAuth2授权和认证" href=https://blog.chensoul.cc/posts/2023/12/18/til/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>2023-12-15｜JNDI InitialContext源码分析、ClassLoader加载机制</h2></header><section class=entry-content><p>Today I Learned. 今天分享内容：JNDI InitialContext源码分析、ClassLoader加载机制。
JNDI InitialContext 源码分析 JNDI包结构 javax.naming
Context InitialContext Name CompositeName CompoundName NameImpl NameParser NamingEnumeration Referenceable RefAddr BinaryRefAddr StringRefAddr NameClassPair Binding Reference LinkRef javax.naming.directory
Attribute
BasicAttribute Attributes
BasicAttributes DirContext
InitialDirContext ModificationItem
SearchControls
SearchResult
javax.naming.spi
NamingManager DirectoryManager ObjectFactory DirObjectFactory ObjectFactoryBuilder StateFactory DirStateFactory InitialContextFactory InitialContextFactoryBuilder Resolver ContinuationContext ContinuationDirContext ResolveResult InitialContext 构造方法 InitialContext的初始化有几种方式：
通过构造方法 通过 InitialContextFactory#getInitialContext 通过协议转换创建 InitialContext.getURLOrDefaultInitCtx(String name) 一个 JNDI 示例：
public class DNSClient { public static void main(String[] args) { Hashtable&lt;String, String> env = new Hashtable&lt;>(); env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.dns.DnsContextFactory"); env.put(Context.PROVIDER_URL, "dns://114.114.114.114"); try { DirContext ctx = new InitialDirContext(env); Attributes res = ctx.getAttributes("example.com", new String[]{"A"}); System.out.println(res); } catch (NamingException e) { e....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-12-15</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/jndi/>jndi</a><a href=https://blog.chensoul.cc/tags/classloader/>classloader</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>5 min</span></span></footer><a class=entry-link aria-label="post link to 2023-12-15｜JNDI InitialContext源码分析、ClassLoader加载机制" href=https://blog.chensoul.cc/posts/2023/12/15/til/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>All things about MicroProfile</h2></header><section class=entry-content><p>最近在一些开源项目中看到了 MicroProfile ，于是在网上查阅了相关资料加深对 MicroProfile 的理解，并做了笔记形成此文。
MicroProfile MicroProfile是一个开放的企业级Java微服务框架，旨在简化和标准化基于微服务架构的应用程序开发。它是由Eclipse Foundation主导的一个开源项目，致力于提供轻量级、可移植和可互操作的Java微服务规范和实现。
MicroProfile的目标是为Java开发人员提供一个规范集合，使他们能够更轻松地构建和部署云原生应用程序。它结合了Java EE、Jakarta EE和其他相关规范，为开发人员提供了一组核心功能和扩展，以支持构建可伸缩、弹性和高性能的微服务应用程序。
MicroProfile提供了一系列的规范，包括：
MicroProfile Config MicroProfile JWT RBAC MicroProfile Health MicroProfile Fault Tolerance MicroProfile Metrics MicroProfile OpenAPI MicroProfile OpenTracing MicroProfile REST Client MicroProfile Context Propagation MicroProfile Reactive Streams Operators MicroProfile Reactive Messaging MicroProfile GraphQL MicroProfile Long Running Actions MicroProfile Telemetry MicroProfile 实现：
Payara Micro：是一个用于容器化Jakarta EE应用部署的轻量级中间件平台，不需要安装、配置或重写代码，可以快速部署 WildFly by Redhat：是一个轻量级、模块化的微服务框架，集中、简单、以用户为中心，实现了Jakarta EE和Eclipse MicroProfile的最新企业Java标准。 Quarkus by RedHat：为GraalVM和OpenJDK HotSpot构建的Kubernetes Native Java堆栈，由最佳的Java库和标准精心打造。 Apache TomEE：这是Apache Tomcat Java企业版，它结合了几个Java企业项目，包括Apache OpenEJB、Apache OpenJPA、Apache OpenWebBeans、Apache MyFaces和其他许多项目。 Hammock：这是一个基于CDI的bootstrapping Java企业微服务框架，由于其灵活性和简单性，用于构建应用程序 Openliberty：是一个开源的轻量级Java EE微服务框架，用于构建快速高效的云原生Java微服务应用，只运行所需的服务，同时考虑最新的Eclipse MicroProfile标准 Helidon by Oracle：这是一个Java库的集合，用于编写在快速的Helidon Reactive WebServer上运行的Java微服务，这是一个由Netty驱动的Web核心，同时支持MicroProfile及其标准规范。 KumuluzEE：是一个轻量级框架，用于使用标准的Java/JavaEE/JakartaEE/EE4J技术和API开发微服务，可选择扩展，如使用Node.js、Go和其他语言，并将现有应用程序迁移到云原生架构和微服务，以便更容易地进行云原生微服务开发。 Launcher by Fujitsu：它由富士通公司开发，是一个支持某些MicroProfile规范的Java EE微服务框架，可以将应用捆绑到über-jar/fat文件（JAR文件，包含其所有需要的依赖项） ThornTail (过时的)：是一个Java企业级微服务框架，它只将需要的和指定的包捆绑到一个JAR文件中，并有足够的运行时间来运行它们 MicroProfile发展历史 Infoq 上有一段介绍：
2016 年年中，作为对 Oracle 在发布 Java EE 8 方面停滞不前的直接回应，社区发起了两个新的倡议，也就是MicroProfile和 Java EE Guardians（现在被称为Jakarta EE Ambassadors）。Java 社区认为，随着用于构建微服务应用的 web 服务技术的出现，企业级 Java 已经落后于时代了。...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-12-14</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/microprofile/>microprofile</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to All things about MicroProfile" href=https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>2023-12-12｜RMI、Java漏洞安全、Semgrep漏洞检测</h2></header><section class=entry-content><p>Today I Learned. 今天我学了：RMI、Java漏洞安全、Semgrep漏洞检测。
RMI 介绍 RMI（Remote Method Invocation）是Java语言提供的一种远程调用机制，用于在分布式系统中实现对象之间的远程通信。
通过Java RMI，开发人员可以像调用本地方法一样调用远程对象的方法。RMI隐藏了底层网络通信的复杂性，使得远程方法调用过程对于开发人员来说更加简单和透明。
发展历史 RMI（Remote Method Invocation）是Java语言提供的一种远程调用机制，它的发展历史可以追溯到上个世纪90年代。
以下是RMI的主要发展历程：
初期版本（Java 1.1）：RMI最早出现在Java 1.1版本中，它提供了基本的远程调用功能，允许开发人员在分布式系统中使用Java对象进行远程方法调用。这个版本的RMI还比较简单，功能相对有限。 RMI-IIOP（Java 1.2）：随着Java 1.2版本的发布，Sun Microsystems（现在的Oracle）引入了RMI-IIOP（RMI over IIOP）的概念，将RMI与CORBA（Common Object Request Broker Architecture）进行了整合。RMI-IIOP使用IIOP（Internet Inter-ORB Protocol）作为底层的通信协议，使得Java对象能够与其他编程语言的对象进行交互。 JDK 1.3和1.4的改进：在JDK 1.3和1.4版本中，RMI得到了进一步改进和增强。其中包括对Java序列化机制的改进，提供了更好的兼容性和性能。此外，还引入了Java Activation Framework（JAF），用于处理传输的数据类型。 Java 5的增强：Java 5引入了一些重要的增强功能，如注解（Annotations）和泛型（Generics）。这些功能使得RMI的使用更加便捷和灵活。 Java 8和后续版本：在Java 8及其后续版本中，RMI并没有进行大规模的改动。然而，随着Java平台的不断发展和改进，RMI仍然是Java分布式系统中常用的远程调用机制之一。 架构 RMI架构包括以下几个核心组件：
远程接口（Remote Interface）：远程接口定义了远程对象的方法列表，客户端可以通过该接口调用远程对象的方法。远程接口必须继承java.rmi.Remote接口，并声明可以被远程调用的方法。 远程对象（Remote Object）：远程对象是实现了远程接口的Java对象。这些对象的方法可以通过RMI进行远程调用。远程对象必须继承java.rmi.server.UnicastRemoteObject类，并实现对应的远程接口。 远程注册表（Remote Registry）：远程注册表是一个中央注册表，用于存储远程对象的引用。客户端可以查询远程注册表以获取远程对象的引用，并通过引用调用远程对象的方法。远程注册表使用RMI注册表服务（rmiregistry）来实现。 Stub（存根）和Skeleton（骨架）：Stub和Skeleton是RMI的关键组件，用于在客户端和服务器之间进行通信。Stub是客户端的代理，它负责将客户端的方法调用转发到远程对象。Skeleton是服务器端的代理，它负责接收客户端的方法调用并将其转发给实际的远程对象。 RMI协议（RMI Protocol）：RMI协议定义了客户端和服务器之间的通信协议，包括请求、响应、参数传递和序列化等细节。RMI协议使用Java序列化来对对象进行编码和解码，以实现对象在网络上的传输。 RMI架构的基本工作流程如下：
服务器端将远程对象注册到远程注册表中。 客户端从远程注册表中获取远程对象的引用。 客户端通过引用调用远程对象的方法。 客户端的方法调用被转发到服务器端的远程对象。 服务器端的远程对象执行相应的方法，并将结果返回给客户端。 客户端接收到方法的返回值。 在JDK 1.2版本（1998）之后，骨架skeleton不再被需要, 由Java的UnicastServerRef#dispatch替代；在JDK 5 （大家常说的1.5）之后，不再需要手动利用rmic命令生成静态Stub，而是会由Java自动地动态生成。这个动态生成也是我们后面JNDI注入的关键。
RMI漏洞 RMI（Remote Method Invocation）在过去的一段时间中曾发现一些安全漏洞，这些漏洞可能会导致安全风险。以下是一些常见的RMI漏洞：
反序列化漏洞：RMI使用Java序列化机制来在网络上传输对象。然而，如果不正确地处理反序列化过程，攻击者可能通过构造恶意序列化数据来执行远程代码。这种漏洞被广泛称为"Java反序列化漏洞"或"Java反序列化攻击"，并且不仅仅影响RMI，还可能影响其他使用Java序列化的技术。 未授权访问漏洞：RMI服务默认情况下可能没有进行适当的身份验证和授权检查。这可能导致攻击者能够未经授权地访问远程对象和调用方法，从而造成安全风险。 注册表绕过漏洞：RMI使用注册表（Registry）来存储远程对象的引用。攻击者可能通过绕过注册表或篡改注册表中的引用，来执行恶意操作或替换原始对象。 未加密的通信漏洞：如果RMI的通信过程没有适当地加密和保护，攻击者可能能够窃听、篡改或重放网络通信，从而获取敏感信息或执行中间人攻击。 为了缓解这些漏洞的风险，建议采取以下安全措施：
及时更新和升级使用的Java运行时环境，以获取最新的安全修复程序。JDK 8u121引入了对RMI漏洞的修复。 在反序列化过程中谨慎处理输入数据，避免接受未受信任的序列化数据。 实施适当的身份验证和授权机制，确保只有经过授权的用户可以访问和调用远程对象。 使用安全协议（如SSL/TLS）对RMI通信进行加密和保护。 配置和限制RMI的网络访问，仅允许受信任的主机和端口进行通信。 对RMI注册表进行安全配置，限制对注册表的访问权限。 RMI用到的技术 Java序列化（Serialization）：RMI使用Java序列化来实现对象在网络上的传输。Java序列化机制允许将Java对象转换为字节流表示，以便在网络上进行传输。RMI使用Java序列化将方法调用和参数编码为字节流，并在客户端和服务器之间进行传输。 Java网络通信（Network Communication）：RMI使用Java的网络通信机制来在客户端和服务器之间进行远程调用的传输。RMI支持多种底层传输协议，如JRMP（Java Remote Method Protocol）和IIOP（Internet Inter-ORB Protocol）。这些协议负责将编码的方法调用和参数传输到远程对象，并将结果返回给客户端。 代理。Stub和Skeleton是RMI中的代理组件。Stub是客户端的代理，Skeleton是服务器端的代理。Stub负责将客户端的方法调用转发到远程对象，而Skeleton接收客户端的方法调用并将其转发给实际的远程对象。Stub和Skeleton处理了网络通信、参数编组和解组等细节，使得远程调用过程对开发人员透明。 Java漏洞 文章 关于Java中RMI的个人拙见
Java JNDI其它注入点分析
Java JNDI注入源码分析
Java RMI反序列化&amp;JNDI注入...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-12-12</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/rmi/>rmi</a><a href=https://blog.chensoul.cc/tags/semgrep/>semgrep</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to 2023-12-12｜RMI、Java漏洞安全、Semgrep漏洞检测" href=https://blog.chensoul.cc/posts/2023/12/12/til/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>JHipster安装和介绍</h2></header><section class=entry-content><p>JHipster 是一个开发平台，可以快速生成，开发和部署现代 Web 应用程序+微服务架构。
JHipster 或者称 Java Hipster，是一个应用代码产生器，能够创建 Spring Boot/Spring Cloud + React/VueJs/AngularJS 的应用。使用 JHipster，首先你要配置好 Java 、Git 以及 Maven 或者 Gradle 的环境，然后通过 NodeJs 管理工具安装 JHipster 。
介绍 JHipster 官网： https://www.jhipster.tech/ ，截止本文发布时，最新版本为 8.0.0 。
JHipster 客户端使用到的技术栈有：
服务端使用的技术栈有：
支持以下部署方式：
JHipster 提供了一个 CLI 工具 generator-jhipster 和在线网站 https://start.jhipster.tech/ ，来创建应用。generator-jhipster 支持本地安装和 docker 安装两种方式。另外，还有一个轻量级的定制工具 jhipseter-lite 可以更细力度的定制。
JHipster Pro 是一个 JHipster 国内落地方案，符合国情的代码生成器解决方案，支持 MyBatis、SMS、OSS。当前最新版本对应 JHipster 官方版本：v7.1.0，网站最近一次跟新是在 2021 年 8 月份。
安装 generator-jhipster 前提条件安装 Java 和 NodeJs，然后通过 npm 或者 yarn 安装 generator-jhipster。以下是通过 npm 安装：
npm install -g generator-jhipster 查看版本：
$ npx jhipster --version 8.0.0-rc.1 另外，可以在 docker 里面安装：
docker image pull jhipster/jhipster docker container run --name jhipster -v ~/jhipster:/home/jhipster/app -v ~/....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-11-02</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/jhipster/>jhipster</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>6 min</span></span></footer><a class=entry-link aria-label="post link to JHipster安装和介绍" href=https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Java设计模式：Circuit Breaker</h2></header><section class=entry-content><p>本文主要介绍 Circuit Breaker 断路器模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。
在一个分布式系统中，不可避免地会出现许多外部依赖，如数据库、网络服务等。这些外部依赖可能会发生故障、延迟或不可用的情况。如果没有适当的措施，这些故障可能会导致整个系统的性能下降，甚至系统崩溃。
断路器模式通过在应用程序和外部依赖之间引入一个断路器接口来解决这个问题。断路器接口充当一个中间层，监视对外部依赖的调用。当外部依赖发生故障时，断路器可以迅速地中断对外部依赖的调用，避免资源的浪费和故障的传递。
除了断路器接口之外，断路器模式还涉及以下几个重要的知识点：
故障阈值（Failure Threshold）：断路器模式通过设置故障阈值来判断服务的健康状态。当服务的失败次数达到或超过故障阈值时，断路器会打开，阻止对服务的进一步调用。 回退响应（Fallback Response）：当断路器打开时，可以为调用方提供回退响应。回退响应是一个预定义的响应，用于代替无法正常调用的服务的响应。回退响应可以是事先定义好的静态响应，或者是通过调用备用服务来获取的响应。 断路器状态（Circuit Breaker State）：断路器可以处于不同的状态，如关闭（Closed）、打开（Open）和半开（Half-Open）。初始状态通常是关闭状态，表示服务正常可用。当服务的失败次数达到故障阈值时，断路器会打开，阻止对服务的进一步调用。在一定时间后，断路器会进入半开状态，允许发起一次测试调用。如果测试调用成功，断路器将重新关闭；如果测试调用仍然失败，断路器将重新打开。 断路器的自动恢复（Automatic Recovery）：断路器模式通常具有自动恢复功能。在断路器打开的状态下，一段时间过去后，断路器会尝试重新关闭，以允许对服务的正常调用。自动恢复可以防止长时间的服务中断，提供给服务一个机会来恢复正常运行。 健康检查（Health Check）：断路器模式可以通过定期的健康检查来监控服务的状态。健康检查可以是定期发送心跳请求或执行一些特定的健康检查操作。通过健康检查，可以及时发现服务的故障或不可用状态，并相应地打开断路器。 示例 首先，您需要创建一个监控服务类，它将使用断路器来包装远程服务的调用。以下是一个示例监控服务类的代码：
public class MonitoringService { private final CircuitBreaker delayedService; private final CircuitBreaker quickService; public MonitoringService(CircuitBreaker delayedService, CircuitBreaker quickService) { this.delayedService = delayedService; this.quickService = quickService; } public String localResourceResponse() { return "Local Service is working"; } public String delayedServiceResponse() { try { return this.delayedService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } public String quickServiceResponse() { try { return this.quickService.attemptRequest(); } catch (RemoteServiceException e) { return e.getMessage(); } } } 在上述代码中，MonitoringService 类接受两个断路器对象作为参数，分别用于包装延迟服务和快速服务的远程调用。它还包含一个用于获取本地资源的方法。...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-10-26</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>5 min</span></span></footer><a class=entry-link aria-label="post link to Java设计模式：Circuit Breaker" href=https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Java设计模式：Chain</h2></header><section class=entry-content><p>本文主要介绍 Chain 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
目的 通过给多个对象一个处理请求的机会，避免请求的发送者和它的接收者耦合。串联接收对象并在链条中传递请求直到一个对象处理它。
介绍 责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象按照顺序处理请求，直到其中一个对象能够处理该请求为止。该模式将请求发送者和接收者解耦，使多个对象都有机会处理请求，同时避免请求发送者与接收者之间的直接耦合。
在责任链模式中，通常会构建一个处理请求的链条，链条上的每个对象都有一个指向下一个对象的引用。当请求到达链条的起点时，它会依次经过链条上的每个对象，直到找到能够处理请求的对象为止。每个对象都可以决定是否处理请求，或者将请求传递给下一个对象。
以下是责任链模式的几个关键角色：
抽象处理器（Handler）：定义处理请求的接口，并包含一个指向下一个处理器的引用。通常会提供一个处理请求的方法。 具体处理器（ConcreteHandler）：实现抽象处理器的接口，具体处理请求的逻辑。如果自己无法处理请求，则将请求传递给下一个处理器。 客户端（Client）：创建责任链，并将请求发送给链条的起点。 下面是一个示例，说明如何使用责任链模式处理请求：
// 抽象处理器 public abstract class Handler { protected Handler nextHandler; public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } public abstract void handleRequest(Request request); } // 具体处理器 public class ConcreteHandler1 extends Handler { @Override public void handleRequest(Request request) { if (满足处理条件) { // 处理请求的逻辑 } else if (nextHandler != null) { // 将请求传递给下一个处理器 nextHandler.handleRequest(request); } } } // 具体处理器2和具体处理器3的定义与具体处理器1类似 // 客户端 public class Client { public static void main(String[] args) { Handler handler1 = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); Handler handler3 = new ConcreteHandler3(); // 构建责任链 handler1....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-10-16</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to Java设计模式：Chain" href=https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Java设计模式：Callback</h2></header><section class=entry-content><p>本文主要介绍 Callback 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 回调（Callback）是一种设计模式，在这种模式中，一个可执行的代码被作为参数传递给其他代码，接收方的代码可以在适当的时候调用它。
在真实世界的例子中，当我们需要在任务完成时被通知时，我们可以将一个回调方法传递给调用者，并等待它调用以通知我们。简单地说，回调是一个传递给调用者的方法，在定义的时刻被调用。
维基百科说
在计算机编程中，回调又被称为“稍后调用”函数，可以是任何可执行的代码用来作为参数传递给其他代码；其它代码被期望在给定时间内调用回调方法。
代码 回调是一个只有一个方法的简单接口。
public interface Callback { void call(); } 下面我们定义一个任务它将在任务执行完成后执行回调。
public abstract class Task { final void executeWith(Callback callback) { execute(); Optional.ofNullable(callback).ifPresent(Callback::call); } public abstract void execute(); } public final class SimpleTask extends Task { private static final Logger LOGGER = getLogger(SimpleTask.class); @Override public void execute() { LOGGER.info("Perform some important activity and after call the callback method."); } } 最后这里是我们如何执行一个任务然后接收一个回调当它完成时。
var task = new SimpleTask(); task.executeWith(() -> LOGGER.info("I'm done now.")); 类图 适用场景 回调模式适用于以下场景：
异步操作：当需要在异步操作完成后执行某些操作时，可以使用回调模式。例如，在网络请求中，可以传递一个回调函数，在请求完成后调用该函数处理响应数据。 事件处理：当需要对事件进行响应和处理时，可以使用回调模式。例如，在图形界面开发中，可以注册某个控件的回调函数，以便在用户触发事件时执行相应的操作。 插件扩展：当需要为应用程序提供扩展性，允许第三方插件在特定事件发生时进行自定义操作时，可以使用回调模式。例如，游戏引擎中的事件系统允许开发者注册回调函数以响应游戏中的特定事件。 回调链：当需要按特定顺序执行多个回调函数，并将前一个回调函数的结果传递给下一个回调函数时，可以使用回调模式。这种情况下，回调函数形成了一个回调链。 模板方法模式：回调模式常与模板方法模式结合使用。模板方法模式定义了一个算法的骨架，而具体的步骤由子类实现。可以使用回调模式将子类中的具体步骤作为回调函数传递给模板方法。 总的来说，回调模式适用于需要在特定事件发生后执行某些操作的情况，以及需要实现解耦和灵活性的场景。它提供了一种在代码间通信的方式，使得代码可以更加模块化和可复用。
Java 例子 CyclicBarrier 构造函数可以接受回调，该回调将在每次障碍被触发时触发。 FAQ 回调模式如何实现解耦和灵活性？ 回调模式通过将一个可执行的代码块（回调函数）作为参数传递给其他代码，实现了解耦和灵活性。
解耦性：回调模式可以将调用方与被调用方解耦，使它们之间的关系更加松散。调用方只需要知道回调函数的接口，而不需要了解具体的实现细节。被调用方在特定的时机调用回调函数，而不需要知道调用方的具体实现。这种解耦性使得系统中的不同部分可以独立地进行修改和扩展，而不会对彼此产生过多的依赖。
灵活性：回调模式提供了一种灵活的扩展机制。通过传递不同的回调函数，可以改变程序的行为或逻辑，而不需要修改原有的代码。这种灵活性使得系统可以适应不同的需求和变化，而不需要进行大规模的修改或重构。同时，回调模式也允许在运行时动态地修改回调函数，从而实现更高级的动态行为。...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-10-13</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to Java设计模式：Callback" href=https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]Spring Boot3和Spring6中的新特性</h2></header><section class=entry-content><p>Spring Boot 3.0 于 2022 年 11 月正式发布，包含一些新功能和改进。这是继大约 4.5 年前发布 Spring Boot 2.0 后 Spring Boot 的第一个主要版本。它也是第一个支持 Spring Framework 6.0 的 Spring Boot GA 版本。作为开发人员，我们需要了解这些更新，才能顺利使用 Spring Boot。毫无疑问，新版本中最大的转变之一是放弃了对旧版本 Java 的支持。
在本文中，我们将讨论“Spring Boot 3 和 Spring 6 中的新功能”。
Spring 3.0 版本有哪些主要亮点？ Spring 3.0 版本的亮点包括：
Java 17 基线 支持 Jakarta EE 10 和 EE 9 基线 支持使用 GraalVM 生成本机映像，取代实验性 Spring Native 项目 通过测微计和测微计追踪提高了可观测性 谁可以真正使用 Spring Boot 3？ 如前所述，Spring Boot 3.0 最大的转变是忽略了对旧版本 Java 的支持。是的，我们至少需要 Java 17 才能使用 Spring Boot 3.0。因此，在使用 Spring Boot 3.0 之前必须具备 JDK 17 环境。
Spring Boot 3 和 Spring 6 有哪些新功能？ 这里需要注意的重要一点是 Spring Boot 3.0 构建于 Spring Framework 6 之上并需要 Spring Framework 6。因此，如果您的 pom....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-10-13</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>java</a><a href=https://blog.chensoul.cc/tags/spring-boot/>spring boot</a><a href=https://blog.chensoul.cc/tags/spring/>spring</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>4 min</span></span></footer><a class=entry-link aria-label="post link to [译]Spring Boot3和Spring6中的新特性" href=https://blog.chensoul.cc/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://blog.chensoul.cc/tags/java/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>