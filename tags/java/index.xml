<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>java on ChenSoul</title>
    <link>https://blog.chensoul.com/tags/java/</link>
    <description>Recent content in java on ChenSoul</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 05 May 2023 09:00:00 +0800</lastBuildDate><atom:link href="https://blog.chensoul.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《Effective Java 3》笔记7：排除过时的对象引用</title>
      <link>https://blog.chensoul.com/posts/2023/05/05/eliminate-obsolete-object-references/</link>
      <pubDate>Fri, 05 May 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/05/eliminate-obsolete-object-references/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。 介绍 &amp;ldquo;Eliminate obsolete object references&amp;rdquo; 是一条Java编程最佳实践的原则，指的是在代码中及时清理不</description>
      <content:encoded><![CDATA[<p>本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。</p>
<h2 id="介绍">介绍</h2>
<p>&ldquo;Eliminate obsolete object references&rdquo; 是一条Java编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为null，这样JVM可以及时回收它所占用的内存。</p>
<p>考虑以下简单的堆栈实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.EmptyStackException</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Can you spot the &#34;memory leak&#34;?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Stack</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">elements</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Stack</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="n">Object</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ensureCapacity</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">++]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="k">new</span> <span class="n">EmptyStackException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">elements</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Ensure space for at least one more element, roughly
</span></span></span><span class="line"><span class="cl"><span class="cm">     * doubling the capacity each time the array needs to grow.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">ensureCapacity</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">elements</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">size</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">elements</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">elements</span><span class="o">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这个程序没有明显的错误。你可以对它进行详尽的测试，它会以优异的成绩通过所有的测试，但是有一个潜在的问题。简单地说，该程序有一个「内存泄漏」问题，由于垃圾收集器活动的增加或内存占用的增加，它可以悄无声息地表现为性能的降低。在极端情况下，这种内存泄漏可能导致磁盘分页，甚至出现 OutOfMemoryError 程序故障，但这种故障相对少见。</p>
<p>那么内存泄漏在哪里呢？如果堆栈增长，然后收缩，那么从堆栈中弹出的对象将不会被垃圾收集，即使使用堆栈的程序不再引用它们。这是因为栈保留了这些对象的旧引用。一个过时的引用，是指永远不会被取消的引用。在本例中，元素数组的「活动部分」之外的任何引用都已过时。活动部分由索引小于大小的元素组成。</p>
<p>垃圾收集语言中的内存泄漏（更确切地说是无意的对象保留）是暗藏的风险。如果无意中保留了对象引用，那么对象不仅被排除在垃圾收集之外，该对象引用的任何对象也被排除在外，依此类推。即使只是无意中保留了一些对象引用，许多许多的对象也可能被阻止被垃圾收集，从而对性能产生潜在的巨大影响。</p>
<p>解决这类问题的方法很简单：一旦引用过时，就将置空。在我们的 Stack 类中，对某个项的引用一旦从堆栈中弹出就会过时。pop 方法的正确版本如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">Object</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="n">EmptyStackException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">elements</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// Eliminate obsolete reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>用 null 处理过时引用的另一个好处是，如果它们随后被错误地关联引用，程序将立即失败，出现 NullPointerException，而不是悄悄地做错误的事情。尽可能快地检测编程错误总是有益的。</p>
<p>那么，什么时候应该取消引用呢？Stack 类的哪些方面容易导致内存泄漏？简单地说，它管理自己的内存。存储池包含元素数组的元素（对象引用单元，而不是对象本身）数组的活动部分（如前面所定义的）中的元素被分配，而数组其余部分中的元素是空闲的。垃圾收集器没有办法知道这一点；对于垃圾收集器，元素数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。只要数组元素成为非活动部分的一部分，程序员就可以通过手动清空数组元素，有效地将这个事实传递给垃圾收集器。</p>
<p>一般来说，一个类管理它自己的内存时，程序员应该警惕内存泄漏。当释放一个元素时，该元素中包含的任何对象引用都应该被置为 null。</p>
<p><strong>另一个常见的内存泄漏源是缓存。</strong> 一旦将对象引用放入缓存中，就很容易忘记它就在那里，并且在它变得无关紧要之后很久仍将它留在缓存中。有几个解决这个问题的办法。如果你非常幸运地实现了一个缓存，只要缓存外有对其键的引用，那么就将缓存表示为 WeakHashMap；当条目过时后，条目将被自动删除。记住，WeakHashMap 只有在缓存条目的预期生存期由键的外部引用（而不是值）决定时才有用。</p>
<p>更常见的情况是，缓存条目的有效生存期定义不太好，随着时间的推移，条目的价值会越来越低。在这种情况下，缓存偶尔应该清理那些已经停用的条目。这可以通过后台线程（可能是 <code>ScheduledThreadPoolExecutor</code>）或向缓存添加新条目时顺便完成。LinkedHashMap 类通过其 <code>removeEldestEntry</code> 方法简化了后一种方法。对于更复杂的缓存，你可能需要直接使用 <code>java.lang.ref</code>。</p>
<p><strong>内存泄漏的第三个常见来源是侦听器和其他回调。</strong> 如果你实现了一个 API，其中客户端注册回调，但不显式取消它们，除非你采取一些行动，否则它们将累积。确保回调被及时地垃圾收集的一种方法是仅存储对它们的弱引用，例如，将它们作为键存储在 WeakHashMap 中。</p>
<h3 id="如何排除过时对象引用">如何排除过时对象引用</h3>
<p>以下是一些示例，展示了如何使用Java语言中的一些技术来排除过时的对象引用。</p>
<ol>
<li>在循环中使用局部变量</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do something with str
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，我们使用局部变量<code>str</code>来引用列表中的元素，而不是重复地使用<code>list.get(i)</code>。这样，当循环结束时，<code>str</code>的引用将被自动清除，避免了过时的对象引用。</p>
<ol start="2">
<li>在使用完对象后及时清除引用</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">SomeObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SomeObject</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// do something with obj
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// clear the reference to obj
</span></span></span></code></pre></div><p>在这个示例中，我们在使用完对象后立即将其引用设置为null，以便JVM可以及时回收它所占用的内存。如果不清除引用，对象将一直存在于内存中，直到JVM进行垃圾回收。</p>
<ol start="3">
<li>使用弱引用</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">SomeObject</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="n">SomeObject</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">SomeObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// do something with obj
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// clear the reference to obj
</span></span></span></code></pre></div><p>在这个示例中，我们使用了一个弱引用来引用对象，以便在对象不再被强引用时可以被及时回收。当我们需要使用对象时，可以通过弱引用获取对象的引用，使用完后及时将其引用设置为null。</p>
<ol start="4">
<li>使用try-with-resources语句</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">try</span> <span class="o">(</span><span class="n">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&#34;file.txt&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do something with in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，我们使用了try-with-resources语句来打开一个文件流，并在使用完后自动关闭它。这样可以确保在不再需要文件流时，它的引用将被清除，避免了过时的对象引用。</p>
<ol start="5">
<li>使用软引用</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">SomeObject</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SoftReference</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="n">SomeObject</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">SomeObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// do something with obj
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// clear the reference to obj
</span></span></span></code></pre></div><p>在这个示例中，我们使用了一个软引用来引用对象，以便在JVM需要回收内存时可以回收对象。软引用在内存不足时通常会被回收，但在内存充足时可以保留对象，避免了过时的对象引用。</p>
<ol start="6">
<li>使用虚引用</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="n">SomeObject</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReferenceQueue</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="n">PhantomReference</span><span class="o">&lt;</span><span class="n">SomeObject</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PhantomReference</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="n">SomeObject</span><span class="o">(),</span> <span class="n">queue</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">ref</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span> <span class="c1">// clear the reference to obj
</span></span></span></code></pre></div><p>在这个示例中，我们使用了一个虚引用来引用对象，以便在JVM回收对象之前可以进行一些必要的清理工作。虚引用在JVM回收对象时会被添加到一个引用队列中，因此我们可以在对象被回收之前执行必要的清理工作。</p>
<ol start="7">
<li>使用对象池</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">ObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">objects</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">T</span> <span class="nf">getObject</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">T</span> <span class="n">obj</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">objects</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">obj</span> <span class="o">=</span> <span class="n">createObject</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">obj</span> <span class="o">=</span> <span class="n">objects</span><span class="o">.</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">objects</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">returnObject</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">objects</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">T</span> <span class="nf">createObject</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// create a new object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，我们使用了一个对象池来管理对象的生命周期。当需要一个对象时，我们从对象池中获取一个对象，而不是每次都创建一个新的对象。当不再需要对象时，我们将其返回到对象池中，以便其他对象可以重复使用。对象池可以避免过时的对象引用，并提高代码的性能和可伸缩性。</p>
<ol start="8">
<li>使用弱散列映射</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">SomeObject</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">SomeObject</span> <span class="n">key</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SomeObject</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">key</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// clear the reference to key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// the entry in the map may be removed if key is not strongly referenced elsewhere
</span></span></span></code></pre></div><p>在这个示例中，我们使用了一个弱散列映射来存储对象引用和相应的值。当对象不再被强引用时，它的引用可能被从映射中删除，从而避免了过时的对象引用。弱散列映射通常用于缓存和事件处理等场景。</p>
<ol start="9">
<li>使用缓存</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">SomeObjectCache</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_SIZE</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">SomeObject</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">SomeObject</span><span class="o">&gt;(</span><span class="n">MAX_SIZE</span><span class="o">,</span> <span class="mf">0.75f</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">SomeObject</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">MAX_SIZE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="n">SomeObject</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">SomeObject</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，我们使用了一个缓存来存储对象引用和相应的值。当缓存达到最大大小时，最旧的条目将被自动删除，从而避免了过时的对象引用。缓存通常用于频繁访问的数据和计算结果，可以提高代码的性能和可伸缩性。</p>
<ol start="10">
<li>使用对象池框架</li>
</ol>
<p>对象池框架是一种用于管理对象生命周期的通用框架，可以避免过时的对象引用和提高代码的性能和可伸缩性。一些流行的对象池框架包括Apache Commons Pool和Google Guava Cache。</p>
<h2 id="扩展">扩展</h2>
<h3 id="弱引用软引用和虚引用区别">弱引用、软引用和虚引用区别</h3>
<p>弱引用、软引用和虚引用是Java中三种不同类型的引用，它们之间的区别如下：</p>
<h4 id="弱引用weakreference">弱引用（WeakReference）</h4>
<p>弱引用是一种较弱的引用类型，当一个对象只被弱引用所引用时，它在下一次垃圾回收时会被回收。</p>
<p>弱引用通常用于需要缓存大量对象的应用场景，例如缓存和高速缓存等。在这些场景中，使用弱引用可以避免占用过多的内存，同时又可以快速访问缓存中的对象。</p>
<p>应该使用弱引用的情况包括：</p>
<ol>
<li>
<p>需要缓存大量对象：使用弱引用可以避免占用过多的内存空间，从而可以缓存更多的对象。</p>
</li>
<li>
<p>不需要快速访问缓存中的对象：由于弱引用只有在下一次垃圾回收时才会被回收，因此可能会导致较长的访问延迟。如果应用程序可以容忍这种情况，可以考虑使用弱引用。</p>
</li>
<li>
<p>需要频繁的垃圾回收：由于弱引用只有在下一次垃圾回收时才会被回收，因此可能会导致频繁的垃圾回收。如果应用程序可以容忍这种情况，可以考虑使用弱引用。</p>
</li>
</ol>
<p>例如，我们可以使用弱引用来实现一个缓存，当内存不足时，JVM会自动回收弱引用所引用的对象，从而避免内存泄漏和OOM错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">SomeObject</span><span class="o">&gt;&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">SomeObject</span> <span class="nf">getObject</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SomeObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">SomeObject</span><span class="o">&gt;</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">reference</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">obj</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">obj</span> <span class="o">=</span> <span class="n">createObject</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;&gt;(</span><span class="n">obj</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，我们使用弱引用来缓存对象，当内存不足时，JVM会自动回收弱引用所引用的对象。这样可以避免占用过多的内存，同时又可以快速访问缓存中的对象。</p>
<h4 id="软引用softreference">软引用（SoftReference）</h4>
<p>软引用是一种较强的引用类型，当一个对象只被软引用所引用时，只有在内存不足时才会被回收。</p>
<p>软引用通常用于需要缓存大量对象的应用场景，例如图片缓存、数据缓存等。在这些场景中，使用软引用可以避免占用过多的内存，同时又可以快速访问缓存中的对象。</p>
<p>应该使用软引用的情况包括：</p>
<ol>
<li>
<p>需要缓存大量对象：使用软引用可以避免占用过多的内存空间，从而可以缓存更多的对象。</p>
</li>
<li>
<p>需要快速访问缓存中的对象：使用软引用可以快速访问缓存中的对象，避免频繁地加载和计算。</p>
</li>
<li>
<p>可以容忍偶尔的垃圾回收：由于软引用只有在内存不足时才会被回收，因此可能会导致偶尔的垃圾回收。如果应用程序可以容忍这种情况，可以考虑使用软引用。</p>
</li>
</ol>
<p>例如，我们可以使用软引用来实现一个图片缓存，当内存不足时，JVM会自动回收软引用所引用的对象，从而避免内存泄漏和OOM错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">Bitmap</span><span class="o">&gt;&gt;</span> <span class="n">imageCache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">Bitmap</span> <span class="nf">loadImage</span><span class="o">(</span><span class="n">String</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Bitmap</span> <span class="n">bitmap</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">Bitmap</span><span class="o">&gt;</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">imageCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">reference</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bitmap</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">bitmap</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bitmap</span> <span class="o">=</span> <span class="n">downloadImage</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">bitmap</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">imageCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="k">new</span> <span class="n">SoftReference</span><span class="o">&lt;&gt;(</span><span class="n">bitmap</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">bitmap</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，我们使用软引用来缓存图片，当内存不足时，JVM会自动回收软引用所引用的对象。这样可以避免占用过多的内存，同时又可以快速访问缓存中的图片。</p>
<h4 id="虚引用phantomreference">虚引用（PhantomReference）</h4>
<p>虚引用是Java中四种引用类型中最弱的一种，它主要用于跟踪对象被垃圾回收的状态。虚引用本身并不会对对象的生命周期产生影响，但可以在对象被垃圾回收时收到一个通知，从而进行一些清理或其他操作。</p>
<p>虚引用的使用场景比较少，一般用于以下几个方面：</p>
<ol>
<li><strong>对象的finalize()方法：</strong> 虚引用可以用于实现对象的finalize()方法，当对象被垃圾回收时，虚引用会收到一个通知，从而触发对象的finalize()方法。</li>
<li><strong>NIO DirectByteBuffer对象的释放：</strong> 在使用NIO编程时，可能会创建大量的DirectByteBuffer对象，这些对象可能会占用大量的内存空间。当这些对象不再使用时，需要手动调用System.gc()方法触发一次垃圾回收，才能释放这些对象的内存。使用虚引用可以避免手动调用System.gc()方法，当这些对象被垃圾回收时，虚引用会收到一个通知，从而释放这些对象的内存。</li>
<li><strong>对象池的管理：</strong> 在一些需要频繁创建和销毁对象的应用场景中，可以使用对象池来提高性能。当对象不再使用时，可以将对象放入虚引用中，当对象被垃圾回收时，虚引用会收到一个通知，从而将对象从对象池中移除。</li>
</ol>
<p>需要注意的是，虚引用不适用于缓存或其他需要快速访问对象的应用场景，因为虚引用本身并不保证对象的可用性和可访问性。</p>
<blockquote>
<p>因此，软引用和弱引用的主要区别在于它们的强度和垃圾回收的时机。软引用比弱引用更强，只有在内存不足时才会被回收，而弱引用则更弱，只有在下一次垃圾回收时才会被回收。同时，使用软引用可能会导致更少的垃圾回收，但可能会占用更多的内存空间，而使用弱引用可能会导致更频繁的垃圾回收，但可以更快地释放内存空间。</p>
</blockquote>
<h3 id="弱引用是否会影响程序的性能">弱引用是否会影响程序的性能？</h3>
<p><code>弱引用可能会影响程序的性能，因为它们可能会导致频繁的垃圾回收。</code>由于弱引用<code>只有在下一次垃圾回收时才会被回收</code>，因此当使用大量的弱引用时，可能会导致更频繁的垃圾回收，从而降低程序的性能。</p>
<p>当一个对象只被弱引用所引用时，在下一次垃圾回收时它会被回收。如果应用程序中存在大量的弱引用对象，每次垃圾回收都需要扫描这些对象，从而增加了垃圾回收的时间和开销。</p>
<p>因此，在使用弱引用时需要注意以下几点：</p>
<ol>
<li>不要过度使用弱引用：如果应用程序中存在大量的弱引用对象，可能会导致频繁的垃圾回收，从而影响程序的性能。因此，应该避免过度使用弱引用，尽可能减少弱引用对象的数量。</li>
<li>注意垃圾回收的时机：弱引用只在下一次垃圾回收时才会被回收，因此可能会导致较长的访问延迟。在使用弱引用时需要注意垃圾回收的时机，如果应用程序需要快速访问缓存中的对象，可能需要使用其他类型的引用。</li>
<li>检查弱引用是否被回收：当一个对象只被弱引用所引用时，它在下一次垃圾回收时会被回收。在使用弱引用时需要注意检查弱引用对象是否被回收，避免引用无效的对象。</li>
</ol>
<h3 id="如何检查弱引用对象是否被回收">如何检查弱引用对象是否被回收？</h3>
<p>在Java中，可以通过获取弱引用对象的get()方法返回的对象来检查引用对象是否被回收。当一个弱引用所引用的对象被回收后，get()方法返回的对象将为null。</p>
<p>例如，以下示例代码演示了如何使用弱引用检查对象是否被回收：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">weakRef</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;&gt;(</span><span class="n">obj</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 检查对象是否被回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="o">(</span><span class="n">weakRef</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对象未被回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Object is alive&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对象已被回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Object has been collected&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，我们创建了一个对象，并使用弱引用来引用它。然后，我们通过检查弱引用对象的get()方法返回的对象来判断对象是否被回收。</p>
<p>当对象未被回收时，get()方法返回的对象不为null，表示对象仍然存活。当对象被回收时，get()方法返回的对象为null，表示对象已经被回收。</p>
<p>需要注意的是，由于弱引用只在下一次垃圾回收时才会被回收，因此在使用弱引用检查对象是否被回收时，需要注意垃圾回收的时机。如果应用程序需要立即检查对象是否被回收，可以手动触发一次垃圾回收，例如通过<code>System.gc()</code>方法来触发。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Effective Java 3》笔记4：用私有构造函数使类不可实例化</title>
      <link>https://blog.chensoul.com/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</link>
      <pubDate>Fri, 05 May 2023 08:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记：用私有构造函数使类不可实例化。 介绍 使用私有构造函数强制实现不可实例化的主要原因是防止类被意</description>
      <content:encoded><![CDATA[<p>本文是 《Effective Java 3》第二章的学习笔记：用私有构造函数使类不可实例化。</p>
<h2 id="介绍">介绍</h2>
<p>使用私有构造函数强制实现不可实例化的主要原因是防止类被意外地实例化，以使代码更加健壮和可靠。在某些情况下，我们只需要使用类中的静态方法和静态字段，而不需要创建该类的实例。如果类中没有显式地定义私有构造函数，Java编译器将会自动为该类生成一个默认的公共构造函数，这意味着该类可以在其他类中被实例化。如果这不是我们想要的，为了防止其他人意外地实例化我们的类，我们可以将构造函数设置为私有。</p>
<p>此外，使用私有构造函数强制实现不可实例化还有以下优点：</p>
<ol>
<li>明确表明该类不可被实例化，提高了代码的可读性和可维护性。</li>
<li>防止类被子类化，从而避免了继承所带来的副作用和不必要的复杂性。</li>
<li>提高了代码的安全性，防止其他类在不合适的情况下实例化该类。</li>
</ol>
<p>这是一个实现了私有构造函数强制实现不可实例化的类的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UtilityClass</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 禁止默认构造函数防止实例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="nf">UtilityClass</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="n">AssertionError</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 其他静态方法和字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>这个类中的私有构造函数会在被调用时抛出<code>AssertionError</code>。这样做可以确保构造函数永远不会从类内部或外部调用。</p>
<p>通过将构造函数设置为私有，这个类就不能从外部被实例化。这个习惯用法也防止了类被子类化。如果一个类的构造函数是私有的，那么它不能被子类调用，因为子类必须调用父类的构造函数来完成初始化。因此，如果一个类的构造函数是私有的，它就不能被子类化，因为子类不能调用父类的构造函数来完成初始化。</p>
<p>以下是一个示例，展示了如何使用私有构造函数防止类被子类化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FinalClass</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">FinalClass</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，<code>FinalClass</code>被声明为<code>final</code>，因此不能被子类化。此外，它的构造函数是私有的，因此不能从子类中被调用。由于该类不能被子类化，因此它的行为不会受到子类的影响，从而避免了继承所带来的副作用和不必要的复杂性。</p>
<p>在某些情况下，将类设置为不能被实例化，但可以被子类化是有用的。这通常是因为我们希望子类化的类能够继承父类的行为和属性，同时又不希望外部能够实例化该类。以下是一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="nf">Animal</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Dog</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Woof!&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个例子中，<code>Animal</code>类被设置为抽象类，它的构造函数被设置为<code>protected</code>，这意味着该类不能被实例化，但可以被子类化。<code>Dog</code>类继承了<code>Animal</code>类，并实现了<code>makeSound()</code>方法。由于<code>Animal</code>类的构造函数被设置为<code>protected</code>，所以<code>Dog</code>类可以调用父类的构造函数来进行初始化。</p>
<p>在这个例子中，我们希望<code>Animal</code>类能够提供一些通用的行为和属性，同时又不希望外部能够实例化该类，因为<code>Animal</code>类本身并不是一种具体的动物。而<code>Dog</code>类作为<code>Animal</code>类的子类，可以继承<code>Animal</code>类的行为和属性，并实现自己的特定行为，以实现具体的功能。</p>
<h2 id="用途">用途</h2>
<p>私有构造函数还有其他一些用途，以下是一些常见的用途：</p>
<ol>
<li>
<p>防止实例化：私有构造函数可以防止类被实例化，这对于只包含静态方法和静态字段的实用工具类非常有用。这些类可以通过将构造函数设置为私有来防止它们被实例化，从而避免不必要的对象创建和资源浪费。</p>
</li>
<li>
<p>强制实现单例：单例模式是一种常见的设计模式，它要求一个类有且仅有一个实例，并提供一个全局访问点。私有构造函数可以强制实现单例模式，因为它可以防止类被实例化，除非类的内部定义了一个静态实例并提供了一个公共的静态访问方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，<code>Singleton</code>类的构造函数是私有的，因此它不能被其他类实例化。<code>getInstance()</code>方法提供了一个全局访问点，并在需要时创建了一个静态实例。由于构造函数是私有的，因此只有<code>Singleton</code>类的内部才能创建实例，从而实现了单例模式。</p>
</li>
<li>
<p>防止子类化：私有构造函数可以防止类被子类化，从而避免了继承所带来的副作用和不必要的复杂性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FinalClass</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">FinalClass</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，<code>FinalClass</code>类被声明为<code>final</code>，它的构造函数是私有的，因此它不能被子类化。该类提供了一些静态方法，可以在其他类中调用，但是不能被子类化。</p>
</li>
<li>
<p>限制继承：如果一个类的构造函数是私有的，那么它不能被继承，这可以用来限制类的继承。</p>
</li>
<li>
<p>实现工厂方法：工厂方法是一种常见的设计模式，它提供了一个创建对象的接口，但是将具体的对象创建过程留给了子类或具体的实现类。私有构造函数可以与工厂方法一起使用，以确保只有工厂方法能够创建对象，从而使对象创建过程更加可控和安全。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Shape</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Shape</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Shape</span> <span class="nf">createRectangle</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Rectangle</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Shape</span> <span class="nf">createCircle</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Circle</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">extends</span> <span class="n">Shape</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Rectangle</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">extends</span> <span class="n">Shape</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Circle</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，<code>Shape</code>类的构造函数是私有的，因此它不能被实例化。<code>Shape</code>类提供了两个静态工厂方法，<code>createRectangle()</code>和<code>createCircle()</code>，用于创建不同的形状。<code>Rectangle</code>和<code>Circle</code>类继承自<code>Shape</code>类，并实现了自己的构造函数。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Effective Java 3》笔记6：避免创建不必要的对象</title>
      <link>https://blog.chensoul.com/posts/2023/04/24/avoid-creating-unnecessary-objects/</link>
      <pubDate>Mon, 24 Apr 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/24/avoid-creating-unnecessary-objects/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记：避免创建不必要的对象。 介绍 创建对象时，经常会复用对象。如果对象是不可变的，那么它总是可以被</description>
      <content:encoded><![CDATA[<p>本文是 《Effective Java 3》第二章的学习笔记：避免创建不必要的对象。</p>
<h2 id="介绍">介绍</h2>
<p>创建对象时，经常会复用对象。如果对象是不可变的，那么它总是可以被复用的。</p>
<p>下面一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;bikini&#34;</span><span class="o">);</span> <span class="c1">// DON&#39;T DO THIS!
</span></span></span></code></pre></div><p>该语句每次执行时都会创建一个新的 String 实例，而这些对象创建都不是必需的。String 构造函数的参数 <code>(&quot;bikini&quot;)</code> 本身就是一个 String 实例，在功能上与构造函数创建的所有对象相同。如果这种用法发生在循环或频繁调用的方法中，创建大量 String 实例是不必要的。</p>
<p>改进后的版本如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;bikini&#34;</span><span class="o">;</span>
</span></span></code></pre></div><p>这个版本使用单个 String 实例，而不是每次执行时都创建一个新的实例。此外，可以保证在同一虚拟机中运行的其他代码都可以复用该对象，只要恰好包含相同的字符串字面量。</p>
<p>通常可以通过使用静态工厂方法来避免创建不必要的对象，而不是在提供这两种方法的不可变类上使用构造函数。例如，工厂方法 <code>Boolean.valueOf(String)</code> 比构造函数 <del>Boolean(String)</del> 更可取，后者在 Java 9 中被弃用了。构造函数每次调用时都必须创建一个新对象，而工厂方法从来不需要这样做，在实际应用中也不会这样做。除了复用不可变对象之外，如果知道可变对象不会被修改，也可以复用它们。</p>
<p>有些对象的创建的代价相比而言要昂贵得多。如果你需要重复地使用这样一个「昂贵的对象」，那么最好将其缓存以供复用。</p>
<p>下面是使用正则表达式最简单的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Performance can be greatly improved!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRomanNumeral</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s">&#34;^(?=.)M*(C[MD]|D?C{0,3})&#34;</span> <span class="o">+</span> <span class="s">&#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这个实现的问题是它依赖于 <code>String.matches</code> 方法。<strong>虽然 String.matches 是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能关键的情况下重复使用。</strong> 问题在于，它在内部为正则表达式创建了一个 Pattern 实例，并且只使用一次，之后就进行垃圾收集了。创建一个 Pattern 实例是很昂贵的，因为它需要将正则表达式编译成有限的状态机。</p>
<p>为了提高性能，将正则表达式显式编译为 Pattern 实例（它是不可变的），作为类初始化的一部分，缓存它，并在每次调用 isRomanNumeral 方法时复用同一个实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Reusing expensive object for improved performance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RomanNumerals</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Pattern</span> <span class="n">ROMAN</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">&#34;^(?=.)M*(C[MD]|D?C{0,3})&#34;</span> <span class="o">+</span> <span class="s">&#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRomanNumeral</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ROMAN</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="na">matches</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>如果频繁调用 isRomanNumeral，改进版本将提供显著的性能提升。不仅性能得到了改善，清晰度也得到了提高。为不可见的 Pattern 实例创建一个静态终态字段允许我们为它命名，这比正则表达式本身更容易阅读。</p>
<p>如果加载包含改进版 isRomanNumeral 方法的类时，该方法从未被调用过，那么初始化字段 ROMAN 是不必要的。因此，可以用延迟初始化字段的方式在第一次调用 isRomanNumeral 方法时才初始化字段，而不是在类加载时初始化，<strong>但不建议这样做</strong>。通常情况下，<strong>延迟初始化会使实现复杂化，而没有明显的性能改善</strong>。</p>
<p>当一个对象是不可变的，很明显，它可以安全地复用，但在其他情况下，它远不那么明显，甚至违反直觉。考虑适配器的情况，也称为视图。适配器是委托给支持对象的对象，提供了一个替代接口。因为适配器的状态不超过其支持对象的状态，所以不需要为给定对象创建一个给定适配器的多个实例。</p>
<p>例如，Map 接口的 keySet 方法返回 Map 对象的 Set 视图，其中包含 Map 中的所有键。事实上，返回的 Set 实例通常是可变的，但所有返回的对象在功能上都是相同的，因为它们都由相同的 Map 实例支持。因此，对给定 Map 对象上的 keySet 的每次调用都可能返回相同的 Set 实例。</p>
<p>由于返回的 Set 实例在功能上是相同的，因此创建 keySet 视图对象的多个实例是不必要的，也没有好处。因此，在使用 keySet 视图的时候，我们应该尽可能地重用同一个 Set 实例，而不是每次调用 keySet 方法都创建一个新的 Set 实例。</p>
<p>以下是一个示例，展示了如何重用 keySet 视图的 Set 实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestKeySetReuse</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&#34;one&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&#34;two&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">&#34;three&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">keySet1</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">keySet2</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">keySet1</span> <span class="o">==</span> <span class="n">keySet2</span><span class="o">);</span> <span class="c1">// true，说明是同一个实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">keySet1</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span> <span class="c1">// {2=two, 3=three}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">keySet2</span><span class="o">);</span> <span class="c1">// [2, 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，我们首先创建了一个 HashMap 对象，并向其中添加了一些键值对。然后，我们两次调用 keySet 方法，分别将返回的 Set 实例保存到 keySet1 和 keySet2 变量中。</p>
<p>由于 keySet1 和 keySet2 是由相同的 Map 实例支持的，因此它们是相等的，即 <code>keySet1 == keySet2</code> 返回 true。我们可以看到，实际上它们是同一个 Set 实例。</p>
<p>然后，我们从 keySet1 中删除一个键，并打印出 Map 和 keySet2 的内容。我们可以看到，当我们修改了 keySet1 中的内容时，keySet2 也被修改了，因为它们是同一个 Set 实例。</p>
<p>因此，在使用 Map 的 keySet 方法时，应该尽可能地重用同一个 Set 实例，以避免不必要的对象创建和不必要的行为。</p>
<p>另一种创建不必要对象的方法是自动装箱，它允许程序员混合基本类型和包装类型，根据需要自动装箱和拆箱。<strong>自动装箱模糊了基本类型和包装类型之间的区别，</strong> 两者有细微的语义差别和不明显的性能差别。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Hideously slow! Can you spot the object creation?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">sum</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="n">L</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这个程序得到了正确的答案，但是由于一个字符的印刷错误，它的速度比实际要慢得多。变量 sum 被声明为 Long 而不是 long，这意味着程序将构造大约 231 个不必要的 Long 实例（大约每次将 Long i 添加到 Long sum 时都有一个实例）。将 sum 的声明从 Long 更改为 long，机器上的运行时间将从 6.3 秒减少到 0.59 秒。教训很清楚：<strong>基本类型优于包装类，还应提防意外的自动装箱。</strong></p>
<p>本条目不应该被曲解为是在暗示创建对象是成本昂贵的，应该避免。相反，创建和回收这些小对象的构造函数成本是很低廉的，尤其是在现代 JVM 实现上。<strong>创建额外的对象来增强程序的清晰性、简单性或功能通常是件好事。</strong></p>
<p>相反，通过维护自己的对象池来避免创建对象不是一个好主意，除非池中的对象非常重量级。证明对象池是合理的对象的典型例子是数据库连接。建立连接的成本非常高，因此复用这些对象是有意义的。然而，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代 JVM 实现具有高度优化的垃圾收集器，在轻量级对象上很容易胜过这样的对象池。</p>
<h2 id="总结">总结</h2>
<ol>
<li>
<p>避免创建不必要的对象可以提高性能和减少内存占用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 不推荐的写法，会创建不必要的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Integer</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐的写法，使用基本类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>如果一个对象是不可变的，可以将其缓存起来并重复使用，而不是每次需要时都创建一个新对象。</p>
<p>以下是一些常见的不可变对象和它们的缓存实现：</p>
<ul>
<li><strong>字符串常量池</strong></li>
</ul>
<p>Java 语言中的字符串是不可变的，因此字符串常量可以被缓存起来并重复使用。Java 虚拟机维护了一个字符串常量池，它缓存了所有的字符串常量，并确保相同的字符串只被创建一次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="o">;</span> <span class="c1">// 从字符串常量池中获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="o">;</span> <span class="c1">// 从字符串常量池中获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;Hello&#34;</span><span class="o">);</span> <span class="c1">// 创建新的字符串对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s3</span><span class="o">);</span> <span class="c1">// false
</span></span></span></code></pre></div><ul>
<li><strong>数字常量池</strong></li>
</ul>
<p>Java 语言中的整数、浮点数和字符等基本数据类型的值也可以被缓存起来并重复使用。Java 虚拟机维护了一个数字常量池，它缓存了一定范围内的整数、浮点数和字符等基本数据类型的值，并确保相同的值只被创建一次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Integer</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span> <span class="c1">// 从数字常量池中获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Integer</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span> <span class="c1">// 从数字常量池中获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Integer</span> <span class="n">i3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> <span class="c1">// 创建新的 Integer 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i1</span> <span class="o">==</span> <span class="n">i2</span><span class="o">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i1</span> <span class="o">==</span> <span class="n">i3</span><span class="o">);</span> <span class="c1">// false
</span></span></span></code></pre></div><p>注意：数字常量池的范围可以通过 JVM 参数 <code>-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来调整，其中 <code>&lt;size&gt;</code> 是常量池的大小。</p>
<ul>
<li><strong>枚举常量</strong></li>
</ul>
<p>Java 语言中的枚举常量是不可变的，它们在枚举类型被加载时就被创建并缓存起来，而不是每次需要时都创建一个新对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">enum</span> <span class="n">Color</span> <span class="o">{</span> <span class="n">RED</span><span class="o">,</span> <span class="n">GREEN</span><span class="o">,</span> <span class="n">BLUE</span> <span class="o">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Color</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">;</span> <span class="c1">// 获取枚举常量 RED
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Color</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">GREEN</span><span class="o">;</span> <span class="c1">// 获取枚举常量 GREEN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Color</span> <span class="n">c3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Color</span><span class="o">(</span><span class="s">&#34;YELLOW&#34;</span><span class="o">);</span> <span class="c1">// 创建新的枚举常量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="o">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">);</span> <span class="c1">// true
</span></span></span></code></pre></div><ul>
<li><strong>LocalDate、LocalTime、LocalDateTime</strong></li>
</ul>
<p>Java 8 引入的日期时间 API 中的 LocalDate、LocalTime、LocalDateTime 类型都是不可变的。这些类型的对象可以被缓存起来并重复使用，以提高程序的性能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">LocalDate</span> <span class="n">today</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">();</span> <span class="c1">// 获取当前日期
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">LocalDate</span> <span class="n">tomorrow</span> <span class="o">=</span> <span class="n">today</span><span class="o">.</span><span class="na">plusDays</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 计算明天的日期
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">LocalDate</span> <span class="n">yesterday</span> <span class="o">=</span> <span class="n">today</span><span class="o">.</span><span class="na">minusDays</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 计算昨天的日期
</span></span></span></code></pre></div><p>可以使用线程安全的 ConcurrentHashMap 来实现 LocalDate 的缓存：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">LocalDate</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="s">&#34;2023-04-24&#34;</span><span class="o">,</span> <span class="n">LocalDate</span><span class="o">::</span><span class="n">parse</span><span class="o">);</span>
</span></span></code></pre></div><ul>
<li><strong>BigDecimal</strong></li>
</ul>
<p>Java 中的 BigDecimal 类型也是不可变的，它们的值在创建后不会改变。因此，可以将 BigDecimal 对象缓存起来并重复使用，以避免不必要的对象创建。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">BigDecimal</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span> <span class="c1">// 缓存 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BigDecimal</span> <span class="n">one</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">ONE</span><span class="o">;</span> <span class="c1">// 缓存 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BigDecimal</span> <span class="n">ten</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">TEN</span><span class="o">;</span> <span class="c1">// 缓存 10
</span></span></span></code></pre></div><p>可以使用静态 final 常量来实现 BigDecimal 的缓存：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Constants</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">BigDecimal</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">BigDecimal</span> <span class="n">ONE</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">ONE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">BigDecimal</span> <span class="n">TEN</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">TEN</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><ul>
<li><strong>Immutable Collections</strong></li>
</ul>
<p>Guava 和 Java 9+ 中都提供了不可变集合类，如 ImmutableList、ImmutableSet、ImmutableMap 等。这些不可变集合类的对象是不可变的，因此可以被缓存起来并重复使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ImmutableList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span> <span class="c1">// 创建不可变列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// 创建不可变集合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ImmutableMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">ImmutableMap</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// 创建不可变映射
</span></span></span></code></pre></div><p>可以使用静态 final 常量来实现不可变集合的缓存：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Constants</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">LIST</span> <span class="o">=</span> <span class="n">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">MAP</span> <span class="o">=</span> <span class="n">ImmutableMap</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>避免使用装箱类型，如 Integer、Boolean 等，因为它们在自动装箱和拆箱时会创建不必要的对象。可以使用基本类型和对象包装类型之间的相互转换方法来避免这种情况。</p>
</li>
<li>
<p>对于大量的短字符串，可以考虑使用字符串池或者使用 String.intern() 方法，以避免创建大量的 String 对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 不推荐的写法，会创建大量的 String 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">str</span> <span class="o">+=</span> <span class="s">&#34;a&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐的写法，使用 StringBuilder 和字符串池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">intern</span><span class="o">();</span>
</span></span></code></pre></div><blockquote>
<p><strong>String.intern() 方法</strong></p>
<p>String.intern() 方法是一个 native 方法，它的作用是返回字符串对象的规范化表示形式，即返回字符串常量池中与该字符串相等的对象的引用（如果常量池中已经存在该字符串，则直接返回常量池中的对象；否则，将该字符串添加到常量池中，并返回该字符串的引用）。</p>
<p>例如，假设我们有如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;hello&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
</span></span></code></pre></div><p>在这个代码中，我们首先创建了一个字符串对象 s1，它是字符串常量池中的一个对象。然后，我们通过 new 关键字创建了一个新的字符串对象 s2，它与 s1 的内容相同，但是它在堆内存中创建。接下来，我们调用 s2 的 intern() 方法，将 s2 放入字符串常量池中，并返回常量池中的对象引用。因此，s3 指向的是字符串常量池中的对象。</p>
<p>需要注意的是，由于字符串常量池中的字符串对象是唯一的，因此使用 intern() 方法可以节省内存空间。但是，由于字符串常量池的空间是有限的，如果程序中大量使用 intern() 方法，可能会导致常量池溢出的问题。因此，如果不是必须使用 intern() 方法，最好不要使用它。</p>
<p>另外，<strong>由于 intern() 方法是一个 native 方法，它的性能可能会比较低。在实际开发中，应该根据具体情况进行选择，避免滥用 intern() 方法</strong>。</p>
</blockquote>
</li>
<li>
<p>尽量使用静态工厂方法而不是构造方法创建对象，因为静态工厂方法可以重复使用已经创建的对象，从而避免创建不必要的对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 不推荐的写法，每次都创建一个新的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Date</span> <span class="n">now</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Date</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐的写法，使用静态工厂方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Date</span> <span class="n">now</span> <span class="o">=</span> <span class="n">Date</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
</span></span></code></pre></div></li>
<li>
<p>避免创建不必要的数组，可以使用 List、Set、Map 等集合类型来代替数组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 不推荐的写法，会创建不必要的数组对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]{</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐的写法，使用 List
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p>如果必须创建不可变的数组，可以使用静态工厂方法 Arrays.asList() 来创建 List，从而避免创建额外的数组对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 不推荐的写法，会创建不必要的数组对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]{</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">};</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐的写法，使用 Arrays.asList()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p>避免创建过多的临时对象，如在循环中创建的对象。可以重复使用已经创建的对象，或者使用可重用的对象池来减少对象的创建和垃圾回收。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 不推荐的写法，会创建不必要的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐的写法，使用可重用的对象池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="n">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuffer</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="o">.</span><span class="na">setLength</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>避免在类的构造方法中创建大量的对象。如果在构造方法中创建大量的对象，会导致内存占用过大，从而影响程序的性能。可以将对象的创建放在需要使用的方法中，或者使用懒加载的方式来延迟对象的创建。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 不推荐的写法，会在构造方法中创建大量的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐的写法，将对象的创建放在需要使用的方法中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getList</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>避免在递归方法中创建不必要的对象。如果在递归方法中创建不必要的对象，会导致内存占用过大，从而导致栈溢出等问题。可以使用可重用的对象池来减少对象的创建和垃圾回收。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 不推荐的写法，会在递归方法中创建不必要的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐的写法，使用可重用的对象池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cache</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">n</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">cache</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">,</span> <span class="n">cache</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ol>
<h2 id="适配器模式">适配器模式</h2>
<p>适配器模式是一种常见的设计模式，它可以帮助我们将一个对象的接口适配成另一个对象的接口。适配器模式通常用于以下情况：</p>
<ol>
<li>当我们需要使用一个已有的类，但是它的接口与我们期望的不兼容时，我们可以使用适配器模式来将其接口适配成我们需要的接口。</li>
<li>当我们需要使用多个不兼容的类时，我们可以使用适配器模式来将它们的接口适配成一个统一的接口。</li>
</ol>
<p>在适配器模式中，适配器对象通常是不可变的，因为它们的状态不超过支持对象的状态。因此，可以安全地复用适配器对象。</p>
<p>例如，考虑一个支持英国插头的设备，但我们需要将其插入到一个美国插座上。我们可以使用一个适配器来适配英国插头到美国插座。适配器的状态不超过英国插头的状态，因此可以安全地复用适配器对象，而不必为每个设备创建一个新的适配器对象。</p>
<p>以下是一个简单的适配器示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 支持英国插头的设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BritishDevice</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">plugIn</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Plugged in British device&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 美国插座接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">USPlug</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">plug</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 英国到美国的适配器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BritishToUSAdapter</span> <span class="kd">implements</span> <span class="n">USPlug</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">BritishDevice</span> <span class="n">device</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">BritishToUSAdapter</span><span class="o">(</span><span class="n">BritishDevice</span> <span class="n">device</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">device</span> <span class="o">=</span> <span class="n">device</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">plug</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">device</span><span class="o">.</span><span class="na">plugIn</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 美国插座
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">USOutlet</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">plugIn</span><span class="o">(</span><span class="n">USPlug</span> <span class="n">plug</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">plug</span><span class="o">.</span><span class="na">plug</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 测试适配器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestAdapter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">BritishDevice</span> <span class="n">device</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BritishDevice</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">BritishToUSAdapter</span> <span class="n">adapter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BritishToUSAdapter</span><span class="o">(</span><span class="n">device</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">USOutlet</span> <span class="n">outlet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">USOutlet</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">outlet</span><span class="o">.</span><span class="na">plugIn</span><span class="o">(</span><span class="n">adapter</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，我们定义了一个 BritishDevice 类来模拟一个支持英国插头的设备。我们还定义了一个 USPlug 接口来表示一个美国插头，以及一个 USOutlet 类来表示一个美国插座。</p>
<p>我们使用一个适配器类 BritishToUSAdapter 来适配 BritishDevice 到 USPlug 接口。适配器类的构造函数接收一个 BritishDevice 对象，并将其保存在一个成员变量中。适配器实现了 USPlug 接口，并将 plug 方法委托给 BritishDevice 对象的 plugIn 方法。</p>
<p>在测试适配器时，我们创建了一个 BritishDevice 对象和一个适配器对象，并将适配器对象传递给 USOutlet 的 plugIn 方法。USOutlet 对象使用适配器对象来将 BritishDevice 对象适配到 USPlug 接口，从而将其插入到美国插座中。</p>
<p>在这个示例中，<strong>适配器对象是不可变的，因为它的状态不超过支持对象的状态。因此，我们可以安全地复用适配器对象，而不必为每个设备创建一个新的适配器对象。</strong></p>
<h2 id="扩展">扩展</h2>
<h3 id="java-8-的-stream-api--避免创建不必要对象">Java 8 的 Stream API  避免创建不必要对象</h3>
<p>下面这段代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">categoryStatistics</span><span class="o">.</span><span class="na">getData</span><span class="o">().</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToLong</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">getValue</span><span class="o">()).</span><span class="na">sum</span><span class="o">();</span>
</span></span></code></pre></div><p>在使用 <code>list.stream().mapToLong(t -&gt; t.getValue()).sum()</code> 对集合中的元素进行求和时，确实可以通过这种方式来避免创建不必要的对象。</p>
<p>具体来说，<code>mapToLong()</code> 方法会将集合中的元素映射为一个 LongStream 对象，而 LongStream 对象是一个<code>原始类型流</code>，它在内存中的占用空间比较小。因此，使用 <code>mapToLong() </code>方法可以避免创建不必要的对象，从而提高程序的性能。</p>
<p>另外，sum() 方法是一个终端操作，它会对流中的所有元素进行求和，并返回最终的结果。由于 sum() 方法是一个终端操作，它会直接对流中的元素进行求和，而不会创建新的对象。因此，使用 sum() 方法可以进一步避免创建不必要的对象，从而提高程序的性能。</p>
<blockquote>
<p>在大多数情况下，<code>list.stream().mapToLong(t -&gt; t.getValue()).sum()</code> 的性能会比 <code>list.stream().mapToLong(t -&gt; t.getValue()).reduce(0L, (a, b) -&gt; a + b)</code> 更好。</p>
<p>原因是，<code>sum()</code> 方法是一个终端操作，它会对流中的所有元素进行求和，并返回最终的结果。<strong><code>sum()</code> 方法底层使用了一些优化技术，例如使用循环展开、使用 SIMD 指令等，从而充分利用 CPU 的性能优势，提高计算速度</strong>。</p>
<p>相比之下，<code>reduce()</code> 方法是一个归约操作，它将对流中的元素进行累计计算，并返回最终的结果。由于 <code>reduce() </code>方法需要对元素进行二元操作，因此它比 <code>sum()</code> 方法更加复杂，可能会带来一些额外的开销。此外，<code>reduce()</code> 方法还需要指定一个初始值，如果初始值不当，可能会导致结果错误或者性能下降。</p>
<p>不过，对于某些特殊情况，<code>reduce()</code> 方法可能会比 <code>sum()</code> 方法更加适用。例如，如果我们需要对流中的元素进行自定义的累计计算，就需要使用 <code>reduce() </code>方法。此外，<code>reduce()</code>方法还支持并行计算，可以充分利用多核处理器的性能优势，提高计算速度。</p>
<p>综上所述，我们应该根据具体情况选择使用 <code>sum()</code> 方法还是 <code>reduce()</code> 方法。<strong>对于大多数情况下的求和操作，<code>sum()</code> 方法是一个更好的选择，因为它比<code> reduce()</code> 方法更加高效。但是，在某些特殊情况下，<code>reduce()</code> 方法可能会更加适用</strong>。</p>
</blockquote>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-15｜Umami升级到2.0、汉街蜡像馆、使用Strava跑步</title>
      <link>https://blog.chensoul.com/posts/2023/04/18/weekly_review_15/</link>
      <pubDate>Tue, 18 Apr 2023 17:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/18/weekly_review_15/</guid>
      <description>前言 ​ 题图：楚河汉街蜡像馆 本篇是对 2023-04-10 到 2023-04-16 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这周的工作不算忙碌，继续学</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-01.png" alt="weekly-review-15-01"  />
</p>
<p>​														<em>题图：楚河汉街蜡像馆</em></p>
<p>本篇是对 <code>2023-04-10</code> 到 <code>2023-04-16</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这周的工作不算忙碌，继续学习《Effective Java 3》这本书，并花了一些时间学习 Rust、Python 的基础语法。</p>
<p>这个月已经过了一半，减肥也进行了两周，体重从72公斤减到了现在的68.4公斤。在之前每天走路1万步的基础上，打算开始每天跑步，比记录跑步数据。</p>
<p>这周总计支出916元，明细如下：</p>
<ul>
<li>4月12日：329元，开通ETC预存300元</li>
<li>4月15日：116元，周末买菜做饭</li>
<li>4月16日：471元，老婆过生，吃饭和看电影</li>
</ul>
<p>四月累计支出共 2025 元，其中餐饮和购物占了一半。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-05.jpeg" alt="weekly-review-15-05" style="width:50%;" />
<h2 id="健身">健身</h2>
<p>这周每天走路步数如下，其中有一天因为加班而没有完成一万步的目标。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-06.png" alt="weekly-review-15-06" style="width:50%;" />
<p>受 <a href="https://conge.livingwithfcs.org/">@Conge</a> 博客影响，开始记录每天的跑步数据。首先是注册了 strava 账号，然后参考 <a href="https://github.com/yihong0618/running_page">running_page</a> 部署了一个我的跑步主页 <a href="https://run.chensoul.com/">run.chensoul.com</a>。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-02.png" alt="weekly-review-15-02"  />
</p>
<p>因为我之前是使用悦跑圈 APP 记录跑步，所以又参考<a href="https://github.com/yihong0618/running_page/blob/master/README-CN.md#joyrun%E6%82%A6%E8%B7%91%E5%9C%88">这篇文章</a>导出 gpx 数据，然后<a href="https://github.com/yihong0618/running_page/blob/master/README-CN.md#gpx_to_strava">同步</a>到 Strava。最后，可以把悦跑圈 APP 卸载了。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-03.png" alt="weekly-review-15-03"  />
</p>
<p>上周跑步数据如下，总计28.64公里，比上周的19.05公里多了9.6公里。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-04.png" alt="weekly-review-15-04"  />
</p>
<p>上面搞定了之后，就可以使用 Strava 来跑步了。为了增加社交乐趣性，我在 n8n 里面创建了一个 workflow，将 Strava 活动发送到我的『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，效果如下。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-07.png" alt="weekly-review-15-07" style="width:50%;" />
<h2 id="umami升级到20">Umami升级到2.0</h2>
<p>1、首先备份数据库</p>
<p>2、升级数据库</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone https://github.com/umami-software/migrate-v1-v2.git
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> migrate-v1-v2
</span></span><span class="line"><span class="cl">yarn install
</span></span><span class="line"><span class="cl">yarn build
</span></span></code></pre></div><p>创建 .env 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-properties" data-lang="properties"><span class="line"><span class="cl"><span class="c1">#修改为你的数据库地址</span>
</span></span><span class="line"><span class="cl"><span class="na">DATABASE_URL</span><span class="o">=</span><span class="s">postgresql://umami:xxxxx@postgres.chensoul.com:5432/umami</span>
</span></span></code></pre></div><p>运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">yarn start
</span></span></code></pre></div><p>3、重新部署静态页面</p>
<p>日志提示报错：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-16.png" alt="weekly-review-15-16"  />
</p>
<p>解决办法是修改 scripts/check-db.js：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-17.png" alt="weekly-review-15-17"  />
</p>
<p>4、修改跟踪脚本，把站点中所有追踪脚本名字<code>umami.js</code>改为<code>script.js</code>。</p>
<p>5、最后查看实时仪表盘。我的 umami 实时 <a href="https://umami.chensoul.com/realtime/f110cfa0-b737-4690-a032-2b9073a57fc3">访问地址</a></p>
<h2 id="工作">工作</h2>
<h3 id="effective-java-3-笔记">Effective Java 3 笔记</h3>
<p>请参考《<a href="/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources">Effective Java 3 笔记：依赖注入优于硬编码资源</a>》。</p>
<h2 id="汉街蜡像馆">汉街蜡像馆</h2>
<p>周末趁武汉旅游大年卡还没过期，跑到楚河汉街蜡像馆去溜达了一圈。因为有年卡，省去了150元的门票。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-08.png" alt="weekly-review-15-08" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-09.png" alt="weekly-review-15-09" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-10.png" alt="weekly-review-15-10" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-11.png" alt="weekly-review-15-11" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-12.png" alt="weekly-review-15-12" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-13.png" alt="weekly-review-15-13" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-14.png" alt="weekly-review-15-14" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-15.png" alt="weekly-review-15-15" style="width:67%;" />
<h2 id="好物分享">好物分享</h2>
<p>虽然大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。</p>
<h3 id="一些文章">一些文章</h3>
<p>1、<a href="https://www3.ntu.edu.sg/home/ehchua/programming/index.html">Java 编程教程</a></p>
<p><img loading="lazy" src="https://cdn.beekka.com/blogimg/asset/202301/bg2023011504.webp" alt="img"  />
</p>
<p>这个网站是新加坡南洋理工大学的一位老师的教案（英文），主要内容为新生的 Java 编程</p>
<p>2、<a href="https://offsec.tools/">offsec.tools</a></p>
<p><img loading="lazy" src="https://cdn.beekka.com/blogimg/asset/202301/bg2023012101.webp" alt="img"  />
</p>
<p>这个网站收集各种安全相关的软件工具，目前共有600多个。</p>
<p>3、<a href="https://juemuren4449.com/archives/habit-formation-plan">我的习惯养成计划：五分钟规则+打卡</a></p>
<p>4、<a href="https://www.jitao.tech/posts/my-guiding-principles-after-20-years-of-programming/">我编程 20 年的指导原则</a></p>
<p>5、<a href="https://lenciel.com/2022/10/renaming-with-zmv/">用 zmv 批量重命名文件</a></p>
<h3 id="一些工具">一些工具</h3>
<ul>
<li><a href="https://webperformancereport.com/">WebPerformance Report</a> 这个网站可以用邮箱订阅你的网站性能的个性化报告。它会监控指定网站的性能，每周会发送一封报告邮件给你。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Effective Java 3》笔记5：依赖注入优于硬编码资源</title>
      <link>https://blog.chensoul.com/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</link>
      <pubDate>Mon, 17 Apr 2023 17:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。 介绍 依赖注入是软件工程中使用的一种设计模式，用</description>
      <content:encoded><![CDATA[<p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。</p>
<h2 id="介绍">介绍</h2>
<p>依赖注入是软件工程中使用的一种设计模式，用于将组件和依赖项相互解耦。而不是在组件内部创建和管理依赖项，我们从外部传递它们。这种方法可以帮助创建更模块化和灵活的代码。</p>
<p>相比之下，硬编码资源涉及在组件内部直接创建和管理依赖项。这种方法可能会使代码不太灵活，难以维护。</p>
<h2 id="举例">举例</h2>
<p>许多类依赖于一个或多个底层资源。例如，拼写检查程序依赖于字典。常见做法是，将这种类实现为静态实用工具类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Inappropriate use of static utility - inflexible &amp; untestable!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpellChecker</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Lexicon</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="o">...;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">SpellChecker</span><span class="o">()</span> <span class="o">{}</span> <span class="c1">// Noninstantiable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">suggestions</span><span class="o">(</span><span class="n">String</span> <span class="n">typo</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>类似地，我们也经常看到它们的单例实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Inappropriate use of singleton - inflexible &amp; untestable!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpellChecker</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SpellChecker</span><span class="o">(...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Lexicon</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="o">...;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">SpellChecker</span><span class="o">(...)</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">suggestions</span><span class="o">(</span><span class="n">String</span> <span class="n">typo</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这两种方法都不令人满意，因为它们假设只使用一个字典。在实际应用中，每种语言都有自己的字典，特殊的字典用于特殊的词汇表。另外，最好使用一个特殊的字典进行测试。</p>
<p>你可以尝试让 SpellChecker 支持多个字典：首先取消 dictionary 字段的 final 修饰，并在现有的拼写检查器中添加更改 dictionary 的方法。但是在并发环境中这种做法是笨拙的、容易出错的和不可行的。<strong>静态实用工具类和单例不适用于由底层资源参数化的类。</strong></p>
<p>所需要的是支持类的多个实例的能力（在我们的示例中是 SpellChecker），每个实例都使用客户端需要的资源（在我们的示例中是 dictionary）。满足此要求的一个简单模式是在<strong>创建新实例时将资源传递给构造函数。</strong> 这是依赖注入的一种形式：字典是拼写检查器的依赖项，在创建它时被注入到拼写检查器中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Dependency injection provides flexibility and testability
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpellChecker</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Lexicon</span> <span class="n">dictionary</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">SpellChecker</span><span class="o">(</span><span class="n">Lexicon</span> <span class="n">dictionary</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">dictionary</span> <span class="o">=</span> <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">dictionary</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">suggestions</span><span class="o">(</span><span class="n">String</span> <span class="n">typo</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>依赖注入模式非常简单，许多程序员在不知道其名称的情况下使用了多年。虽然拼写检查器示例只有一个资源（字典），但是依赖注入可以处理任意数量的资源和任意依赖路径。它保持了不可变性，因此多个客户端可以共享依赖对象（假设客户端需要相同的底层资源）。<strong>依赖注入同样适用于构造函数、静态工厂和构建器</strong>。</p>
<p>以下是这些情况的示例：</p>
<h3 id="构造函数">构造函数</h3>
<p>在构造函数中使用依赖注入是最常见的方式。例如，假设我们有一个名为<code>UserService</code>的类，它需要一个能够验证用户的<code>UserValidator</code>接口作为依赖项。我们可以像这样在构造函数中注入<code>UserValidator</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">UserValidator</span> <span class="n">userValidator</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">(</span><span class="n">UserValidator</span> <span class="n">userValidator</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">userValidator</span> <span class="o">=</span> <span class="n">userValidator</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><h3 id="静态工厂">静态工厂</h3>
<p>静态工厂是一种创建对象的方式，它将创建对象的逻辑封装在一个静态方法中。例如，假设我们有一个名为<code>UserServiceFactory</code>的类，它负责创建<code>UserService</code>实例。我们可以像这样在静态工厂方法中注入<code>UserValidator</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceFactory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">UserService</span> <span class="nf">createUserService</span><span class="o">(</span><span class="n">UserValidator</span> <span class="n">userValidator</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">UserService</span><span class="o">(</span><span class="n">userValidator</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="构建器">构建器</h3>
<p>构建器是一种创建对象的方式，它将创建对象的逻辑封装在一个构建器类中。例如，假设我们有一个名为<code>UserServiceBuilder</code>的类，它负责创建<code>UserService</code>实例。我们可以像这样在构建器类中注入<code>UserValidator</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceBuilder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">UserValidator</span> <span class="n">userValidator</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">UserServiceBuilder</span> <span class="nf">withUserValidator</span><span class="o">(</span><span class="n">UserValidator</span> <span class="n">userValidator</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">userValidator</span> <span class="o">=</span> <span class="n">userValidator</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">UserService</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">UserService</span><span class="o">(</span><span class="n">userValidator</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这样，我们可以使用构建器来创建<code>UserService</code>实例，并在构建器中注入<code>UserValidator</code>。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">UserValidator</span> <span class="n">userValidator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CustomUserValidator</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">UserService</span> <span class="n">userService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UserServiceBuilder</span><span class="o">().</span><span class="na">withUserValidator</span><span class="o">(</span><span class="n">userValidator</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><p>这种模式的一个有用变体是将资源工厂传递给构造函数。资源工厂是一种创建和提供对象的方式，它可以在需要时动态地创建和返回资源。在将资源工厂传递给构造函数时，我们可以将对象的创建和配置逻辑从类中移除，从而实现更好的可测试性和可维护性。</p>
<p>以下是一个使用资源工厂传递给构造函数的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">UserValidator</span> <span class="n">userValidator</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">DataSource</span> <span class="n">dataSource</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">(</span><span class="n">ResourceFactory</span> <span class="n">resourceFactory</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">userValidator</span> <span class="o">=</span> <span class="n">resourceFactory</span><span class="o">.</span><span class="na">createUserValidator</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">dataSource</span> <span class="o">=</span> <span class="n">resourceFactory</span><span class="o">.</span><span class="na">createDataSource</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">authenticate</span><span class="o">(</span><span class="n">String</span> <span class="n">username</span><span class="o">,</span> <span class="n">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// perform authentication using userValidator and dataSource
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>UserService</code>类需要一个能够验证用户的<code>UserValidator</code>实例和一个<code>DataSource</code>实例。这两个依赖项都是通过资源工厂来创建的。通过将资源工厂传递给构造函数，我们可以将对象的创建和配置逻辑从类中移除，并使其更加灵活和可维护。</p>
<p>例如，假设我们有一个名为<code>MySqlResourceFactory</code>的类，它实现了<code>ResourceFactory</code>接口，并用于创建<code>UserValidator</code>和<code>DataSource</code>实例。我们可以像这样使用它来创建<code>UserService</code>实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ResourceFactory</span> <span class="n">resourceFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MySqlResourceFactory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">UserService</span> <span class="n">userService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UserService</span><span class="o">(</span><span class="n">resourceFactory</span><span class="o">);</span>
</span></span></code></pre></div><p>使用这种方法，我们将<code>UserService</code>类与具体的资源实现解耦，并使其更加灵活和可维护。同时，我们可以轻松地模拟和测试<code>UserService</code>类，因为我们可以在测试中传递不同的资源工厂实现，而不需要依赖于外部资源。</p>
<h3 id="函数式接口">函数式接口</h3>
<p>在Java 8中，<code>Supplier&lt;T&gt;</code>是一个函数式接口，用于表示一个无参数函数，该函数返回类型为<code>T</code>。由于其函数式特性，<code>Supplier&lt;T&gt;</code>非常适合表示工厂，因为它可以提供一种通用的方式来创建对象。</p>
<p>以下是一个使用<code>Supplier&lt;T&gt;</code>表示工厂的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">UserValidator</span> <span class="n">userValidator</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">UserValidator</span><span class="o">&gt;</span> <span class="n">userValidatorFactory</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">userValidator</span> <span class="o">=</span> <span class="n">userValidatorFactory</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">authenticate</span><span class="o">(</span><span class="n">String</span> <span class="n">username</span><span class="o">,</span> <span class="n">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// perform authentication using userValidator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>UserService</code>类的构造函数接受一个<code>Supplier&lt;UserValidator&gt;</code>作为参数。这个<code>Supplier</code>可以在需要时动态地创建<code>UserValidator</code>实例。在<code>UserService</code>类中，我们可以通过调用<code>userValidatorFactory.get()</code>来获取<code>UserValidator</code>实例。</p>
<p>例如，假设我们有一个名为<code>CustomUserValidator</code>的类，它实现了<code>UserValidator</code>接口，并用于验证用户。我们可以像这样使用<code>UserService</code>类和<code>Supplier&lt;T&gt;</code>来创建<code>UserService</code>实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">UserValidator</span><span class="o">&gt;</span> <span class="n">userValidatorFactory</span> <span class="o">=</span> <span class="n">CustomUserValidator</span><span class="o">::</span><span class="k">new</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">UserService</span> <span class="n">userService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UserService</span><span class="o">(</span><span class="n">userValidatorFactory</span><span class="o">);</span>
</span></span></code></pre></div><p>在上面的示例中，<code>userValidatorFactory</code>是一个<code>Supplier&lt;UserValidator&gt;</code>实例，它使用<code>CustomUserValidator::new</code>构造函数引用来创建<code>UserValidator</code>实例。通过将这个<code>Supplier</code>传递给<code>UserService</code>类的构造函数，我们可以创建<code>UserService</code>实例，而无需显式地创建<code>UserValidator</code>实例。</p>
<p>使用<code>Supplier&lt;T&gt;</code>表示工厂可以使我们的代码更加简洁和灵活。它可以使对象的创建更加通用，并允许我们在需要时动态地创建对象。同时，由于<code>Supplier&lt;T&gt;</code>是一个函数式接口，我们可以使用lambda表达式和方法引用来创建工厂，使代码更加简洁和易于理解。</p>
<h2 id="优点">优点</h2>
<p>以下是使用依赖注入比硬编码资源的优点：</p>
<ol>
<li>可测试性：使用依赖注入，很容易创建和注入模拟对象进行测试。这样，我们可以将正在测试的组件隔离开来，并专注于测试其行为，而不必担心其依赖项的行为。</li>
<li>灵活性：使用依赖注入，我们可以轻松地用不同实现替换依赖项。这在需要更改组件的行为而不更改其代码时非常有用。</li>
<li>解耦：依赖注入有助于将组件与其依赖项解耦，使代码更加模块化并易于维护。</li>
<li>关注点分离：依赖注入将依赖项的创建和管理与组件本身分离，允许更清晰地分离关注点。</li>
</ol>
<h2 id="运用">运用</h2>
<p>依赖注入是一种常见的设计模式，被广泛应用于许多开源框架中。以下是一些常见的开源框架和库，它们使用依赖注入来管理对象之间的依赖关系：</p>
<ol>
<li>Spring Framework：Spring是一个非常流行的Java框架，它使用依赖注入来管理应用程序中的对象之间的依赖关系。Spring通过<code>@Autowired</code>注解和XML配置文件来实现依赖注入。</li>
<li>Google Guice：Guice是一个轻量级的依赖注入框架，它使用Java注解来实现依赖注入。Guice提供了一个<code>Binder</code>接口，使用户可以配置注入规则。</li>
<li>Dagger：Dagger是一个基于Java和Android平台的依赖注入框架，它使用Java注解和代码生成技术来实现依赖注入。Dagger提供了一个<code>Component</code>接口，用于表示应用程序对象之间的依赖关系。</li>
<li>CDI：CDI是Java EE 6中引入的一种依赖注入框架，它使用Java注解和XML配置文件来实现依赖注入。CDI提供了一个<code>BeanManager</code>接口，使用户可以配置和管理应用程序对象之间的依赖关系。</li>
<li>Micronaut：Micronaut是一个轻量级的依赖注入框架，它使用Java注解和字节码生成技术来实现依赖注入。Micronaut提供了一个<code>@Inject</code>注解，用于标记需要注入的依赖项。</li>
<li>Weld：Weld是一个Java SE和Java EE的依赖注入框架，它使用Java注解和XML配置文件来实现依赖注入。Weld提供了一个<code>BeanManager</code>接口，用于配置和管理应用程序对象之间的依赖关系。</li>
<li>PicoContainer：PicoContainer是一个轻量级的依赖注入框架，它使用Java注解和代码生成技术来实现依赖注入。PicoContainer提供了一个<code>Container</code>接口，用于表示应用程序对象之间的依赖关系。</li>
<li>HK2：HK2是Java EE 8和Jakarta EE 9的依赖注入框架，它使用Java注解和XML配置文件来实现依赖注入。HK2提供了一个<code>ServiceLocator</code>接口，用于配置和管理应用程序对象之间的依赖关系。</li>
<li>Micrometer：Micrometer是一个用于度量应用程序性能的库，它使用依赖注入来管理度量记录器之间的依赖关系。Micrometer支持多种依赖注入框架，包括Spring和Guice。</li>
<li>Google Dagger Hilt：Dagger Hilt是一个基于Dagger 2的依赖注入库，它使用注解来管理对象之间的依赖关系。它提供了一些附加功能，例如使用<code>@ViewModelInject</code>注解来注入ViewModel依赖项。</li>
<li>Quarkus：Quarkus是一个用于构建可扩展的Java应用程序的框架，它使用依赖注入来管理应用程序对象之间的依赖关系。它支持多种依赖注入框架，包括CDI、Spring和Guice。</li>
<li>Micronaut Data：Micronaut Data是一个用于管理数据库访问的库，它使用依赖注入来管理数据访问对象之间的依赖关系。它支持多种ORM框架，包括Hibernate和JDBC。</li>
<li>Akka：Akka是一个用于构建事件驱动应用程序的库，它使用依赖注入来管理Actor之间的依赖关系。它提供了一个<code>@Inject</code>注解，用于标记需要注入的依赖项。</li>
<li>JHipster：JHipster是一个用于生成现代Web应用程序的框架，它使用依赖注入来管理应用程序对象之间的依赖关系。它支持多种依赖注入框架，包括Spring和Guice。</li>
<li>Vert.x：Vert.x是一个基于事件驱动的应用程序框架，它使用依赖注入来管理应用程序对象之间的依赖关系。它支持多种依赖注入框架，包括CDI和Guice。</li>
<li>Quarkus Reactive：Quarkus Reactive是一个用于构建反应式应用程序的框架，它使用依赖注入来管理应用程序对象之间的依赖关系。它支持多种依赖注入框架，包括CDI和Spring。</li>
<li>Micronaut Security：Micronaut Security是一个用于管理Web应用程序安全的库，它使用依赖注入来管理安全服务之间的依赖关系。它支持多种安全框架，包括Spring Security和Apache Shiro。</li>
<li>Eclipse MicroProfile：Eclipse MicroProfile是一个用于构建微服务的框架，它使用依赖注入来管理微服务之间的依赖关系。它支持多种依赖注入框架，包括CDI和Guice。</li>
<li>Kotlin Koin：Koin是一个用于Kotlin应用程序的依赖注入库，它使用DSL语法来管理应用程序对象之间的依赖关系。它支持单例、工厂和懒加载等不同的注入模式。</li>
<li>Spring Cloud：Spring Cloud是一个用于构建分布式系统的框架，它使用依赖注入来管理分布式系统之间的依赖关系。它支持多种依赖注入框架，包括Spring和Guice。</li>
<li>Micronaut HTTP Client：Micronaut HTTP Client是一个用于管理HTTP客户端的库，它使用依赖注入来管理HTTP客户端之间的依赖关系。它支持多种HTTP客户端实现，包括Apache HttpClient和Netty。</li>
<li>Quarkus Security：Quarkus Security是一个用于管理Web应用程序安全的库，它使用依赖注入来管理安全服务之间的依赖关系。它支持多种安全框架，包括Spring Security和Apache Shiro。</li>
</ol>
<p>这些框架和库都使用依赖注入来管理对象之间的依赖关系，使代码更加灵活、可维护和可测试。它们提供了一些不同的注入技术和API，以适应不同的应用场景和需求。</p>
<h3 id="spring依赖注入">Spring依赖注入</h3>
<p>在Spring框架中，依赖注入是核心特性之一。Spring使用依赖注入来管理应用程序对象之间的依赖关系，以实现松耦合、可测试和可扩展的代码。以下是Spring中使用依赖注入的方法：</p>
<ol>
<li>注解：Spring使用注解将依赖项注入到对象中。常用的注解包括<code>@Autowired</code>、<code>@Qualifier</code>和<code>@Value</code>。其中，<code>@Autowired</code>注解用于自动装配依赖项，<code>@Qualifier</code>注解用于指定依赖项的名称或限定符，<code>@Value</code>注解用于从属性文件或环境变量中注入值。</li>
<li>XML配置文件：Spring也支持使用XML配置文件来定义对象之间的依赖关系。在XML配置文件中，可以使用<code>&lt;bean&gt;</code>元素定义对象，并使用<code>&lt;property&gt;</code>元素设置对象的属性和依赖项。</li>
<li>Java配置类：Spring还支持使用Java配置类来定义对象之间的依赖关系。在Java配置类中，可以使用<code>@Configuration</code>注解定义配置类，并使用<code>@Bean</code>注解定义对象，并使用<code>@Autowired</code>注解注入依赖项。</li>
</ol>
<p>以下是一些在Spring中使用依赖注入的例子：</p>
<p><strong>1、自动装配示例：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">   <span class="kd">private</span> <span class="kd">final</span> <span class="n">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">   <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(</span><span class="n">MyRepository</span> <span class="n">myRepository</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">   <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个例子中，<code>MyService</code>类通过构造函数注入了<code>MyRepository</code>依赖。在<code>MyService</code>对象创建时，Spring框架自动装配并注入了<code>MyRepository</code>对象。</p>
<p><strong>2、XML配置示例：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;myService&#34;</span> <span class="na">class=</span><span class="s">&#34;com.example.MyService&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="nt">&lt;constructor-arg</span> <span class="na">ref=</span><span class="s">&#34;myRepository&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;myRepository&#34;</span> <span class="na">class=</span><span class="s">&#34;com.example.MyRepository&#34;</span><span class="nt">/&gt;</span>
</span></span></code></pre></div><p>在这个例子中，<code>MyService</code>类和<code>MyRepository</code>类被定义为Spring的bean，并在XML配置文件中指定它们之间的依赖关系。在<code>MyService</code>对象创建时，Spring框架自动创建并注入了<code>MyRepository</code>对象。</p>
<p><strong>3、Java配置示例：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">   <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">   <span class="kd">public</span> <span class="n">MyService</span> <span class="nf">myService</span><span class="o">(</span><span class="n">MyRepository</span> <span class="n">myRepository</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="k">new</span> <span class="n">MyService</span><span class="o">(</span><span class="n">myRepository</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">   <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">   <span class="kd">public</span> <span class="n">MyRepository</span> <span class="nf">myRepository</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="k">new</span> <span class="n">MyRepository</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">   <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个例子中，<code>AppConfig</code>类通过<code>@Bean</code>注解定义了<code>MyService</code>对象和<code>MyRepository</code>对象，并通过方法参数的方式注入了<code>MyRepository</code>依赖。在应用程序启动时，Spring框架会自动创建并注入这些对象。</p>
<h4 id="spring依赖注入意事项">Spring依赖注入意事项</h4>
<p>在使用Spring中的依赖注入时，有一些注意事项需要注意，以确保代码的正确性和可维护性。</p>
<ol>
<li>依赖项注入的顺序：如果一个类依赖于多个其他类，那么这些依赖项的注入顺序可能会影响到代码的正确性。为了避免这种情况，可以使用<code>@DependsOn</code>注解指定依赖项之间的顺序。</li>
<li>循环依赖：如果两个或多个类之间出现循环依赖，那么会导致对象无法正确创建。为了避免这种情况，可以使用构造函数注入或setter注入来解决循环依赖问题。</li>
<li>作用域：Spring提供了多种作用域，包括单例、原型和请求作用域等。在使用依赖注入时，需要了解每种作用域的区别和适用场景，并选择合适的作用域。</li>
<li>配置文件管理：在使用XML配置文件或Java配置类时，需要注意配置文件或类的管理和维护。可以使用Spring的Profile功能来管理不同的配置文件或类，并根据不同的环境或需求来选择合适的配置。</li>
<li>依赖注入类型选择：Spring支持多种依赖注入类型，包括构造函数注入、setter注入和字段注入等。需要根据情况选择合适的依赖注入类型，并考虑到代码的可测试性和可维护性。</li>
</ol>
<h4 id="如何避免循环依赖问题">如何避免循环依赖问题</h4>
<p>循环依赖是指两个或多个类之间相互依赖而导致无法正确创建对象的情况。在Spring中，可以通过以下几种方式来避免循环依赖问题：</p>
<ol>
<li>使用构造函数注入：构造函数注入是指依赖项通过构造函数的方式进行注入。这种方式可以避免循环依赖问题，因为对象的创建顺序是确定的，每个对象都必须先创建其依赖项，然后才能创建自身。</li>
<li>使用setter注入：setter注入是指依赖项通过setter方法进行注入。这种方式可以避免循环依赖问题，因为对象的创建顺序是不确定的，每个对象都可以先创建自身，然后再通过setter方法注入其依赖项。</li>
<li>使用<code>@Lazy</code>注解：<code>@Lazy</code>注解可以延迟依赖项的注入，直到对象第一次使用该依赖项时才进行注入。这种方式可以避免循环依赖问题，因为对象的创建顺序是不确定的，每个对象都可以先创建自身，然后再等待其依赖项被注入。</li>
<li>优化依赖关系：如果出现循环依赖问题，可以通过优化依赖关系来解决。例如，将依赖项抽象成接口或抽象类，然后通过不同的实现类来解决循环依赖问题。</li>
</ol>
<h4 id="spring多种依赖注入类的优缺点">Spring多种依赖注入类的优缺点</h4>
<p>Spring支持多种依赖注入类型，包括构造函数注入、setter注入和字段注入等。各种依赖注入类型的优缺点如下：</p>
<p><strong>1、构造函数注入</strong></p>
<p>优点：</p>
<ul>
<li>对象创建时依赖项已经确定，可以保证依赖项的完整性和正确性。</li>
<li>依赖项是只读的，可以保证对象的不变性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>构造函数注入比较繁琐，需要在每个类中添加构造函数和依赖项参数。</li>
</ul>
<p><strong>2、setter注入</strong></p>
<p>优点：</p>
<ul>
<li>setter注入比较灵活，可以随时注入或更改依赖项。</li>
<li>可以使用默认构造函数创建对象，简化代码。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对象创建时依赖项可能还未注入，需要进行null检查。</li>
<li>setter方法是公共的，可能会影响对象的不变性。</li>
</ul>
<p><strong>3、字段注入</strong></p>
<p>优点：</p>
<ul>
<li>简单方便，不需要手动编写构造函数或setter方法。</li>
<li>可以使用默认构造函数创建对象，简化代码。</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖项是公共的，可能会影响对象的不变性。</li>
<li>对象创建时依赖项可能还未注入，需要进行null检查。</li>
</ul>
<p>总的来说，**构造函数注入是最推荐的依赖注入方式，因为它可以保证对象的完整性和正确性。**setter注入和字段注入则比较灵活，但需要注意依赖项的注入时机和可能对对象不变性的影响。根据具体的情况和需求，可以选择合适的依赖注入方式。</p>
<h2 id="总结">总结</h2>
<p>总之，不要使用单例或静态实用工具类来实现依赖于一个或多个底层资源的类，这些资源的行为会影响类的行为，也不要让类直接创建这些资源。相反，将创建它们的资源或工厂传递给构造函数（或静态工厂或构建器）。这种操作称为依赖注入，它将大大增强类的灵活性、可复用性和可测试性。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-14｜如何学习一门编程语言</title>
      <link>https://blog.chensoul.com/posts/2023/04/13/weekly_review_14/</link>
      <pubDate>Thu, 13 Apr 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/13/weekly_review_14/</guid>
      <description>前言 本篇是对 2023-04-03 到 2023-04-09 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这周还是和以前一样每天运动，并开始施行断食。因为</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekl-review-14-01.jpg" alt="weekl-review-14-01"  />
</p>
<p>本篇是对 <code>2023-04-03</code> 到 <code>2023-04-09</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这周还是和以前一样每天运动，并开始施行断食。因为是刚开始断食，有时候忍不住饥饿感而吃了一些东西。</p>
<p>本周工作主要是发布了一个版本，其余时间用来学习 Rust 和 Python，初学这两种语言，他们语法上有很多相似之处。如何学习一门编程语言？整理了一些步骤。尝试了一下用多种语言编写猜数游戏，这些语言包括 Rust、Ptyhon、Go、NodeJs、JavaScript、Kotlin、Bash，除了 Java。这是一个很有意思的事情，如果能够把这些语言都熟练掌握，那就更好了。</p>
<h2 id="关于健身">关于健身</h2>
<p>完成了每天一万步的计划，并且共跑步 5 次，一共 18.6 公里，平均配速 7 分钟4 9 秒，每天跳绳 500+。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekl-review-14-03.jpg" alt="weekl-review-14-03" style="width:67%;" />
<h2 id="关于记账">关于记账</h2>
<p>本周继续使用微信记账本记录每天支出。累计消费835元，明细如下：</p>
<ul>
<li>
<p>4月3日，周一：支出 59 元，餐饮</p>
</li>
<li>
<p>4月4日，周二：支出 0 元，</p>
</li>
<li>
<p>4月5日，周三：支出 228 元，超市购物</p>
</li>
<li>
<p>4月6日，周四：支出 15 元，停车费</p>
</li>
<li>
<p>4月7日，周五：支出 12 元</p>
</li>
<li>
<p>4月8日，周六：支出 415 元，加油+餐饮</p>
</li>
<li>
<p>4月8日，周日：支出 106 元，餐饮</p>
</li>
</ul>
<h2 id="如何学习一门编程语言">如何学习一门编程语言</h2>
<p>学习一门编程语言的基础语法对于初学者来说非常重要，以下是一些详细的步骤：</p>
<ol>
<li>了解编程语言的基础概念：在学习编程语言之前，了解编程的基础概念是非常重要的。例如，变量、数据类型、条件语句、循环、函数等等。</li>
<li>寻找学习资源：学习编程语言的基础语法可以通过各种学习资源来实现，如书籍、教程、在线视频和交互式学习平台等。选择适合自己的学习资源是非常重要的。</li>
<li>学习变量和数据类型：在学习编程语言之前，学习变量和数据类型是必须的。了解如何定义变量、赋值和使用不同的数据类型，例如字符串、整数、浮点数、布尔值等等。</li>
<li>学习条件语句：条件语句是编程语言中的重要概念之一。例如，学习如何使用if语句和else语句，使程序在特定条件下执行不同的代码块。</li>
<li>学习循环：循环是编程语言中的另一个重要概念。例如，学习如何使用while循环和for循环，使程序在特定条件下重复执行代码块。</li>
<li>学习函数：函数是编程语言中的重要概念之一。学习如何定义和使用函数，以将代码结构化并重用。</li>
<li>练习编写代码：练习编写代码是学习编程语言基础语法的重要方式。编写小程序或项目，例如打印&quot;Hello World&quot;、计算器或猜数字游戏等。</li>
<li>学习调试和错误处理：学习如何调试代码和处理常见错误，例如语法错误、逻辑错误和运行时错误等。</li>
</ol>
<p>总结一下，学习一门编程语言的步骤：</p>
<ul>
<li>
<p>安装</p>
</li>
<li>
<p>Hello World</p>
<ul>
<li>注释</li>
<li>格式化输出</li>
</ul>
</li>
<li>
<p>变量和常量</p>
</li>
<li>
<p>数据类型</p>
<ul>
<li>基本类型
<ul>
<li>运算</li>
<li>类型转换</li>
</ul>
</li>
<li>复杂类型</li>
</ul>
</li>
<li>
<p>表达式和语句</p>
<ul>
<li>条件</li>
<li>循环</li>
<li>断言</li>
</ul>
</li>
<li>
<p>函数</p>
</li>
<li>
<p>类和对象</p>
</li>
<li>
<p>包和模块</p>
</li>
<li>
<p>异常处理</p>
</li>
<li>
<p>标准库</p>
<ul>
<li>IO</li>
<li>网络</li>
<li>多线程</li>
</ul>
</li>
<li>
<p>单元测试</p>
</li>
</ul>
<p>接下来，打算按照上面的步骤来学习 Rust、Python、Go，也许还会有 NodeJs 和 Kotlin，并整理相关笔记。</p>
<h2 id="工作">工作</h2>
<h3 id="effective-java-3-笔记">Effective Java 3 笔记</h3>
<p>请参考 <a href="/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/">《Effective Java 3》笔记：使用私有构造函数或枚举类型创建单例</a></p>
<h3 id="rust">Rust</h3>
<p>因为对 <a href="https://tauri.app/">Tauri</a> 这个 GUI 框架挺感兴趣，所以我开始学习 Rust 了，目前在参考 <a href="https://rustwiki.org/">https://rustwiki.org/</a> 上的 <a href="https://rustwiki.org/zh-CN/rust-by-example/">通过例子学 Rust</a> 和 《Rust权威指南》 学习 Rust。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekl-review-14-02.jpg" alt="weekl-review-14-02" style="width:50%;" />
<h2 id="好物分享">好物分享</h2>
<p>虽然大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。</p>
<h3 id="一些文章">一些文章</h3>
<ul>
<li><a href="http://ebookconverter.blogspot.com/2013/11/where-to-find-epub-file-in-ibooks-for.html">Where to find the EPUB file in iBooks for Mac under OS X 10.9 Mavericks</a></li>
<li><a href="https://roy.wang/umami-js-quicken/">使用 CDN 加速 Umami 静态资源</a></li>
<li><a href="https://blog.alswl.com/2023/04/web-api-guidelines/">实用 Web API 规范</a></li>
<li><a href="https://utgd.net/article/9367">一次本地免费过滤 RSS 的尝试：NetNewsWire</a></li>
<li><a href="https://catcoding.me/p/redis-antriez/">不想当作家的程序员写不出 Redis</a></li>
<li><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2023/03/30/kotlin-syntax.html">Kotlin 语法一站式手册</a></li>
</ul>
<h3 id="一些工具">一些工具</h3>
<ul>
<li><a href="https://listmonk.app/">Listmonk</a> 一款自主托管的电子邮件列表管理工具。它允许您将邮件列表导入到自己的服务器中，并使用它来管理您的邮件列表和发送电子邮件。Listmonk具有良好的可扩展性和自定义性，可通过REST API进行操作，并支持高级功能，例如自定义字段、模板和自动化工作流程，从而使其成为一个非常有用和灵活的电子邮件列表管理工具。与其他在线邮件列表服务相比，Listmonk的优势之一是您完全掌控自己的数据和服务器，因此您不必担心第三方公司的数据隐私问题。</li>
<li><a href="https://ricks-apps.com/osx/sitesucker/index.html">SiteSucker</a> SiteSucker是一款MacOS平台上的免费工具，它可以帮助用户将整个网站下载到本地电脑中。使用SiteSucker，用户只需要输入目标网站的URL，它就会自动下载该网站的所有页面、图像、视频和其他资源，并将它们保存在本地硬盘上，以便用户离线浏览或备份。SiteSucker支持多线程下载和断点续传，可以在不中断下载的情况下暂停和恢复下载任务。此外，它还可以过滤URL，以便用户只下载特定类型的文件，例如HTML、图像或视频文件。总之，SiteSucker是一款非常实用的工具，适用于需要离线浏览网站、备份网站或进行网站抓取的用户。</li>
<li><a href="https://montaigne.io/">Montaigne</a> 用苹果笔记来创建网站、博客或作品集</li>
<li><a href="https://github.com/BlueMatthew/WechatExporter">WechatExporter</a> 聊天记录导出</li>
<li><a href="https://paw.cloud/">RapidAPI</a> 一款MacOS平台上的API开发工具，它旨在帮助开发人员更轻松地设计、测试和调试API。Paw提供了一个直观的用户界面，可以让用户轻松地构建和调试API请求，并查看服务器响应。Paw支持多种API协议和格式，例如REST、SOAP、GraphQL、JSON和XML等，可以与多种服务器端点和身份验证方式进行集成。此外，Paw还具有强大的自动化和脚本化功能，允许用户使用JavaScript或Python编写自定义脚本，以自动化API测试和集成工作流程。</li>
<li><a href="https://gist.github.com/VincentSit/a682f4162b998c7f24d08ab34bf233da">卸载MacOS微信键盘</a></li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Effective Java 3》笔记3：使用私有构造函数或枚举类型创建单例</title>
      <link>https://blog.chensoul.com/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</link>
      <pubDate>Tue, 11 Apr 2023 08:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。 介绍 单例是一个只实例化一次的类。单例通常表示无</description>
      <content:encoded><![CDATA[<p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。</p>
<h2 id="介绍">介绍</h2>
<p>单例是一个只实例化一次的类。单例通常表示无状态对象，比如函数或系统组件，它们在本质上是唯一的。<strong>将一个类设计为单例会使它的客户端测试时变得困难，</strong> 除非它实现了作为其类型的接口，否则无法用模拟实现来代替单例。</p>
<h2 id="实现">实现</h2>
<p>实现单例有两种常见的方法。两者都基于保持构造函数私有和导出公共静态成员以提供对唯一实例的访问。</p>
<p>在第一种方法中，成员是一个 final 字段：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Singleton with public final field
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Elvis</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Elvis</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Elvis</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Elvis</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>私有构造函数只调用一次，用于初始化 <code>public static final </code>修饰的 Elvis 类型字段 <code>INSTANCE</code>。不使用 <code>public</code> 或 <code>protected</code> 的构造函数保证了「独一无二」的空间：一旦初始化了 Elvis 类，就只会存在一个 Elvis 实例，不多也不少。客户端所做的任何事情都不能改变这一点，但有一点需要注意：拥有特殊权限的客户端可以借助 <code>AccessibleObject.setAccessible</code> 方法利用反射调用私有构造函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Constructor</span><span class="o">&lt;?&gt;[]</span> <span class="n">constructors</span> <span class="o">=</span> <span class="n">Elvis</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructors</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">AccessibleObject</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="n">constructors</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">constructors</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;Elvis&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Elvis</span> <span class="n">instance</span> <span class="o">=</span> <span class="o">(</span><span class="n">Elvis</span><span class="o">)</span> <span class="n">name</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">instance</span><span class="o">.</span><span class="na">leaveTheBuilding</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">});</span>
</span></span></code></pre></div><p>如果需要防范这种攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。</p>
<p>在实现单例的第二种方法中，公共成员是一种静态工厂方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Singleton with static factory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Elvis</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Elvis</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Elvis</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Elvis</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Elvis</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>所有对 <code>getInstance()</code> 方法的调用都返回相同的对象引用，并且不会创建其他 Elvis 实例。</p>
<p>公共字段方法的主要优点是 API 明确了类是单例的：public static 修饰的字段是 final 的，因此它总是包含相同的对象引用。第二个优点是更简单。</p>
<p>静态工厂方法的一个优点是，它可以在不更改 API 的情况下决定类是否是单例。工厂方法返回唯一的实例，但是可以对其进行修改，为调用它的每个线程返回一个单独的实例。第二个优点是，如果应用程序需要的话，可以编写泛型的单例工厂。使用静态工厂的最后一个优点是方法引用能够作为一个提供者，例如 <code>Elvis::getInstance</code> 是 <code>Supplier&lt;Elvis&gt;</code> 的提供者。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Elvis</span><span class="o">&gt;</span> <span class="n">sup</span> <span class="o">=</span> <span class="n">Elvis</span><span class="o">::</span><span class="n">getInstance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Elvis</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">sup</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span><span class="o">.</span><span class="na">leaveTheBuilding</span><span class="o">();</span>
</span></span></code></pre></div><p>除非能够与这些优点沾边，否则使用 public 字段的方式更可取。</p>
<p>要使单例类使用这两种方法中的任何一种实现可序列化，仅仅在其声明中添加实现 <code>serializable</code> 是不够的。要维护单例保证，应声明所有实例字段为 <code>transient</code>，并提供 <code>readResolve</code> 方法。否则，每次反序列化实例时，都会创建一个新实例，在我们的示例中，这会导致出现虚假的 Elvis。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// readResolve method to preserve singleton property
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">private</span> <span class="n">Object</span> <span class="nf">readResolve</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Return the one true Elvis and let the garbage collector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// take care of the Elvis impersonator.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>实现单例的第三种方法是声明一个单元素枚举：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Enum singleton - the preferred approach
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Elvis</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">INSTANCE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这种方法类似于 <code>public</code> 字段方法，但是它更简洁，默认提供了序列化机制，提供了对多个实例化的严格保证，即使面对复杂的序列化或反射攻击也是如此。这种方法可能有点不自然，但是<strong>单元素枚举类型通常是实现单例的最佳方法。</strong> 注意，如果你的单例必须扩展一个超类而不是 <code>Enum</code>（尽管你可以声明一个 Enum 来实现接口），你就不能使用这种方法。</p>
<h2 id="扩展">扩展</h2>
<p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。在Java语言中，单例模式一般有以下几种实现方式：</p>
<h3 id="饿汉式单例模式">饿汉式单例模式</h3>
<p>在类加载时就创建单例实例，因此也称为静态初始化单例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EagerSingleton</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">EagerSingleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EagerSingleton</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">EagerSingleton</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">EagerSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="懒汉式单例模式">懒汉式单例模式</h3>
<p>在第一次调用<code>getInstance()</code>方法时才创建单例实例，也称为延迟初始化单例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LazySingleton</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="n">LazySingleton</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">LazySingleton</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="n">LazySingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LazySingleton</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例代码中，我们使用了<code>synchronized</code>关键字来保证线程安全。但是这种方式会影响性能，因为每次调用<code>getInstance()</code>方法都会进行同步。因此，我们可以使用双重检查锁定来提高性能。</p>
<h3 id="双重检查锁定单例模式">双重检查锁定单例模式</h3>
<p>在懒汉式单例模式的基础上，使用双重检查锁定来保证线程安全和性能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LazySingleton</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="n">LazySingleton</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">LazySingleton</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">LazySingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">LazySingleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LazySingleton</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上述实现中，<code>instance</code> 字段使用 <code>volatile</code> 关键字修饰，可以确保多个线程都能够正确地处理该变量。</p>
<p>在 <code>getInstance()</code> 方法中，首先检查实例是否已经存在，如果存在则直接返回实例引用。否则，获取类对象的锁，再次检查实例是否存在。如果实例仍然不存在，则创建实例。由于 <code>synchronized</code> 关键字可以确保同一时刻只有一个线程可以进入临界区，因此可以避免多个线程同时创建实例的情况。</p>
<p>需要注意的是，在使用双重锁检测时，需要使用 <code>volatile</code> 关键字来保证多个线程都能够正确地处理共享变量。同时，为了保证所有线程都看到同一个实例，需要使用静态字段来存储单例实例。</p>
<blockquote>
<p><strong>关于  <code>volatile</code> 关键字修饰</strong></p>
<p>在 Java 中，当一个变量被多个线程共享时，如果没有采取特殊的措施，可能会出现一个线程修改了变量值，但其他线程并没有看到该变量的变化的情况。这是因为每个线程都有自己的 CPU 缓存，该变量的值可能存在于某个线程的 CPU 缓存中，但其他线程并没有及时更新缓存中的值。</p>
<p><code>volatile</code> 是一种 Java 关键字，它可以确保多个线程都能够正确地处理该变量。当一个变量被声明为 <code>volatile</code> 时，它会具有以下特性：</p>
<ol>
<li>可见性：当一个线程修改了 <code>volatile</code> 变量的值时，其他线程可以立即看到该变化。</li>
<li>禁止指令重排：编译器和 CPU 会对指令进行重排以提高执行效率，但有时这种重排可能会导致多线程程序出现问题。<code>volatile</code> 变量的写操作会在读操作之前，确保变量的修改对其他线程立即可见，从而禁止指令重排。</li>
</ol>
<p>在上述单例模式实现中，<code>instance</code> 字段被声明为 <code>volatile</code>，这是为了确保多个线程都能够正确地处理该变量。如果没有使用 <code>volatile</code>，可能会出现某个线程创建了实例，但其他线程并没有看到该变化的情况。使用 <code>volatile</code> 可以确保多个线程都能够正确地处理 <code>instance</code> 变量，从而避免出现多个实例的情况。</p>
</blockquote>
<h3 id="枚举单例模式">枚举单例模式</h3>
<p>使用枚举类型来定义单例，它保证了线程安全和序列化安全。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">enum</span> <span class="n">EnumSingleton</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">INSTANCE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>关于枚举</strong></p>
<p>在 Java 中，枚举是一种特殊的类，它可以用于定义一组常量。枚举常量是在枚举类被加载时创建的，且只会被创建一次。因此，枚举天然具有单例模式的特性。</p>
<p>在 Java 中，单例模式是一种常用的设计模式，它可以确保某个类只有一个实例，并提供全局访问点。单例模式的实现方式有多种，包括懒汉式、饿汉式、双重检查锁等。但是，这些实现方式都需要考虑线程安全和序列化等问题，而枚举天然具有线程安全和序列化的特性。</p>
<p>枚举类是在 Java 1.5 版本中引入的，它是一个特殊的类，可以用于定义一组常量。枚举常量是在枚举类被加载时创建的，且只会被创建一次。因此，枚举天然具有单例模式的特性，而且枚举类的实现方式非常简单，无需考虑线程安全和序列化等问题。因此，使用枚举实现单例模式是一种简单、安全、高效的方式。</p>
</blockquote>
<p>一个实际中使用的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@AllArgsConstructor</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Getter</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">enum</span> <span class="n">ChannelType</span> <span class="kd">implements</span> <span class="n">CodeAware</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">VMS</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&#34;语音电话&#34;</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">AbstractNotificationStrategy</span> <span class="nf">strategy</span><span class="o">(</span><span class="n">Properties</span> <span class="n">properties</span><span class="o">,</span> <span class="n">NotificationTemplate</span> <span class="n">notificationTemplate</span><span class="o">,</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">NotificationUser</span><span class="o">&gt;</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">VmsNotificationStrategy</span><span class="o">(</span><span class="k">new</span> <span class="n">VmsNotificationChannel</span><span class="o">(</span><span class="n">properties</span><span class="o">),</span> <span class="n">notificationTemplate</span><span class="o">,</span> <span class="n">users</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">NotificationTemplate</span> <span class="nf">template</span><span class="o">(</span><span class="n">String</span> <span class="n">title</span><span class="o">,</span> <span class="n">String</span> <span class="n">template</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">imageUrls</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">VmsNotificationTemplate</span><span class="o">(</span><span class="n">title</span><span class="o">,</span> <span class="n">template</span><span class="o">,</span> <span class="n">imageUrls</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">},</span>
</span></span><span class="line"><span class="cl">    <span class="n">FEISHU</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">&#34;飞书&#34;</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">AbstractNotificationStrategy</span> <span class="nf">strategy</span><span class="o">(</span><span class="n">Properties</span> <span class="n">properties</span><span class="o">,</span> <span class="n">NotificationTemplate</span> <span class="n">notificationTemplate</span><span class="o">,</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">NotificationUser</span><span class="o">&gt;</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">FeishuNotificationStrategy</span><span class="o">(</span><span class="k">new</span> <span class="n">FeishuNotificationChannel</span><span class="o">(</span><span class="n">properties</span><span class="o">),</span> <span class="n">notificationTemplate</span><span class="o">,</span> <span class="n">users</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">NotificationTemplate</span> <span class="nf">template</span><span class="o">(</span><span class="n">String</span> <span class="n">title</span><span class="o">,</span> <span class="n">String</span> <span class="n">template</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">imageUrls</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">FeishuNotificationTemplate</span><span class="o">(</span><span class="n">title</span><span class="o">,</span> <span class="n">template</span><span class="o">,</span> <span class="n">imageUrls</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Integer</span> <span class="n">code</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">AbstractNotificationStrategy</span> <span class="nf">strategy</span><span class="o">(</span><span class="n">Properties</span> <span class="n">properties</span><span class="o">,</span> <span class="n">NotificationTemplate</span> <span class="n">notificationTemplate</span><span class="o">,</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">NotificationUser</span><span class="o">&gt;</span> <span class="n">users</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">NotificationTemplate</span> <span class="nf">template</span><span class="o">(</span><span class="n">String</span> <span class="n">title</span><span class="o">,</span> <span class="n">String</span> <span class="n">template</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">imageUrls</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="静态内部类单例模式">静态内部类单例模式</h3>
<p>静态内部类单例模式是一种常用的实现单例模式的方式，它可以保证线程安全且实现简单。在该模式中，单例实例是通过静态内部类来实现的。</p>
<blockquote>
<p>在 Java 中，静态内部类是一种特殊的类，它是在另一个类内部定义的静态类。静态内部类可以访问外部类的静态字段和方法，但不能访问外部类的非静态字段和方法。</p>
</blockquote>
<p>使用静态内部类实现单例模式的方式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StaticInnerClassSingleton</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">StaticInnerClassSingleton</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonHolder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">StaticInnerClassSingleton</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StaticInnerClassSingleton</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">StaticInnerClassSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">SingletonHolder</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上述代码中，<code>SingletonHolder</code> 是静态内部类，它包含一个静态常量 <code>INSTANCE</code>，该常量是在静态内部类被加载时创建的，且只会被创建一次。由于静态内部类的加载是在需要时才进行的，因此可以实现懒加载的效果。在 <code>getInstance</code> 方法中，直接返回 <code>SingletonHolder.INSTANCE</code> 即可获取单例实例。</p>
<p>在静态内部类单例模式中，由于静态内部类的加载是在需要时才进行的，且只会被加载一次，因此可以保证单例实例的线程安全。在多线程环境下，多个线程同时调用 <code>getInstance</code> 方法时，由于静态内部类的加载是线程安全的，因此可以保证只有一个单例实例被创建。</p>
<p>此外，静态内部类单例模式的实现方式简单且易于理解，而且不需要考虑线程安全和序列化等问题，因此是一种常用的实现单例模式的方式。</p>
<h3 id="注册式单例模式">注册式单例模式</h3>
<p>使用容器来存储单例实例，通过唯一的标识符来访问单例实例。</p>
<p>总的来说，每种实现方式都有其适用的场景和优缺点，开发者需要根据具体的需求来选择合适的实现方式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonRegistry</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">registry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">SingletonRegistry</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">register</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">registry</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="n">Object</span> <span class="nf">getSingleton</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">registry</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例代码中，我们在<code>register()</code>方法和<code>getSingleton()</code>方法上都加了<code>synchronized</code>关键字，确保了多线程情况下的线程安全。但是这种方式会影响性能，因为每次调用<code>getSingleton()</code>方法都会进行同步。</p>
<p>以下是使用并发容器实现线程安全的示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonRegistry</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">registry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">SingletonRegistry</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">register</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">registry</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">getSingleton</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">registry</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用<code>ConcurrentMap</code>的<code>computeIfAbsent</code>方法可以更加简洁地实现线程安全的注册式单例模式，它可以确保多线程情况下的线程安全，并且避免了使用<code>synchronized</code>关键字带来的性能问题。</p>
<p>以下是使用<code>ConcurrentMap</code>的<code>computeIfAbsent</code>方法实现线程安全的示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonRegistry</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">registry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">SingletonRegistry</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">register</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">registry</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">getSingleton</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">registry</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">createSingleton</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">createSingleton</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// create singleton object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例代码中，我们使用<code>ConcurrentHashMap</code>来存储注册信息，并且使用了<code>putIfAbsent</code>方法来避免重复添加元素。在<code>getSingleton</code>方法中，我们使用了<code>computeIfAbsent</code>方法来获取单例实例，如果实例不存在，则调用<code>createSingleton</code>方法创建实例。由于<code>ConcurrentHashMap</code>的并发操作是线程安全的，因此使用<code>computeIfAbsent</code>方法可以确保多线程情况下的线程安全。</p>
<h2 id="运用">运用</h2>
<p>以下，整理了常见的开源框架中单例模式运用。</p>
<h3 id="log4j">Log4j</h3>
<p>Log4j 是一个用于记录日志的开源框架，它使用单例模式来管理 Logger 的实例。Logger 是一个线程安全的类，用于记录应用程序的日志信息。</p>
<p>以下是 Log4j 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Logger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Logger</span><span class="o">&gt;</span> <span class="n">instances</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Logger</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Logger</span> <span class="nf">getLogger</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Logger</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">instances</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">instances</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">instance</span> <span class="o">=</span> <span class="n">instances</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Logger</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                    <span class="n">instances</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">instance</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，Logger 使用一个 Map 来缓存所有的 Logger 实例，并在需要获取 Logger 实例时使用双重检查锁定机制来确保只有一个线程可以创建实例。</p>
<h3 id="jedis">Jedis</h3>
<p>Jedis 是一个用于连接 Redis 数据库的开源框架，它使用单例模式来管理 JedisPool 的实例。JedisPool 是一个线程安全的类，用于管理可重用的 Jedis 实例。</p>
<p>以下是 Jedis 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JedisPool</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">JedisPool</span><span class="o">&gt;</span> <span class="n">INSTANCES</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">JedisPool</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="n">JedisPool</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">String</span> <span class="n">host</span><span class="o">,</span> <span class="kt">int</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">host</span> <span class="o">+</span> <span class="s">&#34;:&#34;</span> <span class="o">+</span> <span class="n">port</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">JedisPool</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">INSTANCES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JedisPool</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">INSTANCES</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">instance</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，Jedis 使用一个 ConcurrentHashMap 来缓存所有的 JedisPool 实例，并在需要获取 JedisPool 实例时使用 synchronized 方法来确保只有一个线程可以创建实例。</p>
<h3 id="retrofit">Retrofit</h3>
<p>Retrofit 是一个用于简化 HTTP 请求的开源框架，它使用单例模式来管理 Retrofit 的实例。Retrofit 是一个线程安全的类，用于创建 HTTP 请求。</p>
<p>以下是 Retrofit 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Retrofit</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Retrofit</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Retrofit</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Retrofit</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Retrofit</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">create</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// create HTTP request using service interface
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，Retrofit 使用静态变量和静态方法来获取单例实例，并在整个应用程序中共享使用。</p>
<h3 id="gson">Gson</h3>
<p>Gson 是一个用于将 JSON 字符串转换为 Java 对象的开源框架，它使用单例模式来管理 Gson 的实例。Gson 是一个线程安全的类，用于处理 JSON 数据。</p>
<p>以下是 Gson 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Gson</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Gson</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Gson</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Gson</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Gson</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">fromJson</span><span class="o">(</span><span class="n">String</span> <span class="n">json</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">classOfT</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// convert JSON string to Java object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，Gson 使用静态变量和静态方法来获取单例实例，并在整个应用程序中共享使用。</p>
<h3 id="spring-framework">Spring Framework</h3>
<p>Spring Framework 是一个用于构建企业级 Java 应用程序的开源框架，它使用单例模式来管理 Bean 的实例。Bean 是一个线程安全的类，用于实现应用程序的业务逻辑。</p>
<p>以下是 Spring Framework 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultListableBeanFactory</span> <span class="kd">implements</span> <span class="n">BeanFactory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">singletonObjects</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;(</span><span class="mi">256</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getBean</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">BeansException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Object</span> <span class="n">bean</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">bean</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">bean</span> <span class="o">=</span> <span class="n">createBean</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">bean</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Object</span> <span class="nf">createBean</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// create Bean instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，Spring Framework 使用一个 ConcurrentHashMap 来缓存所有的 Bean 实例，并在需要获取 Bean 实例时使用双重检查锁定机制来确保只有一个线程可以创建实例。</p>
<h3 id="hibernate">Hibernate</h3>
<p>Hibernate 是一个用于处理关系数据库的开源框架，它使用单例模式来管理 SessionFactory 的实例。SessionFactory 是一个线程安全的类，用于创建和管理 Session 对象。</p>
<p>以下是 Hibernate 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SessionFactory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">SessionFactory</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SessionFactory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">SessionFactory</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">SessionFactory</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Session</span> <span class="nf">openSession</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// create and return new Session object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，Hibernate 使用静态变量和静态方法来获取单例实例，并在整个应用程序中共享使用。</p>
<h3 id="junit">JUnit</h3>
<p>JUnit 是一个用于编写单元测试的开源框架，它使用单例模式来管理 TestSuite 的实例。TestSuite 是一个线程安全的类，用于管理测试用例的集合。</p>
<p>以下是 JUnit 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestSuite</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">TestSuite</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestSuite</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">testCases</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">TestSuite</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">TestSuite</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addTestCase</span><span class="o">(</span><span class="n">TestCase</span> <span class="n">testCase</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">testCases</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">testCase</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="n">TestResult</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">TestCase</span> <span class="n">testCase</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">testCase</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，JUnit 使用静态变量和静态方法来获取 TestSuite 的单例实例，并在整个测试应用程序中共享使用。</p>
<h3 id="apache-commons-lang">Apache Commons Lang</h3>
<p>Apache Commons Lang 是一个用于提供常用 Java 工具类的开源库，它使用单例模式来管理 CharSet 的实例。CharSet 是一个线程安全的类，用于管理字符集编码。</p>
<p>以下是 Apache Commons Lang 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CharSet</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">CharSet</span><span class="o">&gt;</span> <span class="n">INSTANCES</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">CharSet</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">CharSet</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">CharSet</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">INSTANCES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">CharSet</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">instance</span> <span class="o">=</span> <span class="n">INSTANCES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CharSet</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                    <span class="n">INSTANCES</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">instance</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，Apache Commons Lang 使用一个 ConcurrentHashMap 来缓存所有的 CharSet 实例，并在需要获取 CharSet 实例时使用双重检查锁定机制来确保只有一个线程可以创建实例。</p>
<h3 id="apache-commons-pool">Apache Commons Pool</h3>
<p>Apache Commons Pool 是一个用于管理对象池的开源库，它使用单例模式来管理 ObjectPool 的实例。ObjectPool 是一个线程安全的类，用于管理可重用对象的池。</p>
<p>以下是 Apache Commons Pool 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">ObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ObjectPool</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">INSTANCES</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">GenericObjectPool</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">PooledObjectFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">factory</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ObjectPool</span><span class="o">&lt;?&gt;</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">INSTANCES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericObjectPool</span><span class="o">&lt;&gt;(</span><span class="n">factory</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">INSTANCES</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">instance</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">(</span><span class="n">ObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;)</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，Apache Commons Pool 使用一个 ConcurrentHashMap 来缓存所有的 ObjectPool 实例，并在需要获取 ObjectPool 实例时使用 synchronized 方法来确保只有一个线程可以创建实例。</p>
<h3 id="tomcat">Tomcat</h3>
<p>Tomcat 是一个用于运行 Java Web 应用程序的开源服务器，它使用单例模式来管理 ServletContext 的实例。ServletContext 是一个线程安全的类，用于管理 Web 应用程序的上下文信息。</p>
<p>以下是 Tomcat 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationContext</span> <span class="kd">extends</span> <span class="n">StandardContext</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ApplicationContext</span><span class="o">&gt;</span> <span class="n">INSTANCES</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">ApplicationContext</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ApplicationContext</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">String</span> <span class="n">contextPath</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ApplicationContext</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">INSTANCES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">contextPath</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">ApplicationContext</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">instance</span> <span class="o">=</span> <span class="n">INSTANCES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">contextPath</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ApplicationContext</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                    <span class="n">instance</span><span class="o">.</span><span class="na">setPath</span><span class="o">(</span><span class="n">contextPath</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">INSTANCES</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">contextPath</span><span class="o">,</span> <span class="n">instance</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，Tomcat 使用一个 ConcurrentHashMap 来缓存所有的 ServletContext 实例，并在需要获取 ServletContext 实例时使用双重检查锁定机制来确保只有一个线程可以创建实例。</p>
<h3 id="okhttp">OkHttp</h3>
<p>OkHttp 是一个用于进行网络请求的开源框架，它使用单例模式来管理 OkHttpClient 的实例。OkHttpClient 是一个线程安全的类，用于管理网络请求的配置和执行。</p>
<p>以下是 OkHttp 的单例模式实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OkHttpClient</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">OkHttpClient</span><span class="o">&gt;</span> <span class="n">INSTANCES</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">OkHttpClient</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// private constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="n">OkHttpClient</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="s">&#34;default&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">OkHttpClient</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">INSTANCES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OkHttpClient</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">                    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">INSTANCES</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">instance</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// other methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例中，OkHttp 使用一个 ConcurrentHashMap 来缓存所有的 OkHttpClient 实例，并在需要获取 OkHttpClient 实例时使用 synchronized 方法来确保只有一个线程可以创建实例。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-13｜健身、记账、更新SSL证书、代码提交百度站点收录</title>
      <link>https://blog.chensoul.com/posts/2023/04/04/weekly_review_13/</link>
      <pubDate>Tue, 04 Apr 2023 15:40:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/04/weekly_review_13/</guid>
      <description>前言 本篇是对 2023-03-27 到 2023-04-02 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 本周是三月的最后一周，想到这，就想对随便对三月份</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-13-01.jpeg" alt="weekly-review-13-01"  />
</p>
<p>本篇是对 <code>2023-03-27</code> 到 <code>2023-04-02</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>本周是三月的最后一周，想到这，就想对随便对三月份做个总结。总结的方面，大概包括工作、生活、学习、健身、财务、娱乐几个方面。万事开头难，不知道能者多少，但是，相信不管写多少，都是有意义的。</p>
<p>先来说说最近一周做了什么。查看一下 gitlab 上标签提交记录，这周发布了一个版本，其余时间是进行测试，为下周发布做准备。在工作之余，开始学习《Effective Java 3》，并用 chatgpt 作为辅助工作，加深对技术的理解。另外，有了想学习 React、Rust、Go、Pyhon 的想法。想学的东西有点多，只能一步步来。争取每天利用下班之后的一个小时进行碎片化的学习，并且做好相关笔记，如有可能发布在这个博客上面。加油！</p>
<p>这周完成了每天一万步的计划，其中周末走了 3 万多步，并且还开始了跑步。</p>
<h2 id="关于健身">关于健身</h2>
<p>完成了每天一万步的计划，并且共跑步 8 次，一共 26 公里，最高平均配速 7 分钟，还跳绳一次（550 下）。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-13-03.jpeg" alt="weekly-review-13-03" style="width:50%;" />
<p>跑步的目的不是快，而是乐此不疲。每天跑步 5 公里，每次消耗 300 卡路里的热量，大概需要 10 周才能瘦 10 斤。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-13-02.jpeg" alt="weekly-review-13-02" style="width:50%;" />
<p>光靠走路和跑步，想在 4 月完成瘦 10 斤的目标，应该是不可能的，打算辅助间歇性断食，看下效果。</p>
<blockquote>
<p>跑步是一种有氧运动，可以促进身体代谢，消耗体内的脂肪和热量，达到减肥的效果。但是减肥的效果受到很多因素的影响，如个人的体重、身高、年龄、性别、饮食习惯、跑步强度、频率和时长等。</p>
<p>通常来说，减肥的基本原理是消耗更多的热量，从而达到体重减轻的效果。每天跑步 5 公里的运动量相对较小，一般在一个小时左右可以完成。如果每天坚持跑步，同时注意饮食控制，增加其他有氧运动和合理的休息，可能会在几个月内看到一定的减肥效果。</p>
<p>根据一般的减肥经验，每消耗 3500 卡路里的热量就可以减少一斤体重。假设每次跑步消耗 300 卡路里的热量，那么每天跑步 5 公里约消耗 300 ~ 400 卡路里的热量。如果每天坚持跑步，并且保持每天消耗 300 ~ 400 卡路里的热量，那么大约需要 10 周时间才能减少 10 斤体重。</p>
</blockquote>
<h2 id="关于记账">关于记账</h2>
<p>上周开始，在寻找一个记账的 APP，想开始记录每天的收入与支出。当然，更多的应该是支出了。现在，大环境不行，公司裁员不停，必须要开源节流，手上储备足够的现金。</p>
<p>找来找去，发现微信里没有有个『微信记账本』小程序就可以在微信里自动记账，也支持手动记账。于是，这周试了一下这个小程序，并有意的控制自己每天的输出。因为每天都有带饭，这样中饭就不用花钱了；早餐呢，是泡之前买的黑芝麻糊喝，省去了早餐费用。结果是，这周的支出只有 4.5 元。一次是早上买了一本豆浆，一次是早上跑步怕迟到就骑了一次动感单车。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-13-05.jpeg" alt="weekly-review-13-05" style="width:50%;" />
<p>正好三月结束了，查看了一下三月的支出报表。总的来说，三月支出的有点多，超乎了我的想象。如果每个月都是支出这么多，那以后的零花钱就不够用了。还是要勒紧裤腰带过日子啊。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-13-04.jpeg" alt="weekly-review-13-04" style="width:50%;" />
<h2 id="更新-ssl-证书">更新 SSL 证书</h2>
<p>安装 acme.sh</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">curl https://get.acme.sh <span class="p">|</span> sh -s <span class="nv">email</span><span class="o">=</span>chensoul.eth@gmail.com
</span></span></code></pre></div><p><strong>我的域名托管在cloudflare</strong>，故需要获取 <a href="https://dash.cloudflare.com/profile/api-tokens">cloudflare API key</a>，在 <code>API 令牌</code> 页面，点击查看 <code>Global API Key</code>。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-13-06.png" alt="weekly-review-13-06"  />
</p>
<p>保存 <code>CF_Key</code> 和 <code>CF_Email</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CF_Key</span><span class="o">=</span><span class="s2">&#34;cloudflare 中查看你的 key&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CF_Email</span><span class="o">=</span><span class="s2">&#34;chensoul.eth@gmail.com&#34;</span>
</span></span></code></pre></div><p>生成证书，并重启 nginx：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">acme.sh --issue -d <span class="s2">&#34;chensoul.com&#34;</span> -d <span class="s2">&#34;*.chensoul.com&#34;</span> --dns dns_cf <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>--cert-file      /usr/local/nginx/ssl/chensoul.com.cer  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>--key-file       /usr/local/nginx/ssl/chensoul.com.key  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>--fullchain-file /usr/local/nginx/ssl/fullchain.cer <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>--reloadcmd <span class="s2">&#34;nginx -s reload&#34;</span>
</span></span></code></pre></div><p>移除域名证书自动更新</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">acme.sh --remove -d chensoul.com -d <span class="s2">&#34;*.chensoul.com&#34;</span>
</span></span></code></pre></div><h2 id="百度站点收录">百度站点收录</h2>
<p>参考 <a href="https://ifttl.com/push-urls-to-baidu/">向百度主动推送网站链接</a> 使用脚本定时推送网站链接到百度站点。对 <code>push_to_baidu.sh</code> 脚本的  parse 方法做了如下修改，以解决 <code>xmllint 解析带有命名空间的 xml 文件报错</code> 的问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> parse <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">local</span> <span class="nv">file</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="nv">$file</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$XMLLINT</span> --format --xpath <span class="s2">&#34;//*[local-name()=&#39;loc&#39; and namespace-uri()=&#39;http://www.sitemaps.org/schemas/sitemap/0.9&#39;]/text()&#34;</span> <span class="s2">&#34;</span><span class="nv">$file</span><span class="s2">&#34;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s/https/\nhttps/g&#39;</span> &gt; <span class="s2">&#34;</span><span class="nv">$URL_TEMP</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="nv">$URL_TEMP</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="工作">工作</h2>
<h3 id="effective-java-3-笔记">Effective Java 3 笔记</h3>
<p>请参考 <a href="/posts/2023/04/03/builder-instead-of-constructors/">《Effective Java 3》笔记：使用构造器代替构造函数</a></p>
<h3 id="rust">Rust</h3>
<p>因为对 <a href="https://tauri.app/">Tauri</a> 这个 GUI 框架挺感兴趣，所以我开始学习 Rust 了，目前在参考 <a href="https://rustwiki.org/">https://rustwiki.org/</a> 上的 <a href="https://rustwiki.org/zh-CN/rust-by-example/">通过例子学 Rust</a> 和 <a href="https://rustwiki.org/zh-CN/book/">Rust 程序设计语言</a> 学习 Rust。</p>
<h2 id="好物分享">好物分享</h2>
<p>虽然大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。</p>
<h3 id="一些文章">一些文章</h3>
<ul>
<li>
<p><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2023/03/28/go-wasm-usage.html">Go wasm 使用：Go 代码编译成 WebAssembly 及调用</a></p>
</li>
<li>
<p><a href="https://ourai.ws/posts/what-i-have-done-in-2023-q1/">失业三个月，我都干了啥？</a></p>
</li>
<li>
<p><a href="https://www.bboy.app/2023/04/04/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bgitea%E7%9A%84action/">介绍一下gitea的action</a></p>
</li>
<li>
<p><a href="https://blog.p2hp.com/archives/10711">作为绝对初学者学习 Web 开发</a></p>
</li>
</ul>
<h3 id="一些工具">一些工具</h3>
<ul>
<li>
<p>数据统计分析：<a href="https://usefathom.com/">https://usefathom.com</a></p>
</li>
<li>
<p>Cloudflare 图床：<a href="https://www.cloudflare.com/zh-cn/products/cloudflare-images/">Cloudflare Images</a></p>
</li>
<li>
<p>Java 单元测试插件：<a href="https://squaretest.com/">Squaretest for IntelliJ IDEA</a></p>
</li>
<li>
<p>基于标记的科学排版系统：<a href="https://typst.app/">Typst</a>。可以协同工作，且界面更友好。旨在成为 LaTeX、Word 和 Google Docs 等的替代品。</p>
</li>
<li>
<p>数据可视化资源库：<a href="https://vis.zone/lib/">https://vis.zone/lib/</a>。网站提供非常全面的可视化图表类型供参考，还收集了很多实现可视化的代码、工具、课程、书籍。</p>
</li>
<li>
<p>一个免费的 chatgpt 在线 web：https://chatbot.theb.ai/#/chat/1002</p>
</li>
</ul>
<h3 id="一些视频">一些视频</h3>
<p>以下是最近在看的电视、动画片</p>
<p>-《飚速宅男》第五季。一群高中生骑自行车的热血故事。</p>
<p>-《潘多拉伪造的乐园》。此剧讲述了一名拥有令人称羡生活的女子在恢复过往的记忆后，为保护自己和家人对随意操纵自己命运的人展开报复的故事</p>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Effective Java 3》笔记2：使用构造器代替构造方法</title>
      <link>https://blog.chensoul.com/posts/2023/04/03/builder-instead-of-constructors/</link>
      <pubDate>Mon, 03 Apr 2023 16:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/03/builder-instead-of-constructors/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。 介绍 当一个类需要多个构造函数参数时，可以考虑使</description>
      <content:encoded><![CDATA[<p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。</p>
<h2 id="介绍">介绍</h2>
<p>当一个类需要多个构造函数参数时，可以考虑使用<strong>构建器模式</strong>来创建对象。构建器模式是一种创建对象的设计模式，它可以通过链式调用方法的方式来设置对象的构造参数，并最终返回一个构造完整的对象。</p>
<h2 id="优点">优点</h2>
<p>使用构建器模式的原因有以下几点：</p>
<ol>
<li>避免构造函数参数过多的问题：当一个类需要多个构造函数参数时，构造函数的参数列表可能会变得很长，这会导致代码难以理解和维护。使用构建器模式可以将构造函数参数拆分成多个方法，从而使代码更加清晰易懂。</li>
<li>提高代码的可读性和可维护性：使用构建器模式可以使代码更加易懂和易维护，因为可以通过方法名来清晰地表达每个参数的含义。</li>
<li>提供更多的灵活性和可定制性：构建器模式可以提供更多的灵活性和可定制性，因为可以在构造对象时进行更多的逻辑处理和判断。例如，可以在构建器中添加验证逻辑，以确保参数的有效性。</li>
<li>支持多线程环境：构建器模式可以支持多线程环境，因为每个构建器都是独立的，不会受到其他线程的影响。</li>
</ol>
<p>以下是一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NutritionFacts</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">servingSize</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">servings</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">calories</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">fat</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">sodium</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">carbohydrate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">NutritionFacts</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">servingSize</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">servingSize</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">servings</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">servings</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">calories</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">calories</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">fat</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">fat</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">sodium</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">sodium</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">carbohydrate</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">carbohydrate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//省略 get set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Required parameters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">servingSize</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">servings</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Optional parameters - initialized to default values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span> <span class="n">calories</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kt">int</span> <span class="n">fat</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kt">int</span> <span class="n">sodium</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kt">int</span> <span class="n">carbohydrate</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="nf">Builder</span><span class="o">(</span><span class="kt">int</span> <span class="n">servingSize</span><span class="o">,</span> <span class="kt">int</span> <span class="n">servings</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">servingSize</span> <span class="o">=</span> <span class="n">servingSize</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">servings</span> <span class="o">=</span> <span class="n">servings</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">calories</span><span class="o">(</span><span class="kt">int</span> <span class="n">calories</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">calories</span> <span class="o">=</span> <span class="n">calories</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">fat</span><span class="o">(</span><span class="kt">int</span> <span class="n">fat</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">fat</span> <span class="o">=</span> <span class="n">fat</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">sodium</span><span class="o">(</span><span class="kt">int</span> <span class="n">sodium</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">sodium</span> <span class="o">=</span> <span class="n">sodium</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">carbohydrate</span><span class="o">(</span><span class="kt">int</span> <span class="n">carbohydrate</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">carbohydrate</span> <span class="o">=</span> <span class="n">carbohydrate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">NutritionFacts</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">NutritionFacts</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上述示例中，我们定义了一个名为 NutritionFacts 的类，它包含了一些营养成分的信息，例如每份的大小、总份数、卡路里、脂肪、钠和碳水化合物等成员变量。我们还定义了一个名为 Builder 的静态内部类，用于构建 NutritionFacts 对象。</p>
<p>在 Builder 类中，我们定义了一个带有两个参数的构造方法，并在其中初始化了必需的成员变量 servingSize 和 servings。我们还定义了一些可选的方法，用于设置 NutritionFacts 对象的卡路里、脂肪、钠和碳水化合物等成员变量。这些方法都支持链式调用，并返回 Builder 对象本身，以便进行多次方法调用。</p>
<p>在 Builder 类中，我们最终定义了一个 build() 方法，用于创建 NutritionFacts 对象并返回。在 build() 方法中，我们调用 NutritionFacts 的私有构造器并将 Builder 对象作为参数传递进去，从而创建 NutritionFacts 对象并初始化其成员变量。</p>
<p>现在，我们可以使用 NutritionFacts.Builder 类来创建 NutritionFacts 对象，并使用链式调用来设置 NutritionFacts 对象的成员变量。例如，我们可以使用以下代码来创建一个每份大小为 240ml、总共有 8 份、卡路里为 100、脂肪为 2、钠为 35、碳水化合物为 27 的 NutritionFacts 对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">NutritionFacts</span> <span class="n">cocaCola</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NutritionFacts</span><span class="o">.</span><span class="na">Builder</span><span class="o">(</span><span class="mi">240</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">calories</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">fat</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">sodium</span><span class="o">(</span><span class="mi">35</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">carbohydrate</span><span class="o">(</span><span class="mi">27</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><p>在上述代码中，我们首先创建了一个 NutritionFacts.Builder 对象，并在构造函数中传递了每份大小和总份数等参数。然后，我们使用链式调用来设置卡路里、脂肪、钠和碳水化合物等成员变量，并最终调用 build() 方法来创建 NutritionFacts 对象。</p>
<p>可以使用 lombok 注解来简化代码，但是，<strong>无法在构造器的构造方法里设置必要参数。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">lombok.Builder</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Builder</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NutritionFacts</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">servingSize</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">servings</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">calories</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">fat</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">sodium</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">carbohydrate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="缺点">缺点</h2>
<p>虽然构建器模式可以提高代码的可读性、可维护性以及提供更多的灵活性和可定制性，但它也有一些缺点，包括：</p>
<ol>
<li>增加代码复杂度：使用构建器模式会增加代码的复杂度，因为需要创建一个独立的构建器类，并且需要在构建器类中定义多个方法来设置对象的属性。这会增加代码量并且需要更多的时间来编写和维护代码。</li>
<li>增加内存开销：使用构建器模式需要创建一个独立的构建器对象，并且需要在构建器对象中保存对象的属性。这会增加内存开销，并且在创建对象时需要更多的时间和资源。</li>
<li>对于简单对象不适用：构建器模式更适用于构造复杂对象，对于简单对象来说，使用构建器模式可能会增加代码的复杂度和开销。</li>
<li>需要额外的代码：使用构建器模式需要编写额外的代码来创建构建器类和定义方法。如果只需要构造一个简单的对象，使用构建器模式可能会浪费时间和资源。</li>
</ol>
<h2 id="层次构建器">层次构建器</h2>
<p>层次构建器（Hierarchical Builder）是一种构建器模式的扩展，它允许创建层次结构的对象，并支持在父对象中嵌套子对象。它通常由一个抽象的构建器接口，多个具体的构建器实现和一个指导者（Director）组成。</p>
<p>在层次构建器中，每个构建器都负责创建特定类型的对象，并且可以在其构建方法中调用其他构建器的构建方法来创建嵌套的子对象。指导者负责协调构建器的顺序和调用构建器的方法来构建对象层次结构。</p>
<p>层次构建器模式的优点包括：</p>
<ol>
<li>支持创建复杂的对象层次结构，能够构建包含多个层次和嵌套子对象的对象。</li>
<li>提供了更好的可读性和可维护性，因为每个构建器都只需要关注一个特定类型的对象，而且可以通过方法名来清晰地表达每个参数的含义。</li>
<li>提供了更多的灵活性和可定制性，因为可以在构建器中添加验证逻辑，以确保参数的有效性，并且可以动态地组合构建器来创建不同类型的对象。</li>
</ol>
<p>层次构建器模式的缺点包括：</p>
<ol>
<li>
<p>代码量：由于层次构建器模式需要定义多个构建器类，因此代码量会比较大，尤其是在构建复杂对象时。</p>
</li>
<li>
<p>嵌套层次：层次构建器模式中的对象层次结构是通过嵌套多个构建器实现的，这会导致代码的嵌套层次较深，可能会影响代码的可读性和可维护性。</p>
</li>
<li>
<p>可能会增加内存开销：因为每个构建器都需要创建一个独立的对象，并且需要在构建器对象中保存对象的属性。对于大型对象和多级嵌套结构，开销可能会很大。</p>
</li>
<li>
<p>不适合简单对象的构建：层次构建器模式适用于构建复杂对象层次结构，但对于简单的对象构建，使用层次构建器模式可能会显得过于繁琐和不必要。</p>
</li>
</ol>
<h3 id="使用">使用</h3>
<h4 id="举例-1">举例 1</h4>
<p>1、定义抽象的构建器接口，用于创建不同类型的对象和添加子对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ComputerBuilder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">buildCPU</span><span class="o">(</span><span class="n">String</span> <span class="n">model</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">buildGPU</span><span class="o">(</span><span class="n">String</span> <span class="n">model</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">buildMemory</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">addStorage</span><span class="o">(</span><span class="n">String</span> <span class="n">type</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">addPeripheral</span><span class="o">(</span><span class="n">String</span> <span class="n">type</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Computer</span> <span class="nf">getResult</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>2、创建具体的构建器实现，用于构建不同类型的对象和添加子对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DesktopBuilder</span> <span class="kd">implements</span> <span class="n">ComputerBuilder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Desktop</span> <span class="n">computer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Desktop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildCPU</span><span class="o">(</span><span class="n">String</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">setCPU</span><span class="o">(</span><span class="k">new</span> <span class="n">CPU</span><span class="o">(</span><span class="n">model</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildGPU</span><span class="o">(</span><span class="n">String</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">setGPU</span><span class="o">(</span><span class="k">new</span> <span class="n">GPU</span><span class="o">(</span><span class="n">model</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildMemory</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">setMemory</span><span class="o">(</span><span class="k">new</span> <span class="n">Memory</span><span class="o">(</span><span class="n">size</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addStorage</span><span class="o">(</span><span class="n">String</span> <span class="n">type</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">addStorage</span><span class="o">(</span><span class="k">new</span> <span class="n">Storage</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">size</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addPeripheral</span><span class="o">(</span><span class="n">String</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">addPeripheral</span><span class="o">(</span><span class="k">new</span> <span class="n">Peripheral</span><span class="o">(</span><span class="n">type</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Computer</span> <span class="nf">getResult</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">computer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LaptopBuilder</span> <span class="kd">implements</span> <span class="n">ComputerBuilder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Laptop</span> <span class="n">computer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Laptop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildCPU</span><span class="o">(</span><span class="n">String</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">setCPU</span><span class="o">(</span><span class="k">new</span> <span class="n">CPU</span><span class="o">(</span><span class="n">model</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildGPU</span><span class="o">(</span><span class="n">String</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">setGPU</span><span class="o">(</span><span class="k">new</span> <span class="n">GPU</span><span class="o">(</span><span class="n">model</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildMemory</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">setMemory</span><span class="o">(</span><span class="k">new</span> <span class="n">Memory</span><span class="o">(</span><span class="n">size</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addStorage</span><span class="o">(</span><span class="n">String</span> <span class="n">type</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">addStorage</span><span class="o">(</span><span class="k">new</span> <span class="n">Storage</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">size</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addPeripheral</span><span class="o">(</span><span class="n">String</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">computer</span><span class="o">.</span><span class="na">addPeripheral</span><span class="o">(</span><span class="k">new</span> <span class="n">Peripheral</span><span class="o">(</span><span class="n">type</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Computer</span> <span class="nf">getResult</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">computer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>3、创建指导者类，用于协调构建器的顺序和调用构建器的方法来构建对象层次结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ComputerDirector</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ComputerBuilder</span> <span class="n">builder</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">ComputerDirector</span><span class="o">(</span><span class="n">ComputerBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">builder</span> <span class="o">=</span> <span class="n">builder</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">construct</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">buildCPU</span><span class="o">(</span><span class="s">&#34;Intel Core i7&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">buildGPU</span><span class="o">(</span><span class="s">&#34;Nvidia GeForce RTX 3080&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">buildMemory</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">addStorage</span><span class="o">(</span><span class="s">&#34;SSD&#34;</span><span class="o">,</span> <span class="mi">512</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">addPeripheral</span><span class="o">(</span><span class="s">&#34;Keyboard&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">addPeripheral</span><span class="o">(</span><span class="s">&#34;Mouse&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>4、使用层次构建器模式创建计算机系统对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ComputerBuilder</span> <span class="n">desktopBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DesktopBuilder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">ComputerBuilder</span> <span class="n">laptopBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LaptopBuilder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ComputerDirector</span> <span class="n">director</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ComputerDirector</span><span class="o">(</span><span class="n">desktopBuilder</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">director</span><span class="o">.</span><span class="na">construct</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Computer</span> <span class="n">desktop</span> <span class="o">=</span> <span class="n">desktopBuilder</span><span class="o">.</span><span class="na">getResult</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">director</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ComputerDirector</span><span class="o">(</span><span class="n">laptopBuilder</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">director</span><span class="o">.</span><span class="na">construct</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Computer</span> <span class="n">laptop</span> <span class="o">=</span> <span class="n">laptopBuilder</span><span class="o">.</span><span class="na">getResult</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 将两个计算机系统对象组合成一个更大的计算机系统对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ComputerSystem</span> <span class="n">system</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ComputerSystem</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">system</span><span class="o">.</span><span class="na">addComputer</span><span class="o">(</span><span class="n">desktop</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">system</span><span class="o">.</span><span class="na">addComputer</span><span class="o">(</span><span class="n">laptop</span><span class="o">);</span>
</span></span></code></pre></div><p>在上面的示例中，DesktopBuilder和LaptopBuilder分别是具体的构建器实现，用于创建桌面计算机和笔记本电脑对象。ComputerDirector是指导者类，用于协调构建器的顺序和调用构建器的方法来构建对象层次结构。使用ComputerDirector构建计算机系统对象时，可以先使用DesktopBuilder构建桌面计算机对象，再使用LaptopBuilder构建笔记本电脑对象，最后将两个计算机系统对象组合成一个更大的计算机系统对象。</p>
<p>下面是另一个使用层次构建器模式创建层次结构对象的例子，假设需要创建一个组织结构的层次结构对象，其中包含多个部门和嵌套子部门：</p>
<p>1、定义抽象的构建器接口，用于创建不同类型的对象和添加子对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">DepartmentBuilder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">buildName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">buildManager</span><span class="o">(</span><span class="n">String</span> <span class="n">manager</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">addSubDepartment</span><span class="o">(</span><span class="n">Department</span> <span class="n">subDepartment</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Department</span> <span class="nf">getResult</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">DepartmentImpl</span> <span class="kd">implements</span> <span class="n">Department</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">String</span> <span class="n">manager</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Department</span><span class="o">&gt;</span> <span class="n">subDepartments</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setManager</span><span class="o">(</span><span class="n">String</span> <span class="n">manager</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">manager</span> <span class="o">=</span> <span class="n">manager</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addSubDepartment</span><span class="o">(</span><span class="n">Department</span> <span class="n">subDepartment</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">subDepartments</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">subDepartment</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeSubDepartment</span><span class="o">(</span><span class="n">Department</span> <span class="n">subDepartment</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">subDepartments</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">subDepartment</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Department</span><span class="o">&gt;</span> <span class="nf">getSubDepartments</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">subDepartments</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getManager</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">manager</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DevelopmentDepartment</span> <span class="kd">extends</span> <span class="n">DepartmentImpl</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 添加特定于开发部门的属性和方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SalesDepartment</span> <span class="kd">extends</span> <span class="n">DepartmentImpl</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 添加特定于销售部门的属性和方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>2、创建具体的构建器实现，用于构建不同类型的对象和添加子对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SalesDepartmentBuilder</span> <span class="kd">implements</span> <span class="n">DepartmentBuilder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">SalesDepartment</span> <span class="n">department</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SalesDepartment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">department</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildManager</span><span class="o">(</span><span class="n">String</span> <span class="n">manager</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">department</span><span class="o">.</span><span class="na">setManager</span><span class="o">(</span><span class="n">manager</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addSubDepartment</span><span class="o">(</span><span class="n">Department</span> <span class="n">subDepartment</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">department</span><span class="o">.</span><span class="na">addSubDepartment</span><span class="o">(</span><span class="n">subDepartment</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Department</span> <span class="nf">getResult</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">department</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DevelopmentDepartmentBuilder</span> <span class="kd">implements</span> <span class="n">DepartmentBuilder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">DevelopmentDepartment</span> <span class="n">department</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DevelopmentDepartment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">department</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildManager</span><span class="o">(</span><span class="n">String</span> <span class="n">manager</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">department</span><span class="o">.</span><span class="na">setManager</span><span class="o">(</span><span class="n">manager</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addSubDepartment</span><span class="o">(</span><span class="n">Department</span> <span class="n">subDepartment</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">department</span><span class="o">.</span><span class="na">addSubDepartment</span><span class="o">(</span><span class="n">subDepartment</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Department</span> <span class="nf">getResult</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">department</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>3、创建指导者类，用于协调构建器的顺序和调用构建器的方法来构建对象层次结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrganizationDirector</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">DepartmentBuilder</span> <span class="n">builder</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">OrganizationDirector</span><span class="o">(</span><span class="n">DepartmentBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">builder</span> <span class="o">=</span> <span class="n">builder</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">construct</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">buildName</span><span class="o">(</span><span class="s">&#34;Organization&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">buildManager</span><span class="o">(</span><span class="s">&#34;CEO&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Department</span> <span class="n">salesDept</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SalesDepartment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">salesDept</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;Sales Department&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">salesDept</span><span class="o">.</span><span class="na">setManager</span><span class="o">(</span><span class="s">&#34;Sales Manager&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">addSubDepartment</span><span class="o">(</span><span class="n">salesDept</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Department</span> <span class="n">devDept</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DevelopmentDepartment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">devDept</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;Development Department&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">devDept</span><span class="o">.</span><span class="na">setManager</span><span class="o">(</span><span class="s">&#34;Development Manager&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Department</span> <span class="n">frontendDevDept</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DevelopmentDepartment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">frontendDevDept</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;Front-end Development Department&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">frontendDevDept</span><span class="o">.</span><span class="na">setManager</span><span class="o">(</span><span class="s">&#34;Front-end Development Manager&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">devDept</span><span class="o">.</span><span class="na">addSubDepartment</span><span class="o">(</span><span class="n">frontendDevDept</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Department</span> <span class="n">backendDevDept</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DevelopmentDepartment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">backendDevDept</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;Back-end Development Department&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">backendDevDept</span><span class="o">.</span><span class="na">setManager</span><span class="o">(</span><span class="s">&#34;Back-end Development Manager&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">devDept</span><span class="o">.</span><span class="na">addSubDepartment</span><span class="o">(</span><span class="n">backendDevDept</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">addSubDepartment</span><span class="o">(</span><span class="n">devDept</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>4、使用层次构建器模式创建组织结构对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">DepartmentBuilder</span> <span class="n">salesDeptBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SalesDepartmentBuilder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">DepartmentBuilder</span> <span class="n">devDeptBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DevelopmentDepartmentBuilder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">OrganizationDirector</span> <span class="n">director</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OrganizationDirector</span><span class="o">(</span><span class="n">salesDeptBuilder</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">director</span><span class="o">.</span><span class="na">construct</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Department</span> <span class="n">salesDept</span> <span class="o">=</span> <span class="n">salesDeptBuilder</span><span class="o">.</span><span class="na">getResult</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">director</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OrganizationDirector</span><span class="o">(</span><span class="n">devDeptBuilder</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">director</span><span class="o">.</span><span class="na">construct</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Department</span> <span class="n">devDept</span> <span class="o">=</span> <span class="n">devDeptBuilder</span><span class="o">.</span><span class="na">getResult</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 将两个部门对象组合成一个更大的组织结构对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Organization</span> <span class="n">organization</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Organization</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">organization</span><span class="o">.</span><span class="na">addDepartment</span><span class="o">(</span><span class="n">salesDept</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">organization</span><span class="o">.</span><span class="na">addDepartment</span><span class="o">(</span><span class="n">devDept</span><span class="o">);</span>
</span></span></code></pre></div><p>在上面的示例中，SalesDepartmentBuilder和DevelopmentDepartmentBuilder分别是具体的构建器实现，用于创建销售部门和开发部门对象。OrganizationDirector是指导者类，用于协调构建器的顺序和调用构建器的方法来构建对象层次结构。使用OrganizationDirector构建组织结构对象时，可以先使用SalesDepartmentBuilder构建销售部门对象，再使用DevelopmentDepartmentBuilder构建开发部门对象，最后将两个部门对象组合成一个更大的组织结构对象。</p>
<h4 id="举例-2">举例 2</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ComputerComponent</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">manufacturer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">model</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="nf">ComputerComponent</span><span class="o">(</span><span class="n">Builder</span><span class="o">&lt;?&gt;</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">manufacturer</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">manufacturer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">model</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">model</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getManufacturer</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">manufacturer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getModel</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">model</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Builder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">String</span> <span class="n">manufacturer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">String</span> <span class="n">model</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">T</span> <span class="nf">setManufacturer</span><span class="o">(</span><span class="n">String</span> <span class="n">manufacturer</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">manufacturer</span> <span class="o">=</span> <span class="n">manufacturer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">self</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">T</span> <span class="nf">setModel</span><span class="o">(</span><span class="n">String</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">self</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">protected</span> <span class="kd">abstract</span> <span class="n">T</span> <span class="nf">self</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">ComputerComponent</span> <span class="nf">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Motherboard</span> <span class="kd">extends</span> <span class="n">ComputerComponent</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">socketType</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="nf">Motherboard</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">super</span><span class="o">(</span><span class="n">builder</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">socketType</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">socketType</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getSocketType</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">socketType</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="kd">extends</span> <span class="n">ComputerComponent</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">Builder</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">String</span> <span class="n">socketType</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">setSocketType</span><span class="o">(</span><span class="n">String</span> <span class="n">socketType</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">socketType</span> <span class="o">=</span> <span class="n">socketType</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">protected</span> <span class="n">Builder</span> <span class="nf">self</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Motherboard</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">Motherboard</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CPU</span> <span class="kd">extends</span> <span class="n">ComputerComponent</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">coreCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="nf">CPU</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">super</span><span class="o">(</span><span class="n">builder</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">coreCount</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">coreCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCoreCount</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">coreCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="kd">extends</span> <span class="n">ComputerComponent</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">Builder</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kt">int</span> <span class="n">coreCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">setCoreCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">coreCount</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">coreCount</span> <span class="o">=</span> <span class="n">coreCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">protected</span> <span class="n">Builder</span> <span class="nf">self</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">CPU</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">CPU</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Computer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Motherboard</span> <span class="n">motherboard</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">CPU</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="nf">Computer</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">motherboard</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">motherboard</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cpu</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Motherboard</span> <span class="nf">getMotherboard</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">motherboard</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">CPU</span> <span class="nf">getCpu</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">Motherboard</span> <span class="n">motherboard</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">CPU</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">setMotherboard</span><span class="o">(</span><span class="n">Motherboard</span> <span class="n">motherboard</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">motherboard</span> <span class="o">=</span> <span class="n">motherboard</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">setCpu</span><span class="o">(</span><span class="n">CPU</span> <span class="n">cpu</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Computer</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">Computer</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Motherboard</span><span class="o">.</span><span class="na">Builder</span> <span class="n">motherboardBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Motherboard</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setManufacturer</span><span class="o">(</span><span class="s">&#34;ASUS&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setModel</span><span class="o">(</span><span class="s">&#34;ROG Strix Z590-E Gaming&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setSocketType</span><span class="o">(</span><span class="s">&#34;LGA 1200&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">CPU</span><span class="o">.</span><span class="na">Builder</span> <span class="n">cpuBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CPU</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setManufacturer</span><span class="o">(</span><span class="s">&#34;Intel&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setModel</span><span class="o">(</span><span class="s">&#34;Core i9-11900K&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setCoreCount</span><span class="o">(</span><span class="mi">8</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Computer</span><span class="o">.</span><span class="na">Builder</span> <span class="n">computerBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Computer</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setMotherboard</span><span class="o">(</span><span class="n">motherboardBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setCpu</span><span class="o">(</span><span class="n">cpuBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Computer</span> <span class="n">computer</span> <span class="o">=</span> <span class="n">computerBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><p>在这个示例中，<code>ComputerComponent</code> 类是一个抽象基类，定义了计算机组件的基本属性和方法。它还定义了一个抽象的构建器类，用于构建它的子类的实例。</p>
<p>每个 <code>ComputerComponent</code> 的具体子类都有自己的具体构建器类，该类扩展了抽象构建器类。具体构建器提供了设置相应组件属性的方法，例如主板的制造商、型号和插座类型，处理器的时钟速度和内存的容量。</p>
<p><code>Computer</code> 类代表一个完整的计算机系统，并具有用于构建 <code>Computer</code> 类的实例的构建器类。<code>Computer.Builder</code> 类提供了设置每个组件属性的方法，使用 <code>Consumer</code> 函数接口来接受配置相应构建器的 lambda 表达式。</p>
<h2 id="使用-1">使用</h2>
<p>以下是几个常见开源框架中使用建造者模式的例子：</p>
<h3 id="retrofit">Retrofit</h3>
<p>Retrofit是一个Android和Java平台上的RESTful API库，它使用建造者模式来创建RestAdapter对象。RestAdapter.Builder类是一个建造者类，它包含了一系列的方法，用于设置Retrofit的配置选项，如设置API的base URL、设置HTTP Client、设置Converter等。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RestAdapter</span> <span class="n">restAdapter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RestAdapter</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setEndpoint</span><span class="o">(</span><span class="s">&#34;https://api.github.com&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setClient</span><span class="o">(</span><span class="k">new</span> <span class="n">OkClient</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setLogLevel</span><span class="o">(</span><span class="n">RestAdapter</span><span class="o">.</span><span class="na">LogLevel</span><span class="o">.</span><span class="na">FULL</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="gson">Gson</h3>
<p>Gson是一个用于在Java对象和JSON数据之间进行序列化和反序列化的库。它使用建造者模式来创建Gson对象。GsonBuilder类是一个建造者类，它包含了一系列的方法，用于配置Gson的行为，如设置日期格式、设置字段的命名策略等。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Gson</span> <span class="n">gson</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GsonBuilder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setDateFormat</span><span class="o">(</span><span class="s">&#34;yyyy-MM-dd&#39;T&#39;HH:mm:ssZ&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setFieldNamingPolicy</span><span class="o">(</span><span class="n">FieldNamingPolicy</span><span class="o">.</span><span class="na">LOWER_CASE_WITH_UNDERSCORES</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="apache-httpclient">Apache HttpClient</h3>
<p>Apache HttpClient是一个用于创建HTTP客户端的库，它使用建造者模式来创建HttpClient对象。HttpClientBuilder类是一个建造者类，它包含了一系列的方法，用于配置HttpClient的行为，如设置连接池、设置代理、设置Cookie管理器等。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">HttpClient</span> <span class="n">httpClient</span> <span class="o">=</span> <span class="n">HttpClientBuilder</span><span class="o">.</span><span class="na">create</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setMaxConnTotal</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setMaxConnPerRoute</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setProxy</span><span class="o">(</span><span class="k">new</span> <span class="n">HttpHost</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">,</span> <span class="mi">8080</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setDefaultCookieStore</span><span class="o">(</span><span class="k">new</span> <span class="n">BasicCookieStore</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="apache-kafka">Apache Kafka</h3>
<p>Apache Kafka是一个分布式消息队列系统，它使用建造者模式来创建Producer和Consumer对象。ProducerConfig和ConsumerConfig类是建造者类，它们包含了一系列的方法，用于配置Producer和Consumer的行为，如设置broker地址、设置序列化器等。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Properties</span> <span class="n">producerProps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">producerProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ProducerConfig</span><span class="o">.</span><span class="na">BOOTSTRAP_SERVERS_CONFIG</span><span class="o">,</span> <span class="s">&#34;localhost:9092&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">producerProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ProducerConfig</span><span class="o">.</span><span class="na">KEY_SERIALIZER_CLASS_CONFIG</span><span class="o">,</span> <span class="n">StringSerializer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">producerProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ProducerConfig</span><span class="o">.</span><span class="na">VALUE_SERIALIZER_CLASS_CONFIG</span><span class="o">,</span> <span class="n">StringSerializer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Producer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">producer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KafkaProducer</span><span class="o">&lt;&gt;(</span><span class="n">producerProps</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Properties</span> <span class="n">consumerProps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">consumerProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">BOOTSTRAP_SERVERS_CONFIG</span><span class="o">,</span> <span class="s">&#34;localhost:9092&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">consumerProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">KEY_DESERIALIZER_CLASS_CONFIG</span><span class="o">,</span> <span class="n">StringDeserializer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">consumerProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">VALUE_DESERIALIZER_CLASS_CONFIG</span><span class="o">,</span> <span class="n">StringDeserializer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">consumerProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">GROUP_ID_CONFIG</span><span class="o">,</span> <span class="s">&#34;my-group&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KafkaConsumer</span><span class="o">&lt;&gt;(</span><span class="n">consumerProps</span><span class="o">);</span>
</span></span></code></pre></div><h3 id="apache-commons-configuration">Apache Commons Configuration</h3>
<p>Apache Commons Configuration是一个用于读取和写入各种配置文件的库，它使用建造者模式来创建Configuration对象。ConfigurationBuilder类是一个建造者类，它包含了一系列的方法，用于配置Configuration的行为，如设置配置文件类型、设置属性的分隔符等。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Configuration</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConfigurationBuilder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setDelimiterParsingDisabled</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setFile</span><span class="o">(</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;config.properties&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setListDelimiterHandler</span><span class="o">(</span><span class="k">new</span> <span class="n">DefaultListDelimiterHandler</span><span class="o">(</span><span class="sc">&#39;,&#39;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="guava">Guava</h3>
<p>Guava是一个Google开发的Java库，它包含了许多实用的工具类和数据结构，其中包括使用建造者模式来创建的ImmutableList、ImmutableMap和ImmutableSet等不可变集合类。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ImmutableList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">ImmutableList</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;bar&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;baz&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ImmutableMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">ImmutableMap</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span><span class="n">builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;bar&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;baz&#34;</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;bar&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;baz&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="jpa">JPA</h3>
<p>Java Persistence API（JPA）是Java EE平台的一个ORM框架，它使用建造者模式来创建EntityManagerFactory对象。EntityManagerFactoryBuilder类是一个建造者类，它包含了一系列的方法，用于配置EntityManagerFactory的行为，如设置数据源、设置JPA的属性等。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">EntityManagerFactory</span> <span class="n">entityManagerFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EntityManagerFactoryBuilder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">dataSource</span><span class="o">(</span><span class="n">myDataSource</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">persistenceUnit</span><span class="o">(</span><span class="s">&#34;myPersistenceUnit&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">properties</span><span class="o">(</span><span class="n">myProperties</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="spring-framework">Spring Framework</h3>
<p>Spring Framework是一个Java平台上的开源应用程序框架，它使用建造者模式来创建RestTemplate和HttpHeaders对象。RestTemplateBuilder和HttpHeadersBuilder类是建造者类，它们包含了一系列的方法，用于配置RestTemplate和HttpHeaders的行为，如设置连接超时、设置请求头等。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RestTemplateBuilder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setConnectTimeout</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setReadTimeout</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">HttpHeaders</span> <span class="n">headers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HttpHeadersBuilder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><h2 id="优化">优化</h2>
<p>建造者模式的优化主要包括以下几个方面：</p>
<h3 id="使用静态内部类优化建造者模式">使用静态内部类优化建造者模式</h3>
<p>建造者模式通常使用一个Builder类来构建复杂对象，为了避免Builder类变得过于臃肿，可以将其设计为静态内部类，这样可以使代码更加清晰，同时也能够保证线程安全。</p>
<h3 id="使用流式接口优化建造者模式">使用流式接口优化建造者模式</h3>
<p>流式接口是一种链式调用的方式，它可以将多个方法调用连接起来，形成一个链式结构，使得代码更加简洁易读。在建造者模式中，可以使用流式接口来优化Builder类，使得客户端可以通过链式调用的方式来创建复杂对象，从而简化代码。</p>
<h3 id="使用默认值优化建造者模式">使用默认值优化建造者模式</h3>
<p>在建造者模式中，有些属性是必须的，而有些属性是可选的，可以使用默认值来为可选属性设置默认值，从而避免客户端必须为每个可选属性都提供值的情况，同时也能够简化客户端代码。</p>
<h3 id="使用java-8中的optional类优化建造者模式">使用Java 8中的Optional类优化建造者模式</h3>
<p>Java 8中引入了Optional类，该类可以用于处理可能为null的值，可以进一步优化建造者模式中的代码。</p>
<p>在建造者模式中，我们通常需要设置多个属性，其中有些属性可能是可选的，如果直接使用null来表示可选属性的值，可能会导致代码出现空指针异常，而使用Optional类可以避免这个问题。</p>
<p>下面是一个使用Optional类优化建造者模式的示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.Optional</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Computer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">memory</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">hardDisk</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">graphicsCard</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Computer</span><span class="o">(</span><span class="n">ComputerBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">cpu</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">memory</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">memory</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">hardDisk</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">hardDisk</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">graphicsCard</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">graphicsCard</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略getter方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ComputerBuilder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">String</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">String</span> <span class="n">memory</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">String</span> <span class="n">hardDisk</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">graphicsCard</span> <span class="o">=</span> <span class="n">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">ComputerBuilder</span> <span class="nf">setCpu</span><span class="o">(</span><span class="n">String</span> <span class="n">cpu</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">ComputerBuilder</span> <span class="nf">setMemory</span><span class="o">(</span><span class="n">String</span> <span class="n">memory</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">memory</span> <span class="o">=</span> <span class="n">memory</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">ComputerBuilder</span> <span class="nf">setHardDisk</span><span class="o">(</span><span class="n">String</span> <span class="n">hardDisk</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">hardDisk</span> <span class="o">=</span> <span class="n">hardDisk</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">ComputerBuilder</span> <span class="nf">setGraphicsCard</span><span class="o">(</span><span class="n">String</span> <span class="n">graphicsCard</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">graphicsCard</span> <span class="o">=</span> <span class="n">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">graphicsCard</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Computer</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">Computer</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例代码中，我们使用 <code>Optional</code> 类来表示可选属性的值，将graphicsCard属性的类型改为<code>Optional&lt;String&gt;</code>。在 ComputerBuilder 类中，我们使用 <code>Optional.ofNullable </code>方法来将可选属性的值转换为 Optional 对象，并在调用 build 方法时，将 Optional 对象转换为普通的字符串类型。</p>
<h3 id="使用-lambda表达式优化建造者模式">使用 Lambda表达式优化建造者模式</h3>
<p>Lambda表达式是Java 8中引入的一种新的语言特性，可以进一步优化建造者模式中的代码，使得代码更加简洁易读。</p>
<p>在建造者模式中，我们通常需要定义多个属性，并在构造方法中进行初始化。使用Lambda表达式可以避免定义多个属性的问题，将属性的赋值操作通过Lambda表达式传递给构造方法。</p>
<p>下面是一个使用Lambda表达式优化建造者模式的示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.Optional</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.util.function.Consumer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Computer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">memory</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">hardDisk</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">graphicsCard</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Computer</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">ComputerBuilder</span><span class="o">&gt;</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ComputerBuilder</span> <span class="n">computerBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ComputerBuilder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">computerBuilder</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">cpu</span> <span class="o">=</span> <span class="n">computerBuilder</span><span class="o">.</span><span class="na">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">memory</span> <span class="o">=</span> <span class="n">computerBuilder</span><span class="o">.</span><span class="na">memory</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">hardDisk</span> <span class="o">=</span> <span class="n">computerBuilder</span><span class="o">.</span><span class="na">hardDisk</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">graphicsCard</span> <span class="o">=</span> <span class="n">computerBuilder</span><span class="o">.</span><span class="na">graphicsCard</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略getter方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ComputerBuilder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">String</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">String</span> <span class="n">memory</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">String</span> <span class="n">hardDisk</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">graphicsCard</span> <span class="o">=</span> <span class="n">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">ComputerBuilder</span> <span class="nf">setCpu</span><span class="o">(</span><span class="n">String</span> <span class="n">cpu</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">ComputerBuilder</span> <span class="nf">setMemory</span><span class="o">(</span><span class="n">String</span> <span class="n">memory</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">memory</span> <span class="o">=</span> <span class="n">memory</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">ComputerBuilder</span> <span class="nf">setHardDisk</span><span class="o">(</span><span class="n">String</span> <span class="n">hardDisk</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">hardDisk</span> <span class="o">=</span> <span class="n">hardDisk</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">ComputerBuilder</span> <span class="nf">setGraphicsCard</span><span class="o">(</span><span class="n">String</span> <span class="n">graphicsCard</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">graphicsCard</span> <span class="o">=</span> <span class="n">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">graphicsCard</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Computer</span> <span class="n">computer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Computer</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">setCpu</span><span class="o">(</span><span class="s">&#34;Intel i7&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">setMemory</span><span class="o">(</span><span class="s">&#34;16GB&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">setHardDisk</span><span class="o">(</span><span class="s">&#34;512GB SSD&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">setGraphicsCard</span><span class="o">(</span><span class="s">&#34;NVIDIA GTX 1660&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在这个示例代码中，我们将 Computer 类的构造方法改为接收一个 <code>Consumer&lt;ComputerBuilder&gt; </code>类型的参数，这个参数表示一个包含属性赋值操作的 Lambda 表达式。在构造方法中，我们先创建一个ComputerBuilder 对象，然后通过 Lambda 表达式调用 ComputerBuilder 对象的方法来设置属性值，并最终通过 ComputerBuilder 对象创建 Computer 对象。</p>
<h3 id="使用泛型和反射优化">使用泛型和反射优化</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">EntityCreator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">classInstance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">T</span> <span class="n">entityObj</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">EntityCreator</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">classInstance</span><span class="o">,</span> <span class="n">Object</span><span class="o">...</span> <span class="n">initParams</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">classInstance</span> <span class="o">=</span> <span class="n">classInstance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">paramTypes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Class</span><span class="o">&lt;?&gt;[</span><span class="n">initParams</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">initParams</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">String</span> <span class="n">checkStr</span> <span class="o">=</span> <span class="n">initParams</span><span class="o">[</span><span class="n">index</span><span class="o">].</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">checkStr</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;Integer&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">paramTypes</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">checkStr</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;Double&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">paramTypes</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="kt">double</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">checkStr</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;Boolean&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">paramTypes</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="kt">boolean</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">checkStr</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;String&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">paramTypes</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">initParams</span><span class="o">[</span><span class="n">index</span><span class="o">].</span><span class="na">getClass</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Constructor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">constructor</span> <span class="o">=</span> <span class="n">classInstance</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="n">paramTypes</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">constructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">entityObj</span> <span class="o">=</span> <span class="n">constructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">initParams</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">EntityCreator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">String</span> <span class="n">paramName</span><span class="o">,</span> <span class="n">Object</span> <span class="n">paramValue</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Field</span> <span class="n">field</span> <span class="o">=</span> <span class="n">classInstance</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="n">paramName</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">field</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">entityObj</span><span class="o">,</span> <span class="n">paramValue</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">T</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">entityObj</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>​		如此，可移除整个内部 Builder 类，NutritionFacts 类私有构造的参数仅包括两个必填的 servingSize、servings 字段：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NutritionFacts</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Required parameters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">servingSize</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">servings</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Optional parameters - initialized to default values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">calories</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">fat</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">sodium</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">carbohydrate</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">NutritionFacts</span><span class="o">(</span><span class="kt">int</span> <span class="n">servingSize</span><span class="o">,</span> <span class="kt">int</span> <span class="n">servings</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">servingSize</span> <span class="o">=</span> <span class="n">servingSize</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">servings</span> <span class="o">=</span> <span class="n">servings</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>该案例的客户端代码改为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">NutritionFacts</span> <span class="n">cocaCola</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EntityCreator</span><span class="o">&lt;&gt;(</span><span class="n">NutritionFacts</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">240</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="s">&#34;calories&#34;</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="s">&#34;sodium&#34;</span><span class="o">,</span> <span class="mi">35</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="s">&#34;carbohydrate&#34;</span><span class="o">,</span> <span class="mi">27</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>《Effective Java 3》笔记1：静态工厂方法代替构造函数</title>
      <link>https://blog.chensoul.com/posts/2023/04/03/static-factory-methods-instead-of-constructors/</link>
      <pubDate>Mon, 03 Apr 2023 12:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/03/static-factory-methods-instead-of-constructors/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。 介绍 静态工厂方法是指在类中定义一个静态方法，用</description>
      <content:encoded><![CDATA[<p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。</p>
<h2 id="介绍">介绍</h2>
<p>静态工厂方法是指在类中定义一个静态方法，用于创建该类的实例。示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Boolean</span> <span class="nf">valueOf</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">b</span> <span class="o">?</span> <span class="n">Boolean</span><span class="o">.</span><span class="na">TRUE</span> <span class="o">:</span> <span class="n">Boolean</span><span class="o">.</span><span class="na">FALSE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>与构造函数不同的是，静态工厂方法可以有自己的名称，并且可以根据参数的不同返回不同的对象实例。</p>
<h2 id="优点">优点</h2>
<p>这本书中提到了一些静态工厂方法的优点，包括：</p>
<ol>
<li>
<p>静态工厂方法可以有意义的名称：与构造函数不同，静态工厂方法可以有自己的名称，这使得代码更具有可读性和可维护性。</p>
<blockquote>
<p>例如，BigInteger 类提供了一个返回素数的静态工厂方法 <code>BigInteger.probablePrime</code> 。</p>
</blockquote>
</li>
<li>
<p>静态工厂方法可以隐藏实现细节：静态工厂方法可以隐藏对象的创建和初始化过程，使客户端代码更加简洁和易于维护。</p>
<blockquote>
<p>这是服务提供者框架的基础。</p>
<p>服务提供者框架中有三个基本组件：服务接口，代表要实现的服务；提供者注册 API，提供者使用它来注册实现，以及服务访问
API，客户端使用它来获取服务的实例。服务访问 API 允许客户端指定选择实现的标准。在没有这些条件的情况下，API
返回一个默认实现的实例，或者允许客户端循环使用所有可用的实现。服务访问 API 是灵活的静态工厂，它构成了服务提供者框架的基础。</p>
<p>服务提供者框架的第四个可选组件是服务提供者接口，它描述了产生服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须以反射的方式实例化实现。</p>
<p>在 JDBC 中，<code>Connection</code> 扮演服务接口的角色。<code>DriverManager.registerDriver</code> 是提供者注册的
API，<code>DriverManager.getConnection</code> 是服务访问 API，<code>Driver</code> 是服务提供者接口。</p>
<p>服务提供者框架模式有许多变体。例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口，这是桥接模式。依赖注入框架可以看作是强大的服务提供者。由于是
Java 6，该平台包括一个通用服务提供者框架 <code>Java.util.ServiceLoader</code>，所以你不需要，通常也不应该自己写。JDBC 不使用
ServiceLoader，因为前者比后者要早。</p>
</blockquote>
</li>
<li>
<p>静态工厂方法可以返回缓存的对象：静态工厂方法可以返回缓存的对象，这避免了创建新对象的开销，提高了性能。</p>
<blockquote>
<p>这种技术类似于享元模式。如果经常请求相同的对象，特别是在创建对象的代价很高时，它可以极大地提高性能。</p>
</blockquote>
<p><strong>举例 1：使用 ConcurrentHashMap</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadSafeCache</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ThreadSafeCache</span><span class="o">&gt;</span> <span class="n">instances</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">ThreadSafeCache</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ThreadSafeCache</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instances</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ThreadSafeCache</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>computeIfAbsent</code> 方法用于计算缓存对象。如果 <code>key</code> 在 <code>instances</code> 中不存在，则使用 lambda
表达式 <code>k -&gt; new ThreadSafeCache()</code> 创建一个新的 <code>ThreadSafeCache</code> 对象，并将该对象与 <code>key</code> 关联。如果 <code>key</code>
已经存在，则直接返回与之关联的 <code>ThreadSafeCache</code> 对象。</p>
<p>使用 <code>computeIfAbsent</code> 方法可以更简洁地实现线程安全的缓存类，并且可以确保在多线程环境下的线程安全性。</p>
</li>
</ol>
<p><strong>举例 2：使用 synchronized 关键字</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadSafeCache</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ThreadSafeCache</span><span class="o">&gt;</span> <span class="n">instances</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">ThreadSafeCache</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="n">ThreadSafeCache</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(!</span><span class="n">instances</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">instances</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="n">ThreadSafeCache</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instances</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><ol start="4">
<li>
<p>静态工厂方法可以返回子类对象：静态工厂方法可以返回实现了某个接口或继承了某个类的子类对象，这提高了代码的灵活性和可扩展性。</p>
<blockquote>
<p>例如，Java 的 Collections 框架有 45
个接口实用工具实现，提供了不可修改的集合、同步集合等。几乎所有这些实现都是通过一个非实例化类（<code>java.util.Collections</code>
）中的静态工厂方法导出的。返回对象的类都是私有的子类。</p>
</blockquote>
<p><strong>举例：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Shape</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">implements</span> <span class="n">Shape</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Drawing Circle&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Square</span> <span class="kd">implements</span> <span class="n">Shape</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Drawing Square&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShapeFactory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Shape</span> <span class="nf">getShape</span><span class="o">(</span><span class="n">String</span> <span class="n">shapeType</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">shapeType</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">shapeType</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">&#34;CIRCLE&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">Circle</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">shapeType</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">&#34;SQUARE&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">new</span> <span class="n">Square</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>ShapeFactory</code> 类使用静态工厂方法 <code>getShape</code> 来创建 <code>Shape</code> 对象。如果 <code>shapeType</code> 参数为 <code>CIRCLE</code>
，则创建 <code>Circle</code> 对象并返回，如果参数为 <code>SQUARE</code>，则创建 <code>Square</code> 对象并返回。</p>
</li>
<li>
<p>静态工厂方法可以返回不可变对象：静态工厂方法可以返回不可变对象，这确保了对象的安全性和线程安全性。</p>
<p><strong>举例</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ThreadSafeImmutableClass</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">ThreadSafeImmutableClass</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ThreadSafeImmutableClass</span> <span class="nf">getInstance</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">ThreadSafeImmutableClass</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上面的示例中，<code>ThreadSafeImmutableClass</code> 类使用静态工厂方法 <code>getInstance</code>
来创建不可变对象。由于该类的属性都是 <code>final</code> 的，因此该对象是不可变的。由于没有任何状态可以修改，因此该对象是线程安全的。</p>
</li>
</ol>
<h2 id="缺点">缺点</h2>
<p>使用静态工厂方法也有一些缺点，例如：</p>
<ol>
<li>静态工厂方法可能会导致代码的可测试性变差，因为它们往往是静态的，难以进行模拟和替换。</li>
<li>静态工厂方法可能会使代码的扩展性变差，因为它们通常是静态的，难以扩展和修改。</li>
<li>静态工厂方法可能会使代码的可读性变差，因为它们往往是自定义的，难以理解和维护。</li>
</ol>
<p>仅提供静态工厂方法也存在一些局限：</p>
<ol>
<li>不可继承：静态工厂方法是通过类名直接调用的，因此无法通过继承来创建对象的变体或子类对象。</li>
<li>可能难以扩展：如果在实现静态工厂方法时没有考虑到所有可能的用例，那么在需要添加新功能或对象类型时可能会很难扩展。</li>
<li>可能难以测试：如果静态工厂方法中包含复杂的逻辑或依赖外部资源，那么在测试时可能会很难模拟或替换这些依赖项。</li>
<li>可能会引起混淆：如果在同一个类中定义多个静态工厂方法，它们可能具有相似的名称或参数类型，从而可能会导致混淆或误用。</li>
<li>对象创建可能较慢：如果创建对象需要进行复杂的计算或依赖大量的外部资源，那么静态工厂方法可能会导致对象创建的性能问题。</li>
</ol>
<p>所以，在选择不同的静态工厂方法时，需要考虑以下几个因素：</p>
<ol>
<li>目的：考虑每个工厂方法的目的，以及它是否符合您的需求。不同的工厂方法可能有不同的目的，例如创建新对象、返回共享实例或从一种类型转换为另一种类型。</li>
<li>灵活性：考虑每个工厂方法的灵活性。某些工厂方法可能比其他工厂方法更灵活，允许更多的自定义或配置选项。</li>
<li>可读性：考虑工厂方法的可读性。好的工厂方法应该易于阅读和理解，具有清晰的名称和明确的参数。</li>
<li>性能：考虑每个工厂方法的性能影响。根据具体的用例，某些工厂方法可能比其他工厂方法更高效或更快。</li>
<li>兼容性：考虑工厂方法是否与您现有的代码库和第三方库兼容。根据具体的技术和框架，某些工厂方法可能比其他工厂方法更兼容。</li>
<li>维护：考虑每个工厂方法的维护影响。根据实现的复杂性以及文档和支持的可用性，某些工厂方法可能比其他工厂方法更易于维护。</li>
</ol>
<h2 id="使用">使用</h2>
<p>以下是一些常见静态工厂方法的名称：</p>
<ul>
<li>
<p><code>from</code>，用于从其他类型的对象或数据源中创建一个对象，例如 <code>Date.from</code> 和 <code>Duration.from</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Date</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Date</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">instant</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p><code>of</code>，一个聚合方法，它接受多个参数并返回一个包含这些参数的实例，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Set</span><span class="o">&lt;</span><span class="n">Rank</span><span class="o">&gt;</span> <span class="n">faceCards</span> <span class="o">=</span> <span class="n">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">JACK</span><span class="o">,</span> <span class="n">QUEEN</span><span class="o">,</span> <span class="n">KING</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p><code>valueOf</code>，一种替代 <code>from</code> 和 <code>of</code> 但更冗长的方法，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">BigInteger</span> <span class="n">prime</span> <span class="o">=</span> <span class="n">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p><code>instance</code> 或 <code>getInstance</code>，返回一个实例，该实例由其参数（如果有的话）描述，但不具有相同的值，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">StackWalker</span> <span class="n">luke</span> <span class="o">=</span> <span class="n">StackWalker</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">options</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p><code>create</code> 或 <code>newInstance</code>，与 <code>instance</code> 或 <code>getInstance</code> 类似，只是该方法保证每个调用都返回一个新实例，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Object</span> <span class="n">newArray</span> <span class="o">=</span> <span class="n">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">classObject</span><span class="o">,</span> <span class="n">arrayLen</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p><code>getType</code>，类似于 <code>getInstance</code>，但如果工厂方法位于不同的类中，则使用此方法。其类型是工厂方法返回的对象类型，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">FileStore</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">Files</span><span class="o">.</span><span class="na">getFileStore</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Runtime</span> <span class="n">runtime</span> <span class="o">=</span> <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">();</span>
</span></span></code></pre></div></li>
<li>
<p><code>newType</code>，与 <code>newInstance</code> 类似，但是如果工厂方法在不同的类中使用。类型是工厂方法返回的对象类型，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="n">Files</span><span class="o">.</span><span class="na">newBufferedReader</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p><code>type</code>，一个用来替代 <code>getType</code> 和 <code>newType</code> 的比较简单的方式，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Complaint</span><span class="o">&gt;</span> <span class="n">litany</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">legacyLitany</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p><code>parse</code>：用于从字符串或其他格式中解析出一个对象，例如 <code>LocalDate.parse</code> 和 <code>NumberFormat.parse</code>。</p>
</li>
<li>
<p><code>build</code>：用于构建一个对象，例如 <code>RequestBuilder.build</code> 和 <code>ResponseBuilder.build</code>。</p>
</li>
</ul>
<p>还有一些常用的静态工厂方法名称：</p>
<ol>
<li><code>asXxx</code>：用于将该类的对象转换为其他类型的对象，例如 <code>ByteBuffer.asCharBuffer</code> 和 <code>FileChannel.asIntBuffer</code>。</li>
<li><code>toXxx</code>：用于将该类的对象转换为其他类型的对象，例如 <code>BigInteger.toByteArray</code> 和 <code>String.toCharArray</code>。</li>
<li><code>getXXX</code>：用于获取某个对象，例如 <code>TimeZone.getDefault</code>。</li>
<li><code>newXxx</code>：用于创建一个新的对象，例如 <code>File.newFile</code> 和 <code>Thread.newThread</code>。</li>
<li><code>withXxx</code>：用于创建一个修改了指定属性的对象的副本，例如 <code>LocalDate.withYear</code> 和 <code>HttpHeaders.withAccept</code>。</li>
<li><code>forXxx</code>：用于创建一个与指定参数相关的对象，例如 <code>Charset.forName</code> 和 <code>ThreadLocalRandom.forWeb</code>。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-12｜车辆被堵、开车总结、Effective Java3笔记</title>
      <link>https://blog.chensoul.com/posts/2023/03/28/weekly_review_12/</link>
      <pubDate>Tue, 28 Mar 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/03/28/weekly_review_12/</guid>
      <description>前言 本篇是对 2023-03-20 到 2023-03-26 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 上周去同济医院检查鼾症，检查结果是轻度症状，医生</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-12-01.jpeg" alt="weekly-review-12-01"  />
</p>
<p>本篇是对 <code>2023-03-20</code> 到 <code>2023-03-26</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>上周去同济医院检查鼾症，检查结果是轻度症状，医生建议多运动减肥。这周每天走路 1 万步的目标已达成。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-12-02.png" alt="weekly-review-12-02" style="width:50%;" />
<p>工作上发布了一个版本，另外两个迭代正在进行中，预计这周再发布一个版本。从飞书通讯录看到又有三个非技术类同事被裁，这周周会，部门领导说最近又有一个做商务的同事被优化了。</p>
<p>上周有一天早上，车子停在小区里面，被两个车子挡住了前后道路，联系不上车主，只好坐地铁上班。话说，自从开车上班之后，使用手机的频率明显降低了很多。</p>
<p>上周末阳光正好，于是回家去给已故的亲人扫墓。周六回老家，周日回老婆家。逝者已逝，活着的人要善待自己，好好吃饭，好好睡觉，好好工作，好好运动。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-12-03.jpeg" alt="weekly-review-12-03" style="width:50%;" />
<h2 id="工作">工作</h2>
<h3 id="effective-java-3-笔记">Effective Java 3 笔记</h3>
<p>请参考 <a href="/posts/2023/04/03/static-factory-methods-instead-of-constructors/">《Effective Java 3》笔记：静态工厂方法代替构造函数</a>。</p>
<h3 id="machine-learning-with-go">Machine-Learning-With-Go</h3>
<p>B站视频：<a href="https://www.bilibili.com/video/BV1iW411w7ev">「课程」使用Go做机器学习</a></p>
<p>源代码：<a href="https://github.com/PacktPublishing/Machine-Learning-With-Go">Machine-Learning-With-Go</a></p>
<h2 id="生活">生活</h2>
<h3 id="车辆被堵">车辆被堵</h3>
<p>早上准备开车上班，发现车子前后道路都被车辆占道了。前面车辆占道，昨天晚上下班回来就发现了，也确认了这个车辆没有留挪车电话。当时就隐隐担忧今天早上会被挡住前后道路。没有想到，真的被挡了。后面的车辆留了挪车电话。六点半开始，我就给后面车的车主打电话发短信，对方一直没接电话，估计手机调静音还在睡觉吧。没有想到的是，截止到现在时间八点，他还没有给我回电话，这哥们睡得那是真香啊。</p>
<p>在道路被占用之后，我做了什么？除了给留了号码的那个车主打电话之外，我还想到交管 12123 APP 上面有一个一键挪车功能。于是，试了一下这个功能。原以为这个功能可以电话通知到对方挪车。实际情况却只是提交了一个工单而已，真是一个鸡肋的功能。用户使用这个功能，是希望及时联系到车主过来挪车，而不是提交一个工单之后，傻傻的等待。另外，这个功能也不能叫一键挪车，因为点击了这个功能之后，还要输入车牌号、上传照片。更好的体验应该是只用上传占用道路的车辆照片，由系统识别出车牌号，然后后台找到车主的手机号，生成一个临时号码并调用手机的拨号功能。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-12-04.jpeg" alt="weekly-review-12-04" style="width:50%;" />
<p>在道路被占用之后，我的心态是怎样的？刚开始想生气愤怒，后来想了想，事已至此，没有必要生气，生气只能影响自己一天的心情和好运。并尝试把这种对自己不利的一面转化为对自己有利的一面。原想六点半开车上班，道路被占之后，就可以体验一下七点多甚至八点多开车上班需要多长时间以及是否堵车。</p>
<p>如果是我把道路占用了，我该怎么做呢？首先，是车上留一个手机号码；其次，是第二天早上保证手机不关机并且没有静音。</p>
<p>如何避免再次出现这样的情况呢？一是通过电话或者便条的形式提醒车主要在车上留一个挪车电话并保证电话畅通，二是反馈给物业让物业来提醒小区里的车主不要随意占用车道。</p>
<h3 id="开车总结">开车总结</h3>
<p>学到了新知识：</p>
<ul>
<li>学会了如何调节前灯的高度。数字越大，灯光照射的越近。</li>
</ul>
<p>开车需要改进的地方：</p>
<ul>
<li>1、今天在菜场点火的时候，错把油门当刹车</li>
<li>2、准备加速超过左边货车的时候，货车打了右前灯，下意识地把方向盘向右打了一点</li>
<li>3、遇到红绿灯变黄灯时，刹车太急。想冲过去，但犹豫了。这样做太危险，不能存在侥幸心理。下次遇到这种情况，宁可提前刹车，等红灯过了，再向前行驶。</li>
</ul>
<h2 id="好物分享">好物分享</h2>
<p>虽然大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。</p>
<h3 id="一些文章">一些文章</h3>
<ul>
<li>
<p><a href="https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/">做了 6 年程序员，我学到的 10 条经验</a></p>
</li>
<li>
<p><a href="https://mritd.com/2021/06/06/jetbrains-plugins/">JetBrains 常用插件</a></p>
</li>
<li>
<p><a href="https://blog.skyju.cc/post/v2ray-warp-go-unlock-new-bing/">v2ray + warp-go 非全局使用Cloudflare WARP解锁New Bing等服务</a></p>
</li>
<li>
<p><a href="https://blog.17lai.site/posts/8f152670/">如何创建属于自己的私人资料库与私人搜索引擎 _</a></p>
</li>
<li>
<p><a href="https://1byte.io/google-large-scale-dev/">如何高效地协作开发：一些 Google 的实践</a></p>
</li>
<li>
<p><a href="https://jasonkayzk.github.io/2023/03/28/Java%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E5%BA%93Caffeine/">Java高性能缓存库Caffeine</a></p>
</li>
</ul>
<h3 id="一些工具">一些工具</h3>
<ul>
<li>
<p><a href="https://hao.uisdc.com/">优设导航官网</a>：设计导航2013年上线至今，是优设网旗下最专业好用的设计师导航网站！设计导航为设计师提供UI设计、设计教程、素材下载、高清图库、配色方案、App设计、网页设计等设计网站导航指引。设计导航每周更新，设计风向标就看优设网！</p>
</li>
<li>
<p><a href="https://dusays.com/567/">Zeabur 属于国人的免费托管平台</a></p>
</li>
<li>
<p><a href="https://luyuhuang.tech/2023/03/21/nvim.html">Neovim 使用体验</a></p>
</li>
<li>
<p><a href="https://www.domon.cn/github-copilotmian-fei-ping-ti-codeium/">Github Copilot免费平替 - Codeium</a></p>
</li>
<li>
<p><a href="https://chatdoc.com/">Chat with documents</a></p>
</li>
<li>
<p><a href="https://codeium.com/">Codeium</a>：一款免费的类 Github Copilot 的 AI 代码辅助产品，可以便捷的和 AI 进行结对编程。初步使用下来和主流的 IDE 的集成很好，感兴趣的朋友可以先到<a href="https://codeium.com/playground">浏览器里在线尝试一番</a>。</p>
</li>
</ul>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-12-05.jpeg" alt="codeium"  />
</p>
<h3 id="一些视频">一些视频</h3>
<ul>
<li>飚速宅男第五季</li>
<li>魔女</li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-8｜内存泄漏、公司裁员、练车</title>
      <link>https://blog.chensoul.com/posts/2023/02/27/weekly_review_8/</link>
      <pubDate>Mon, 27 Feb 2023 08:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/02/27/weekly_review_8/</guid>
      <description>前言 本篇是对 2023-02-20 到 2023-02-26 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这篇周报又是在地铁上完成编写的。回顾这一周的工作</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-02-20</code> 到 <code>2023-02-26</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这篇周报又是在地铁上完成编写的。回顾这一周的工作，还是项目测试、修复 bug 和准备上线发布。平静的工作节奏因为突如其来的裁员消息而变得内卷起来，大家下班的时间都纷纷往后移到了20 点左右。周末的时候，还是练车，从汉口开车到新洲。刚开始有点不敢，后来还是鼓起勇气，平安的到达。</p>
<h2 id="工作">工作</h2>
<h3 id="内存泄漏">内存泄漏</h3>
<p>这周线上环境，出现了告警，提示 jvm 出现了 full gc。于是赶紧 dump 内存进行分析查找原因。顺便整理了内存相关的知识。</p>
<p><strong>什么是内存泄漏？</strong></p>
<p>这个问题直接问 chatgpt：</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-08-01.png" alt="weekly-review-08-01"  />
</p>
<p>内存泄漏（Memory Leak）是指在程序中动态分配的内存由于某些原因程序未能释放或无法释放，导致系统内存的实际可用空间不断减少的现象。内存泄漏的发生会导致程序占用的内存越来越多，最终导致程序崩溃或系统变慢。</p>
<p>在Java中，程序员通常使用new运算符在堆上分配内存，这些内存不再使用时必须释放，否则就会出现内存泄漏。下面是一些常见的Java内存泄漏的情况：</p>
<ol>
<li>对象持有过多的引用</li>
</ol>
<p>当一个对象持有其他对象的引用时，这些对象就不能被垃圾收集器回收，导致内存泄漏。比如，一个静态集合（如Map、List）持有了大量对象的引用，但是这些对象已经不再需要了，却因为集合中仍然持有这些对象的引用，导致这些对象无法被回收，造成内存泄漏。</p>
<ol start="2">
<li>长时间持有对象锁</li>
</ol>
<p>在Java中，如果一个线程获取了一个对象的锁，但是在释放锁之前发生了异常，那么这个锁就不会被释放，从而导致内存泄漏。这种情况特别容易发生在synchronized块中。</p>
<ol start="3">
<li>不正确的缓存使用</li>
</ol>
<p>如果程序员不正确地使用缓存，就会导致内存泄漏。比如，如果使用一个静态Map来缓存对象，但是不从Map中删除对象，那么这些对象就会一直存在于内存中，造成内存泄漏。</p>
<ol start="4">
<li>大量创建临时对象</li>
</ol>
<p>如果程序频繁地创建临时对象，而这些对象又没有被及时清除，就会导致内存泄漏。比如，在循环中创建大量的字符串对象，但是没有及时清除，就会导致内存泄漏。</p>
<p>为了避免内存泄漏，Java程序员可以使用一些技术来优化程序，比如使用缓存池、避免使用不必要的静态变量、使用finalize()方法释放资源等等。</p>
<p><strong>如何排查内存泄漏？</strong></p>
<ul>
<li>
<p>内存分析工具：内存分析工具可以帮助您找到哪些对象占用了大量的内存。一些常用的内存分析工具包括：Eclipse MAT、VisualVM 和 YourKit。这些工具可以帮助您分析内存快照、查找内存泄漏并确定导致内存泄漏的代码位置。</p>
</li>
<li>
<p>堆转储文件：堆转储文件是一个包含了 JVM 堆中所有对象的快照。您可以使用以下命令生成一个堆转储文件：jmap -dump:format=b,file=heap.bin <PID>，其中<PID>是您的 Java 应用程序的进程 ID。然后，您可以使用内存分析工具来分析该文件。</p>
</li>
<li>
<p>代码审查：在编写代码时，您可以使用一些技巧来避免内存泄漏。例如，您应该确保正确地关闭流和数据库连接，避免在循环中创建对象，以及使用软引用或弱引用来存储缓存数据等。通过仔细审查代码并识别可能导致内存泄漏的部分，可以避免这些问题在运行时发生。</p>
</li>
<li>
<p>监视工具：JVM 提供了一些监视工具，例如 jstat 和 jconsole，可以用于监视 JVM 的内存使用情况。通过监视这些指标，您可以识别是否存在内存泄漏的迹象。</p>
</li>
<li>
<p>代码注入：在您的应用程序中，您可以注入一些代码，例如使用 JMX、AOP 等，以便您可以实时监视内存使用情况，并记录任何内存泄漏迹象。</p>
</li>
</ul>
<p>参考文章</p>
<ul>
<li>
<p><a href="https://www.cnblogs.com/rude3knife/p/13570423.html">一次完整的JVM堆外内存泄漏故障排查记录</a></p>
</li>
<li>
<p><a href="https://droidyue.com/blog/2015/11/28/article-java-8-lambdas-a-peek-under-the-hood">深入探索Java 8 Lambda表达式</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/weixin_34722015/article/details/114815917">java lambda表达式内存泄露_浅谈Java内存泄露</a></p>
</li>
</ul>
<h3 id="裁员">裁员</h3>
<p>去年公司就在裁员，陆陆续续裁了几次，每次都是裁两三个，动作都不大，但是很高效。因为部门人数就在五十左右，所以谁没来上班，都能很快察觉。</p>
<p>公司要在六月份上市，上市之前要使财报好看，就要开源节流、降本增效。节约成本的一个方式就是裁员，据说这次裁员动作比以前都大都迅速，今天提出裁员人数，明天就要给出名单，月底就要走人。</p>
<p>现在还只是二月份，离六月还有三个月。谁也不知道，后面还会有什么更大的裁员动作。说不定哪天就空出一个工位，说不定哪天领导就换了人，说不定哪天部门就被拆散了。</p>
<p>互联网公司最大的变化就是变化。之前在阿里工作，公司的价值观里有一条就是拥抱变化。</p>
<p>拥抱变化的最好方式就是积极面对，主动加班，提高工作效率，增加工作产出。</p>
<h2 id="生活">生活</h2>
<h3 id="练车">练车</h3>
<p>这是买车之后的第二周，还是没有开车去上班。一是因为开车不过熟练，胆子小，不敢开得太快；二是公司楼下的停车位还没有办好。</p>
<p>周六本想叫朋友过来给我当陪练，后来因为要回新洲，就算了，还是自己开车，带着老婆回新洲。</p>
<p>老婆科目一考过了，后面因为工作原因就没去练车和考试。她坐副驾驶，一边剥豆子一边提醒我注意交通规则。</p>
<p>在老婆的坐镇之下，顺利的从汉口开车六十公里到达新洲，路上没有违反交通规则。</p>
<p>周六下午去看了一下潘塘花朝节，有点失望，没有想象中的热闹。可能因为这不是正宗的花朝节，正宗的应该是在旧街。</p>
<p>逛了一圈，买了两百菜刀、一个砧板、两颗果树、一盆墨兰花。</p>
<p>周六从新洲开回阳逻，周日又从阳逻开回老家去看父亲。买车后第一次回家，放了鞭炮🧨。</p>
<p>中午包饺子，吃完饭就去菜园收割青菜。农村对于城市里上班族来说，一大好处是，每次回家，都可以装满青菜带回城市。</p>
<p>下午，从老家驱车回阳逻再到汉口。在开车的过程中，发现和总结了一些问题。</p>
<p>之前开车，总是盯着仪表盘，看车速达到了多少。车速一到 70 多就下意识地松油门和踩刹车。现在开始把眼睛注意力放到前方，不去可以在意车速，只是当导航提示我超速的时候，我白降低一点速度。</p>
<p>在红绿灯之前，如果不转弯，不要提前换道或者超车，保持中间道路行驶即可。</p>
<h2 id="好物分享">好物分享</h2>
<p>虽然大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。</p>
<h3 id="一些文章">一些文章</h3>
<ul>
<li>
<p><a href="https://blog.baoshuo.ren/post/actions-ssl-cert/">使用 GitHub Actions 自动申请与部署 SSL 证书</a></p>
</li>
<li>
<p><a href="https://phind.com/">The AI search engine for developers</a></p>
</li>
<li>
<p><a href="https://magickpen.com/">用 AI 写文章</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/weixin_34722015/article/details/114815917">java lambda表达式内存泄露_浅谈Java内存泄露</a></p>
</li>
<li>
<p><a href="https://kenengba.com/post/3769.html">在家躺着拿工资，是挺过意不去的</a></p>
</li>
<li>
<p><a href="https://blog.mikeoperfect.com/posts/11517/">车辆违章和交通事故处理流程</a></p>
</li>
<li>
<p><a href="https://blog.alswl.com/2020/03/before-code-review/">浅谈 Code Review 之事前准备</a></p>
</li>
</ul>
<h3 id="一些工具">一些工具</h3>
<h4 id="1raycasthttpswwwraycastcom">1、<a href="https://www.raycast.com/">Raycast</a></h4>
<p>Raycast是一款想要取代 Spotlight 的快捷启动器，通过 Mac 上面的一些组合键来为让你完成在 Mac 上面的快捷启动，提高你日常当中在 Mac 上面的操作效率，如果以 macOS 系统版本风格来比喻的话，Alfred 的 UI 风格应该能匹配几年前的 macOS 吧，而 Raycast 却是能够驾驭 macOS Big Sur 全新的视觉风格。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-08-02.png" alt="weekly-review-08-02"  />
</p>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-6｜买车和选号、粉色理论</title>
      <link>https://blog.chensoul.com/posts/2023/02/13/weekly_review_6/</link>
      <pubDate>Mon, 13 Feb 2023 00:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/02/13/weekly_review_6/</guid>
      <description>前言 本篇是对 2023-02-06 到 2023-02-12 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这篇周报又是在坐地铁的时候完成编写的，一边坐地铁</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-02-06</code> 到 <code>2023-02-12</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这篇周报又是在坐地铁的时候完成编写的，一边坐地铁，一边回顾上一周发生的事情，一边复盘和总结。坐地铁大概有一个半小时，从家到公司的一段通勤路程。现在还没有买车，所以都是坐地铁上下班。</p>
<p>说到车，周六去二手市场买了一辆 17 年出产的上汽宝来，今天周一去过了户并且选了一个幸运的车牌号，尾号是 8688，寓意着要发发发！</p>
<p>上个月报名的内观训练营，这周也结业了，训练营运营人员还给我发了一个结业证书。</p>
<p>这是写周报的第六周，观察了一下博客访问量，从开始统计起到这周不到一个月的时间，访问量突破了 1000。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/blog-pv-1000.png" alt="blog-pv-1000"  />
</p>
<h2 id="工作">工作</h2>
<p>这周的工作主要内容是在项目里实现用户可以切换租户和租户数据拆分。</p>
<p>第一个功能的需求是一个账号（有姓名、手机号、密码等属性）可以访问多个租户，在每个租户里有自己的数据权限和角色。第二个功能，主要是使用 SQL 进行数据加工。</p>
<p>总体上来说，这周工作处于充实忙碌的情况。而且，上下班的通勤时间，也在 B 站上看视频。这周主要看的是小马哥的 Java 训练营的公开视频。小马哥的 B 站视频，是我最近刷的比较多的一个视频，另外一个是 coder1v5 的视频，他们分享的视频都是关于 Java 的，里面有非常多的干货，而且还提供了源代码。如果你也是一名 Java 开发工程师，推荐你也关注他们。</p>
<h2 id="生活">生活</h2>
<h3 id="买车和选号">买车和选号</h3>
<p>去年 11 月 16 日，拿到了驾照，直到现在才买了一辆车。过年前，因为疫情加上工作忙，一直没有抽出时间去了解车子行情。可能是对于车子的需求感没有那么强的原因，才导致考驾照、买车不积极。结婚之前，住在公司旁边，走路五分钟上下班，根本就用不上车。结婚之后，从光谷搬到汉口，每天上下班在路上通勤时间都有三个小时了。每天早上七点就要起来做饭（带饭到公司，中午微波炉热着吃，每天可以省下一餐伙食费），然后去赶地铁。疫情放开之前，地铁上人不多，每次都有位置坐。疫情放开之后，地铁里都是人，不是每次都有位置坐，经常要站着。站着的时候，有时候就内观冥想，想想最近有没有做得不对的地方，想想工作下一步该怎么计划；有时候就看 B 站关于 Java 的视频。也算是充分利用了这段通勤时间。</p>
<p>为了上下班通勤更方便，才计划买车的，也不知道开车能够缩短多少通勤时间，也希望这节约下来的时间，可以用在读书和健身上。另外一方面，买车了之后，回家看望父母会更方便。这就是买车的原因。</p>
<img src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/my-first-car.jpeg" style="width:60%"/>
<p>考虑到刚拿驾照、以后还要买房，这次就只买了一个二手车。原计划只买个三万左右的车，最后还是超出了预算。</p>
<p>去二手市场买车的时候，是在周六，周末过不了户，所以这周一又过来办理过户和选车牌号。过户的过程还是很快的，全部交给二手市场的人代办。至于，选车牌号，之前了解了一下，车牌号尽量选尾号都是数字的，这样好记；不要带数字 4，不吉利；选号有时间限制，超过了时间未选，会默认选第一个。点击 “选号开始” 按钮之前，心里还有点紧张。当看到第一屏的号码时候，很快地扫描了一遍，发现了一个尾号为 8688 的号码。于是，就跟一同过来买车的姐夫说，这个号码怎么样。姐夫激动地说这个号码好，就选这个。真的没有想到今天运气这么好，选到了这么好的一个号码。激动得想跟朋友圈里的好友分享。之前买车的时候，付完预付款，就有分享买车的喜悦的冲动。这时候，老婆在旁边跟我说，要低调，不要和身边的亲戚说。所以，就一直没有告诉亲人和身边的朋友。没想到，这次选了一个幸运的车牌号，还是没忍住发了一个部分好友不可见的朋友圈。</p>
<p>这说明自己定力还是不够，分享欲太强，不够谦虚和低调。满招损，谦受益。只是买了一个车和选到一个幸运的车牌号而已，不能高兴太早，后面还要花时间练车上路、开车还要慢和稳，不能出交通事故，铭记 “新手上路，多多指教”。</p>
<p>学英语，最重要的是练习。开车，最重要的是慢。</p>
<h2 id="学习">学习</h2>
<h3 id="内观冥想">内观冥想</h3>
<p>一月份报名内观冥想训练营的初衷是想学习内观冥想的方法，后来因为每天早上要赶地铁以及觉得课程内容和自己期望的有些差距，就没有坚持听课和打卡。</p>
<p>虽然，没有听完所有课程，但是从开始几节课程，初步体会和感受了一下什么是内观冥想，也认识了一些内观冥想的朋友。也没有想到，最后还收到了一个结业证书。</p>
<img src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/vipassana-study-certificate.jpeg" style="width:60%"/>
<h3 id="python">Python</h3>
<p>最近有个机器学习的项目，用到了 Python，所以需要学习 Python 并掌握相关的业务知识。这一个机会，同时也是一个挑战。</p>
<h2 id="娱乐">娱乐</h2>
<p>-《粉色理论》。这部泰国双女主的同性电视剧，豆瓣上评分 9.2，在这周完结了。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/fenhonglilun.jpeg" alt="fenhonglilun"  />
</p>
<h2 id="分享">分享</h2>
<ul>
<li>
<p><a href="https://pdai.tech/md/spring/springboot/springboot-x-task-hashwheeltimer-timer.html">HashedWheelTimer</a>：是来自于 Netty 的工具类，在 netty-common 包中。它用于实现延时任务。</p>
</li>
<li>
<p><a href="https://github.com/killbill/killbill-commons">Killbill common queue</a>：一个基于DB实现的分布式的队列，它上层还包装了EventBus事件总线机制。</p>
</li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
