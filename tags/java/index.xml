<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on ChenSoul</title>
    <link>https://blog.chensoul.cc/tags/java/</link>
    <description>Recent content in Java on ChenSoul</description>
    <generator>Hugo -- 0.134.3</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 27 Aug 2024 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://blog.chensoul.cc/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ThingsBoard源码编译和Idea运行</title>
      <link>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</link>
      <pubDate>Tue, 27 Aug 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</guid>
      <description>&lt;p&gt;ThingsBoard 源码地址：&lt;a href=&#34;https://github.com/thingsboard/thingsboard&#34; target=&#34;_blank&#34;&gt;https://github.com/thingsboard/thingsboard&lt;/a&gt;，从 &lt;a href=&#34;https://github.com/thingsboard/thingsboard/releases/tag/v3.7&#34; target=&#34;_blank&#34;&gt;3.7&lt;/a&gt; 版本之后，要求 JDK17。官方提供了源码编译的文档：&lt;a href=&#34;https://thingsboard.io/docs/user-guide/install/building-from-source/&#34; target=&#34;_blank&#34;&gt;Building from sources&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;源码编译&#34;&gt;源码编译&lt;/h2&gt;
&lt;p&gt;下载代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone git@github.com:thingsboard/thingsboard.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;设置当前 JDK 版本为 17 以上。这里我使用 sdkman 切换 java。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sdk use java 17.0.12-tem
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;终端编译源码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; thingsboard
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mvn clean install -Dmaven.test.skip&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果在编译过程中提示找不到 Gradle：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]领域驱动设计速成课程</title>
      <link>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</link>
      <pubDate>Mon, 05 Aug 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design&#34; target=&#34;_blank&#34;&gt;https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为复杂领域开发软件是一项具有挑战性的任务。&lt;/p&gt;
&lt;p&gt;随着问题领域的复杂性不断增长，创建准确表示业务概念、规则和流程的软件变得越来越困难。设计不良的软件很快就会变成难以理解、难以维护和扩展的混乱代码。&lt;/p&gt;
&lt;p&gt;领域驱动设计（DDD）为这个问题提供了解决方案。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Github Action 发布 Jar 到 Maven 中央仓库</title>
      <link>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</link>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</guid>
      <description>&lt;p&gt;作为一名 Java 开发者,将自己的项目发布到 Maven 中央仓库是一个非常重要的步骤。这不仅可以让更多的开发者发现和使用您的项目,也可以提高项目的知名度和影响力。&lt;/p&gt;
&lt;p&gt;在过去,发布 Jar 到 Maven 中央仓库通常需要手动完成一系列繁琐的步骤，比如：申请 JIRA 账号、创建 Sonatype JIRA Issure、上传 Jar 包、签名 Jar 包等。但是随着 Github Action 的出现，这个过程变得更加自动化和简单。&lt;/p&gt;</description>
    </item>
    <item>
      <title>将 Maven 站点发布到 GitHub Pages</title>
      <link>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</link>
      <pubDate>Thu, 18 Jul 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</guid>
      <description>&lt;p&gt;本文源代码：&lt;a href=&#34;https://github.com/chensoul/maven-site-github-example/&#34; target=&#34;_blank&#34;&gt;https://github.com/chensoul/maven-site-github-example/&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;创建-java-maven-项目&#34;&gt;创建 Java Maven 项目&lt;/h2&gt;
&lt;p&gt;让我们使用 Maven 创建一个简单的 Java 项目&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mvn archetype:generate &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -DgroupId&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;com.mycompany.app &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -DartifactId&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;maven-site-github-example &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -DarchetypeArtifactId&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;maven-archetype-quickstart &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -DarchetypeVersion&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1.4 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -DinteractiveMode&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这将创建包含 Maven 项目的&lt;em&gt;my-app&lt;/em&gt;文件夹。让我们进入该文件夹并确保它编译正常：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; maven-site-github-example
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mvn clean verify
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们还可以生成该项目的站点：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译][译]OAuth2 with Spring 第5部分：使用PKCE保护您的Spring Boot应用程序以增强安全性</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</guid>
      <description>&lt;p&gt;原文地址：https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第1部分：了解基本概念</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</guid>
      <description>&lt;p&gt;原文地址：https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a&lt;/p&gt;
&lt;p&gt;在本系列&lt;strong&gt;关于 Spring 的 OAuth2&lt;/strong&gt;的文章中，我将尝试介绍和解释与 OAuth2 相关的每一个问题以及如何在 Spring 框架中实现这些问题。请记住，OAuth2 完全是一个概念性的东西，在不同的框架中，它有自己的实现。此外，许多应用程序开发人员开发自己的 OAuth2 实现，而不使用 Spring 框架提供的 OAuth2 框架支持。因此，我将就这个主题撰写一系列文章。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</guid>
      <description>&lt;p&gt;原文地址：https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第4部分：Spring授权客户端与Google授权服务器的社交登录演示</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</guid>
      <description>&lt;p&gt;原文地址：https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]如何组织代码</title>
      <link>https://blog.chensoul.cc/posts/2024/05/30/how-to-structure-our-code/</link>
      <pubDate>Thu, 30 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/30/how-to-structure-our-code/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://medium.com/@minadev/how-to-structure-our-code-b5e7b1c32c21&#34; target=&#34;_blank&#34;&gt;How to Structure Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;软件设计最佳实践，逐层发现包、按功能发现包以及六角形架构/端口和适配器。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这篇博文中，我将探讨如何构建我们的代码并讨论最佳实践，涵盖三种不同的方法：按层打包、按功能打包以及六边形架构/端口和适配器及其优缺点。&lt;/p&gt;</description>
    </item>
    <item>
      <title>All things about Spring Modulith</title>
      <link>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</link>
      <pubDate>Thu, 09 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</guid>
      <description>&lt;p&gt;VMware 推出了一个实验性的项目&lt;a href=&#34;https://spring.io/projects/spring-modulith&#34; target=&#34;_blank&#34;&gt;Spring Modulith&lt;/a&gt;，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]比较 Socket.IO 和 HTTP：主要区别和用例</title>
      <link>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</link>
      <pubDate>Wed, 08 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://ably.com/topic/socketio-vs-http&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/socketio-vs-http&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对&lt;a href=&#34;https://ably.com/topic/socketio&#34; target=&#34;_blank&#34;&gt;Socket.IO&lt;/a&gt;实时库和&lt;a href=&#34;https://ably.com/topic/websockets-vs-http#http&#34; target=&#34;_blank&#34;&gt;HTTP&lt;/a&gt;协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。&lt;/p&gt;
&lt;h2 id=&#34;什么是socketio&#34;&gt;什么是Socket.IO？&lt;/h2&gt;
&lt;p&gt;Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]2024年最好的WebSocket替代品</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://ably.com/topic/websocket-alternatives&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/websocket-alternatives&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;什么是-websocket&#34;&gt;什么是 WebSocket？&lt;/h2&gt;
&lt;p&gt;简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]Apache Kafka、RabbitMQ 与 AWS SNSSQS：哪个消息代理最好？</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将消息从一个组件获取到另一个组件是微服务架构中最重要的部分之一。每个服务必须能够与任何其他服务异步、可靠且大规模地通信。&lt;/p&gt;
&lt;p&gt;这就是消息代理的用武之地。消息代理（例如 Apache Kafka、RabbitMQ 和&lt;a href=&#34;https://ably.com/topic/aws-sns-vs-sqs&#34; target=&#34;_blank&#34;&gt;AWS SNS/SQS&lt;/a&gt;）为您提供一个通用接口和一组保证，而不是手动协调可能数千个微服务之间的通信。这简化了集成并更容易推理您的系统。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]HTTP 的演变 – HTTP2 深入探讨</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/http2/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/http2/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://ably.com/topic/http2&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/http2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以毫不夸张地说，超文本传输协议 (HTTP) 造就了我们所熟知的互联网。 HTTP 最初是由万维网的发明者蒂姆·伯纳斯·李 (Tim Berners-Lee) 于 1989 年提出的应用程序协议。第一个记录版本 HTTP/0.9 被称为单行协议。鉴于它催生了万维网，它现在可以被描述为有史以来最伟大的俏皮话。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]Java和WebSockets：构建可靠的实时应用程序</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</guid>
      <description>&lt;p&gt;原文：&lt;a href=&#34;https://ably.com/topic/websockets-java&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/websockets-java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在全球范围内，人们对实时传输数据的需求不断增长，&lt;a href=&#34;https://ably.com/topic/websockets&#34; target=&#34;_blank&#34;&gt;WebSocket&lt;/a&gt;可能是此类用例中最流行的传输协议。在 WebSocket 出现之前，“实时”网络已经存在，但它很难实现，通常速度较慢，并且是通过破解现有的网络技术来实现的，而这些技术并不是为实时应用程序设计的。 WebSocket 协议为真正的实时网络铺平了道路。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]WebSocket API和协议说明</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</guid>
      <description>&lt;p&gt;原文地址：&lt;a href=&#34;https://ably.com/topic/websockets&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/websockets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WebSocket 标志着 Web 开发的转折点。 WebSocket 技术旨在以事件为驱动，并针对低延迟进行了优化，已成为许多寻求构建交互式实时数字体验以提供令人愉悦的用户体验的组织和开发人员的首选。本文探讨了与 WebSocket 相关的关键主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://ably.com/topic/websockets#web-sockets-the-web-socket-protocol-and-api-explained&#34; target=&#34;_blank&#34;&gt;WebSocket 协议和 API 解释&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://ably.com/topic/websockets-vs-http&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/websockets-vs-http&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当谈到 WebSocket 与 HTTP 时，决定使用哪一种并不总是那么明确。哪一个更好？您的应用程序应该使用哪一款？&lt;/p&gt;
&lt;p&gt;但问题的答案不一定是其中之一 - 开发人员经常根据场景在同一个应用程序中同时使用 WebSocket 和 HTTP。更重要的问题是 - 我如何确定 WebSockets 还是 HTTP 是特定类型通信的正确通信协议？&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]WebSocket与REST</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://ably.com/topic/websocket-vs-rest&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/websocket-vs-rest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。&lt;/p&gt;
&lt;p&gt;好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://ably.com/topic/websockets-kafka&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/websockets-kafka&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ThingsBoard的领域模型</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</guid>
      <description>&lt;p&gt;ThingsBoard是一个开源的物联网平台，用于管理和监控物联网设备和数据。它提供了一个可扩展的架构，可以连接各种设备，并实时收集、处理和分析设备生成的数据。&lt;/p&gt;
&lt;h2 id=&#34;领域模型&#34;&gt;领域模型&lt;/h2&gt;
&lt;p&gt;在ThingsBoard中，领域模型是一个关键概念，用于描述物联网系统中的物理实体、属性和行为。以下是ThingsBoard中的主要领域模型组件：&lt;/p&gt;</description>
    </item>
    <item>
      <title>All things about ThingsBoard</title>
      <link>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</link>
      <pubDate>Mon, 29 Apr 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</guid>
      <description>&lt;p&gt;thingsboard 是一款乌克兰团队基于java语言研发的开源物联网框架，开源的是ce版，企业版需要购买授权且无源码。&lt;/p&gt;
&lt;p&gt;官方网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Thingsboard 官网：&lt;a href=&#34;https://thingsboard.io/&#34; target=&#34;_blank&#34;&gt;https://thingsboard.io/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thingsboard社区免费版本：&lt;a href=&#34;https://demo.thingsboard.io/&#34; target=&#34;_blank&#34;&gt;https://demo.thingsboard.io/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thingsboard 企业付费版本：&lt;a href=&#34;https://thingsboard.cloud/&#34; target=&#34;_blank&#34;&gt;https://thingsboard.cloud/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thingsboard 源码：&lt;a href=&#34;https://github.com/thingsboard/thingsboard&#34; target=&#34;_blank&#34;&gt;https://github.com/thingsboard/thingsboard&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TBMQ 源码：&lt;a href=&#34;https://github.com/thingsboard/tbmq&#34; target=&#34;_blank&#34;&gt;https://github.com/thingsboard/tbmq&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中文网：&lt;a href=&#34;http://www.ithingsboard.com/&#34; target=&#34;_blank&#34;&gt;http://www.ithingsboard.com/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>TBMQ测试和源码分析</title>
      <link>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</link>
      <pubDate>Sun, 28 Apr 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动 TBMQ 程序，浏览器访问 http://localhost:8083，创建一个 Application，Credentials Type 为   BASIC，客户端 ID、用户名和密码均设置为 tbmq_app&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 mosquitto 测试订阅消息&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mosquitto_sub -d -q &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; -h localhost -p &lt;span class=&#34;m&#34;&gt;1883&lt;/span&gt; -t tbmq/demo/+ -i &lt;span class=&#34;s1&#34;&gt;&amp;#39;tbmq_app&amp;#39;&lt;/span&gt; -u &lt;span class=&#34;s1&#34;&gt;&amp;#39;tbmq_app&amp;#39;&lt;/span&gt; -P &lt;span class=&#34;s1&#34;&gt;&amp;#39;tbmq_app&amp;#39;&lt;/span&gt; -c -v
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Debug 调试 MqttSessionHandler 类的 &lt;code&gt;channelRead(ChannelHandlerContext ctx, Object msg)&lt;/code&gt; 方法&lt;/p&gt;</description>
    </item>
    <item>
      <title>ThingsBoard TBMQ本地和通过Docker运行</title>
      <link>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</link>
      <pubDate>Wed, 17 Apr 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</guid>
      <description>&lt;h2 id=&#34;docker-compose-运行&#34;&gt;docker-compose 运行&lt;/h2&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/&#34; target=&#34;_blank&#34;&gt;https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载源代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; tbmq/docker
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建逻辑卷并执行安装程序&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./scripts/docker-create-volumes.sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./scripts/docker-install-tbmq.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行服务&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./scripts/docker-start-services.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;浏览器访问：&lt;a href=&#34;http://localhost:8083&#34; target=&#34;_blank&#34;&gt;http://localhost:8083&lt;/a&gt;，用户名/密码：sysadmin@thingsboard.org / sysadmin&lt;/p&gt;
&lt;p&gt;查看 HaProxy 日志，发现出现异常：&lt;code&gt;Error: Specified qdisc kind is unknown.&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;目前，尚未找到解决办法，只能不使用 HaProxy 而是直接访问 tbmq1，修改 docker-compose.yml ，暴露容器端口 8083 到本地的 8083：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Circuit Breaker</title>
      <link>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/circuit-breaker/&#34; target=&#34;_blank&#34;&gt;Circuit Breaker&lt;/a&gt; 断路器模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Chain</title>
      <link>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</link>
      <pubDate>Mon, 16 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/chain/&#34; target=&#34;_blank&#34;&gt;Chain&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;目的&#34;&gt;目的&lt;/h2&gt;
&lt;p&gt;通过给多个对象一个处理请求的机会，避免请求的发送者和它的接收者耦合。串联接收对象并在链条中传递请求直到一个对象处理它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Callback</title>
      <link>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</link>
      <pubDate>Fri, 13 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/callback/&#34; target=&#34;_blank&#34;&gt;Callback&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;回调（Callback）是一种设计模式，在这种模式中，一个可执行的代码被作为参数传递给其他代码，接收方的代码可以在适当的时候调用它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Caching</title>
      <link>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/caching/&#34; target=&#34;_blank&#34;&gt;Caching&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;缓存模式（Caching Pattern）是一种设计模式，旨在通过在资源使用后将其保留在某个快速访问的存储中，并在需要时重新使用资源，以避免昂贵的资源重新获取。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Bytecode</title>
      <link>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</link>
      <pubDate>Fri, 22 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/bytecode/&#34; target=&#34;_blank&#34;&gt;Bytecode&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;字节码设计模式是一种软件设计模式，它允许以数据驱动的方式定义和执行行为。在字节码设计模式中，行为被表示为一系列虚拟机指令，这些指令被编码为字节码，并在运行时执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Builder</title>
      <link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</link>
      <pubDate>Tue, 05 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/builder/&#34; target=&#34;_blank&#34;&gt;Builder&lt;/a&gt; 构造器模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;构造器模式（Builder Pattern）是一种创建型设计模式，用于将复杂对象的构建过程与其表示分离，从而可以使用相同的构建过程创建不同的表示。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Business Delegate</title>
      <link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</link>
      <pubDate>Tue, 05 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/business-delegate/&#34; target=&#34;_blank&#34;&gt;Business Delegate&lt;/a&gt; 业务委托模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;业务委托模式（Business Delegate Pattern）在表示层和业务层之间引入了一个抽象层，旨在实现这两个层之间的松散耦合，并封装了有关如何定位、连接和交互业务对象的逻辑。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Bridge</title>
      <link>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</link>
      <pubDate>Mon, 28 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/bridge/&#34; target=&#34;_blank&#34;&gt;Bridge&lt;/a&gt; 桥接模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;桥接模式（Bridge Pattern）是一种结构型设计模式，用于将抽象与其实现分离，使它们可以独立地变化。桥接模式通过创建两个独立的层次结构，一个是抽象部分，一个是实现部分，来实现这种分离。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Balking</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/balking/&#34; target=&#34;_blank&#34;&gt;Balking&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;止步模式（Balking）是一种在对象处于特定状态时才执行操作的设计模式。它用于防止对象在不完整或不合适的状态下执行某些代码，从而确保代码的正确性和一致性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记17：减少可变性</title>
      <link>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</link>
      <pubDate>Mon, 14 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第四章《类和接口》的学习笔记：减少可变性。&lt;/p&gt;
&lt;h2 id=&#34;原文&#34;&gt;原文&lt;/h2&gt;
&lt;p&gt;不可变类是实例不能被修改的类。每个实例中包含的所有信息在对象的生命周期内都是固定的，因此永远不会观察到任何更改。Java 库包含许多不可变的类，包括 String、基本类型的包装类、BigInteger 和 BigDecimal。这么做有很好的理由：不可变类比可变类更容易设计、实现和使用。它们不太容易出错，而且更安全。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Async Method Invocation</title>
      <link>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</link>
      <pubDate>Mon, 14 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</guid>
      <description>&lt;p&gt;本文主要介绍 Async Method Invocation 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Async Method Invocation（异步方法调用）是一种编程模式，用于处理异步操作和并发执行。它允许在执行某个操作时不阻塞主线程，而是将操作委托给另一个线程或处理程序，并在操作完成后获取结果或执行回调。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：API Gateway </title>
      <link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</link>
      <pubDate>Sun, 13 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</guid>
      <description>&lt;p&gt;本文主要介绍 API Gateway 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;目的&#34;&gt;目的&lt;/h2&gt;
&lt;p&gt;API 网关设计模式旨在将所有对微服务的调用聚合到一起。客户端通过调用 API 网关来实现对多个微服务的访问，而不是直接调用每个微服务。这种模式的目的是解决以下问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Arrange/Act/Assert</title>
      <link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</link>
      <pubDate>Sun, 13 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</guid>
      <description>&lt;p&gt;本文主要介绍 Arrange/Act/Assert 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Arrange/Act/Assert（安排/执行/断言）又称 Given/When/Then，是一种测试设计模式，用于组织和编写单元测试的结构。它提供了一种清晰的测试布局，使得测试代码易于理解和维护。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Ambassador</title>
      <link>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</link>
      <pubDate>Thu, 06 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</guid>
      <description>&lt;p&gt;本文主要介绍 Ambassador 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]微服务设计模式</title>
      <link>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</link>
      <pubDate>Mon, 26 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</guid>
      <description>&lt;p&gt;基于微服务的应用程序的主要特征在 &lt;a href=&#34;http://web.archive.org/web/20190705163602/http://blog.arungupta.me/microservices-monoliths-noops/&#34; target=&#34;_blank&#34;&gt;微服务、单体和 NoOps&lt;/a&gt; 中定义。它们是功能分解或领域驱动设计、定义良好的接口、明确发布的接口、单一责任原则和潜在的多语言。每项服务都是完全自主和全栈的。&lt;/p&gt;
&lt;p&gt;因此，更改服务实现不会影响其他服务，因为它们使用定义良好的接口进行通信。这种应用程序有几个优点，但它不是 &lt;a href=&#34;http://web.archive.org/web/20190705163602/http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html&#34; target=&#34;_blank&#34;&gt;免费的午餐&lt;/a&gt;，需要在 NoOps 方面付出大量努力。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Aggregator Microservices</title>
      <link>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</link>
      <pubDate>Mon, 26 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</guid>
      <description>&lt;p&gt;本文主要介绍 Aggregator Microservices 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记15：尽量减少类和成员的可访问性</title>
      <link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link>
      <pubDate>Thu, 15 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第四章《类和接口》的学习笔记：尽量减少类和成员的可访问性。&lt;/p&gt;
&lt;p&gt;类和接口是 Java 编程语言的核心。它们是抽象的基本单位。该语言提供了许多强大的元素，你可以使用它们来设计类和接口。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;《Effective Java, Third Edition》这本书中的第四章主要讲述了如何尽量减少类和成员的可访问性，以提高代码的封装性、安全性和可维护性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记16：在公共类中，使用访问器方法，而不是公共字段</title>
      <link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link>
      <pubDate>Thu, 15 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第四章《类和接口》的学习笔记：在公共类中，使用访问器方法，而不是公共字段。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;与其直接将类的内部字段公开为公共字段，推荐使用访问器方法（也称为 getter 和 setter）来访问和修改对象的状态。这样可以使类对其内部表示保持控制，并为类的客户端提供一种抽象程度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Adapter</title>
      <link>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</link>
      <pubDate>Sat, 10 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</guid>
      <description>&lt;p&gt;本文主要介绍 Adapter 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Visitor</title>
      <link>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</link>
      <pubDate>Fri, 02 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</guid>
      <description>&lt;p&gt;本文主要介绍 Visitor 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Acyclic Visitor</title>
      <link>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</link>
      <pubDate>Thu, 01 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</guid>
      <description>&lt;p&gt;本文主要介绍 Acyclic Visitor 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>周报-21｜Python之禅、产品经理被优化、端午节送节</title>
      <link>https://blog.chensoul.cc/posts/2023/05/31/weekly_review_21/</link>
      <pubDate>Wed, 31 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/31/weekly_review_21/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-21-00.jpg&#34; alt=&#34;weekly-review-21-00&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;center&gt;&lt;i&gt;公司价值观&lt;/i&gt;&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;本篇是对 &lt;code&gt;2023-05-22&lt;/code&gt; 到 &lt;code&gt;2023-05-28&lt;/code&gt; 这周生活的记录与思考。首发在我的个人 &lt;a href=&#34;https://blog.chensoul.cc/&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;，你可以移步了解更多或者给我留言。&lt;/p&gt;
&lt;p&gt;周一，休产假的产品经理回来上班，得知她被优化之后，内心有些不舍和伤感。中午，组长请大家一起吃了饭。晚上，产品经理交割完办公用户之后，就没来上班了。自此，过完年后，公司至少有三位女同事修完产假之后就离职了，有的是主动，更多的应该是被动。虽然有 N+1 赔偿，但是，这个社会对女性还是不够公平。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记12：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：始终覆盖 toString 方法。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;虽然 Object 提供 toString 方法的实现，但它返回的字符串通常不是类的用户希望看到的。它由后跟「at」符号（@）的类名和 hash 代码的无符号十六进制表示（例如 &lt;code&gt;PhoneNumber@163b91&lt;/code&gt;）组成。toString 的通用约定是这么描述的，返回的字符串应该是「简洁但信息丰富的表示，易于阅读」。虽然有人认为 &lt;code&gt;PhoneNumber@163b91&lt;/code&gt; 简洁易懂，但与 &lt;code&gt;707-867-5309&lt;/code&gt; 相比，它的信息量并不大。toString 约定接着描述，「建议所有子类覆盖此方法。」好建议，确实！&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记13：明智地覆盖 clone 方法</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：明智地覆盖 clone 方法。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Cloneable 接口的目的是作为 mixin 接口，用于让类来宣称它们允许克隆。不幸的是，它没有达到这个目的。它的主要缺点是缺少 clone 方法，并且 Object 类的 clone 方法是受保护的。如果不求助于反射，就不能仅仅因为对象实现了 Cloneable 接口就能调用 clone 方法。即使反射调用也可能失败，因为不能保证对象具有可访问的 clone 方法。尽管存在多种缺陷，但该机制的使用范围相当广泛，因此理解它是值得的。本条目将告诉你如何实现行为良好的 clone 方法，讨论什么时候应该这样做，并提供替代方案。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记14：考虑实现 Comparable 接口</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;与本章讨论的其他方法不同，compareTo 方法不是在 Object 中声明的。相反，它是 Comparable 接口中的唯一方法。它在性质上类似于 Object 的 equals 方法，除了简单的相等比较之外，它还允许顺序比较，而且它是通用的。一个类实现 Comparable，表明实例具有自然顺序。对实现 Comparable 的对象数组进行排序非常简单：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Active Object</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</guid>
      <description>&lt;p&gt;本文主要介绍 Active Object 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title>
      <link>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</link>
      <pubDate>Tue, 23 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在覆盖了 equals 方法的类中，必须覆盖 hashCode 方法。&lt;/strong&gt; 如果你没有这样做，该类将违反 hashCode 方法的一般约定，这将阻止该类在 HashMap 和 HashSet 等集合中正常运行。以下是根据 Object 规范修改的约定：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Abstract Document</title>
      <link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</link>
      <pubDate>Mon, 22 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</guid>
      <description>&lt;p&gt;本文主要介绍 Abstract Document 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Abstract Factory</title>
      <link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</link>
      <pubDate>Mon, 22 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</guid>
      <description>&lt;p&gt;本文主要介绍 Abstract Factory 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JSR 166规范</title>
      <link>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</link>
      <pubDate>Thu, 18 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</guid>
      <description>&lt;h2 id=&#34;jsr-介绍&#34;&gt;JSR 介绍&lt;/h2&gt;
&lt;p&gt;JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 &lt;a href=&#34;http://jcp.org/en/jsr/detail?id=335&#34; target=&#34;_blank&#34;&gt;JSR 335&lt;/a&gt;，新的日期和时间 API 对应的是 &lt;a href=&#34;http://jcp.org/en/jsr/detail?id=310&#34; target=&#34;_blank&#34;&gt;JSR 310&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定</title>
      <link>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</link>
      <pubDate>Wed, 17 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：覆盖 equals 方法时应遵守的约定。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;覆盖 equals 方法似乎很简单，但是有很多覆盖的方式会导致出错，而且后果可能非常严重。避免问题的最简单方法是不覆盖 equals 方法，在这种情况下，类的每个实例都只等于它自己。如果符合下列任何条件，就是正确的做法：&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记8：避免使用终结器和清除器</title>
      <link>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</link>
      <pubDate>Mon, 08 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：避免使用终结器和清除器。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;终结器是不可预测的、常常是危险的，通常也是不必要的。&lt;/strong&gt; 它们的使用可能导致不稳定的行为、低效率和可移植性问题。终结器有一些有效的用途，我们稍后会介绍，但通常情况下应该避免使用它们。从 Java 9 开始，终结器已经被弃用，但它们仍然被 Java 库使用。Java 9 中终结器的替代品是清除器。 &lt;strong&gt;清除器的危险比终结器小，但仍然不可预测、缓慢，而且通常是不必要的。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记9：使用 try-with-resources 优于 try-finally</title>
      <link>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</link>
      <pubDate>Mon, 08 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：使用 try-with-resources 优于 try-finally。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Java 库包含许多必须通过调用 close 方法手动关闭的资源。常见的有 InputStream、OutputStream 和 java.sql.Connection。关闭资源常常会被客户端忽略，这会导致可怕的性能后果。虽然这些资源中的许多都使用终结器作为安全网，但终结器并不能很好地工作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记4：用私有构造函数使类不可实例化</title>
      <link>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</link>
      <pubDate>Fri, 05 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：用私有构造函数使类不可实例化。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;使用私有构造函数强制实现不可实例化的主要原因是防止类被意外地实例化，以使代码更加健壮和可靠。在某些情况下，我们只需要使用类中的静态方法和静态字段，而不需要创建该类的实例。如果类中没有显式地定义私有构造函数，Java 编译器将会自动为该类生成一个默认的公共构造函数，这意味着该类可以在其他类中被实例化。如果这不是我们想要的，为了防止其他人意外地实例化我们的类，我们可以将构造函数设置为私有。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记7：排除过时的对象引用</title>
      <link>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</link>
      <pubDate>Fri, 05 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Eliminate obsolete object references&amp;rdquo; 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记6：避免创建不必要的对象</title>
      <link>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</link>
      <pubDate>Mon, 24 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：避免创建不必要的对象。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;创建对象时，经常会复用对象。如果对象是不可变的，那么它总是可以被复用的。&lt;/p&gt;
&lt;p&gt;下面一个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;bikini&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// DON&amp;#39;T DO THIS!&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;该语句每次执行时都会创建一个新的 String 实例，而这些对象创建都不是必需的。String 构造函数的参数 &lt;code&gt;(&amp;quot;bikini&amp;quot;)&lt;/code&gt; 本身就是一个 String 实例，在功能上与构造函数创建的所有对象相同。如果这种用法发生在循环或频繁调用的方法中，创建大量 String 实例是不必要的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记5：依赖注入优于硬编码资源</title>
      <link>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</link>
      <pubDate>Mon, 17 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;依赖注入是软件工程中使用的一种设计模式，用于将组件和依赖项相互解耦。而不是在组件内部创建和管理依赖项，我们从外部传递它们。这种方法可以帮助创建更模块化和灵活的代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记3：使用私有构造函数或枚举类型创建单例</title>
      <link>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</link>
      <pubDate>Tue, 11 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;单例是一个只实例化一次的类。单例通常表示无状态对象，比如函数或系统组件，它们在本质上是唯一的。&lt;strong&gt;将一个类设计为单例会使它的客户端测试时变得困难，&lt;/strong&gt; 除非它实现了作为其类型的接口，否则无法用模拟实现来代替单例。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记1：静态工厂方法代替构造函数</title>
      <link>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;静态工厂方法是指在类中定义一个静态方法，用于创建该类的实例。示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;valueOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;FALSE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;与构造函数不同的是，静态工厂方法可以有自己的名称，并且可以根据参数的不同返回不同的对象实例。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记2：使用构造器代替构造方法</title>
      <link>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;当一个类需要多个构造函数参数时，可以考虑使用&lt;strong&gt;构建器模式&lt;/strong&gt;来创建对象。构建器模式是一种创建对象的设计模式，它可以通过链式调用方法的方式来设置对象的构造参数，并最终返回一个构造完整的对象。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
