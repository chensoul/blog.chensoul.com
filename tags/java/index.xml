<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on ChenSoul</title><link>https://blog.chensoul.cc/tags/java/</link><description>Recent content in Java on ChenSoul</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 04 Nov 2024 21:00:00 +0800</lastBuildDate><atom:link href="https://blog.chensoul.cc/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Tutorials</title><link>https://blog.chensoul.cc/tutorials/</link><pubDate>Mon, 04 Nov 2024 21:00:00 +0800</pubDate><guid>https://blog.chensoul.cc/tutorials/</guid><description>&lt;h3 id="java">Java&lt;/h3>
&lt;h3 id="kubernetes">Kubernetes&lt;/h3>
&lt;h3 id="microservices">Microservices&lt;/h3>
&lt;h3 id="spring-boot">Spring Boot&lt;/h3>
&lt;h3 id="spring-cloud">Spring Cloud&lt;/h3>
&lt;h3 id="spring-security-oauth-20">Spring Security OAuth 2.0&lt;/h3>
&lt;h3 id="heading">&lt;/h3></description></item><item><title>[译]领域驱动设计速成课程</title><link>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</link><pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</guid><description>&lt;p>原文链接：&lt;a href="https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design" target="_blank">https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design&lt;/a>&lt;/p>
&lt;p>为复杂领域开发软件是一项具有挑战性的任务。&lt;/p>
&lt;p>随着问题领域的复杂性不断增长，创建准确表示业务概念、规则和流程的软件变得越来越困难。设计不良的软件很快就会变成难以理解、难以维护和扩展的混乱代码。&lt;/p>
&lt;p>领域驱动设计（DDD）为这个问题提供了解决方案。&lt;/p>
&lt;p>DDD 是一种软件开发方法，它通过强调对核心领域和业务逻辑进行建模的重要性并使用这些模型作为软件设计的基础来解决领域复杂性。&lt;/p></description></item><item><title>[译]OAuth2 with Spring 第1部分：了解基本概念</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</guid><description>&lt;p>原文地址：&lt;a href="https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a" target="_blank">https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a&lt;/a>&lt;/p>
&lt;p>在本系列&lt;strong>关于 Spring 的 OAuth2&lt;/strong>的文章中，我将尝试介绍和解释与 OAuth2 相关的每一个问题以及如何在 Spring 框架中实现这些问题。请记住，OAuth2 完全是一个概念性的东西，在不同的框架中，它有自己的实现。此外，许多应用程序开发人员开发自己的 OAuth2 实现，而不使用 Spring 框架提供的 OAuth2 框架支持。因此，我将就这个主题撰写一系列文章。&lt;/p></description></item><item><title>[译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</guid><description>&lt;p>原文地址：&lt;a href="https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a" target="_blank">https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a&lt;/a>&lt;/p>
&lt;p>在&lt;a href="https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-2-getting-started-with-authorization-server/">上一篇文章&lt;/a>中，我们讨论了使用 client_credential 的 OAuth2 授权服务器配置。在本文中，我们将讨论使用 authorization_code 授予类型的授权服务器配置。此授权流程将有一个 OIDC 客户端，它将通过使用授权码进行请求来获取 JWT 令牌。&lt;/p></description></item><item><title>[译]OAuth2 with Spring 第4部分：Spring授权客户端与Google授权服务器的社交登录演示</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</guid><description>&lt;p>原文地址：&lt;a href="https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5" target="_blank">https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5&lt;/a>&lt;/p>
&lt;p>在&lt;a href="https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/">之前的文章&lt;/a>中，我们学习了如何使用 OIDC 连接到我们自己的授权服务器。我们在自托管授权服务器中定义了我们自己的客户端应用程序。在今天的文章中，我们将使用 Google 和 GitHub 作为我们的授权服务器，并将我们的授权客户端应用程序连接到这些授权服务器并从它们接收令牌。应用程序登录屏幕将如下所示。&lt;/p></description></item><item><title>[译]OAuth2 with Spring 第5部分：使用PKCE保护您的Spring Boot应用程序以增强安全性</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</guid><description>&lt;p>原文地址：&lt;a href="https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769" target="_blank">https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>免责声明：本文技术性很强，需要清楚了解本系列前几篇文章，特别是第 1 部分和第 3 部分。&lt;/p></description></item><item><title>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websockets-kafka" target="_blank">https://ably.com/topic/websockets-kafka&lt;/a>&lt;/p>
&lt;p>Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。&lt;/p></description></item><item><title>Java设计模式：Circuit Breaker</title><link>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</link><pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/circuit-breaker/" target="_blank">Circuit Breaker&lt;/a> 断路器模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Chain</title><link>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/chain/" target="_blank">Chain&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Callback</title><link>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</link><pubDate>Fri, 13 Oct 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/callback/" target="_blank">Callback&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Caching</title><link>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</link><pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/caching/" target="_blank">Caching&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Bytecode</title><link>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/bytecode/" target="_blank">Bytecode&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Builder</title><link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/builder/" target="_blank">Builder&lt;/a> 构造器模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Business Delegate</title><link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/business-delegate/" target="_blank">Business Delegate&lt;/a> 业务委托模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Bridge</title><link>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/bridge/" target="_blank">Bridge&lt;/a> 桥接模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Balking</title><link>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</guid><description>&lt;p>本文主要介绍 &lt;a href="https://java-design-patterns.com/zh/patterns/balking/" target="_blank">Balking&lt;/a> 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>《Effective Java 3》笔记17：减少可变性</title><link>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</guid><description>&lt;p>本文是 《Effective Java 3》第四章《类和接口》的学习笔记：减少可变性。&lt;/p>
&lt;h2 id="原文">原文&lt;/h2>
&lt;p>不可变类是实例不能被修改的类。每个实例中包含的所有信息在对象的生命周期内都是固定的，因此永远不会观察到任何更改。Java 库包含许多不可变的类，包括 String、基本类型的包装类、BigInteger 和 BigDecimal。这么做有很好的理由：不可变类比可变类更容易设计、实现和使用。它们不太容易出错，而且更安全。&lt;/p></description></item><item><title>Java设计模式：Async Method Invocation</title><link>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</guid><description>&lt;p>本文主要介绍 Async Method Invocation 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：API Gateway</title><link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</link><pubDate>Sun, 13 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</guid><description>&lt;p>本文主要介绍 API Gateway 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Arrange/Act/Assert</title><link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</link><pubDate>Sun, 13 Aug 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</guid><description>&lt;p>本文主要介绍 Arrange/Act/Assert 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Ambassador</title><link>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</guid><description>&lt;p>本文主要介绍 Ambassador 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>[译]微服务设计模式</title><link>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</guid><description>&lt;p>基于微服务的应用程序的主要特征在 &lt;a href="http://web.archive.org/web/20190705163602/http://blog.arungupta.me/microservices-monoliths-noops/" target="_blank">微服务、单体和 NoOps&lt;/a> 中定义。它们是功能分解或领域驱动设计、定义良好的接口、明确发布的接口、单一责任原则和潜在的多语言。每项服务都是完全自主和全栈的。&lt;/p>
&lt;p>因此，更改服务实现不会影响其他服务，因为它们使用定义良好的接口进行通信。这种应用程序有几个优点，但它不是 &lt;a href="http://web.archive.org/web/20190705163602/http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html" target="_blank">免费的午餐&lt;/a>，需要在 NoOps 方面付出大量努力。&lt;/p></description></item><item><title>Java设计模式：Aggregator Microservices</title><link>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</guid><description>&lt;p>本文主要介绍 Aggregator Microservices 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>《Effective Java 3》笔记15：尽量减少类和成员的可访问性</title><link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid><description>&lt;p>本文是 《Effective Java 3》第四章《类和接口》的学习笔记：尽量减少类和成员的可访问性。&lt;/p>
&lt;p>类和接口是 Java 编程语言的核心。它们是抽象的基本单位。该语言提供了许多强大的元素，你可以使用它们来设计类和接口。&lt;/p></description></item><item><title>《Effective Java 3》笔记16：在公共类中，使用访问器方法，而不是公共字段</title><link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid><description>&lt;p>本文是 《Effective Java 3》第四章《类和接口》的学习笔记：在公共类中，使用访问器方法，而不是公共字段。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>与其直接将类的内部字段公开为公共字段，推荐使用访问器方法（也称为 getter 和 setter）来访问和修改对象的状态。这样可以使类对其内部表示保持控制，并为类的客户端提供一种抽象程度。&lt;/p></description></item><item><title>Java设计模式：Adapter</title><link>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</link><pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</guid><description>&lt;p>本文主要介绍 Adapter 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Visitor</title><link>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</link><pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</guid><description>&lt;p>本文主要介绍 Visitor 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Acyclic Visitor</title><link>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</guid><description>&lt;p>本文主要介绍 Acyclic Visitor 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>《Effective Java 3》笔记12：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title><link>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：始终覆盖 toString 方法。&lt;/p></description></item><item><title>《Effective Java 3》笔记13：明智地覆盖 clone 方法</title><link>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：明智地覆盖 clone 方法。&lt;/p></description></item><item><title>《Effective Java 3》笔记14：考虑实现 Comparable 接口</title><link>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。&lt;/p></description></item><item><title>Java设计模式：Active Object</title><link>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</guid><description>&lt;p>本文主要介绍 Active Object 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title><link>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</link><pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。&lt;/p></description></item><item><title>Java设计模式：Abstract Document</title><link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</guid><description>&lt;p>本文主要介绍 Abstract Document 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>Java设计模式：Abstract Factory</title><link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</guid><description>&lt;p>本文主要介绍 Abstract Factory 模式，在 &lt;a href="https://java-design-patterns.com/" target="_blank">Java Design Patterns&lt;/a> 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p></description></item><item><title>JSR 166规范</title><link>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</guid><description>&lt;h2 id="jsr-介绍">JSR 介绍&lt;/h2>
&lt;p>JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=335" target="_blank">JSR 335&lt;/a>，新的日期和时间 API 对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=310" target="_blank">JSR 310&lt;/a>。&lt;/p></description></item><item><title>《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定</title><link>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</link><pubDate>Wed, 17 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</guid><description>&lt;p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：覆盖 equals 方法时应遵守的约定。&lt;/p></description></item><item><title>《Effective Java 3》笔记8：避免使用终结器和清除器</title><link>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</link><pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：避免使用终结器和清除器。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>&lt;strong>终结器是不可预测的、常常是危险的，通常也是不必要的。&lt;/strong> 它们的使用可能导致不稳定的行为、低效率和可移植性问题。终结器有一些有效的用途，我们稍后会介绍，但通常情况下应该避免使用它们。从 Java 9 开始，终结器已经被弃用，但它们仍然被 Java 库使用。Java 9 中终结器的替代品是清除器。 &lt;strong>清除器的危险比终结器小，但仍然不可预测、缓慢，而且通常是不必要的。&lt;/strong>&lt;/p></description></item><item><title>《Effective Java 3》笔记9：使用 try-with-resources 优于 try-finally</title><link>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</link><pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：使用 try-with-resources 优于 try-finally。&lt;/p></description></item><item><title>《Effective Java 3》笔记4：用私有构造函数使类不可实例化</title><link>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</link><pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：用私有构造函数使类不可实例化。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>使用私有构造函数强制实现不可实例化的主要原因是防止类被意外地实例化，以使代码更加健壮和可靠。在某些情况下，我们只需要使用类中的静态方法和静态字段，而不需要创建该类的实例。如果类中没有显式地定义私有构造函数，Java 编译器将会自动为该类生成一个默认的公共构造函数，这意味着该类可以在其他类中被实例化。如果这不是我们想要的，为了防止其他人意外地实例化我们的类，我们可以将构造函数设置为私有。&lt;/p></description></item><item><title>《Effective Java 3》笔记7：排除过时的对象引用</title><link>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</link><pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>&amp;ldquo;Eliminate obsolete object references&amp;rdquo; 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。&lt;/p></description></item><item><title>《Effective Java 3》笔记6：避免创建不必要的对象</title><link>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记：避免创建不必要的对象。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>创建对象时，经常会复用对象。如果对象是不可变的，那么它总是可以被复用的。&lt;/p></description></item><item><title>《Effective Java 3》笔记5：依赖注入优于硬编码资源</title><link>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</link><pubDate>Mon, 17 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p></description></item><item><title>《Effective Java 3》笔记3：使用私有构造函数或枚举类型创建单例</title><link>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</link><pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p></description></item><item><title>《Effective Java 3》笔记1：静态工厂方法代替构造函数</title><link>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p></description></item><item><title>《Effective Java 3》笔记2：使用构造器代替构造方法</title><link>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</guid><description>&lt;p>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p></description></item></channel></rss>