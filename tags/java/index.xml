<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on ChenSoul</title>
    <link>https://blog.chensoul.cc/tags/java/</link>
    <description>Recent content in Java on ChenSoul</description>
    <generator>Hugo -- 0.134.3</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 05 Aug 2024 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://blog.chensoul.cc/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[译]领域驱动设计速成课程</title>
      <link>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</link>
      <pubDate>Mon, 05 Aug 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design&#34; target=&#34;_blank&#34;&gt;https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为复杂领域开发软件是一项具有挑战性的任务。&lt;/p&gt;
&lt;p&gt;随着问题领域的复杂性不断增长，创建准确表示业务概念、规则和流程的软件变得越来越困难。设计不良的软件很快就会变成难以理解、难以维护和扩展的混乱代码。&lt;/p&gt;
&lt;p&gt;领域驱动设计（DDD）为这个问题提供了解决方案。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译][译]OAuth2 with Spring 第5部分：使用PKCE保护您的Spring Boot应用程序以增强安全性</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</guid>
      <description>&lt;p&gt;原文地址：https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第1部分：了解基本概念</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</guid>
      <description>&lt;p&gt;原文地址：https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a&lt;/p&gt;
&lt;p&gt;在本系列&lt;strong&gt;关于 Spring 的 OAuth2&lt;/strong&gt;的文章中，我将尝试介绍和解释与 OAuth2 相关的每一个问题以及如何在 Spring 框架中实现这些问题。请记住，OAuth2 完全是一个概念性的东西，在不同的框架中，它有自己的实现。此外，许多应用程序开发人员开发自己的 OAuth2 实现，而不使用 Spring 框架提供的 OAuth2 框架支持。因此，我将就这个主题撰写一系列文章。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</guid>
      <description>&lt;p&gt;原文地址：https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]OAuth2 with Spring 第4部分：Spring授权客户端与Google授权服务器的社交登录演示</title>
      <link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</link>
      <pubDate>Wed, 05 Jun 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</guid>
      <description>&lt;p&gt;原文地址：https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</title>
      <link>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;https://ably.com/topic/websockets-kafka&#34; target=&#34;_blank&#34;&gt;https://ably.com/topic/websockets-kafka&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Circuit Breaker</title>
      <link>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/26/java-design-patterns-circuit-breaker/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/circuit-breaker/&#34; target=&#34;_blank&#34;&gt;Circuit Breaker&lt;/a&gt; 断路器模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;断路器模式（Circuit Breaker Pattern）是一种在分布式系统中处理故障和提高系统可靠性的设计模式。它的主要目标是防止故障的传递，并在故障发生时提供优雅的故障处理机制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Chain</title>
      <link>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</link>
      <pubDate>Mon, 16 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/16/java-design-patterns-chain/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/chain/&#34; target=&#34;_blank&#34;&gt;Chain&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;目的&#34;&gt;目的&lt;/h2&gt;
&lt;p&gt;通过给多个对象一个处理请求的机会，避免请求的发送者和它的接收者耦合。串联接收对象并在链条中传递请求直到一个对象处理它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Callback</title>
      <link>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</link>
      <pubDate>Fri, 13 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/13/java-design-patterns-callback/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/callback/&#34; target=&#34;_blank&#34;&gt;Callback&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;回调（Callback）是一种设计模式，在这种模式中，一个可执行的代码被作为参数传递给其他代码，接收方的代码可以在适当的时候调用它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Caching</title>
      <link>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/25/java-design-patterns-cahcing/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/caching/&#34; target=&#34;_blank&#34;&gt;Caching&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;缓存模式（Caching Pattern）是一种设计模式，旨在通过在资源使用后将其保留在某个快速访问的存储中，并在需要时重新使用资源，以避免昂贵的资源重新获取。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Bytecode</title>
      <link>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</link>
      <pubDate>Fri, 22 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/22/java-design-patterns-bytecode/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/bytecode/&#34; target=&#34;_blank&#34;&gt;Bytecode&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;字节码设计模式是一种软件设计模式，它允许以数据驱动的方式定义和执行行为。在字节码设计模式中，行为被表示为一系列虚拟机指令，这些指令被编码为字节码，并在运行时执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Builder</title>
      <link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</link>
      <pubDate>Tue, 05 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-builder/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/builder/&#34; target=&#34;_blank&#34;&gt;Builder&lt;/a&gt; 构造器模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;构造器模式（Builder Pattern）是一种创建型设计模式，用于将复杂对象的构建过程与其表示分离，从而可以使用相同的构建过程创建不同的表示。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Business Delegate</title>
      <link>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</link>
      <pubDate>Tue, 05 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/05/java-design-patterns-business-delegate/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/business-delegate/&#34; target=&#34;_blank&#34;&gt;Business Delegate&lt;/a&gt; 业务委托模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;业务委托模式（Business Delegate Pattern）在表示层和业务层之间引入了一个抽象层，旨在实现这两个层之间的松散耦合，并封装了有关如何定位、连接和交互业务对象的逻辑。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Bridge</title>
      <link>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</link>
      <pubDate>Mon, 28 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/28/java-design-patterns-bridge/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/bridge/&#34; target=&#34;_blank&#34;&gt;Bridge&lt;/a&gt; 桥接模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;桥接模式（Bridge Pattern）是一种结构型设计模式，用于将抽象与其实现分离，使它们可以独立地变化。桥接模式通过创建两个独立的层次结构，一个是抽象部分，一个是实现部分，来实现这种分离。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Balking</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/</guid>
      <description>&lt;p&gt;本文主要介绍 &lt;a href=&#34;https://java-design-patterns.com/zh/patterns/balking/&#34; target=&#34;_blank&#34;&gt;Balking&lt;/a&gt; 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;止步模式（Balking）是一种在对象处于特定状态时才执行操作的设计模式。它用于防止对象在不完整或不合适的状态下执行某些代码，从而确保代码的正确性和一致性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记17：减少可变性</title>
      <link>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</link>
      <pubDate>Mon, 14 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/14/minimize-mutability/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第四章《类和接口》的学习笔记：减少可变性。&lt;/p&gt;
&lt;h2 id=&#34;原文&#34;&gt;原文&lt;/h2&gt;
&lt;p&gt;不可变类是实例不能被修改的类。每个实例中包含的所有信息在对象的生命周期内都是固定的，因此永远不会观察到任何更改。Java 库包含许多不可变的类，包括 String、基本类型的包装类、BigInteger 和 BigDecimal。这么做有很好的理由：不可变类比可变类更容易设计、实现和使用。它们不太容易出错，而且更安全。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Async Method Invocation</title>
      <link>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</link>
      <pubDate>Mon, 14 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/14/java-design-patterns-async-method-invocation/</guid>
      <description>&lt;p&gt;本文主要介绍 Async Method Invocation 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Async Method Invocation（异步方法调用）是一种编程模式，用于处理异步操作和并发执行。它允许在执行某个操作时不阻塞主线程，而是将操作委托给另一个线程或处理程序，并在操作完成后获取结果或执行回调。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：API Gateway </title>
      <link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</link>
      <pubDate>Sun, 13 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-api-gateway/</guid>
      <description>&lt;p&gt;本文主要介绍 API Gateway 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;目的&#34;&gt;目的&lt;/h2&gt;
&lt;p&gt;API 网关设计模式旨在将所有对微服务的调用聚合到一起。客户端通过调用 API 网关来实现对多个微服务的访问，而不是直接调用每个微服务。这种模式的目的是解决以下问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Arrange/Act/Assert</title>
      <link>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</link>
      <pubDate>Sun, 13 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/13/java-design-patterns-arrange-act-assert/</guid>
      <description>&lt;p&gt;本文主要介绍 Arrange/Act/Assert 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Arrange/Act/Assert（安排/执行/断言）又称 Given/When/Then，是一种测试设计模式，用于组织和编写单元测试的结构。它提供了一种清晰的测试布局，使得测试代码易于理解和维护。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Ambassador</title>
      <link>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</link>
      <pubDate>Thu, 06 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</guid>
      <description>&lt;p&gt;本文主要介绍 Ambassador 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译]微服务设计模式</title>
      <link>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</link>
      <pubDate>Mon, 26 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</guid>
      <description>&lt;p&gt;基于微服务的应用程序的主要特征在 &lt;a href=&#34;http://web.archive.org/web/20190705163602/http://blog.arungupta.me/microservices-monoliths-noops/&#34; target=&#34;_blank&#34;&gt;微服务、单体和 NoOps&lt;/a&gt; 中定义。它们是功能分解或领域驱动设计、定义良好的接口、明确发布的接口、单一责任原则和潜在的多语言。每项服务都是完全自主和全栈的。&lt;/p&gt;
&lt;p&gt;因此，更改服务实现不会影响其他服务，因为它们使用定义良好的接口进行通信。这种应用程序有几个优点，但它不是 &lt;a href=&#34;http://web.archive.org/web/20190705163602/http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html&#34; target=&#34;_blank&#34;&gt;免费的午餐&lt;/a&gt;，需要在 NoOps 方面付出大量努力。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Aggregator Microservices</title>
      <link>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</link>
      <pubDate>Mon, 26 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/26/java-design-patterns-aggregator-microservices/</guid>
      <description>&lt;p&gt;本文主要介绍 Aggregator Microservices 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记15：尽量减少类和成员的可访问性</title>
      <link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link>
      <pubDate>Thu, 15 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第四章《类和接口》的学习笔记：尽量减少类和成员的可访问性。&lt;/p&gt;
&lt;p&gt;类和接口是 Java 编程语言的核心。它们是抽象的基本单位。该语言提供了许多强大的元素，你可以使用它们来设计类和接口。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;《Effective Java, Third Edition》这本书中的第四章主要讲述了如何尽量减少类和成员的可访问性，以提高代码的封装性、安全性和可维护性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记16：在公共类中，使用访问器方法，而不是公共字段</title>
      <link>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</link>
      <pubDate>Thu, 15 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/15/minimize-the-accessibility-of-classes-and-members/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第四章《类和接口》的学习笔记：在公共类中，使用访问器方法，而不是公共字段。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;与其直接将类的内部字段公开为公共字段，推荐使用访问器方法（也称为 getter 和 setter）来访问和修改对象的状态。这样可以使类对其内部表示保持控制，并为类的客户端提供一种抽象程度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Adapter</title>
      <link>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</link>
      <pubDate>Sat, 10 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/10/java-design-patterns-adapter/</guid>
      <description>&lt;p&gt;本文主要介绍 Adapter 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Visitor</title>
      <link>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</link>
      <pubDate>Fri, 02 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/02/java-design-patterns-visitor/</guid>
      <description>&lt;p&gt;本文主要介绍 Visitor 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Acyclic Visitor</title>
      <link>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</link>
      <pubDate>Thu, 01 Jun 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/06/01/java-design-patterns-acyclic-visitor/</guid>
      <description>&lt;p&gt;本文主要介绍 Acyclic Visitor 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记12：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/always-override-tostring/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：始终覆盖 toString 方法。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;虽然 Object 提供 toString 方法的实现，但它返回的字符串通常不是类的用户希望看到的。它由后跟「at」符号（@）的类名和 hash 代码的无符号十六进制表示（例如 &lt;code&gt;PhoneNumber@163b91&lt;/code&gt;）组成。toString 的通用约定是这么描述的，返回的字符串应该是「简洁但信息丰富的表示，易于阅读」。虽然有人认为 &lt;code&gt;PhoneNumber@163b91&lt;/code&gt; 简洁易懂，但与 &lt;code&gt;707-867-5309&lt;/code&gt; 相比，它的信息量并不大。toString 约定接着描述，「建议所有子类覆盖此方法。」好建议，确实！&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记13：明智地覆盖 clone 方法</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/override-clone-judiciously/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：明智地覆盖 clone 方法。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Cloneable 接口的目的是作为 mixin 接口，用于让类来宣称它们允许克隆。不幸的是，它没有达到这个目的。它的主要缺点是缺少 clone 方法，并且 Object 类的 clone 方法是受保护的。如果不求助于反射，就不能仅仅因为对象实现了 Cloneable 接口就能调用 clone 方法。即使反射调用也可能失败，因为不能保证对象具有可访问的 clone 方法。尽管存在多种缺陷，但该机制的使用范围相当广泛，因此理解它是值得的。本条目将告诉你如何实现行为良好的 clone 方法，讨论什么时候应该这样做，并提供替代方案。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记14：考虑实现 Comparable 接口</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/consider-implementing-comparable/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：考虑实现 Comparable 接口。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;与本章讨论的其他方法不同，compareTo 方法不是在 Object 中声明的。相反，它是 Comparable 接口中的唯一方法。它在性质上类似于 Object 的 equals 方法，除了简单的相等比较之外，它还允许顺序比较，而且它是通用的。一个类实现 Comparable，表明实例具有自然顺序。对实现 Comparable 的对象数组进行排序非常简单：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Active Object</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</guid>
      <description>&lt;p&gt;本文主要介绍 Active Object 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法</title>
      <link>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</link>
      <pubDate>Tue, 23 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/23/always-override-hashcode-when-you-override-equals/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：当覆盖 equals 方法时，总要覆盖 hashCode 方法。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在覆盖了 equals 方法的类中，必须覆盖 hashCode 方法。&lt;/strong&gt; 如果你没有这样做，该类将违反 hashCode 方法的一般约定，这将阻止该类在 HashMap 和 HashSet 等集合中正常运行。以下是根据 Object 规范修改的约定：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Abstract Document</title>
      <link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</link>
      <pubDate>Mon, 22 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</guid>
      <description>&lt;p&gt;本文主要介绍 Abstract Document 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java设计模式：Abstract Factory</title>
      <link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</link>
      <pubDate>Mon, 22 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</guid>
      <description>&lt;p&gt;本文主要介绍 Abstract Factory 模式，在 &lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://java-design-patterns.com/&#34; target=&#34;_blank&#34;&gt;Java Design Patterns&lt;/a&gt; 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JSR 166规范</title>
      <link>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</link>
      <pubDate>Thu, 18 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</guid>
      <description>&lt;h2 id=&#34;jsr-介绍&#34;&gt;JSR 介绍&lt;/h2&gt;
&lt;p&gt;JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 &lt;a href=&#34;http://jcp.org/en/jsr/detail?id=335&#34; target=&#34;_blank&#34;&gt;JSR 335&lt;/a&gt;，新的日期和时间 API 对应的是 &lt;a href=&#34;http://jcp.org/en/jsr/detail?id=310&#34; target=&#34;_blank&#34;&gt;JSR 310&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定</title>
      <link>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</link>
      <pubDate>Wed, 17 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：覆盖 equals 方法时应遵守的约定。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;覆盖 equals 方法似乎很简单，但是有很多覆盖的方式会导致出错，而且后果可能非常严重。避免问题的最简单方法是不覆盖 equals 方法，在这种情况下，类的每个实例都只等于它自己。如果符合下列任何条件，就是正确的做法：&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记8：避免使用终结器和清除器</title>
      <link>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</link>
      <pubDate>Mon, 08 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/08/avoid-finalizers-and-cleaners/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：避免使用终结器和清除器。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;终结器是不可预测的、常常是危险的，通常也是不必要的。&lt;/strong&gt; 它们的使用可能导致不稳定的行为、低效率和可移植性问题。终结器有一些有效的用途，我们稍后会介绍，但通常情况下应该避免使用它们。从 Java 9 开始，终结器已经被弃用，但它们仍然被 Java 库使用。Java 9 中终结器的替代品是清除器。 &lt;strong&gt;清除器的危险比终结器小，但仍然不可预测、缓慢，而且通常是不必要的。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记9：使用 try-with-resources 优于 try-finally</title>
      <link>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</link>
      <pubDate>Mon, 08 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/08/prefer-try-with-resources-to-try-finally/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：使用 try-with-resources 优于 try-finally。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Java 库包含许多必须通过调用 close 方法手动关闭的资源。常见的有 InputStream、OutputStream 和 java.sql.Connection。关闭资源常常会被客户端忽略，这会导致可怕的性能后果。虽然这些资源中的许多都使用终结器作为安全网，但终结器并不能很好地工作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记4：用私有构造函数使类不可实例化</title>
      <link>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</link>
      <pubDate>Fri, 05 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：用私有构造函数使类不可实例化。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;使用私有构造函数强制实现不可实例化的主要原因是防止类被意外地实例化，以使代码更加健壮和可靠。在某些情况下，我们只需要使用类中的静态方法和静态字段，而不需要创建该类的实例。如果类中没有显式地定义私有构造函数，Java 编译器将会自动为该类生成一个默认的公共构造函数，这意味着该类可以在其他类中被实例化。如果这不是我们想要的，为了防止其他人意外地实例化我们的类，我们可以将构造函数设置为私有。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记7：排除过时的对象引用</title>
      <link>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</link>
      <pubDate>Fri, 05 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/05/eliminate-obsolete-object-references/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Eliminate obsolete object references&amp;rdquo; 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记6：避免创建不必要的对象</title>
      <link>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</link>
      <pubDate>Mon, 24 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/24/avoid-creating-unnecessary-objects/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记：避免创建不必要的对象。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;创建对象时，经常会复用对象。如果对象是不可变的，那么它总是可以被复用的。&lt;/p&gt;
&lt;p&gt;下面一个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;bikini&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// DON&amp;#39;T DO THIS!&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;该语句每次执行时都会创建一个新的 String 实例，而这些对象创建都不是必需的。String 构造函数的参数 &lt;code&gt;(&amp;quot;bikini&amp;quot;)&lt;/code&gt; 本身就是一个 String 实例，在功能上与构造函数创建的所有对象相同。如果这种用法发生在循环或频繁调用的方法中，创建大量 String 实例是不必要的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记5：依赖注入优于硬编码资源</title>
      <link>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</link>
      <pubDate>Mon, 17 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;依赖注入是软件工程中使用的一种设计模式，用于将组件和依赖项相互解耦。而不是在组件内部创建和管理依赖项，我们从外部传递它们。这种方法可以帮助创建更模块化和灵活的代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记3：使用私有构造函数或枚举类型创建单例</title>
      <link>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</link>
      <pubDate>Tue, 11 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;单例是一个只实例化一次的类。单例通常表示无状态对象，比如函数或系统组件，它们在本质上是唯一的。&lt;strong&gt;将一个类设计为单例会使它的客户端测试时变得困难，&lt;/strong&gt; 除非它实现了作为其类型的接口，否则无法用模拟实现来代替单例。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记1：静态工厂方法代替构造函数</title>
      <link>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/03/static-factory-methods-instead-of-constructors/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;静态工厂方法是指在类中定义一个静态方法，用于创建该类的实例。示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;valueOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;FALSE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;与构造函数不同的是，静态工厂方法可以有自己的名称，并且可以根据参数的不同返回不同的对象实例。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记2：使用构造器代替构造方法</title>
      <link>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/03/builder-instead-of-constructors/</guid>
      <description>&lt;p&gt;本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;当一个类需要多个构造函数参数时，可以考虑使用&lt;strong&gt;构建器模式&lt;/strong&gt;来创建对象。构建器模式是一种创建对象的设计模式，它可以通过链式调用方法的方式来设置对象的构造参数，并最终返回一个构造完整的对象。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
