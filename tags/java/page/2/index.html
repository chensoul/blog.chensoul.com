<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | ChenSoul</title>
<meta name=keywords content><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/tags/java/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/tags/java/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/tags/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Java"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/tags/java/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Java
<a href=/tags/java/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]如何组织代码</h2></header><div class=entry-content><p>原文链接：How to Structure Code
软件设计最佳实践，逐层发现包、按功能发现包以及六角形架构/端口和适配器。
在这篇博文中，我将探讨如何构建我们的代码并讨论最佳实践，涵盖三种不同的方法：按层打包、按功能打包以及六边形架构/端口和适配器及其优缺点。
在探索构建代码的不同方法之前，我们需要了解基本的软件设计原则：
内聚力：指模块内各类之间的相互关联程度。 耦合度：指不同模块之间的依赖程度。 模块化：指软件系统被划分为独立模块的程度。每个模块都封装了一组特定的功能，并设计为独立工作，同时通过明确定义的接口相互交互。 抽象：隐藏实现细节并仅通过接口公开必要的功能。 关注点分离：设有不同的部分，每个部分解决一个特定的关注点。 封装：将数据和方法捆绑到单个模块或类中以隐藏内部细节。 让我们仔细看看内聚力和耦合力？
内聚力描述了软件的集中程度。它与单一责任原则密切相关。
高内聚力意味着模块内的类紧密相关并具有共同的、明确定义的目的。 低内聚力意味着模块内的类之间关系松散，缺乏明确的目的且职责不相关。 要遵循的最佳实践是实现模块之间的高内聚和松散耦合。
松耦合被认为是结构良好和设计良好的计算机系统的标志，与高内聚力相结合，可带来较高的可读性和可维护性。
现在，让我们探索构建代码的不同方式。首先，我将逐层介绍包，然后逐功能介绍包，并比较两者。之后，我们将探索端口和适配器模式。
层封装 它代表一个项目结构，其中类被组织成多个层，每个层负责一组特定的功能。
src ├── main │ ├── java │ │ └── com │ │ └── app │ │ ├── service │ │ │ └── UserService.java │ │ │ └── OrderService.java │ │ │ └── ProductService.java │ │ ├── domain │ │ │ └── User.java │ │ │ └── Order.java │ │ │ └── Product.java │ │ ├── repository │ │ │ └── UserRepository.java │ │ │ └── OrderRepository.java │ │ │ └── ProductRepository.java │ │ ├── controller │ │ │ └── UserController....</p></div><footer class=entry-footer><span title='2024-05-30 08:00:00 +0800 +0800'>2024-05-30</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;256 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何组织代码" href=https://blog.chensoul.cc/posts/2024/05/30/how-to-structure-our-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>All things about WebSocket</h2></header><div class=entry-content><p>Wikipedia：WebSocket
WebSocket - Web APIs | MDN
PubNub：什么是 WebSocket？
What are WebSockets?
websocket protocol - RFC6455 - tools.ietf.org
WebSocket
Ably：What are WebSockets used for? Pusher：What are WebSockets?
WebSocket vs. HTTP communication protocols
What are WebSockets? | Web Security Academy
Educative：What is WebSocket?
Spring：WebSocket
Writing a WebSocket server in Java - Web APIs
Baeldung：A Guide to the Java API for WebSocket
Baeldung：A Java Client for a WebSockets API
WebSocket Implementation with Spring Boot and STOMP
ApiFox：WebSocket协议入门到精通
JSR 356, Java API for WebSocket
WebSocket 协议解析 [RFC 6455]
WebSocket原理及技术简介
【NO.23】一篇文章彻底搞懂websocket协议的原理与应用（一）
WebSocket 协议详解
WebSocket 协议（RFC 6455 中文版）
用JAVA分别实现WebSocket客户端与服务端
WebSocket Programming with Java
MQTT Websocket Client</p></div><footer class=entry-footer><span title='2024-05-10 16:00:00 +0800 +0800'>2024-05-10</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;101 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to All things about WebSocket" href=https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>All things about Spring Modulith</h2></header><div class=entry-content><p>VMware 推出了一个实验性的项目Spring Modulith，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。
2022 年 11 月推出的Spring Boot 3会是 Spring Modulith 的基础。所以它的基线是 Spring Framework 6、Java 17 和 Jakarta EE 9。Spring Modulith 是Moduliths（其名字有个“s”后缀）项目的继承者。该项目使用 Spring Boot 2.7，目前已经退役，只接收缺陷修正，直至 2023 年 11 月份。
https://spring.io/blog/2022/10/21/introducing-spring-modulith
https://www.baeldung.com/spring-modulith
https://www.baeldung.com/spring-modulith-event-externalization
https://piotrminkowski.com/2023/10/13/guide-to-modulith-with-spring-boot/
https://springdoc.cn/guide-to-modulith-with-spring-boot/
https://medium.com/andamp/event-sourcing-with-spring-modulith-2b35b0569dbb
https://www.geeksforgeeks.org/what-is-spring-modulith/
https://github.com/xsreality/spring-modulith-with-ddd
https://riteshshergill.medium.com/the-spring-modulith-monolithic-but-manageable-ca1532a1e585
https://www.infoq.com/news/2022/11/spring-modulith-launch/
https://dzone.com/articles/architecture-style-modulith-vs-microservices
https://speakerdeck.com/olivergierke/spring-modulith-a-deep-dive
https://www.jappware.com/proffesional-activity/make-monolithic-apps-great-again-with-spring-modulith-coffeejug/
https://blog.worldline.tech/2024/01/23/modulith.html
https://springdoc.cn/spring-modulith-intro/
https://dimitri.codes/checking-out-spring-modulith/
https://www.lefer.cn/posts/29752/
https://www.jdon.com/63003.html
https://blog.csdn.net/cfy_banq/article/details/132185951
https://www.zhihu.com/question/567053421</p></div><footer class=entry-footer><span title='2024-05-09 08:00:00 +0800 +0800'>2024-05-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;67 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to All things about Spring Modulith" href=https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</h2></header><div class=entry-content><p>原文链接：https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249
来源：https://www.thewebmaster.com/
先决条件：了解 javascript、客户端-服务器架构。
完整的代码可以在github上找到。
第 1 部分：概述（http2 的原因、内容、时间、方式）第 2 部分：使用 node-http2 核心和 hapijs 进行探索
免责声明：本文将使用node@v9+附带的http2模块。这里列出了其他几个 http2 客户端-服务器库实现。
让我们开始创建一个具有单一路由的简单 http1.1 服务器。
mkdir hapijs-http2 && \ cd hapijs-http2 && \ npm init -y && \ npm i hapi@^16.6 -s && \ touch http1Server.js 将下面的代码复制到此处或从此处http1Server.js克隆整个存储库。
const Hapi = require('hapi'); const server = new Hapi.Server(); // define server config server.connection({ port: '8000' }); // define route config server.route([{ method: 'GET', path: '/ping', handler: (request, reply) => { reply('pong'); } }]); // start server server.start(err => { if (err) console.error(err) console.log(`Started ${server.connections.length} connections`) }); 现在，让我们进行健全性检查。
启动服务器，node http1Server.js
⇒ http://127.0.0.1:8000/ping pong 凉爽的！如果我们得到 pong 的 ping，让我们尝试将http2集成到我们的 hapijs 服务器中。...</p></div><footer class=entry-footer><span title='2024-05-08 11:34:00 +0800 +0800'>2024-05-08</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;324 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs" href=https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]探索 http2（第 1 部分）：概述</h2></header><div class=entry-content><p>原文链接：https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f
让我们来谈谈 http2 的内容、原因、时间和方式
完整的代码可以在github上找到。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
什么是http2？ **http2*是自 1999 年以来使用的http1.1***之后的最新更新
http2协议注重性能；具体来说，最终用户感知的延迟、网络和服务器资源的使用情况。 （在此处阅读有关规格的信息*）*
为什么是http2？ 换句话说http1.1有什么问题
加载网页是一项资源密集型工作，因为 HTTP/1.1 只允许每个 TCP 连接有一个未完成的请求。网络需要进行更新，以提高效率、安全性和速度。
http2如何解决性能问题？
http2 带来的改进：
**单一连接：**仅使用一个与服务器的连接来加载网站，并且只要网站打开，该连接就保持打开状态。这减少了建立多个 TCP 连接所需的往返次数。（更多信息在这里） **多路复用：**同一连接上同时允许多个请求。以前，在 HTTP/1.1 中，每个传输都必须等待其他传输完成。（更多信息在这里） **服务器推送：**可以将其他资源发送到客户端以供将来使用。（更多信息在这里） **优先级：**请求被分配依赖级别，服务器可以使用它来更快地交付更高优先级的资源。（更多信息在这里） **二进制：**使 HTTP/2 更易于服务器解析、更紧凑且不易出错。将信息从文本转换为二进制不会浪费额外的时间。（更多信息在这里） 标头压缩： HTTP/2 使用HPACK压缩，从而减少开销。在 HTTP/1.1 中，每个请求中的许多标头都使用相同的值发送。（更多信息在这里） 我们什么时候可以开始使用http2？ 现在！
这是时间线，
来源：https://www.polyglotdeveloper.com/
是的，从 1999 年到今天，我们（大多数）都在使用同样好的旧 http1.1； 15年！
如何开始使用http2？ 以下是各种语言的 http2 库实现列表。
根据Can I Use的统计，大约 83% 的在线浏览器已经支持 http2
查看实际情况，http1.1 与 http2（网络节流：快速 3g）
http1.1（左）与http2（右）；让我们在下一节中构建它
在下一部分中，我们将构建一个支持 http2 的简单服务器；具有http1.1向后兼容性；一步一步使用http2-node core 和hapi js。
第 1 部分：概述 第 2 部分：使用 node-http2 核心和 hapijs 进行探索
完整的代码可以在github上找到。</p></div><footer class=entry-footer><span title='2024-05-08 11:30:00 +0800 +0800'>2024-05-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;88 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]探索 http2（第 1 部分）：概述" href=https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]比较 Socket.IO 和 HTTP：主要区别和用例</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/socketio-vs-http
在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对Socket.IO实时库和HTTP协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。
什么是Socket.IO？ Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。
Socket.IO 需要两个库 - 一个在服务器上，一个在客户端上。 Socket.IO 创建者维护以下“官方”：
Socket.IO是 Node.js 服务器组件。 Socket.IO-client是客户端 JavaScript 库。 一些 Socket.IO 客户端和服务器实现可以用其他语言实现。请阅读Socket.IO 是什么来获取列表。
下图总结了典型的 Socket.IO 设置：
Socket.IO 主要特性 Socket.IO 具有以下主要特性：
**向后兼容性：**在现代浏览器中，Socket.IO 使用WebSocket API提供所需的连接并发送消息。 WebSocket 在服务器和浏览器之间提供全双工、低延迟、事件驱动的连接。它也是有状态的。如果需要旧版浏览器支持，或者 WebSocket 连接无法使用（由于防火墙或公司代理），Socket.IO 可以回退到 HTTP 和长轮询。 重连和缓冲： Socket.IO提供自动重连功能。当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送。 多种数据格式： Socket.IO 支持任何可序列化格式的数据传输，包括Buffer或TypedArray等二进制对象。 **致谢：**使用 Socket.IO，一旦成功接收到消息就可以发送响应消息。 命名空间： Socket.IO 使您能够设置具有不同客户端、房间、事件和应用程序逻辑的不同通道。 **广播到不同的客户端组：**从服务器，您可以向所有连接的客户端或子集发送消息。 Socket.IO 的优缺点 Socket.IO 专业人士 连接效率： Socket.IO 使用 HTTP 长轮询发起连接，一旦建立可用性就升级到 WebSocket（有关更多详细信息，请参阅升级机制）。当发生这种情况时，客户端-服务器连接使用单个 WebSocket，而不必启动多个连接，从而减少延迟并改善用户体验。 **客户端和服务器发起的通信：**由于WebSocket提供了全双工、双向的通信通道，因此服务器可以向客户端发送消息，并且两者可以同时发送消息。 事件驱动的通信： WebSocket是一种事件驱动的协议，这意味着您可以在收到消息后立即监听并响应消息，而不是使用轮询机制来检查更新，这样既浪费又低效。 丰富的功能集： Socket.IO 提供了实现实时应用程序所需的一切。当使用原始 HTTP 甚至原始 WebSocket 时，您必须自己实现其中大部分功能。 有状态： Socket.IO 使用 WebSocket，它是有状态的。该状态一直持续到连接关闭为止。 Socket.IO 缺点 **有限的平台支持：**我们之前提到，Socket.IO 在不同的平台和语言上有多种服务器和客户端实现。值得一提的是，其中一些没有得到积极维护，或者功能集有限，因此在考虑使用它们之前请仔细检查它们。此外，Socket.IO 实现与本机 WebSocket 不兼容，因为 Socket.IO 会向其发送的每个数据包添加额外的元数据。 可扩展性： Socket.IO 非常适合有限数量用户的实时通信应用程序。但是，如果您的用户数量和数据量开始变大，您的服务器可能会过载。当您的服务器达到最大负载时，您将需要将连接拆分到多个服务器上，否则可能会丢失重要信息。这种增加的架构复杂性带来了更多问题。阅读Scaling Socket.IO - 实际注意事项以获取更多信息。 **内存泄漏：**已知 Socket.IO 存在一些与内存泄漏相关的问题。内存泄漏不太可能导致任何直接问题，但如果您的应用程序使用了很长一段时间，它们最终可能会导致用户的设备冻结或崩溃。 什么是 HTTP？ HTTP 是一种请求/响应协议，作为 Web 的主要通信机制，构建在 TCP 网络协议之上。有限版本最初由 Tim Berners-Lee 于 1989 年提出，随后经过快速修改以支持更广泛的浏览器和服务器功能。 HTTP 工作组于 1996 年将这些修改记录为 HTTP/1....</p></div><footer class=entry-footer><span title='2024-05-08 11:00:00 +0800 +0800'>2024-05-08</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;326 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]比较 Socket.IO 和 HTTP：主要区别和用例" href=https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]2024年最好的WebSocket替代品</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/websocket-alternatives
什么是 WebSocket？ 简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。
了解更多：
什么是 WebSocket？ WebSocket 是如何工作的？ 什么时候应该考虑使用 WebSocket 替代方案？ 对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括聊天应用程序、多人协作体验以及广播实时路况更新。
了解有关 WebSocket 用例的更多信息
然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。
我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。
了解 WebSocket 的优点和缺点
WebSocket 协议的五种替代方案 现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。
服务器发送的事件 服务器发送事件 (SSE)是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。
服务器发送事件的优点
内置对重新连接的支持。 所有现代浏览器都支持。 轻量级协议。 服务器发送事件的缺点
它是单向的；只有服务器可以将数据推送到客户端。 每个浏览器在同一时间只能有六个并发 SSE 连接。 仅支持UTF-8文本数据； SSE 无法处理二进制数据。 对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。
查看 SSE 与 WebSocket 的比较
长轮询 长轮询是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。
长轮询的优点
长轮询是在XMLHttpRequest的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。 在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。 长轮询的缺点
与 WebSocket 相比，长轮询在服务器上消耗更多资源。 长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。 可靠的消息排序可能是一个问题。 长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。
查看轮询与 WebSocket 相比需要多长时间...</p></div><footer class=entry-footer><span title='2024-05-07 11:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;436 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]2024年最好的WebSocket替代品" href=https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]HTTP 的演变 – HTTP2 深入探讨</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/http2
可以毫不夸张地说，超文本传输协议 (HTTP) 造就了我们所熟知的互联网。 HTTP 最初是由万维网的发明者蒂姆·伯纳斯·李 (Tim Berners-Lee) 于 1989 年提出的应用程序协议。第一个记录版本 HTTP/0.9 被称为单行协议。鉴于它催生了万维网，它现在可以被描述为有史以来最伟大的俏皮话。
随着我们对互联网的需求不断增长，HTTP 作为网络协议也必须不断发展才能提供可接受的性能。 HTTP/2 标志着一次重大改革，是自 1997 年 HTTP/1.1 ( RFC 2068 ) 提供以来第一个新的标准化。本文介绍了 HTTP/2 如何设计来克服 HTTP/1.1 的限制、新协议的实现、HTTP/2 的工作原理以及其自身的限制。
通过单个 TCP 连接的 HTTP/2 客户端-服务器。
出身卑微——HTTP 简史 HTTP/0.9 的“单行协议”由请求组成：方法GET后跟文档地址、可选端口地址，并以回车符和换行符结束。由一串 ASCII 字符组成的请求。只能传输 HTML 文件。没有 HTTP 标头、状态代码或错误代码。
进化的第一阶段必须很快到来。
HTTP/1.0 – 突破限制 为了克服 HTTP/0.9 的严重限制，浏览器和服务器独立修改了协议。一些关键的协议更改：
请求允许包含多个由换行符分隔的标头字段。 服务器发送了包含单个状态行的响应。 响应中添加了一个标头字段。响应标头对象由由换行符分隔的标头字段组成。 服务器可以使用 HTML 以外的文件进行响应。 这些修改没有以有序或商定的方式完成，导致 HTTP/0.9 的不同风格，进而导致互操作性问题。为了解决这些问题，HTTP 工作组成立，并于 1996 年发布了 HTTP/1.0（RFC 1945）。它是一个信息性 RFC，仅记录当时的所有用法。因此，HTTP/1.0 不被视为正式规范或互联网标准。
HTTP/1.0 请求/响应的代码示例 来自客户端的使用 GET 方法的请求
GET /contact HTTP/1.0 Host: www.ably.io User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0) Accept: text/*, text/html, text/html;level=1, */*Accept-Language: en-us 客户端通过 POST 方法发出请求
POST /contact HTTP/1.0 Host: www.ably.io User-Agent: Mozilla/4....</p></div><footer class=entry-footer><span title='2024-05-07 11:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1012 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]HTTP 的演变 – HTTP2 深入探讨" href=https://blog.chensoul.cc/posts/2024/05/07/http2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/websockets-vs-http
当谈到 WebSocket 与 HTTP 时，决定使用哪一种并不总是那么明确。哪一个更好？您的应用程序应该使用哪一款？
但问题的答案不一定是其中之一 - 开发人员经常根据场景在同一个应用程序中同时使用 WebSocket 和 HTTP。更重要的问题是 - 我如何确定 WebSockets 还是 HTTP 是特定类型通信的正确通信协议？
这是您需要了解的一切。
WebSocket 与 HTTP 概览 在此页面上，我们将探讨这些技术的工作原理、它们在实现实时通信方面的表现如何，并就在哪些场景中使用哪些技术提供具体指导。
如果您正在寻找高级比较，以下是主要差异一目了然：
请继续阅读以详细了解这两种流行协议的比较。
HTTP协议 什么是 HTTP？ 从根本上讲，HTTP 是一种通信协议，使客户端（例如 Web 浏览器）和服务器能够共享信息。
例如，HTML 文档、图像、应用程序数据 (JSON) 等。
很难想出比您现在正在阅读的此页面更好的 HTTP 实际示例。
当您加载此页面时，您的浏览器会发出 HTTP 请求，服务器会使用您当前正在阅读的 HTML 文档来响应该请求。
HTTP 是如何工作的？ HTTP 遵循请求-响应消息传递模式，其中客户端发出请求，Web 服务器发送响应，该响应不仅包括请求的内容，还包括有关请求的相关信息。
在底层，每个请求都会打开一个与服务器的短暂连接，然后关闭。
HTTP 示例
网页浏览。 下载图像、视频或二进制文件，例如桌面应用程序。 使用 JavaScript 中的 fetch 函数向 API 发出异步请求。 由于每个 HTTP 请求都包含处理它所需的所有信息，因此服务器无需跟踪连接和请求。
这种无状态设计是有利的，因为它使得可以部署额外的服务器来处理请求，而不需要在服务器之间同步状态逻辑。
此外，由于每个请求都是独立的，因此通过代理路由消息以执行缓存、加密和压缩等增值功能变得非常简单。
这种无状态方法的缺点是客户端打开一个临时连接并为每个请求发送元数据，从而产生少量开销。
当加载网页或下载文件时，这种开销可以忽略不计。但是，如果您发送负载较小的高频请求，它可能会对应用程序的性能产生显着影响。
通过 HTTP 进行实时更新 这种模式（客户端发出请求，服务器发出响应）非常适合网页、文件或应用程序数据等静态资源。
但是，请考虑这样一种情况：客户不知道新信息何时可用。
例如，假设您正在为 BBC 实施突发新闻功能。
在这种情况下，客户不知道故事的下一次更新何时会发生。
现在，您可以对客户端进行编码，以频繁地发出 HTTP 请求，以防万一发生某些情况，并且对于少数客户端来说，这可能工作得足够好。
但是假设您有成百上千个客户端（在 BBC 的情况下有数十万个）向服务器发送请求，而这些请求在更新之间没有产生任何新内容。
这不仅浪费带宽和服务器资源，而且在最近的请求完成后不久更新就会中断 - 可能需要几秒钟才能发送下一个请求并且用户获得更新。一般来说，这种方法称为HTTP 轮询，它既不高效也不实时！
相反，如果服务器能够在新信息可用时将数据推送到客户端，那就更好了，但这从根本上违背了请求-响应模式的原则。
或者确实如此？
HTTP 流式传输 尽管 HTTP 从根本上遵循请求-响应模式，但有一种解决方法可用于实现实时更新。
服务器不是发出完整的响应，而是发出部分 HTTP 响应并保持底层连接打开。
基于上一节的突发新闻示例，通过 HTTP 流，服务器可以在每次新闻更新中断时将部分响应（如果您愿意，可以是块）附加到响应流 - 连接无限期保持打开状态，使服务器能够推送当新信息可用时，以最短的延迟向客户端提供新信息。...</p></div><footer class=entry-footer><span title='2024-05-07 11:00:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;452 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]WebSocket与HTTP：2024年为您的项目选择哪一个" href=https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</h2></header><div class=entry-content><p>原文链接：https://ably.com/topic/websockets-kafka
Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。
由于 Kafka 如此受欢迎，我很好奇是否可以使用它通过互联网和 WebSockets 将实时数据直接流式传输给最终用户。毕竟，Kafka 具有一系列特征，似乎使其成为一个值得注意的选择，例如：
高通量 低延迟 高并发 容错能力 持久性（持久性） 用于将 Kafka 消息流式传输到面向互联网的客户端的现有解决方案 我开始研究实时开发社区对这个用例的看法。我很快发现 Kafka 最初设计用于安全网络内进行机器对机器通信。这让我想到，如果您想通过 WebSocket 将数据从 Kafka 流式传输到面向互联网的用户，您可能需要使用某种中间件。
我继续研究，希望找到一些可以充当中间件的开源解决方案。我发现了其中的几个，理论上可以用作 Kafka 和通过互联网连接数据流的客户端之间的中介：
transfers_websockets_service kafka-websocket kafka-proxy-ws 不幸的是，上面列出的所有解决方案都只是概念证明，仅此而已。它们的功能集有限，并且尚未做好生产准备（尤其是大规模生产）。
然后我研究了成熟的科技公司如何解决这个 Kafka 用例；看来他们确实在使用某种中间件。例如，Trello 开发了WebSocket 协议的简化版本，仅支持订阅和取消订阅命令。 Slack 提供了另一个例子。该公司构建了一个名为Flannel的代理，它本质上是部署到边缘存在点的应用程序级缓存服务。
当然，像 Trello 或 Slack 这样的公司有能力投资所需的资源来构建此类解决方案。然而，开发自己的中间件并不总是一个可行的选择——这是一项非常复杂的任务，需要大量的资源和时间。另一种选择（最方便、最常见的一种）是使用已建立的第三方解决方案。
正如我们所看到的，普遍的共识似乎是 Kafka 本身不适合通过互联网进行最后一英里交付；您需要将它与另一个组件结合使用：面向互联网的实时消息传递服务。
在 Ably，我们的许多客户都通过我们面向互联网的 pub/sub 实时消息服务传输 Kafka消息。为了演示它是多么简单，下面是如何从 Kafka 消费数据并将其发布到 Ably 的示例：
const kafka = require('kafka-node'); const Ably = require('ably'); const ably = new Ably.Realtime({{ABLY_API_KEY}}); const ablyChannel = ably.channels.get('kafka-example'); const Consumer = kafka.Consumer; const client = new kafka....</p></div><footer class=entry-footer><span title='2024-05-07 10:10:00 +0800 +0800'>2024-05-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;549 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端" href=https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/tags/java/>«&nbsp;Prev&nbsp;1/12
</a><a class=next href=https://blog.chensoul.cc/tags/java/page/3/>Next&nbsp;3/12&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>