<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | ChenSoul</title>
<meta name=keywords content><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/tags/java/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/tags/java/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/tags/java/><meta name=twitter:title content="Java | ChenSoul"><meta name=twitter:description content><meta property="og:title" content="Java | ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/tags/java/"><meta property="og:site_name" content="ChenSoul"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-tags kind-term layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories/review/ title=总结>总结</a></li><li><a href=https://blog.chensoul.cc/categories/ title=分类>分类</a></li><li><a href=https://blog.chensoul.cc/tags/ title=标签 class=active>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><header class=page-header><h1>tag: Java</h1><div class=inline-links><span><a href=https://blog.chensoul.cc/tags/java/index.xml target=_blank>RSS</a></span></div></header><article class="post-entry tag-entry"><header class=entry-header><h2>[译]Java和WebSockets：构建可靠的实时应用程序</h2></header><section class=entry-content><p>原文：https://ably.com/topic/websockets-java
在全球范围内，人们对实时传输数据的需求不断增长，WebSocket可能是此类用例中最流行的传输协议。在 WebSocket 出现之前，“实时”网络已经存在，但它很难实现，通常速度较慢，并且是通过破解现有的网络技术来实现的，而这些技术并不是为实时应用程序设计的。 WebSocket 协议为真正的实时网络铺平了道路。
Java是一种流行的编程语言和计算语言。它是 Android 智能手机应用程序的核心编程语言之一，是构建实时系统的可靠选择。 WebSockets 成为 Java 标准版 SDK 的一部分已经有一段时间了。WebSocket 协议最初是在 2013 年作为JSR 356的一部分提出的，目前已作为javax.websocket包的一部分包含在 Java SDK 中。
由于对实时数据的需求正在稳步增长，并且 Java 已成为一种成熟且广泛使用的语言/平台，因此我认为值得考虑为Java 客户端应用程序实现可靠的 WebSocket 解决方案所面临的众多挑战。
现状——简要概述 基本或原始的 WebSocket 实现很少能够满足为未知（但可能非常多）数量的用户提供服务的实时应用程序的需求。大多数时候，您需要考虑扩展 Java 客户端 WebSocket 实现的功能。
为此，您可以使用nv-websocket-client等开源库，其中包含一些附加功能，例如代理支持。这是使用 nv-websocket-client 创建 WebSocket 实例的方法：
// Create a WebSocket. The scheme part can be one of the following: // 'ws', 'wss', 'http' and 'https' (case-insensitive). The user info // part, if any, is interpreted as expected. If a raw socket failed // to be created, an IOException is thrown. WebSocket ws = new WebSocketFactory().createSocket("ws://localhost/endpoint"); 创建 WebSocket 实例后，下一步是注册侦听器以接收 WebSocket 事件：
// Register a listener to receive WebSocket events....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-07</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/websocket/>Websocket</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>3 min</span></span></footer><a class=entry-link aria-label="post link to [译]Java和WebSockets：构建可靠的实时应用程序" href=https://blog.chensoul.cc/posts/2024/05/07/websockets-java/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]WebSocket API和协议说明</h2></header><section class=entry-content><p>原文地址：https://ably.com/topic/websockets
WebSocket 标志着 Web 开发的转折点。 WebSocket 技术旨在以事件为驱动，并针对低延迟进行了优化，已成为许多寻求构建交互式实时数字体验以提供令人愉悦的用户体验的组织和开发人员的首选。本文探讨了与 WebSocket 相关的关键主题：
WebSocket 协议和 API 解释
WebSockets 是如何工作的？
WebSockets的优缺点是什么？
WebSockets 是否可扩展？
WebSocket 的用途是什么？
WebSockets 的最佳替代品是什么？
如何开始使用 WebSockets 构建实时体验
WebSocket 常见问题解答
WebSocket：协议和 API 解释 WebSocket 是一种实时技术，可通过持久的单套接字连接在客户端和服务器之间实现双向全双工通信。只要需要，WebSocket 连接就会保持活动状态（理论上，它可以永远持续下去），允许服务器和客户端随意发送数据，开销最小。
WebSocket 技术由两个核心构建块组成：
WebSocket 协议。 WebSocket API。 WebSocket的历史是什么？ 第一个实时 Web 应用程序开始出现在 2000 年代，试图提供响应迅速、动态和交互式的最终用户体验。然而，在那个时候，实时网络很难实现，而且比我们现在习惯的要慢;它是通过入侵现有的基于HTTP的技术（AJAX和Comet）来实现的，这些技术不是为实时应用程序设计和优化的。很明显，需要一个更好的替代方案。
在 2008 年，开发人员 Michael Carter 和 Ian Hickson 特别敏锐地感受到了在实现任何类似实时的东西时使用 AJAX 和 Comet 的痛苦和局限性。通过在 IRC 和 W3C 邮件列表上的合作，他们提出了一个计划，为网络上的现代、真正的实时通信引入一个新标准。因此，“WebSocket”这个名字被创造出来。
什么是 WebSocket 协议？ WebSocket 协议支持 Web 客户端和 Web 服务器之间通过基础 TCP 连接进行持续的全双工双向通信。该协议旨在允许客户端和服务器实时通信，从而在 Web 应用程序中实现高效且响应迅速的数据传输。
2011 年 12 月，互联网工程任务组 （IETF） 通过 RFC 6455 对 WebSocket 协议进行了标准化。互联网号码分配机构 （IANA） 与 IETF 协调维护 WebSocket 协议注册管理机构，该注册管理机构定义了协议使用的许多代码和参数标识符。
什么是 WebSocket API？ WebSocket API 包含在 HTML Living Standard 中，是一个编程接口，用于创建 WebSocket 连接并管理 Web 应用程序中客户端和服务器之间的数据交换。它为开发人员提供了一种简单且标准化的方法，可以在其应用程序中使用 WebSocket 协议。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-07</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/websocket/>Websocket</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to [译]WebSocket API和协议说明" href=https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[译]WebSocket与REST</h2></header><section class=entry-content><p>原文链接：https://ably.com/topic/websocket-vs-rest
无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。
好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。
在本文中，我们将阐明 REST 与 WebSocket，涵盖：
回顾一下 REST 和 WebSocket 是什么 他们的技术权衡，包括 WebSocket 与 REST 性能 何时应该使用 REST 以及何时 WebSocket 是更好的选择 如果您使用任一协议，则需要填补一些空白。 但如果您正在寻找快速摘要，那么您需要了解以下内容：
当您需要轻松扩展的基础架构来进行无状态 CRUD 操作并且您希望坚持使用标准 Web 工具时，REST 是理想的选择。例如，如果您正在构建一个 API 来将更新发布到社交网络 当您需要客户端和服务器之间进行实时、双向、低延迟通信时，WebSocket 是正确的选择。例如，如果您正在构建聊天应用程序。 什么是REST？ 表述性状态传输 (REST) 是一组原则，定义了通过 HTTP 构建 API 的一种方法。这很容易被忽视，但 REST 不是一种协议，这意味着您可以非常灵活地根据您的需求来塑造它。它的流行很大程度上是由于它的简单性以及它重用了已经用于网络的方法和技术。这在很大程度上定义了它表现良好的用例以及您需要寻找替代方案的用例。
让我们快速了解一下 REST 与其他方法的区别。
REST 的主要特征 **无状态：**对 REST API 发出的每个请求都是独立且自包含的。这使得扩展变得更加简单。当流量增加时，您可以在负载均衡器后面添加更多服务器，因为特定客户端不需要每次都连接到同一台服务器。尽管 HTTP 和 REST 是无状态的，但您可以通过使用客户端 cookie 来跟踪会话和登录状态来维护长时间运行的会话。 **CRUD：**每个 REST 请求都使用标准 HTTP 动词（GET、POST、PUT、PATCH 和 DELETE），与创建、读取、更新、删除操作对齐。 有效负载格式： REST 通常使用 JSON 或 XML 等标准化消息格式进行数据交换。但是您可以使用任何您喜欢的数据格式，只要您设置正确的Content-Type标头即可。 **可缓存：**您可以选择允许客户端和中间基础设施缓存响应。这有助于扩展和响应时间。 同步： REST 所依赖的 HTTP 请求-响应周期最适合短暂、简单的事务，其中客户端在继续下一个任务之前等待响应。 什么是 WebSocket？ REST 适用于短暂、无状态的通信，而 WebSocket 则提供持续、低延迟的双向通信通道。这意味着您与 WebSocket 交互的方式是不同的。因此，您无需使用特定端点构建“WebSocket API”，而是打开一个连接，双方可以在需要时交换消息。这使其成为实时应用程序的理想选择，例如聊天、体育或金融数据的实时流媒体，以及 Figma、Miro 和 Google Docs 等交互式实时协作环境。...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-07</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/websocket/>Websocket</a><a href=https://blog.chensoul.cc/tags/rest/>Rest</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to [译]WebSocket与REST" href=https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>ThingsBoard的领域模型</h2></header><section class=entry-content><p>ThingsBoard是一个开源的物联网平台，用于管理和监控物联网设备和数据。它提供了一个可扩展的架构，可以连接各种设备，并实时收集、处理和分析设备生成的数据。
领域模型 在ThingsBoard中，领域模型是一个关键概念，用于描述物联网系统中的物理实体、属性和行为。以下是ThingsBoard中的主要领域模型组件：
租户（Tenant）：租户是ThingsBoard中的顶级组织单位。它代表了一个独立的实体，可以是一个用户、组织或公司。租户拥有和管理自己的设备、客户、规则和仪表板等资源。租户之间的数据和配置是相互隔离的，每个租户都有自己的独立环境。租户由系统管理员创建和管理。
租户配置（TenantProfile）：用于定义租户级别的配置和属性。
客户（Customer）：客户是租户下的子级实体，代表了物联网系统中的用户或组织。一个租户可以包含多个客户，每个客户都有自己的访问权限和角色。客户可以访问和监控租户下的设备和数据。客户可以有自己的设备、规则和仪表板等资源，但这些资源受到租户级别的限制。客户由租户管理员创建和管理。
用户（User）：保存用户的基本信息
用户的角色（Authority）：SYS_ADMIN、TENANT_ADMIN、CUSTOMER_USER、REFRESH_TOKEN、PRE_VERIFICATION_TOKEN 用户凭证（UserCredentials）：保存用户的密码、激活用户 Token、重置密码 Token、密码使用历史 用户认证设置（UserAuthSettings）：保存用户 2FA 认证设置 用户设置（UserSettings）：保存用户的设置，包括：通用设置、通知、访问过的仪表盘等等 系统设置（AdminSettings）：是用于配置和管理整个系统的全局设置和参数，包括：通用设置、邮件、JWT、连接设置等等。
审计日志（AuditLog）
资产（Asset）：指在系统中表示和管理的物理或虚拟实体。资产可以是设备、传感器、设施、车辆、建筑物、人员或其他实体，其状态、属性和行为可以被监测、控制和管理。
资产配置（AssetProfile）：配置资产使用的默认规则链、队列、移动端仪表盘
设备（Device）：
遥测数据（TsKV）： 最新遥测数据： 属性（AttributeKvEntry）：属性类型分为客户端、服务端、共享 远程调用（Rpc） 设备凭证（DeviceCredentials）： OTA： 设备配置（DeviceProfile）：配置设备使用的默认规则链、队列、移动端仪表盘、边缘网关默认规则链、分配的固件、分配的软件、传输方式、告警规则、设置预配置
告警（Alarm）：包括字段：租户、客户、类型、明细、发起者、告警级别（严重、重要、次要、警告、不确定）、是否应答、是否清除、受理人、开始时间、结束时间、应答时间、清除时间、受理时间、是否传播、是否传播给所有者、是否传播给租户
告警评论（AlarmComment）：
实体告警（EntityAlarm）：
事件（Event）：分为异常事件、组件生命周期事件、规则链调试事件、规则节点事件、统计事件
通知（Notification）:
通知请求（NotificationRequest） 通知模版（NotificationTemplate）： 通知规则（NotificationRule） 通知对象（NotificationTarget） 流程 上报遥测数据 设备配置启用告警规则。温度大于 20 时，产生告警。温度小于 20 时，清除告警。
创建一个设备，设备凭证使用 AccessToken
使用 http api 发送遥测数据
curl -v -X POST http://localhost:8080/api/v1/gs76dj5m47yd3lm1wurd/telemetry --header Content-Type:application/json --data "{temperature:25}" 查看告警
再次发送遥测数据，可以清除告警
源码分析：
使用 http api 发送数据，入口类在 common/transport/http 模块下的 DeviceApiController 类。这个类提供了以下几个接口：
GET /api/v1/{deviceToken}/attributes POST /api/v1/{deviceToken}/attributes GET /api/v1/{deviceToken}/telemetry POST /api/v1/{deviceToken}/telemetry GET /api/v1/{deviceToken}/rpc POST /api/v1/{deviceToken}/rpc POST /api/v1/{deviceToken}/rpc/{requestId} POST /api/v1/{deviceToken}/claim GET /api/v1/{deviceToken}/firmware POST /api/v1/{deviceToken}/firmware GET /api/v1/{deviceToken}/software POST /api/v1/{deviceToken}/software POST /api/v1/provision POST /api/v1/{deviceToken}/telemetry 处理逻辑：
HttpTransportContext TransportService DefaultTransportService TbQueueProducer&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg>> ruleEngineMsgProducer TbRuleEngineQueueConsumerManager TbRuleEngineConsumerContext ActorSystemContext TbActorRef TbActorMailbox AppActor TenantActor RuleChainActor RuleChainActorMessageProcessor RuleNodeActor RuleNodeActorMessageProcessor TbDeviceProfileNode DeviceState AlarmState DefaultTbContext DefaultTbClusterService TbRuleEngineProducerProvider TbQueueProducer&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg>> toRuleEngine 这里面用到了 Transport 、Queue、Actor ，调用链非常长。</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-05-07</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/thingsboard/>Thingsboard</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to ThingsBoard的领域模型" href=https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>All things about ThingsBoard</h2></header><section class=entry-content><p>thingsboard 是一款乌克兰团队基于java语言研发的开源物联网框架，开源的是ce版，企业版需要购买授权且无源码。
官方网站：
Thingsboard 官网：https://thingsboard.io/
Thingsboard社区免费版本：https://demo.thingsboard.io/
Thingsboard 企业付费版本：https://thingsboard.cloud/
Thingsboard 源码：https://github.com/thingsboard/thingsboard
TBMQ 源码：https://github.com/thingsboard/tbmq
中文网：http://www.ithingsboard.com/
ThingsBoard 中文社区：https://www.thingsboard.club/
博客：
What is ThingsBoard? An Overview of ThingsBoard in 2024
How to access MQTT data with ThingsBoard | EMQ
分享｜五分钟学会使用 ThingsBoard 规则链
分享｜五分钟了解 ThingsBoard 物联网平台多种部署场景
分享｜五分钟快速学会 ThingsBoard 打包镜像和 Docker 部署
分享｜五分钟快速学会 ThingsBoard 对接物联网网关
分享｜五分钟快速学会 ThingsBoard DashBoard 基本操作
分享｜五分钟学会 ThingsBoard 本地编译运行和 Linux 部署
分享｜五分钟熟悉 ThingsBoard 前端二次开发。
https://www.cnblogs.com/east196/tag/ThingsBoard/
物联网技术学习指南 https://iot.mushuwei.cn/
物联网开源框架Thingsboard使用总结
https://www.weishadian.com/index.php/tag/thingsboard/page/5/
thingskit博客
ThingsBoard二次开发之源码分析1- 基础知识
源码分析：
ThingsBoard 源码分析 thingsboard源码解析 精尽thingsboard源码解析 https://github.com/blackstar-baba/how-2-use-thingsboard https://chenzhifu.xyz/categories/thingsboard IOT 平台：
http://iot.bctools.cn/ ThingsKit 分布式规则引擎系统，重构于开源IOT项目thingboard</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-04-29</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/thingsboard/>Thingsboard</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to All things about ThingsBoard" href=https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>TBMQ测试和源码分析</h2></header><section class=entry-content><p>启动 TBMQ 程序，浏览器访问 http://localhost:8083，创建一个 Application，Credentials Type 为 BASIC，客户端 ID、用户名和密码均设置为 tbmq_app
使用 mosquitto 测试订阅消息
mosquitto_sub -d -q 1 -h localhost -p 1883 -t tbmq/demo/+ -i 'tbmq_app' -u 'tbmq_app' -P 'tbmq_app' -c -v Debug 调试 MqttSessionHandler 类的 channelRead(ChannelHandlerContext ctx, Object msg) 方法
第一次连接，消息类型是 CONNECT
消息：
固定头：MqttFixedHeader[messageType=CONNECT, isDup=false, qosLevel=AT_MOST_ONCE, isRetain=false, remainingLength=40]
变量头：MqttConnectVariableHeader[name=MQTT, version=4, hasUserName=true, hasPassword=true, isWillRetain=false, isWillFlag=false, isCleanSession=false, keepAliveTimeSeconds=60]
负载：MqttConnectPayload[clientIdentifier=tbmq_app, willTopic=null, willMessage=null, userName=tbmq_app, password=[116, 98, 109, 113, 95, 97, 112, 112]]
address 为空，故从 ChannelHandlerContext 获取客户端地址，并将地址保持到客户端 Session 上下文 ClientSessionCtx
初始化 Session：获取 clientI、mqtt 版本，调用 ClientMqttActorManager 初始化 session：创建 clientActorRef，发送一个 SessionInitMsg 消息
调用 ClientMqttActorManager connect 方法，发送一个 MqttConnectMsg 消息
第二次连接，消息类型是 SUBSCRIBE
MqttSubscribeMessage[fixedHeader=MqttFixedHeader[messageType=SUBSCRIBE, isDup=false, qosLevel=AT_LEAST_ONCE, isRetain=false, remainingLength=16], variableHeader=MqttMessageIdAndPropertiesVariableHeader[messageId=1, properties=io....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-04-28</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/thingsboard/>Thingsboard</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to TBMQ测试和源码分析" href=https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>ThingsBoard TBMQ本地和通过Docker运行</h2></header><section class=entry-content><p>docker-compose 运行 参考：https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/
下载源代码
git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git cd tbmq/docker 创建逻辑卷并执行安装程序
./scripts/docker-create-volumes.sh ./scripts/docker-install-tbmq.sh 运行服务
./scripts/docker-start-services.sh 浏览器访问：http://localhost:8083，用户名/密码：sysadmin@thingsboard.org / sysadmin
查看 HaProxy 日志，发现出现异常：Error: Specified qdisc kind is unknown. 。
目前，尚未找到解决办法，只能不使用 HaProxy 而是直接访问 tbmq1，修改 docker-compose.yml ，暴露容器端口 8083 到本地的 8083：
tbmq1: restart: always container_name: "${TBMQ_1_NAME}" image: "${DOCKER_REPO}/${DOCKER_NAME}:${TBMQ_VERSION}" ports: - "1883" - "8083:8083" #修改这里 - "8084" 然后，通过浏览器访问 浏览器访问：http://localhost:8081
源码编译并运行 安装好 JDK 17+ 和 Maven3.6.3+
下载源代码
git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git cd tbmq 编译代码
mvn clean install -DskipTests 通过 docker-compose 本地安装 postgres、kafka、redis
参考 docker 目录下的文件新建 docker-compose.postgres.yml 文件：
version: '3.0' services: postgres: restart: always image: postgres:15 ports: - "5432:5432" environment: POSTGRES_DB: thingsboard_mqtt_broker POSTGRES_PASSWORD: postgres volumes: - postgres-data:/var/lib/postgresql/data volumes: postgres-data: 新建 docker-compose....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-04-17</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/thingsboard/>Thingsboard</a><a href=https://blog.chensoul.cc/tags/java/>Java</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to ThingsBoard TBMQ本地和通过Docker运行" href=https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>2023-12-19｜Spring Security OAuth2配置JWT、Github Actions配置代码扫描</h2></header><section class=entry-content><p>Today I Learned. 今天分享内容：Spring Security OAuth2 配置JWT、Github Actions配置代码扫描，另外，修改了 spring-security-oauth2-legacy 仓库，支持授权认证中心的多种配置方式（jdbc、内存、redis、jwt）、资源中心的多种配置方式（jwt、jdbc、redis、remote、jwk-set-uri）。
Spring Security OAuth2 配置JWT 使用 Spring Security 实现OAuth2 配置 JWT 非对称加密时， JwtAccessTokenConverter 设置生成私钥签名和公钥验证器（可省略）。
@Bean public JwtAccessTokenConverter jwtAccessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); // 设置私钥签名 converter.setSigner(new RsaSigner((RSAPrivateKey) new RSA("privateKey", null).getPrivateKey())); // 设置公钥验证器，可省略 converter.setVerifier(new RsaVerifier((RSAPublicKey) new RSA(null, "publicKey").getPublicKey())); return jwtAccessTokenConverter; } 注意：这里使用了 Hutool 的 RSA 从字符串生成 PrivateKey 和 PublicKey
去掉对 Hutool 的依赖，则可以使用自己实现的 RSAUtil 类：
public class RSAUtil { public static final String ALGORITHM_KEY = "RSA"; @SneakyThrows public static PrivateKey getPrivateKeyFromString(String privateKeyStr) { byte[] privateKeyBytes = Base64.getDecoder().decode(privateKeyStr.replaceAll("\n", "")); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes); KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_KEY); return keyFactory.generatePrivate(keySpec); } @SneakyThrows public static PublicKey getPublicKeyFromString(String publicKeyStr) { byte[] publicKeyBytes = Base64....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-12-19</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>Java</a><a href=https://blog.chensoul.cc/tags/github/>Github</a><a href=https://blog.chensoul.cc/tags/spring-security/>Spring-Security</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to 2023-12-19｜Spring Security OAuth2配置JWT、Github Actions配置代码扫描" href=https://blog.chensoul.cc/posts/2023/12/19/til/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>2023-12-18｜使用Spring Security实现OAuth2授权和认证</h2></header><section class=entry-content><p>Today I Learned. 今天分享内容：使用Spring Security实现OAuth2授权和认证。
最近在开发 Spring Cloud 微服务时，需要对 OAuth2 的异常处理进行定制，从网上搜到一个 github 仓库：oauth2。这篇仓库的代码实现了 OAuth2 的四种授权模式、I18N 国际化、异常处理、JWT Token，我 fork 了一份代码，做了一些改动，去掉了 webflux、eureka 相关代码。
代码仓库地址：https://github.com/chensoul/spring-security-oauth2-legacy，相关依赖的版本：
spring-boot: 2.7.18 org.springframework.security.oauth:spring-security-oauth2-autoconfigure: 2.6.8 org.springframework.security.oauth:spring-security-oauth2: 2.5.2.RELEASE org.springframework.security:spring-security-jwt 1.1.1.RELEASE 特性 统一异常处理 参考spring security的 ExceptionTranslationFilter 类
异常处理类 AccessDeniedHandler AuthenticationEntryPoint jwt key生成 生成 JKS 文件 keytool -genkeypair -alias myalias -storetype PKCS12 -keyalg RSA -keypass mypass -keystore mykeystore.jks -storepass mypass -validity 3650 导出公钥 # 保存为 public.cer 文件： keytool -exportcert -alias myalias -storepass mypass -keystore mykeystore.jks -file public.cer # 保存为 public.key 文件 keytool -list -rfc --keystore mykeystore.jks -storepass mypass | openssl x509 -inform pem -pubkey > public.key 导出私钥，将其保存为 private.key 文件： keytool -importkeystore -srckeystore mykeystore....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-12-18</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>Java</a><a href=https://blog.chensoul.cc/tags/spring-security/>Spring-Security</a><a href=https://blog.chensoul.cc/tags/oauth2/>Oauth2</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></footer><a class=entry-link aria-label="post link to 2023-12-18｜使用Spring Security实现OAuth2授权和认证" href=https://blog.chensoul.cc/posts/2023/12/18/til/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>2023-12-15｜JNDI InitialContext源码分析、ClassLoader加载机制</h2></header><section class=entry-content><p>Today I Learned. 今天分享内容：JNDI InitialContext源码分析、ClassLoader加载机制。
JNDI InitialContext 源码分析 JNDI包结构 javax.naming
Context InitialContext Name CompositeName CompoundName NameImpl NameParser NamingEnumeration Referenceable RefAddr BinaryRefAddr StringRefAddr NameClassPair Binding Reference LinkRef javax.naming.directory
Attribute
BasicAttribute Attributes
BasicAttributes DirContext
InitialDirContext ModificationItem
SearchControls
SearchResult
javax.naming.spi
NamingManager DirectoryManager ObjectFactory DirObjectFactory ObjectFactoryBuilder StateFactory DirStateFactory InitialContextFactory InitialContextFactoryBuilder Resolver ContinuationContext ContinuationDirContext ResolveResult InitialContext 构造方法 InitialContext的初始化有几种方式：
通过构造方法 通过 InitialContextFactory#getInitialContext 通过协议转换创建 InitialContext.getURLOrDefaultInitCtx(String name) 一个 JNDI 示例：
public class DNSClient { public static void main(String[] args) { Hashtable&lt;String, String> env = new Hashtable&lt;>(); env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.dns.DnsContextFactory"); env.put(Context.PROVIDER_URL, "dns://114.114.114.114"); try { DirContext ctx = new InitialDirContext(env); Attributes res = ctx.getAttributes("example.com", new String[]{"A"}); System.out.println(res); } catch (NamingException e) { e....</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-12-15</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://blog.chensoul.cc/tags/java/>Java</a><a href=https://blog.chensoul.cc/tags/jndi/>Jndi</a><a href=https://blog.chensoul.cc/tags/classloader/>Classloader</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>5 min</span></span></footer><a class=entry-link aria-label="post link to 2023-12-15｜JNDI InitialContext源码分析、ClassLoader加载机制" href=https://blog.chensoul.cc/posts/2023/12/15/til/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/tags/java/page/2/>« Prev Page</a>
<a class=next href=https://blog.chensoul.cc/tags/java/page/4/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>