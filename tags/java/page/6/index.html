<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | ChenSoul</title>
<meta name=keywords content><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/tags/java/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/tags/java/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/tags/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Java"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/tags/java/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Java
<a href=/tags/java/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]如何在Spring中执行@Async</h2></header><div class=entry-content><p>1. 概述 在本教程中，我们将探讨 Spring 中的异步执行支持和 @Async 注解。
简单地说，用 @Async 注解 bean 的方法将使其在单独的线程中执行。换句话说，调用者不会等待被调用方法的完成。
Spring 的一个有趣的方面是，框架中的事件支持还 支持异步处理（如果需要）。
2.启用异步支持 让我们首先通过 Java 注解启用异步处理。
我们将通过将 @EnableAsync 添加到配置类来完成此操作：
@Configuration @EnableAsync public class SpringAsyncConfig { ... } 启用注解就足够了。但也有一些简单的配置选项：
annotation 默认情况下，@EnableAsync 检测 Spring 的 @Async 注解和 EJB 3.1 javax.ejb.Asynchronous。我们也可以使用此选项来检测其他用户定义的注解类型。 mode 指示应使用的建议类型 - 基于 JDK 代理或 AspectJ 编织。 proxyTargetClass 指示应使用的代理类型 — CGLIB 或 JDK。仅当模式设置为 AdviceMode.PROXY 时，此属性才有效。 order 设置应用 AsyncAnnotationBeanPostProcessor 的顺序。默认情况下，它最后运行，以便它可以考虑所有现有代理。 我们还可以使用任务命名空间通过 XML 配置启用异步处理：
&lt;task:executor id="myexecutor" pool-size="5" /> &lt;task:annotation-driven executor="myexecutor"/> 3.@Async 注解 首先，让我们回顾一下规则。 @Async 有两个限制：
它必须仅应用于公共方法。 自调用（从同一个类中调用异步方法）将不起作用。 原因很简单：该方法需要公开，以便可以被代理。并且自调用不起作用，因为它绕过代理并直接调用底层方法。
3.1.返回类型为 void 的方法 这是配置具有 void 返回类型的方法以异步运行的简单方法：
@Async public void asyncMethodWithVoidReturnType() { System.out.println("Execute method asynchronously. " + Thread.currentThread().getName()); } 3.2.具有返回类型的方法 我们还可以通过将实际返回包装在 Future 中来将 @Async 应用于具有返回类型的方法：...</p></div><footer class=entry-footer><span title='2023-08-25 00:00:00 +0800 CST'>2023-08-25</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;338 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何在Spring中执行@Async" href=https://blog.chensoul.cc/posts/2023/08/25/spring-async/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java设计模式：Balking</h2></header><div class=entry-content><p>本文主要介绍 Balking 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
介绍 止步模式（Balking）是一种在对象处于特定状态时才执行操作的设计模式。它用于防止对象在不完整或不合适的状态下执行某些代码，从而确保代码的正确性和一致性。
该模式的核心思想是，在执行操作之前，检查对象的状态，并只在特定的状态下才执行操作。如果对象不处于预期状态，操作将被忽略或推迟执行，从而避免了不必要的操作或不一致的状态转换。
以下是止步模式的要点和示例：
对象状态检查：在执行操作之前，对象会检查自身的状态。这可以通过使用条件语句或状态标志来实现。 特定状态执行：只有当对象处于特定状态时，操作才会被执行。如果对象不满足执行条件，操作将被忽略或推迟执行。 线程安全考虑：由于止步模式通常涉及多线程环境，需要确保对共享资源的访问是线程安全的。可以使用同步机制（如 synchronized 关键字）来保护共享资源。 解释 真实世界例子
洗衣机中有一个开始按钮，用于启动衣物洗涤。当洗衣机处于非活动状态时，按钮将按预期工作，但是如果已经在洗涤，则按钮将不起任何作用。
通俗地说
使用止步模式，仅当对象处于特定状态时才执行特定代码。
维基百科说
禁止模式是一种软件设计模式，仅当对象处于特定状态时才对对象执行操作。例如，一个对象读取 zip 压缩文件并在压缩文件没打开的时候调用 get 方法，对象将在请求的时候”止步“。
程序示例
在此示例中， WashingMachine是一个具有两个状态的对象，可以处于两种状态：ENABLED 和WASHING。 如果机器已启用，则使用线程安全方法将状态更改为 WASHING。 另一方面，如果已经进行了清洗并且任何其他线程执行 wash（），则它将不执行该操作，而是不执行任何操作而返回。
这里是 WashingMachine 类相关的部分。
@Slf4j public class WashingMachine { private final DelayProvider delayProvider; private WashingMachineState washingMachineState; public WashingMachine(DelayProvider delayProvider) { this.delayProvider = delayProvider; this.washingMachineState = WashingMachineState.ENABLED; } public WashingMachineState getWashingMachineState() { return washingMachineState; } public void wash() { synchronized (this) { var machineState = getWashingMachineState(); LOGGER.info("{}: Actual machine state: {}", Thread.currentThread().getName(), machineState); if (this.washingMachineState == WashingMachineState.WASHING) { LOGGER.error("Cannot wash if the machine has been already washing!"); return; } this....</p></div><footer class=entry-footer><span title='2023-08-25 00:00:00 +0800 CST'>2023-08-25</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1207 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Java设计模式：Balking" href=https://blog.chensoul.cc/posts/2023/08/25/java-design-patterns-balking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Boot项目如何实现JWT认证？</h2></header><div class=entry-content><p>没有人可以否认这样一个事实：安全性是生产就绪应用程序的一项重要功能。尽管我们可以使用内存身份验证、JDBC 身份验证或通过 UserDetailsS​​ervice 来保护一个 Web 应用程序的安全。但是，当一个应用程序在内部使用其他应用程序的服务时，使用 Web 服务概念实现安全性就变得很重要。在这种情况下，我们使用具有特定有效期的令牌来保护我们的应用程序。此外，我们将学习“如何在 Spring Boot 项目中实现 JWT 身份验证？”以整体了解 JWT（JSON Web Token）身份验证背后的概念。
由于 JWT 代表“JSON Web Token”，很明显，该令牌仅以 JSON 形式保存数据。
此外，与上述身份验证技术不同，JWT 属于无状态身份验证。简而言之，它没有数据。通常，这种类型的身份验证用于 Web 服务、服务器的水平扩展，甚至在某种程度上用于 OAuth 技术。为了说明该网络服务，让我们可视化从亚马逊预订订单的过程。在这里，用户与 Amazon 应用程序交互，而 Amazon 应用程序在内部通过 Web 服务调用与支付网关应用程序交互。
现在让我们开始讨论我们的主题“如何在 Spring Boot 项目中实现 JWT 身份验证？”以及相关点。
您对整篇文章有何期望？ 读完本文后，您将能够回答：
什么是安全上下文中的无状态和有状态身份验证？ 无状态认证和有状态认证有什么区别？ 那么什么是 Token，什么是 JWT(JSON Web Token)？
使用 JWT 认证有什么好处？
JWT 内部如何运作？
我们在什么情况下使用 JWT 身份验证？
此外，JWT 身份验证和状态身份验证之间有什么区别？
此外，如何生成 JWT 编码令牌以及如何将其解码回来？
如何在 Spring Boot 项目中逐步实现 JWT 认证？
在 Spring Boot 3.0 中，如何在不使用 WebSecurityConfigurerAdapter 的情况下编写安全配置类？
最后，如何测试启用 JWT 安全的应用程序？
什么是无状态和有状态身份验证？ 通常有两种类型的认证技术。两者都发生在客户端服务器概念中，服务器仅在身份验证后才向客户端提供服务。这里的客户端可以是浏览器，也可以是另一个服务器。
状态认证 在这种类型的身份验证中，客户端和服务器之间涉及会话管理。当客户端向服务器请求服务时，它首先登录到服务器。然后服务器创建一个会话并以键值对的形式存储该信息。这个会话是服务器端的一种内存。我们也称其为 HttpSession，因为 Http 协议管理它。
此外，为了响应客户端请求，服务器以 Cookie 的形式向客户端提供带有响应的会话 id。该 cookie 存储在客户端浏览器中。当同一个客户端第二次发出请求时，请求头中也会带有 cookie。因此，服务器会检查请求标头，如果在 cookie 中发现相同的 SID（会话 ID），则假定该请求来自同一客户端。通过这种方式，会话管理就发生了。
当客户端从服务器注销时，会话会相应地被销毁。结果，服务器相应地从内存中删除会话信息（键值）。同样重要的是，对于每个新客户端，服务器都会创建一个新会话（内存）。
无状态身份验证 当客户端向服务器发送服务请求时，它首先登录到服务器。因此，服务器生成一个令牌（编码格式的数据）并将响应发送到客户端。在发出第二个请求时，客户端将相同的令牌与请求一起发送到服务器。现在，服务器从请求中读取令牌并验证令牌。事实上，从第一个请求开始，服务器就检查客户端的有效登录（凭据）。...</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0800 CST'>2023-08-18</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1974 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Boot项目如何实现JWT认证？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Boot项目如何实现Security？</h2></header><div class=entry-content><p>如今，几乎每个客户都要求在实时应用程序中实现强大的安全功能。安全功能对于保持机密性、完整性和可用性的需求是非常有效的。现实世界中有很多类型的安全性，但我们作为开发人员将重点关注应用程序/软件安全性。
此外，在应用程序安全方面，我们的工作基本上是确保两件事。首先，只有有效的用户才能访问该应用程序。其次，如果用户有效，他/她只能访问该应用程序中允许的数据/信息。我认为，没有什么可以解释它们，因为您必须已经了解这两个术语，即身份验证和授权。
您可能已经猜到我们将在当前主题“如何在 Spring Boot 项目中实现安全性？”中讨论什么内容。
在本文中，我们将从基本原理开始学习。接下来，我们将逐步结束它，直到我们有信心在 Spring Boot 应用程序中实现安全功能。因此，让我们开始逐步讨论“如何在 Spring Boot 项目中实现安全性？”。 Spring Boot 教程页面上有一系列有关 Spring Boot Security 的教程。
我们在本文中介绍了两个版本的“如何在 Spring Boot 项目中实现安全性？”的示例：使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。此外，还涵盖了使用 Spring Boot 3.0 及更高版本的“如何在 Spring Boot 项目中实现安全性？”的示例。
您将从本文中学到什么？ 为什么我们需要在 Spring Boot 应用程序中实现安全性？
Security 在 Spring Boot 应用程序内部如何工作？
javax.servlet.Filter 在 Spring Boot 应用程序中实现安全性方面的作用是什么？
Spring Boot 项目中使用了多少种授权类型？
Spring Boot 项目中有多少种实现安全性的方法？
在 Spring Boot 项目中实现 WebSecurity 的步骤是什么？
另外，如何在 Spring Boot 项目中使用@EnableWebSecurity、@Configuration、@Bean？
如何实现内存中身份验证安全示例
如何实现 JDBC 认证安全示例
如何在 Spring Boot 项目中使用 Thymeleaf ？
如何测试启用安全的功能？
相反，如何禁用应用程序的安全功能？
最后但并非最不重要的一点是，您将学习“如何在 Spring Boot 项目中实现安全性？”使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。
为什么我们需要应用程序中的安全性？ 现在，随着恶意攻击将重点从操作系统和网络转移到应用程序/软件和移动设备/设备，一天的数据面临最大的风险。此外，从业务/客户的角度来看，应用程序安全在维护信任、建立品牌形象和降低风险方面发挥着重要作用。事实上，没有其中任何一项，都无法想象一家成功的企业。
总之，无论您是为了内部使用、销售目的还是购买目的而创建应用程序，安全性都是每个应用程序最重要的功能。
根据最新的 2020 年 Verizon 数据泄露调查报告，所有数据泄露中有 43% 是针对 Web 应用程序的攻击。这一数字比 2019 年增加了一倍。此外，86% 的违规行为都是出于经济动机。...</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0800 CST'>2023-08-18</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1807 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Boot项目如何实现Security？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]如何在Spring Boot2中使用UserDetailsService实现安全性？</h2></header><div class=entry-content><p>继续上一篇关于实现 Spring Security 的两种不同方法的文章，在本文中，我们将学习第三种方法“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现 Security？”。经过上一篇文章后，我希望我们都非常熟悉安全性的基础知识，甚至是 Spring Boot 应用程序中的安全性基础知识。这次我们将创建一个用户注册表并将用户及其角色保存到数据库中。
然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
如果您正在寻找“如何在 Spring Boot 3 及以上版本中使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”，请访问有关使用 Spring Boot 3 的 Spring Security UserDetailsS​​ervice 的单独文章。
为了说明这一点，我们将把一些角色发挥作用，并在整个过程中围绕它们进行发挥，以使其变得清晰。此外，我们将有一些页面并限制它们仅可由某些特定角色访问。同样重要的是，我们必须创建一个小型 MVC Web 应用程序，以使注册过程向用户开放。用户在注册时将输入自己的角色。然后我们可以在其之上实现安全功能。
让我们开始相应的主题“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”。
总体而言，您对这篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 在 Spring Security 应用程序中如何内部工作并带有流程图？
另外，如何使用注解：@EnableWebSecurity、@Configuration、@Bean、@GetMapping、@Autowired、@Data、@Entity、@Table、@Id、@GenerateValue、@Column、@ElementCollection、@CollectionTable、@JoinColumn ， @服务
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 是做什么的？使用它有什么好处？ UserDetailsS​​ervice 是 Spring 中 org.springframework.security.core.userdetails 包下的预定义接口。我们的实现类实现了这个接口并重写了它的 loadUserByUsername(String username) 方法。此方法返回 UserDetails，它又是一个接口。预定义的 User 类（org.springframework.security.core.userdetails.User）是 UserDetails 接口的实现。总之，在 loadUserByUsername(String username) 方法中，我们传递用户名，它返回我们预定义的 User 对象（org....</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0800 CST'>2023-08-18</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1597 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何在Spring Boot2中使用UserDetailsService实现安全性？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot2-using-userdetailsservice/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]如何在Spring Boot3中使用UserDetailsService实现安全性？</h2></header><div class=entry-content><p>作为有关 Spring Security 的系列文章的继续，在本文中我们将学习“如何在 Spring Boot 3 中使用 UserDetailsService 实现 Spring Boot 中的安全性？”。经过前面的文章，我希望我们都非常熟悉安全性的基础知识，甚至 Spring Boot 应用程序中的安全性基础知识。 Spring Boot 3 发布后，我们将在这里实现“使用 Spring Boot 3 的 Spring Security UserDetailsService”。
在本文中，我们将创建一个用户注册表单并将用户及其角色保存在数据库中。然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
您对整篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 Spring Boot 3 实现 Spring Security UserDetailsService？
如何在基于 Spring 的应用程序中实现基于角色的安全性？
此外，如何以及在哪里使用注释：@EnableWebSecurity，@Configuration，@Bean，@GetMapping，@Autowired，@Data，@Entity，@Table，@Id，@GenerateValue，@Column，@ElementCollection，@CollectionTable， @JoinColumn，@Service
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
示例中使用的软件/技术 有时某些版本与其他版本冲突。因此，列出经过测试可以相互协作的组合。下面是经过测试的软件组合，用于使用 Spring Boot 3 开发 Spring Security UserDetailsS​​ervice。它也使实现完美无缺。
Spring Boot 3.0.0
JDK 17 or later
Maven 3.8.1 3）Maven 3.8.1
IDE – STS 4.7.1. RELEASE
IDE – STS 4.7.1。发布
Jars Used 下面是这些示例中 maven 使用 pom....</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0800 CST'>2023-08-18</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1651 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何在Spring Boot3中使用UserDetailsService实现安全性？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot3-using-userdetailsservice/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]没有WebSecurityConfigurerAdapter的Spring Security.md</h2></header><div class=entry-content><p>在 Spring Security 模块的上下文中，WebSecurityConfigurerAdapter 是一个抽象类，根据 Spring 官方网站 2022 年 2 月 21 日发布的公告，该类已从 Spring Security 5.7.0-M2 中弃用。它通常用于扩展 configure() 方法由自定义配置子类实现。因此，它鼓励用户转向基于组件的安全配置。为了支持对这种新配置设计的更改，我们将讨论常见用例列表和未来建议的替代方案。因此，我们将讨论没有 WebSecurityConfigurerAdapter 的 Spring Security 用例的实现。
了解这一变化很重要，因为迟早我们将使用最新版本的 Spring Security 来开发安全功能。让我们讨论“没有 WebSecurityConfigurerAdapter 的 Spring Security”主题及其相关概念。
什么是 WebSecurityConfigurerAdapter？ WebSecurityConfigurerAdapter 是 Spring Security 模块提供的一个抽象类。一般来说，我们使用它来重写它的 configure()方法来定义我们的安全配置类。通常，我们在应用程序中实现 Spring Security 时使用两个具有不同参数的 configure() 方法。一种用于声明与身份验证相关的配置，另一种用于声明与授权相关的配置。该代码类似于下面的代码片段。
@Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // configure Authentication ...... } @Override protected void configure(HttpSecurity http) throws Exception { // configure Authorization ...... } } 为什么我们需要学习这个改变？ 如果您使用 Spring Boot 2.7.0 和 maven，它将自动下载 Spring Security 5.7.0 或更高版本。在这种情况下，您会发现 WebSecurityConfigurerAdapter 已被弃用。如果您仍然想使用此类而不弃用，您可以在 pom.xml 中将 Spring Boot 版本更改为较低版本（例如 2.6.6 ），如下所示。它将自动下载低于 5....</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0800 CST'>2023-08-18</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;882 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]没有WebSecurityConfigurerAdapter的Spring Security.md" href=https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security - JWT</h2></header><div class=entry-content><p>简介和概述 JSON Web Token 或 JWT（更常见的名称）是一种开放的互联网标准 (RFC 7519)，用于以紧凑的方式在各方之间安全地传输可信信息。令牌包含编码为 JSON 对象的声明，并使用私有密钥或公钥/私钥对进行数字签名。它们是独立且可验证的，因为它们经过数字签名。 JWT 可以进行签名和/或加密。
签名的令牌验证令牌中包含的声明的完整性，而加密的令牌则向其他方隐藏声明。
JWT 也可用于信息交换，尽管它们更常用于授权，因为它们比使用内存中随机令牌的会话管理具有很多优势。其中最重要的是允许将身份验证逻辑委托给第三方服务器，例如 AuthO 等。
JWT 令牌分为 3 部分，即标头、有效负载和签名，格式为
[Header].[Payload].[Signature] Header − JWT 令牌的标头包含应用于 JWT 的加密操作列表。这可以是签名技术、有关内容类型的元数据信息等。标头以 JSON 对象的形式呈现，该对象被编码为 base64URL。有效 JWT 标头的示例是 { "alg": "HS256", "typ": "JWT" } 这里，“alg”为我们提供了有关所用算法类型的信息，“typ”为我们提供了信息的类型。
Payload − JWT 的有效负载部分包含使用令牌传输的实际数据。这部分也称为 JWT 令牌的“声明”部分。索赔可以分为三种类型：注册索赔、公开索赔和私人索赔。 注册的声明是推荐的但不是强制的声明，例如 iss(发行者)、sub(主题)、aud(受众) 等。 公共声明是那些使用 JWT 的人定义的声明。 私人声明或自定义声明是为了在相关方之间共享信息而创建的用户定义的声明。 有效负载对象的示例可以是。
{ "sub": "12345", "name": "Johnny Hill", "admin": false } 有效负载对象与标头对象一样，也采用 base64Url 编码，并且该字符串构成 JWT 的第二部分。
Signature− JWT 的签名部分用于验证消息在此过程中没有更改。如果令牌是用私钥签名的，它还会验证发送者的身份。它是使用编码的标头、编码的有效负载、秘密和标头中指定的算法创建的。签名的一个例子是。 HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret); 如果我们输入标头、有效负载和签名，我们会得到一个令牌，如下所示。
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6I kpvaG4gRG9lIiwiYWRtaW4iOmZhbHNlfQ.gWDlJdpCTIHVYKkJSfAVNUn0ZkAjMxskDDm-5Fhe WJ7xXgW8k5CllcGk4C9qPrfa1GdqfBrbX_1x1E39JY8BYLobAfAg1fs_Ky8Z7U1oCl6HL63yJq_ wVNBHp49hWzg3-ERxkqiuTv0tIuDOasIdZ5FtBdtIP5LM9Oc1tsuMXQXCGR8GqGf1Hl2qv8MCyn NZJuVdJKO_L3WGBJouaTpK1u2SEleVFGI2HFvrX_jS2ySzDxoO9KjbydK0LNv_zOI7kWv-gAmA j-v0mHdJrLbxD7LcZJEGRScCSyITzo6Z59_jG_97oNLFgBKJbh12nvvPibHpUYWmZuHkoGvuy5RLUA 现在，可以使用承载模式在授权标头中使用此令牌。
Authorization − Bearer 授权 - 持有者
使用 JWT 令牌进行授权是其最常见的应用。令牌通常在服务器中生成并发送到客户端，并存储在会话存储或本地存储中。要访问受保护的资源，客户端将在标头中发送 JWT，如上所述。我们将在下面的部分中看到 Spring Security 中的 JWT 实现。...</p></div><footer class=entry-footer><span title='2023-08-16 00:00:00 +0800 CST'>2023-08-16</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1173 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security - JWT" href=https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-jwt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security - OAuth2</h2></header><div class=entry-content><p>OAuth 2.0 基础知识 OAuth 2.0 由 IETF OAuth 工作组开发并于 2012 年 10 月发布。它作为一种开放授权协议，使第三方应用程序能够代表资源所有者对 HTTP 服务进行有限访问。它可以在不泄露用户身份或长期凭证的情况下做到这一点。第三方应用程序本身也可以代表其使用它。
OAuth 的工作原理包括将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问用户的帐户。
让我们考虑一个例子。假设我们要登录网站“clientsite.com”。我们可以通过 Facebook、Github、Google 或 Microsoft 登录。我们选择上面给出的选项中的任何选项，然后我们将被重定向到相应的网站进行登录。如果登录成功，系统会询问我们是否要授予 clientsite.com 访问其请求的特定数据的权限。
我们选择所需的选项，然后使用授权代码或错误代码重定向到 clientsite.com，登录是否成功取决于我们在第三方资源中的操作。这就是 OAuth 2 的基本工作原理。
OAuth 系统涉及五个关键角色。让我们把它们列出来 -
User / Resource Owner − 用户/资源所有者- 最终用户，负责身份验证并同意与客户端共享资源。 User-Agent − 用户代理- 用户使用的浏览器。 Client − 客户端 - 请求访问令牌的应用程序。 Authorization Server − 授权服务器- 用于验证用户/客户端的服务器。它颁发访问令牌并在其整个生命周期内对其进行跟踪。 Resource Server − 资源服务器- 提供对所请求资源的访问的 API。它验证访问令牌并提供授权。 入门 我们将使用 Spring Security 和 OAuth 2.0 开发一个 Spring Boot 应用程序来说明上述内容。我们现在将开发一个带有内存数据库的基本应用程序来存储用户凭据。该应用程序将使我们轻松了解 OAuth 2.0 与 Spring Security 的工作原理。
让我们使用 Spring 初始化程序在 Java 8 中创建一个 Maven 项目。让我们从 start.spring.io 开始。我们生成一个具有以下依赖项的应用程序 -
Spring Web Spring Security Cloud OAuth2 Spring Boot Devtools 通过上面的配置，我们点击 Generate 按钮生成一个项目。该项目将以 zip 文件形式下载。我们将 zip 解压到一个文件夹中。然后我们可以在我们选择的 IDE 中打开该项目。我在这里使用 Spring Tools Suite，因为它针对 Spring 应用程序进行了优化。我们也可以根据需要使用 Eclipse 或 IntelliJ Idea。...</p></div><footer class=entry-footer><span title='2023-08-16 00:00:00 +0800 CST'>2023-08-16</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;720 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security - OAuth2" href=https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-oauth2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security - 使用数据库表单登录</h2></header><div class=entry-content><p>内容 简介和概述 Spring Security 的基本组件 AuthenticationFilter 认证过滤器 AuthenticationManager 认证管理器 AuthenticationProvider 认证提供者 UserDetailsService 用户详情服务 PasswordEncoder 密码编码器 Spring 安全上下文 表单登录 使用数据库登录 登录尝试限制 入门（实用指南） 简介和概述 除了提供各种内置的身份验证和授权选项之外，Spring Security 还允许我们根据需要自定义身份验证过程。从自定义登录页面到我们自己的自定义身份验证提供程序和身份验证过滤器，我们几乎可以自定义身份验证过程的各个方面。
我们可以定义自己的身份验证过程，范围可以从使用用户名和密码的基本身份验证到复杂的身份验证，例如使用令牌和 OTP 的双因素身份验证。此外，我们可以使用各种数据库 - 关系数据库和非关系数据库，使用各种密码编码器，将恶意用户锁定在其帐户之外，等等。
今天，我们将讨论三种此类自定义，即自定义表单登录、数据库提供的身份验证以及限制登录尝试。尽管这些都是非常基本的用例，但它们仍然可以让我们更仔细地了解 Spring Security 的身份验证和授权过程。我们还将建立一个注册页面，用户可以通过该页面在我们的应用程序中进行注册。
首先我们看一下 Spring Security 的架构。它从 servlet 过滤器开始。这些过滤器拦截请求，对其执行操作，然后将请求传递到过滤器链中的下一个过滤器或请求处理程序，或者在不满足某些条件时阻止它们。正是在这个过程中，Spring Security 可以对请求进行身份验证并对请求执行各种身份验证检查。
它还可以通过不允许未经身份验证或恶意请求访问我们受保护的资源来阻止它们通过。因此我们的应用程序和资源受到保护。
Spring Security 架构的组件 正如我们在上图中看到的那样，Spring Security 的基本组件如下所示。我们将在讨论过程中简要讨论它们。我们还将讨论它们在身份验证和授权过程中的角色。
AuthenticationFilter 认证过滤器 这是拦截请求并尝试对其进行身份验证的过滤器。在 Spring Security 中，它将请求转换为身份验证对象并将身份验证委托给 AuthenticationManager。
AuthenticationManager 认证管理器 它是身份验证的主要策略接口。它使用单独的方法 authenticate()来验证请求。 authenticate() 方法执行身份验证，并在身份验证成功时返回 Authentication 对象，或者在身份验证失败时抛出 AuthenticationException。如果该方法无法决定，它将返回 null。这个过程中的认证过程委托给了我们接下来要讨论的 AuthenticationProvider。
AuthenticationProvider 认证提供者 AuthenticationManager 由 ProviderManager 实现，后者将流程委托给一个或多个 AuthenticationProvider 实例。任何实现 AuthenticationProvider 接口的类都必须实现两个方法——authenticate() 和 supports()。首先，我们来谈谈 supports()方法。它用于检查我们的 AuthenticationProvider 实现类是否支持特定的身份验证类型。如果支持则返回 true，否则返回 false。
接下来是 authenticate() 方法。这是身份验证发生的地方。如果支持该认证类型，则启动认证过程。这里这个类可以使用 UserDetailsS​​ervice 实现的 loadUserByUsername() 方法。如果未找到用户，则会抛出 UsernameNotFoundException。
另一方面，如果找到用户，则使用该用户的身份验证详细信息来验证该用户。例如，在基本认证场景中，可以将用户提供的密码与数据库中的密码进行核对。如果发现它们彼此匹配，则说明成功。然后我们可以从此方法返回一个 Authentication 对象，该对象将存储在安全上下文中，我们将在稍后讨论。
UserDetailsService 用户详情服务 它是 Spring Security 的核心接口之一。任何请求的身份验证主要取决于 UserDetailsS​​ervice 接口的实现。它最常用于数据库支持的身份验证中以检索用户数据。通过单独的 loadUserByUsername() 方法的实现来检索数据，我们可以在其中提供逻辑来获取用户的用户详细信息。如果未找到用户，该方法将抛出 UsernameNotFoundException。...</p></div><footer class=entry-footer><span title='2023-08-16 00:00:00 +0800 CST'>2023-08-16</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1725 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security - 使用数据库表单登录" href=https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-with-database/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/tags/java/page/5/>«&nbsp;Prev&nbsp;5/12
</a><a class=next href=https://blog.chensoul.cc/tags/java/page/7/>Next&nbsp;7/12&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>