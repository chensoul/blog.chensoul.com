<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>java | ChenSoul</title>
<meta name=keywords content><meta name=description content><meta name=author content="chensoul"><link rel=canonical href=https://chensoul.github.io/tags/java/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6db7ab468e55ea6647d68be426a17bae21ff1cddbf1741e547ed2086d010444.css integrity="sha256-1tt6tGjlXqZkfWi+QmoXuuIf8c3b8XQeVH7SCG0BBEQ=" rel="preload stylesheet" as=style><link rel=icon href=https://chensoul.github.io/favicon.ico><link rel=apple-touch-icon href=https://chensoul.github.io/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://chensoul.github.io/tags/java/index.xml><meta name=twitter:title content="java | ChenSoul"><meta name=twitter:description content><meta property="og:title" content="java | ChenSoul"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://chensoul.github.io/tags/java/"><meta property="og:site_name" content="ChenSoul"><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-tags kind-term layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://chensoul.github.io/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://chensoul.github.io/categories/review/ title=总结>总结</a></li><li><a href=https://chensoul.github.io/categories/ title=分类>分类</a></li><li><a href=https://chensoul.github.io/tags/ title=标签 class=active>标签</a></li><li><a href=https://github.com/chensoul/ title=关于 target=_blank>关于<span class=external-link><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><header class=page-header><h1>tag: java</h1><div class=inline-links><span><a href=https://chensoul.github.io/tags/java/index.xml target=_blank>RSS</a></span></div></header><article class="post-entry tag-entry"><header class=entry-header><h2>周报-19｜武功山看日出、Python初学建议</h2></header><section class=entry-content><p>前言 本篇是对 2023-05-08 到 2023-05-14 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。
本周继续学习 python，发现一个质量非常高的 python 学习网站 Real Python，该网站有学习 python 的一些教程，是收费的，部分章节是可以免费观看的。
另外，周五晚上老婆临时起意想去武功山看日出，于是立即规划行程并购买火车票。因为一年半之前，我去过一次，所以规划起来还是很轻松的。上一次去是国庆节碰到下雨，没有看到日出。幸运的是，这次是晴天，不仅看到了日落还看到了日出。这一次没有选择住帐篷，而是住在了云中雾客栈，没想到这个客栈离金顶需要 40 分钟左右的路程，而且有段路程是坑坑洼洼。
去武功山之前，先去了长沙，再次游了橘子洲头，并第一次在长沙跑步打卡。本想在萍乡也跑步打卡，奈何没有得逞。
这次去了长沙和武功山，下次基本上是再也不会去爬武功山了。长沙还会去，因为从武功山回来路上，就和老婆规划着什么时候去张家界。
武功山看日出 理财 这周总计支出 1784 元，明细如下：
5 月 8 日：12 元 5 月 9 日：18 元 5 月 10 日：200 元 5 月 11 日：12 元 5 月 12 日：445 元 5 月 13 日：662 元 5 月 14 日：435 元 因为周末出去旅游，所以本周支出有所增多。
健身 本周跑步 56 公里，最长跑步距离为 13 公里。
明细数据如下：
周末出去旅游，路过长沙，在长沙跑了两天，累计跑了 6 公里。这样，我的跑步数据 从 2 年里我跑过 1 个省份 1 个城市 变成了 2 年里我跑过 2 个省份 2 个城市。
工作 Java 博客 本周完成两篇博客
《Effective Java 3》笔记 10：覆盖 equals 方法时应遵守的约定 JSR 166 规范 Python Python 初学建议 1、新手如何学习 python？...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-18</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/review/>review</a><a href=https://chensoul.github.io/tags/java/>java</a><a href=https://chensoul.github.io/tags/python/>python</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>3 min</span></span></footer><a class=entry-link aria-label="post link to 周报-19｜武功山看日出、Python初学建议" href=https://chensoul.github.io/posts/2023/05/18/weekly_review_19/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>JSR 166规范</h2></header><section class=entry-content><p>JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。
JSR 166 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。
J.U.C，即 java.util.concurrent 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。
Doug Lea 主页：Doug Lea’s Home Page JSR-166：Concurrency JSR-166 Interest Site JSR 166 Slider：JSR-166: Concurrency Utilities java.util.concurrent JavaDoc: JDK 1.5 、 JDK 7 、 JDK 8 、 JDK 9 JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：
JSR-166（Java SE 5）：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。 JSR-166x（Java SE 7）：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。 JSR-166y（Java SE 8）：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。 JSR-166z（Java SE 9）：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。 JUC java....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-18</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>4 min</span></span></footer><a class=entry-link aria-label="post link to JSR 166规范" href=https://chensoul.github.io/posts/2023/05/18/jsr-166/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定</h2></header><section class=entry-content><p>本文是 《Effective Java 3》第三章《对象的通用方法》的学习笔记：覆盖 equals 方法时应遵守的约定。
介绍 覆盖 equals 方法似乎很简单，但是有很多覆盖的方式会导致出错，而且后果可能非常严重。避免问题的最简单方法是不覆盖 equals 方法，在这种情况下，类的每个实例都只等于它自己。如果符合下列任何条件，就是正确的做法：
类的每个实例本质上都是唯一的。 对于像 Thread 这样表示活动实体类而不是值类来说也是如此。Object 提供的 equals 实现对于这些类具有完全正确的行为。
该类不需要提供「逻辑相等」测试。 例如，java.util.regex.Pattern 可以覆盖 equals 来检查两个 Pattern 实例是否表示完全相同的正则表达式，但设计人员认为客户端不需要或不需要这个功能。在这种情况下，从 Object 继承的 equals 实现是理想的。
超类已经覆盖了 equals，超类行为适合于这个类。 例如，大多数 Set 的实现从 AbstractSet 继承其对等实现，List 从 AbstractList 继承实现，Map 从 AbstractMap 继承实现。
类是私有的或包私有的，并且你确信它的 equals 方法永远不会被调用。 如果你非常厌恶风险，你可以覆盖 equals 方法，以确保它不会意外调用：
@Override public boolean equals(Object o) { throw new AssertionError(); // Method is never called } 什么时候覆盖 equals 方法是合适的？当一个类有一个逻辑相等的概念，而这个概念不同于仅判断对象的同一性（相同对象的引用），并且超类还没有覆盖 equals。对于值类通常是这样。值类只是表示值的类，例如 Integer 或 String。使用 equals 方法比较引用和值对象的程序员希望发现它们在逻辑上是否等价，而不是它们是否引用相同的对象。覆盖 equals 方法不仅是为了满足程序员的期望，它还使实例能够作为 Map 的键或 Set 元素时，具有可预测的、理想的行为。
有一个表示状态的内部类。没有覆盖 equals 方法时，equals 的结果与 s1==s2 相同，为 false，即两者并不是相同对象的引用。
public static void main(String[] args) { class Status { public String status; } Status s1 = new Status(); Status s2 = new Status(); System....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-17</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>7 min</span></span></footer><a class=entry-link aria-label="post link to 《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定" href=https://chensoul.github.io/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>周报-18｜导出豆瓣数据、Effective Java 3第二章总结</h2></header><section class=entry-content><p>前言 本篇是对 2023-05-01 到 2023-05-07 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。
继上周实现导出苹果接口数据之后，这周又实现了自动导出豆瓣数据。此外，还萌生了导出每天阅读的数据的想法。奈何现在阅读 app 都需要收费，只能暂且搁置这个想法。
最近在学习 Python，于是将学习中做的笔记发布到了博客，这周发布了两篇文章，希望通过输出来倒逼输入，以此来快速掌握 python 编程并能开发一些项目。另外，计划在学完之后，继续学习 Rust 和 Go，甚至开始学习前端开发。
最近又一次更换了博客主题，主要出发点是想找一个简洁的主题，减少不必要的信息干扰，也不想花时间在修改主题上面。减少了菜单链接。
导出豆瓣数据 最近阅读了一篇文章 很认真的在考虑不再使用豆瓣这件事 ，于是使用 lizheming/doumark-action 导出豆瓣数据。
在我的 github 主页 https://github.com/chensoul/chensoul 创建一个 workflow douban.yml ，每隔一个小时同步一次豆瓣数据（读书、电影、音乐）到 csv 文件。拿到这些文件之后，就可以通过 html + css 渲染出来，类似这个页面 书影音。等豆瓣数据增多之后，再考虑实现这个。
除此之外，之前还实现了通过 n8n 实时同步豆瓣数据到 memos 和 telegram：
通过 python 脚本 获取最近 10 条记录，显示到 我的 github 主页。
理财 这周总计支出 816 元，明细如下：
5 月 1 日：55 元 5 月 2 日：79 元 5 月 3 日：370 元，其中 270 元加油 5 月 4 日：136 元，其中捐款 50 元 5 月 5 日：12 元 5 月 6 日：100 元，手机话费充值 5 月 7 日：64 元 最近一直想统计一下工作和生活中的固定支出费用，于是今天花了点时间做了统计。没想到每年工作和生活中固定支出费用竟然达到了 1529+6180=7709 元。其中大块头是手机话费和停车位费用，手机话费是因为办理一个电信套餐送宽带和一部手机；停车位费用是因为今年买了车。...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-10</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/review/>review</a><a href=https://chensoul.github.io/tags/java/>java</a><a href=https://chensoul.github.io/tags/python/>python</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to 周报-18｜导出豆瓣数据、Effective Java 3第二章总结" href=https://chensoul.github.io/posts/2023/05/10/weekly_review_18/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>《Effective Java 3》笔记9：使用 try-with-resources 优于 try-finally</h2></header><section class=entry-content><p>本文是 《Effective Java 3》第二章的学习笔记：使用 try-with-resources 优于 try-finally。
介绍 Java 库包含许多必须通过调用 close 方法手动关闭的资源。常见的有 InputStream、OutputStream 和 java.sql.Connection。关闭资源常常会被客户端忽略，这会导致可怕的性能后果。虽然这些资源中的许多都使用终结器作为安全网，但终结器并不能很好地工作。
从历史上看，try-finally 语句是确保正确关闭资源的最佳方法，即使在出现异常或返回时也是如此：
// try-finally - No longer the best way to close resources! static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } 这可能看起来不坏，但添加第二个资源时，情况会变得更糟：
// try-finally is ugly when used with more than one resource! static void copy(String src, String dst) throws IOException { InputStream in = new FileInputStream(src); try { OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) >= 0) out.write(buf, 0, n); } finally { out....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-08</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to 《Effective Java 3》笔记9：使用 try-with-resources 优于 try-finally" href=https://chensoul.github.io/posts/2023/05/08/prefer-try-with-resources-to-try-finally/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>《Effective Java 3》笔记8：避免使用终结器和清除器</h2></header><section class=entry-content><p>本文是 《Effective Java 3》第二章的学习笔记：避免使用终结器和清除器。
介绍 终结器是不可预测的、常常是危险的，通常也是不必要的。 它们的使用可能导致不稳定的行为、低效率和可移植性问题。终结器有一些有效的用途，我们稍后会介绍，但通常情况下应该避免使用它们。从 Java 9 开始，终结器已经被弃用，但它们仍然被 Java 库使用。Java 9 中终结器的替代品是清除器。 清除器的危险比终结器小，但仍然不可预测、缓慢，而且通常是不必要的。
终结器是通过在对象上实现 finalize() 方法来实现的，而清除器是通过使用 Cleaner 类来实现的。它们的工作方式有所不同：
终结器是由垃圾回收器自动执行的，无法预测何时执行，也无法保证一定会执行。当垃圾回收器决定将对象回收时，它会调用对象的 finalize() 方法，以便对象在被销毁之前执行一些清理操作。
清除器是由 Java 9 虚拟机通过引用队列和 Cleaner 对象执行的，可以在对象被回收之前或之后执行。在对象被垃圾回收之前，Java 虚拟机会将该对象的引用添加到一个引用队列中，然后在某些时刻，Java 虚拟机会创建一个 Cleaner 对象，并将该引用队列与 Cleaner 对象关联起来。当该对象被垃圾回收时，它的引用将被添加到与 Cleaner 对象关联的引用队列中，Cleaner 对象会在某些时刻自动执行，以便对象在被销毁之前或之后执行一些清理操作。
在 Java 9 中，引入了 java.lang.ref.Cleaner 类，作为终结器的替代品，用于执行对象清理操作。相比终结器，Cleaner 具有以下优点：
显式管理：Cleaner 使用明确的代码路径来管理清理操作，而不是使用隐式的终结器机制。 可控性：Cleaner 允许开发人员控制何时执行清理操作，而不是完全依赖于垃圾回收器的行为。 安全性：Cleaner 执行清理操作时，会确保类加载器已准备好，因此可以安全地执行本地清理操作。 Cleaner 通过注册一个任务来执行清理操作。该任务可以是 Runnable 或者继承自 PhantomReference 类的子类对象。当对象被垃圾回收器回收时，Cleaner 将自动执行注册的任务。
终结器和清除器的使用场景非常有限，因为它们的执行时间不可预测，可能会导致一些问题，例如性能问题、不稳定的行为、低效率和可移植性问题。
终结器和清除器的主要问题是：
它们无法可靠地及时执行，甚至可能根本不会执行。当对象变得不可访问，终结器或清除器对它进行操作的时间是不确定的。这意味着永远不应该在终结器或清除器中执行任何对时间要求很严格的操作。例如，依赖终结器或清除器关闭文件就是一个严重错误，因为打开的文件描述符是有限的资源。如果由于系统在运行终结器或清除器的延迟导致许多文件处于打开状态，程序可能会运行失败，因为它不能再打开其他文件。
终结器的另一个问题是，在终结期间抛出的未捕获异常被忽略，该对象的终结终止。未捕获的异常可能会使其他对象处于损坏状态。如果另一个线程试图使用这样一个损坏的对象，可能会导致任意的不确定性行为。正常情况下，未捕获的异常将终止线程并打印堆栈跟踪，但如果在终结器中出现，则不会打印警告。清除器没有这个问题，因为使用清除器的库可以控制它的线程。
它们可能会导致性能问题。终结器由垃圾回收器执行，这可能会导致垃圾回收过程中的延迟。另一方面，清除器使用单独的线程执行，这可能会导致额外的开销和同步问题。
《Effective Java》第三版建议使用显式终止方法，例如 close()，释放系统资源。当应用程序完成对资源的使用时，可以显式调用这些方法，而不依赖于垃圾回收器来执行它们。
如果必须使用终结器或清除器， 《Effective Java》第三版建议使用防御性编程实现它们，即使用 try-finally 块确保执行关键的清理操作，并避免引用其他可能已被垃圾回收的对象或资源。
扩展 System.gc() System.gc() 方法是 Java 中的一种垃圾回收机制，它可以在请求垃圾回收器运行时强制进行一次垃圾回收。
System.gc() 方法不是强制垃圾回收的方法，因为 Java 虚拟机可以忽略它。Java 编程语言规范要求 System.gc() 方法只是一个建议，不能保证它一定会导致垃圾回收器运行。因此，它不应该被频繁地调用，因为这可能会导致性能问题。
System.gc() 方法的使用场景非常有限。通常情况下，应该让垃圾回收器自行管理内存，而不是使用 System.gc() 方法来强制进行垃圾回收。如果需要确保某些对象在垃圾回收之前被释放，可以使用弱引用或软引用来管理这些对象，或使用显式终止方法来释放系统资源。
需要注意的是，System.gc() 方法可能会耗费较长时间，因为它可能会强制回收所有未使用的对象。因此，在实际使用中，应该谨慎使用 System.gc() 方法，并仅在必要时使用它。
System.runFinalization() System.runFinalization() 方法是在 Java 1.2 版本中引入的。在 Java 1.2 中，引入了垃圾回收器的改进，包括使用引用类型、终结器和垃圾回收器性能的提升。System....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-08</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>3 min</span></span></footer><a class=entry-link aria-label="post link to 《Effective Java 3》笔记8：避免使用终结器和清除器" href=https://chensoul.github.io/posts/2023/05/08/avoid-finalizers-and-cleaners/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>周报-17｜导出苹果健康数据、自动化收集个人数据、FlexyPool动态连接池</h2></header><section class=entry-content><p>前言 本篇是对 2023-04-24 到 2023-04-30 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。
本周二早上跑步右小腿抽筋，跑步暂停了两天，所以有两天走路没有到一万步。在小腿恢复之后，继续跑步，查看 strava 上的统计，这周总共跑了 27 公里，比上周 41 公里少了 14 公里。
这周空闲时间就在想，能不能每天自动收集个人的一些数据，比如，目前我能想到的数据包括跑步、走路、体重、编码、早起等等。
目前是使用 strava app 记录跑步数据，通过 running_page 可以实时收集我的每天 跑步数据。
走路、体重数据可以从苹果健康数据获取：
编码数据可以从 wakatime 获取：
早起的数据，我目前是通过 ios workflow 自动化来实现的。当早起闹钟响起时，往 memos 写入一条记录。
如果可以获取到苹果屏幕使用时间数据，则可以从苹果手机获取每日第一次拿起手机的时间作为早起时间（待研究）。
导出苹果健康数据 如何导出苹果健康数据？可以参考这篇文章 想要分析或备份 iPhone 「健康」应用数据？教你 3 种方法将其导出 。这篇文章提到的 Health Export 工具和 python 脚本我都试过，QS Access 在手机上没有找到。
1. Health Export 在线解析 Health Export 是国外一名独立开发者写的在线解析工具，它专门用于将健康应用导出的 XML 文件转换为 CSV 文件。
Health Export 提供了一个 web 网站 可以解析传苹果手机导出的健康数据。
如何从 IPhone 手机导出苹果健康数据呢？您可以通过以下步骤导出这些数据：
打开“健康”应用程序。 点击屏幕右上角的“个人资料”图标。 滚动到页面底部，找到“导出健康数据”选项，并点击它。 在弹出窗口中选择要导出的数据类型，例如步数、心率等。 点击“下一步”按钮。 在下一个页面中，您可以选择要导出的时间范围。您可以选择“全部数据”或指定日期范围。 点击“请求导出”按钮。 您将被要求输入一个密码以保护您的数据。输入密码后，点击“下一步”按钮。 在弹出窗口中，您可以选择将数据发送到您的电子邮件地址或其他应用程序。 点击“导出”按钮。 完成这些步骤后，您的健康数据将被导出为一个可下载的 zip 文件。您可以将其保存到您的设备上或发送到其他应用程序或云存储服务。
将导出的文件 export.xml 上传到 web 网站 ，稍等片刻可以导出结果。导出的健康数据是一个指标一个 csv 文件，如果想合并数据，需要做进一步处理。
另外，Health Export 也提供了 IOS APP，功能好用，支持选择指定指标数据按日期聚合导出为一个 csv，还有定时导出的功能，遗憾的是需要收费。
2、使用 python 脚本 这里使用了 @Radcliffe 提供的开源代码。目前，Github 可以在国内自由访问，所以直接通过此链接下载名称为 applehealthdata....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-06</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/review/>review</a><a href=https://chensoul.github.io/tags/strava/>strava</a><a href=https://chensoul.github.io/tags/java/>java</a><a href=https://chensoul.github.io/tags/memos/>memos</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>5 min</span></span></footer><a class=entry-link aria-label="post link to 周报-17｜导出苹果健康数据、自动化收集个人数据、FlexyPool动态连接池" href=https://chensoul.github.io/posts/2023/05/06/weekly_review_17/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>《Effective Java 3》笔记7：排除过时的对象引用</h2></header><section class=entry-content><p>本文是 《Effective Java 3》第二章的学习笔记：排除过时的对象引用。
介绍 “Eliminate obsolete object references” 是一条 Java 编程最佳实践的原则，指的是在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为 null，这样 JVM 可以及时回收它所占用的内存。
考虑以下简单的堆栈实现：
import java.util.Arrays; import java.util.EmptyStackException; // Can you spot the "memory leak"? public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; } /** * Ensure space for at least one more element, roughly * doubling the capacity each time the array needs to grow. */ private void ensureCapacity() { if (elements....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-05</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>4 min</span></span></footer><a class=entry-link aria-label="post link to 《Effective Java 3》笔记7：排除过时的对象引用" href=https://chensoul.github.io/posts/2023/05/05/eliminate-obsolete-object-references/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>《Effective Java 3》笔记4：用私有构造函数使类不可实例化</h2></header><section class=entry-content><p>本文是 《Effective Java 3》第二章的学习笔记：用私有构造函数使类不可实例化。
介绍 使用私有构造函数强制实现不可实例化的主要原因是防止类被意外地实例化，以使代码更加健壮和可靠。在某些情况下，我们只需要使用类中的静态方法和静态字段，而不需要创建该类的实例。如果类中没有显式地定义私有构造函数，Java 编译器将会自动为该类生成一个默认的公共构造函数，这意味着该类可以在其他类中被实例化。如果这不是我们想要的，为了防止其他人意外地实例化我们的类，我们可以将构造函数设置为私有。
此外，使用私有构造函数强制实现不可实例化还有以下优点：
明确表明该类不可被实例化，提高了代码的可读性和可维护性。 防止类被子类化，从而避免了继承所带来的副作用和不必要的复杂性。 提高了代码的安全性，防止其他类在不合适的情况下实例化该类。 这是一个实现了私有构造函数强制实现不可实例化的类的示例：
public class UtilityClass { // 禁止默认构造函数防止实例化 private UtilityClass() { throw new AssertionError(); } // 其他静态方法和字段 // ... } 这个类中的私有构造函数会在被调用时抛出AssertionError。这样做可以确保构造函数永远不会从类内部或外部调用。
通过将构造函数设置为私有，这个类就不能从外部被实例化。这个习惯用法也防止了类被子类化。如果一个类的构造函数是私有的，那么它不能被子类调用，因为子类必须调用父类的构造函数来完成初始化。因此，如果一个类的构造函数是私有的，它就不能被子类化，因为子类不能调用父类的构造函数来完成初始化。
以下是一个示例，展示了如何使用私有构造函数防止类被子类化：
public final class FinalClass { private FinalClass() { // private constructor } public static void doSomething() { // do something } } 在这个示例中，FinalClass被声明为final，因此不能被子类化。此外，它的构造函数是私有的，因此不能从子类中被调用。由于该类不能被子类化，因此它的行为不会受到子类的影响，从而避免了继承所带来的副作用和不必要的复杂性。
在某些情况下，将类设置为不能被实例化，但可以被子类化是有用的。这通常是因为我们希望子类化的类能够继承父类的行为和属性，同时又不希望外部能够实例化该类。以下是一个例子：
public abstract class Animal { private String name; protected Animal(String name) { this.name = name; } public String getName() { return name; } public abstract void makeSound(); } public class Dog extends Animal { public Dog(String name) { super(name); } @Override public void makeSound() { System....</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-05</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/java/>java</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to 《Effective Java 3》笔记4：用私有构造函数使类不可实例化" href=https://chensoul.github.io/posts/2023/05/05/enforce-noninstantiability-with-a-private-constructor/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>周报-16｜《灌篮高手》电影、《春山如笑》话剧</h2></header><section class=entry-content><p>前言 本篇是对 2023-04-17 到 2023-04-23 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。
这周的工作，手上累积了三个迭代版本，因为临近五一及其他原因，短期内无法发布上线。开发过程中，想着这些版本都会一个个上线，所以三个版本之间合并了代码，存在了依赖关系。以后，还是需要小版本迭代、上一个版本发布之后再从 main 分支合并代码。
这周先后看了《灌篮高手》电影、《春山如笑》话剧，体验了两种艺术表现形式，都让人失望。
利用空余时间，将 n8n 进行了调整，只将我在豆瓣、github、spotify、blog、strava 上的活动同步到 telegram，而直接不同步到 memos，单独创建一个 workflow 将 telegram 同步到 memos。这样 telegram 是一个对外分享的频道，而 memos 可以分享一些个人的心情或者说说。另外，为了减少对大家的干扰，不再将 rss 订阅内容同步到我的 telegram 频道。
灌篮高手 4 月 20 日，灌篮高手国内上映，抽时间下班和老婆去看了这场电影。看完之后发了一个朋友圈：
两个小时的电影，一场篮球比赛，尽是回忆，留下的是半亩良田半亩差评
这就是我对这个电影的评价。因为情怀而去看了这部电影，却被情怀出卖了，这年头情怀不值钱了么？整部电影以宫城良田为视角，不停的回忆，四十分钟的比赛节奏不停的中断。很多片段都是动画里的内容，没有多少新内容。流川枫的刻画太少、樱木花道还是那样勇猛、晴子就没出现几次。。。
看话剧 周六去中南剧场看了一个话剧《春山如笑》，这是第一次看话剧，第一次接触话剧这个艺术表现形式。相比较于电影，我还是更喜欢看电影。
理财 这周总计支出 292.5 元，明细如下：
4 月 21 日：59 元，和同事一起吃饭 4 月 22 日：232 元，周末买菜做饭，买水果 4 月 24 日：1.5 元，跑步小腿抽筋，骑共享单车回公司 四月累计支出共 2417 元，其中餐饮和购物占了一半。
健身 每天走一万步，这周完成了目标。以后每天跑步的话，这个目标就很容易达成了，甚至这个目标会换成每天跑步。
从 strava 的训练日志，可以看到本周运动记录如下：
从 strava 的训练日历，可以看到截至 24 日，本月运动了 20 天，23 次，一共跑步了 100 公里。
工作 Effective Java 3 笔记 请参考《《Effective Java 3》笔记：避免创建不必要的对象》。
上面这个图是使用 Shots 制作的，它是免费的，可以制作好看的图片，强烈推荐使用。
本周分享 虽然大部分有意思的内容会分享在 『ChenSoul Share』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。
一些文章 使用 Python 实现 RSS 转 Newsletter 5 种微服务注册中心该如何选型？ 5 Years of Indie Hacking 一个技术精致的网站：接口设计和图片加载 抛弃又贵又难用的录屏软件，3 分钟入门 FFmpeg 开始学习和使用 Rust 一些工具 EnhanceAI 使用一行代码为网站的输入框增加上 AI 能力。...</p></section><footer class=entry-footer><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-04-25</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg><span class=post-tags><a href=https://chensoul.github.io/tags/review/>review</a><a href=https://chensoul.github.io/tags/java/>java</a><a href=https://chensoul.github.io/tags/n8n/>n8n</a><a href=https://chensoul.github.io/tags/memos/>memos</a><a href=https://chensoul.github.io/tags/github/>github</a><a href=https://chensoul.github.io/tags/strava/>strava</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 min</span></span></footer><a class=entry-link aria-label="post link to 周报-16｜《灌篮高手》电影、《春山如笑》话剧" href=https://chensoul.github.io/posts/2023/04/25/weekly_review_16/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://chensoul.github.io/tags/java/page/7/>« Prev Page</a>
<a class=next href=https://chensoul.github.io/tags/java/page/9/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://chensoul.github.io/>ChenSoul</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>