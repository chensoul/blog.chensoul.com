<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Oauth2 | ChenSoul</title>
<meta name=keywords content><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/tags/oauth2/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.41fda683d7f28f86c97812787adcc91d7e2ab1225be098c611c57b4995b061db.css integrity="sha256-Qf2mg9fyj4bJeBJ4etzJHX4qsSJb4JjGEcV7SZWwYds=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/tags/oauth2/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/tags/oauth2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Oauth2"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/tags/oauth2/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Oauth2"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Oauth2
<a href=/tags/oauth2/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>All things about OAuth</h2></header><div class=entry-content><p>OAuth 是一种开放协议，允许通过网络、移动和桌面应用程序以简单、标准的方式进行安全授权。
OAuth 2 入门 以下是一些 OAuth 2.0 指南，涵盖了理解和实现客户端和服务器所需的许多主题。
OAuth 2.0 简化版 由 Aaron Parecki 编写的*《OAuth 2.0 Simplified*》是一份专注于编写客户端的 OAuth 2.0 指南，它在入门级别上清晰地概述了规范。
角色：应用程序、API 和用户
创建应用程序
授权
：获取访问令牌
Web 服务器应用程序 单页应用程序 移动应用程序 其他的 发出经过身份验证的请求
与 OAuth 1.0 的区别
身份验证和签名 用户体验和替代授权流程 规模性能 资源
OAuth 2.0 服务器 OAuth 2.0 服务器，由Aaron Parecki编写并由Okta发布，是构建 OAuth 2.0 服务器的指南，其中包括许多不属于规范的细节。
代码和库 有多种语言的客户端和服务器库可以帮助您快速入门。
图书 您可以找到一些有关 OAuth 2.0 的优秀书籍。
咨询 寻找一位OAuth 顾问来帮助您的组织。
Spring Authorization Server Spring Authorization Server官方文档
Spring Authorization Server 配置模型
Spring Authorization Server （如何使用具有 PKCE 的单页应用程序进行身份验证-1）
Spring Authorization Server （如何使用具有 PKCE 的单页应用程序进行身份验证-2）
Spring Authorization Server相关文章</p></div><footer class=entry-footer><span title='2024-06-06 00:00:00 +0800 CST'>2024-06-06</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;85 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to All things about OAuth" href=https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OAuth2和OIDC区别</h2></header><div class=entry-content><p>认证和授权 认证 (Authentication)：
认证是验证用户、设备或系统身份的过程。 常见的认证方式包括用户名/密码、生物特征(如指纹、人脸)、单点登录(SSO)等。 认证确保只有被授权的实体才能访问系统或资源。 授权 (Authorization)：
授权是确定已认证的实体被允许执行哪些操作或访问哪些资源的过程。 授权通常基于预定义的策略和规则，如角色、权限、访问控制列表(ACL)等。 授权决定了经过身份验证的实体可以执行的操作和访问的资源。 认证和授权的关系：
认证是先决条件，在授权之前必须先完成用户或实体的身份验证。 认证确保只有合法的实体可以访问系统，授权则决定了这些实体可以执行哪些操作。 认证和授权通常结合使用，共同构成完整的访问控制机制。 在实际应用中，认证和授权通常遵循以下流程:
用户或客户端提供身份凭证进行认证。 系统验证用户或客户端的身份，确认其身份有效。 根据已验证的身份，授予用户或客户端相应的访问权限和操作权限。 用户或客户端可以在授权范围内执行操作和访问资源。 OIDC OAuth 2.0 代表开放授权，是一种标准，旨在代表用户提供对资源的同意访问，而无需共享用户的凭据。OAuth 2.0 是一种授权协议，而不是身份验证协议，它主要被设计为授予对一组资源（例如远程 API 或用户数据）的访问权限的一种方式。
OAuth 2.0 仅用于授权，用于授予从一个应用程序到另一个应用程序的数据和功能的访问权限。OpenID Connect (OIDC) 是一个位于 OAuth 2.0 之上的薄层，它添加了有关登录人员的登录和个人资料信息。
​ 图片来自Azure 文档
OIDC 的工作原理 授权码流程 要验证用户身份，应用程序首先将用户的浏览器重定向到 OpenID 提供商。OpenID 提供商验证用户身份，并使用授权码将用户的浏览器重定向回应用程序。然后，应用程序使用授权码获取ID Token和Access Token：
隐式流 传统上，无法安全存储机密的应用程序会使用隐式流程。使用此流程不再被视为请求访问令牌的最佳实践。
混合流 混合流程是一种 OpenID Connect 流程，它结合了隐式流程和授权码流程的特征。它使客户端能够直接从授权端点获取一些令牌，同时仍然可以从令牌端点获取其他令牌。
OpenID 演示 您可以使用以下网站来玩自己的：https://openidconnect.net/
OAuth2 和 OIDC OAuth 2.0 和 OpenID Connect (OIDC) 是两个不同但相关的协议，它们之间有以下主要区别:
目的不同： OAuth 2.0 是一种授权框架，目的是授予第三方应用程序有限的访问权限，而不需要共享用户的凭证。 OIDC 是构建在 OAuth 2.0 之上的身份验证协议，目的是提供安全的身份验证和用户信息交换。 认证和授权的区别： OAuth 2.0 主要处理授权，即允许第三方应用程序访问受保护资源的过程。 OIDC 在 OAuth 2.0 的基础上增加了认证功能，即验证用户身份的过程。 返回的数据不同： OAuth 2.0 返回的是访问令牌(Access Token)，用于访问受保护资源。 OIDC 返回的是 ID 令牌(ID Token)，包含了有关已验证用户的声明信息。 协议流程不同： OAuth 2.0 定义了四种授权许可类型，如授权码、隐式、客户端凭证等。 OIDC 在 OAuth 2....</p></div><footer class=entry-footer><span title='2024-06-06 00:00:00 +0800 CST'>2024-06-06</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;176 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to OAuth2和OIDC区别" href=https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译][译]OAuth2 with Spring 第5部分：使用PKCE保护您的Spring Boot应用程序以增强安全性</h2></header><div class=entry-content><p>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769
免责声明：本文技术性很强，需要清楚了解本系列前几篇文章，特别是第 1 部分和第 3 部分。
带有代码交换证明密钥 (PKCE) 的授权代码流用于无法存储客户端机密的应用程序。此类应用程序包括：
原生应用程序——可以反编译并检索客户端凭证的移动应用程序。 单页应用 — 整个源代码可在浏览器中使用。因此，无法安全地存储客户端机密。 怎么运行的 Spring Boot OAuth2 与 PKCE
希望这张图已经足够清晰易懂了。因此，我将直接进入演示。
对于此演示，我们有 3 台服务器。
授权服务器：在端口 9001 上运行。 资源服务器：在端口8090上运行。 社交登录客户端（BFF）：在端口 8080 上运行。 让我们看一下代码。
授权服务器 一、pom.xml
授权服务器的 pom.xml 中没有太多需要解释的变化
application.yml.yml
application.yml文件有很多更改，特别是删除了客户端注册。当前版本的application.yml非常简短，如下所示。
server: port: 9001 logging: level: org: springframework: security: trace 三. SecurityConfig 类
所有的安全配置以及客户端和用户详细信息注册、JWT token 解码都放在此类中
@Configuration public class SecurityConfig { // This first SecurityFilterChain Bean is only specific to authorization server specific configurations // More on this can be found in this stackoverflow question answers: // https://stackoverflow.com/questions/69126874/why-two-formlogin-configured-in-spring-authorization-server-sample-code @Bean @Order(1) public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); http.getConfigurer(OAuth2AuthorizationServerConfigurer.class).oidc(withDefaults()); return http .exceptionHandling(e -> e ....</p></div><footer class=entry-footer><span title='2024-06-05 00:00:00 +0800 CST'>2024-06-05</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;900 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译][译]OAuth2 with Spring 第5部分：使用PKCE保护您的Spring Boot应用程序以增强安全性" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]OAuth2 with Spring 第1部分：了解基本概念</h2></header><div class=entry-content><p>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a
在本系列关于 Spring 的 OAuth2的文章中，我将尝试介绍和解释与 OAuth2 相关的每一个问题以及如何在 Spring 框架中实现这些问题。请记住，OAuth2 完全是一个概念性的东西，在不同的框架中，它有自己的实现。此外，许多应用程序开发人员开发自己的 OAuth2 实现，而不使用 Spring 框架提供的 OAuth2 框架支持。因此，我将就这个主题撰写一系列文章。
什么是 OAuth2 以及为什么？ 根据Octa的说法，OAuth2 是一种用于身份验证和授权的开放标准。它实际上不是一种服务，但它通过 TLS 提供基于令牌的安全性来保护服务。它使用令牌而不是凭据来授权设备、服务器、API 和应用程序。
OAuth2 的主要目的是让用户能够从单个点或提供商访问多个应用程序，这些应用程序可以使用相同的身份验证和授权信息。这意味着，并不总是需要使用用户 ID 和密码登录。相反，用户将被重定向到拥有用户身份的授权服务器，用户只需单击一下即可允许其他应用程序使用其身份验证信息。一旦获得授权，用户就可以使用来自授权服务器的相同 ID。
OAuth2 参与者和授权类型 a) 参与者
对于 OAuth2 架构，有 4 个参与者 -
资源所有者——在授权服务器中拥有自己的授权信息（通常是用户名、密码、角色等）的用户 客户端——客户端可以被视为资源所有者能够请求资源服务器中受保护资源的应用程序 授权服务器——位于客户端和资源所有者中间，检查身份验证和授权的服务器 资源服务器——包含资源 所有者想要访问的资源。 b) 授权类型
OAuth2 有几种授权类型来请求访问令牌。授权类型的唯一目的是生成访问令牌。授权类型包括：
授权码— 为了接收访问令牌，授权客户端向授权服务器发送请求以及先前从授权服务器收到的授权码。本系列的第 3 部分专门介绍此授权码授予。 **PKCE —**代码交换证明密钥 (PKCE) 是授权代码授予的扩展版本，旨在支持单页应用程序或移动应用程序，以防止 CSRF 或授权代码注入攻击。PKCE 最初旨在保护移动应用程序中的授权代码流，但其防止授权代码注入的能力使其适用于每种类型的 OAuth 客户端，甚至是使用客户端身份验证的 Web 应用程序。本系列的第 5 部分描述了此流程的代码示例。 客户端凭证— 在此流程中，客户端应用程序使用 client_id 和 client_secret 进行请求，授权类型为 client_credential。这通常发生在使用服务的第三方应用程序中。本系列的第 2 部分专门介绍此客户端凭证。 刷新令牌授权— 此授权类型由客户端使用。当访问令牌过期时，存储在客户端内存中的刷新令牌将以授权类型 refresh_token 发送到授权服务器。服务器将返回一个新的 access_token。我们不会专门写一篇文章，因为它主要由应用程序内部处理。 了解接收访问令牌的工作流程 OAuth 工作流
为了请求资源服务器中的某些资源，资源所有者需要访问令牌 资源所有者打开一个应用程序（可能是授权服务器的客户端，在上图中为 BusinessClient）来请求资源服务器中的一些安全资源。 当资源所有者请求没有任何令牌的资源时，他/她可以选择授权服务器。 选择后，客户端将被重定向到授权服务器 (OAuthSercer)。授权服务器要求输入用户名和密码（以及grant_type）。 资源所有者提供所需信息并提交。如果信息真实，授权服务器将访问令牌（以及其他信息，可选）发送给客户端。 客户端保存令牌并在内部创建对资源的请求，这是资源所有者在没有令牌时提出的。 收到令牌后，资源服务器将其发送到授权服务器以验证令牌。 如果授权服务器向资源服务器提供了肯定的响应，资源服务器将响应资源所有者请求的信息。 这就是整个过程的工作原理。在我的下一篇文章中，我将深入研究代码并演示使用内存客户端的 OAuth2 实现。
参考： OAuth2 授权类型 — https://oauth.net/2/grant-types/ OAuth2 角色 - http://websystique....</p></div><footer class=entry-footer><span title='2024-06-05 00:00:00 +0800 CST'>2024-06-05</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;104 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]OAuth2 with Spring 第1部分：了解基本概念" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]OAuth2 with Spring 第2部分：授权服务器入门</h2></header><div class=entry-content><p>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-2-getting-started-with-authorization-server-13804910cb2a
Spring 团队最近发布了他们的授权服务器。OAuth2 一直是一个热门话题，而构建或理解授权服务器一直是一个谜。在本系列的第 1 部分中，我描述了几乎所有您需要了解的有关 OAuth2 的概念性内容。在本系列的这篇文章中，我将尝试演示如何构建具有client_credential授权类型的授权服务器。我将从使用配置属性进行自动配置开始解释它们，并通过编写 Java 代码自定义配置。让我们开始吧。
设置授权服务器 让我们转到Spring Initializr并生成项目。
为了创建授权服务器，我们需要 Oauth2 授权服务器依赖。
&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-oauth2-authorization-server&lt;/artifactId> &lt;/dependency> 生成项目并导入到您最喜欢的 IDE。
现在让我们在application.yml中添加我们想要的配置。
在第 1 部分中，我们了解到我们需要一个客户端来从授权服务器获取令牌。因此，我们需要授权服务器有一些客户端信息。在 application.yml 中，我将放置获取令牌和其他授权信息所需的最少客户端信息。
spring: security: oauth2: authorization-server: client: client-1: registration: client-id: client client-secret: "{noop}secret" client-authentication-methods: client_secret_basic authorization-grant-types: client_credentials 根据上面的配置属性，我们注册了一个客户端client-1。
对于client-1，我们定义了 4 个属性：
clientId client-secret client-authentication-methods：本例中为基本身份验证（client_secret_basic） authorization-grant-types：用于请求新令牌的授予类型。在本例中为 client_credentials。 现在，我们必须启动授权服务器应用程序。
接下来，在 postman 中，我们向*/oauth2/token端点发出 POST 请求以获取令牌。为什么是/oauth2/token*端点？
我们可以看到，一旦我们提交请求，我们就会收到详细的令牌信息。
瞧，我们最小的授权服务器现在已经启动并运行了。
该项目的链接可以在这里找到。
问题 1. 我们在哪里找到默认令牌端点？
答：在 OAuth2 的 RFC 中，它提到默认令牌端点应该是*/token*。但是，很难找到 Spring Boot 授权服务器的默认令牌端点。我不得不浏览源代码。在类OAuth2TokenEndpointFilter中，提到了默认令牌端点。
感谢您的耐心阅读。在下一篇文章中，我们将尝试创建一个资源服务器，使用authorization_code授权获取令牌以访问一些私人数据。</p></div><footer class=entry-footer><span title='2024-06-05 00:00:00 +0800 CST'>2024-06-05</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;73 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]OAuth2 with Spring 第2部分：授权服务器入门" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-2-getting-started-with-authorization-server/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端</h2></header><div class=entry-content><p>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a
在上一篇文章中，我们讨论了使用 client_credential 的 OAuth2 授权服务器配置。在本文中，我们将讨论使用 authorization_code 授予类型的授权服务器配置。此授权流程将有一个 OIDC 客户端，它将通过使用授权码进行请求来获取 JWT 令牌。
如今，社交登录非常流行，它已由 OAuth2 和 OIDC 规范标准化。我们今天的讨论主题是设置我们的社交登录客户端 (oidc-client) 应用程序，将其注册到 Spring Boot 授权服务器，使用授权服务器登录并从 OIDC 客户端应用程序访问安全资源。
今天的演示将包含 2 个应用程序：
授权服务器（端口 8080） 社交登录客户端（端口 8081） 由于这是一个复杂的主题，让我们首先查看 UI 中的应用程序身份验证和授权流程，然后再讨论配置。
要继续阅读本文，请从此处获取项目源代码。首先启动授权服务器应用程序，然后在您最喜欢的 IDE 上启动社交登录客户端应用程序。
我们的社交登录客户端有 2 个端点：
“/” 将使我们能够访问公共数据 “/private-data” 将为我们提供 JWT 令牌 在浏览器上，导航到“ http://127.0.0.1:8081/private-data ”。这将带我们进入客户端应用程序的登录页面。
由于我们对社交登录感兴趣，因此不要在此登录页面中输入您的用户名和密码，而是单击oidc-client。它将带您进入授权服务器的登录页面。
在下面的屏幕中输入“ user”作为用户名，输入“ secret”作为密码，然后单击“登录”。
这将带您进入同意页面。请注意同意页面的以下 URL：
http://localhost:8080/oauth2/authorize?response_type=code&amp;client_id=oidc-client&amp;scope=openid%20profile%20read%20write&amp;state=PcF7UjHDmYvmhwpKfv9zVosy0ZBIA2pZe7HHPixZ76E%3D&amp;redirect_uri=http://127.0.0.1:8081/login/oauth2/code/oidc-client&amp;nonce=_KHIsN6mNur-AFQz5KNK0TnZi3VPmj567qbe8-4zPMo&amp;continue
从上面的URL我们可以找到几条信息：
response_type=code client_id=oidc-client scope = openid, profile, read, write redirect_uri=http://127.0.0.1:8081/login/oauth2/code/oidc-client 现在，从上面的页面提供您想要允许客户端应用程序的同意。
如果最初请求的URL（/private-data）具有您刚刚提供的正确同意，它将向我们提供访问令牌和刷新令牌，否则它将显示403错误页面。
现在让我们深入研究代码。
授权服务器配置 在这个应用程序中，所有的事情都在 application.yml 文件中完成。Java 方面没有什么内容，除了主类。
spring: security: user: # Definition of the user details that we will use for login # in the authorization server name: user password: "{noop}secret" roles: USER # Oauth2 client registration starts from here oauth2: authorization-server: client: # We have defined only one client: oidc-client # This client information was also mentioned # in the above URL: client_id=oidc-client oidc-client: registration: # The following client ID and client secret will be matched with the # provided client credentials from client application client-id: oidc-client client-secret: "{noop}secret2" # The following authorization-grant-type will be matched with the # provided authorization-grant-type from the client application authorization-grant-types: - "authorization_code" - "refresh_token" client-authentication-methods: - client_secret_basic # This following redirect URI will be used to redirect the resource owner to the # Client application after the resource owner (user) provides necessary consents....</p></div><footer class=entry-footer><span title='2024-06-05 00:00:00 +0800 CST'>2024-06-05</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;778 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]OAuth2 with Spring 第4部分：Spring授权客户端与Google授权服务器的社交登录演示</h2></header><div class=entry-content><p>原文地址：https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5
在之前的文章中，我们学习了如何使用 OIDC 连接到我们自己的授权服务器。我们在自托管授权服务器中定义了我们自己的客户端应用程序。在今天的文章中，我们将使用 Google 和 GitHub 作为我们的授权服务器，并将我们的授权客户端应用程序连接到这些授权服务器并从它们接收令牌。应用程序登录屏幕将如下所示。
为了实现这一点，我们需要将我们的授权客户端应用程序注册为 Google 授权服务器中的客户端，并使用客户端应用程序中的客户端凭据以及可用范围。
Google 授权服务器中的客户端注册 我们需要在 Google 开发者控制台中创建一个应用程序并配置必要的内容。
打开浏览器并转到https://console.developers.google.com/。您将看到如图 1 所示的屏幕。
图。1
从这里，选择下拉菜单以选择一个项目（1.1）。它将显示一个像上面一样的弹出窗口。从弹出窗口中，单击**“新建项目”按钮（1.2）。由于我已经创建了我的应用程序并将我的应用程序命名为google-auth-server-demo（1.3），所以我不会再创建新的应用程序了。
创建应用程序后，从上面的屏幕中选择您的应用程序，您将看到仪表板。从左侧导航中，单击API 和服务和页面。由于我们目前对列表中的任何 Google 服务都不感兴趣，我们可以单击左侧导航中的凭据 (2.1) 。但如果您有兴趣从客户端应用程序中使用任何 Google 服务，您可能会发现这篇文章很有趣，我在其中演示了如何访问 Google Drive 数据。
图 2
它将带我们进入以下页面。
图 3
从这里，我们可以创建新的凭证 (3.1)。由于我们已经创建了凭证 (3.2)，我们可以编辑它 (3.3) 以查看我们如何配置它。
图 4
在客户端注册页面，我们配置了客户端名称（4.1）、授权 JS 来源（4.2）以注册以应对 CORS 安全问题，授权重定向 URI（4.3）。当我们第一次点击保存按钮（4.4）时，它会为我们生成客户端 ID（4.5）和客户端密钥（4.6）。
我们需要在客户端应用程序的配置文件即application.yml中使用这些客户端ID、客户端密钥和重定向URI。
在授权客户端 application.yml 文件中使用上述信息：
该配置与我们第 3 部分的客户端配置部分非常相似。
spring: security: oauth2: client: registration: google: client-id: "615531537634-806j95c1s18uundif9nl4oggcag7lcm6.apps.googleusercontent.com" client-secret: "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" redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}" 现在，我们需要在 Google 授权服务器中设置同意屏幕，以允许客户端应用程序请求所需的范围。
要进入同意屏幕，我们需要单击左侧导航栏中的Oauth 同意屏幕（5.1）。
图 5
我已经创建了同意屏幕，所以让我们通过编辑应用程序看看我做了什么（5.2）
图 6
此屏幕已在屏幕右侧详细记录（6.1）。遵循这些准则并保存以继续执行步骤 2：范围（6.2）
图 7
在上面的屏幕上，单击**“添加或删除范围”按钮 (7.1)，右侧会打开一个弹出窗口。从这个弹出窗口中，我们为我们的演示 (7.2) 选择了几个最低要求的范围，然后单击“更新”**按钮 (7.3)。更新后，这些范围将显示在图 7 的 (7.4) 部分中。
当我们从此范围步骤单击**“保存并继续”**按钮时，我们可以从客户端应用程序添加一些测试用户来测试。
图 8
为了测试目的，我们只允许 2 个用户（8.1）。
现在，一旦我们保存了步骤 3 和步骤 4，我们就可以准备在客户端应用程序中使用这些范围了。...</p></div><footer class=entry-footer><span title='2024-06-05 00:00:00 +0800 CST'>2024-06-05</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;157 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]OAuth2 with Spring 第4部分：Spring授权客户端与Google授权服务器的社交登录演示" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]OAuth2.0服务器</h2></header><div class=entry-content><p>背景 前言 作者：Aaron Parecki
我第一次接触 OAuth 是在 2010 年，当时我正在构建一个 API，我知道我希望第三方开发人员能够在其基础上构建应用程序。当时，OAuth 看起来令人生畏。OAuth 1 的实现只有少数几个，而 OAuth 2.0 仍是一个草稿。一天晚上，我决定坐下来，拿着精酿啤酒和最新草案的纸质副本，从头到尾阅读它，直到我理解它。
在仔细阅读了长达 44 页的规范后，我学到了以下几点：阅读规范并不是了解 OAuth 工作原理的最佳方式，而且 OAuth 2.0 远没有我最初想象的那么复杂。我开始撰写一份简化的规范概述，当我第一次学习这个规范时，我希望它就存在。我将其作为一篇名为“OAuth 2.0 简化版”的博客文章发布在我的网站上。现在，这篇文章每年的阅读量达到数十万次。很明显，人们知道 OAuth 2.0 是保护其 API 的正确选择，并且正在寻找资源来帮助理解它。
我一直想将这篇博文扩展为更全面的 OAuth 服务器指南，2016 年，我与 Okta 取得了联系，我们在oauth.com上发布了这个新 OAuth 指南的第一个版本。2017 年，我们合作出版了这本书的印刷版，并于 2018 年和 2020 年出版了修订版。
我希望这本书能让 OAuth 2.0 更加平易近人，并为您在继续使用 Web 技术时提供坚实的知识基础。
背景 在 OAuth 出现之前，向第三方应用授予您帐户访问权限的常见模式是简单地向其提供您的密码并允许其以您的身份行事。我们经常在 Twitter 应用中看到这种情况，这些应用会要求您提供 Twitter 密码，以便向您提供一些帐户统计数据，或者要求能够从您的帐户发送推文以换取一些有价值的东西。
这种应用程序获取用户密码的模式显然存在许多问题。由于应用程序需要以用户身份登录服务，因此这些应用程序通常会以纯文本形式存储用户的密码，这使它们成为密码窃取的目标。一旦应用程序获得了用户的密码，它就可以完全访问用户的帐户，包括访问更改用户密码等功能！另一个问题是，在向应用程序提供密码后，您能够撤销该访问权限的唯一方法是更改密码，而用户通常不愿意这样做。
自然，许多服务很快意识到了这种模式的问题和局限性，并寻求快速解决。许多服务实现了类似于 OAuth 1.0 的东西。Flickr 的 API 使用了所谓的“FlickrAuth”，它使用了“frobs”和“tokens”。谷歌创建了“AuthSub”。Facebook 选择向每个应用程序发布一个秘密，并要求应用程序使用该秘密的 md5 哈希对每个请求进行签名。雅虎创建了“BBAuth”（基于浏览器的身份验证）。结果产生了各种各样的解决方案，彼此完全不兼容，并且经常无法解决某些安全问题。
2006 年 11 月左右，Twitter 首席架构师布莱恩·库克 (Blaine Cook) 正在寻找一种更好的 Twitter API 身份验证方法，这种方法不需要用户向第三方应用程序透露他们的 Twitter 密码。
我们想要类似 Flickr Auth / Google AuthSub / Yahoo! BBAuth 的东西，但以开放标准的形式发布，具有通用的服务器和客户端库等。
– 布莱恩·库克，2007 年 4 月 5 日
2007 年，一群致力于 OpenID 开发的人员聚在一起，创建了一个邮件列表，旨在制定 API 访问控制标准提案，该提案可供任何系统使用，无论其是否使用 OpenID。最初的这个小组包括 Blaine Cook、Kellen Elliott-McCrea、Larry Halff、Tara Hunt、Ian McKeller、Chris Messina 和其他一些人。...</p></div><footer class=entry-footer><span title='2024-06-05 00:00:00 +0800 CST'>2024-06-05</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;6389 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]OAuth2.0服务器" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2-server/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]OAuth2简化版</h2></header><div class=entry-content><p>这篇文章以简化的格式描述了 OAuth 2.0，以帮助开发人员和服务提供商实现该协议。
OAuth 2 规范读起来可能有点混乱，所以我写了这篇文章来帮助以简化的格式描述术语。核心规范将许多决策留给实现者，通常基于实现的安全权衡。这篇文章没有描述成功实施 OAuth 2 所需的所有可能决策，而是做出适用于大多数实现的决策。
注意：本文已根据 OAuth 2.0 的当前最佳实践从原始 2012 版本更新而来。原始版本可以在这里找到。
角色 第三方应用程序：“客户端” 客户端是尝试访问用户帐户的应用程序。它需要先获得用户的许可，然后才能执行此操作。
API：“资源服务器” 资源服务器是用于访问用户信息的 API 服务器。
授权服务器 这是提供用户批准或拒绝请求的接口的服务器。在较小的实现中，这可能与 API 服务器是同一台服务器，但更大规模的部署通常会将其构建为单独的组件。
用户：“资源所有者” 资源所有者是授予访问其帐户某些部分的权限的人员。
创建应用程序 在开始 OAuth 过程之前，必须先向服务注册新应用。注册新应用时，通常会注册应用名称、网站、徽标等基本信息。此外，还必须注册一个重定向 URI，用于将用户重定向到 Web 服务器、基于浏览器的应用程序或移动应用程序。
重定向 URI 该服务只会将用户重定向到已注册的 URI，这有助于防止某些攻击。任何 HTTP 重定向 URI 都必须通过 HTTPS 提供。这有助于防止令牌在授权过程中被截获。本机应用可能会使用应用程序的自定义 URL 方案注册重定向 URI，这可能类似于 demoapp://redirect .
客户端 ID 和密码 注册应用后，你将收到一个客户端 ID 和一个（可选）的客户端密码。客户端 ID 被视为公共信息，用于构建登录 URL，或包含在页面上的 Javascript 源代码中。客户端密码必须保密。如果已部署的应用无法对机密保密，例如单页 Javascript 应用或本机应用，则不会使用该密钥，理想情况下，该服务首先不应向这些类型的应用发布机密。
授权 OAuth 2 的第一步是从用户那里获得授权。对于基于浏览器或移动的应用程序，这通常是通过向用户显示服务提供的界面来实现的。
OAuth 2 为不同的用例提供了几种“授权类型”。定义的授权类型包括：
Authorization Code 在 Web 服务器、基于浏览器的应用程序和移动应用程序上运行的应用程序的授权代码
Password 使用用户名和密码登录的密码（仅适用于第一方应用）
Client credentials 在没有用户在场的情况下进行应用程序访问的客户端凭据
Implicit 隐式以前被推荐给没有秘密的客户端，但已被使用授权代码授予与PKCE取代。
下面将详细介绍每个用例。
Web 服务器应用程序 Web 服务器应用程序是您在处理 OAuth 服务器时遇到的最常见的应用程序类型。Web 应用程序是用服务器端语言编写的，并在应用程序源代码不向公众开放的服务器上运行。这意味着应用程序在与授权服务器通信时能够使用其客户端密钥，这有助于避免许多攻击媒介。
授权 创建一个“登录”链接，将用户发送到：
https://authorization-server.com/auth?response_type=code& client_id=CLIENT_ID&amp;redirect_uri=REDIRECT_URI&amp;scope=photos&amp;state=1234zyx response_type=code 指示您的服务器希望收到授权代码 client_id 首次创建应用程序时收到的客户端 ID redirect_uri 示授权完成后要将用户返回到的 URI scope 一个或多个范围值，指示您希望访问用户帐户的哪些部分 state 应用程序生成的随机字符串，稍后将对其进行验证 用户看到授权提示...</p></div><footer class=entry-footer><span title='2024-06-05 00:00:00 +0800 CST'>2024-06-05</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;526 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]OAuth2简化版" href=https://blog.chensoul.cc/posts/2024/06/05/oauth-2-simplified/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RFC6749 | OAuth2.0授权框架中文版</h2></header><div class=entry-content><p>前言 摘要 OAuth2.0 授权框架允许第三方应用获取对 HTTP 服务的有限的访问权限，既可以以资源所有者名义在资源所有者和 HTTP 服务之间进行允许的交互，也可以允许第三方应用以自己的名义进行访问。本规范取代并淘汰 RFC 5849 中描述的 OAuth 1.0 协议。
本备忘录状态 这是一个互联网标准化过程文档。
本文档是互联网工程任务组（IETF）的作品。它代表了 IETF 社区的一致看法。它已接受公开审阅并由互联网工程指导小组（IESG）批准公布。有关互联网标准的进一步信息可在 RFC 5741 的第 2 节找到。
有关本文档的当前状态、勘误表以及如何对它提供反馈可参见 http://www.rfc-editor.org/info/rfc6749。
版权声明 IETF 信托及标识为本文档的作者的个人版权所有（c）2012。保留所有权利。
本文档受 BCP78 和 IETF 信托有关 IETF 文档的法律条款 (http://trustee.ietf.org/license-info)的约束，自本文档发布之日起生效。请仔细查阅这些文件，因为它们描述了与本文档有关的权利和限制。从本文档中提取的代码片段必须按信托法律条款 4.e 节所述包括简化 BSD 许可证文本；并且按简化 BSD 许可证中所述不附带质量保证。
目录 [toc]
1. 简介 在传统的客户端-服务器身份验证模式中，客户端请求服务器上限制访问的资源（受保护资源）时，需要使用资源所有者的凭据在服务器上进行身份验证。资源所有者为了给第三方应用提供受限资源的访问，需要与第三方共享它的凭据。 这造成一些问题和局限：
需要第三方应用存储资源所有者的凭据，以供将来使用，通常是明文密码。 需要服务器支持密码身份认证，尽管密码认证天生就有安全缺陷。 第三方应用获得的资源所有者的受保护资源的访问权限过于宽泛，从而导致资源所有者失去对资源使用时限或使用范围的控制。 资源所有者不能在不撤销对所有第三方的访问权限的情况下撤销对单个第三方的访问权限，而且必须通过更改第三方的密码来这样做。 与任何第三方应用的让步导致对终端用户的密码及该密码所保护的所有数据的让步。 OAuth 通过引入授权层以及分离客户端角色和资源所有者角色来解决这些问题。在 OAuth 中，客户端在请求受资源所有者控制并托管在资源服务器上的资源的访问权限时，将被颁发一组不同于资源所有者所拥有凭据的凭据。
客户端获得一个访问令牌（一个代表特定作用域、生命期以及其他访问属性的字符串），用以代替使用资源所有者的凭据来访问受保护资源。访问令牌由授权服务器在资源所有者认可的情况下颁发给第三方客户端。客户端使用访问令牌访问托管在资源服务器的受保护资源。
例如，终端用户（资源所有者）可以授权一个打印服务（客户端）访问她存储在图片分享服务（资源服务器）上的受保护图片，而无需与打印服务分享自己的用户名和密码。反之，她直接与图片分享服务信任的服务器（授权服务器）进行身份验证，该服务器颁发给打印服务具体委托凭据（访问令牌）。
本规范是为 HTTP（[RFC2616]）协议定制。在任何非 HTTP 协议上使用 OAuth 不在本规范的范围之内。
OAuth 1.0 协议（[RFC5849]）作为一个指导性文档发布，是一个小社区的工作成果。本标准化规范在 OAuth 1.0 的部署经验之上构建，也包括其他使用案例以及从更广泛的 IETF 社区收集到的可扩展性需求。OAuth 2.0 协议不向后兼容 OAuth 1.0。这两个版本可以在网络上共存，实现者可以选择同时支持他们。然而，本规范的用意是新的实现支持按本文档指定的 Auth 2.0，OAuth 1.0 仅用于支持现有的部署。OAuth 2.0 协议与 OAuth 1.0 协议实现细节没有太多关联。熟悉 OAuth 1.0 的实现者应该学习本文档，而不对有关 OAuth 2.0 的结构和细节做任何假设。
1.1. 角色 OAuth 定义了四种角色：
资源所有者
能够授予对受保护资源访问权限的实体。当资源所有者是一个人时，它被称为终端用户。
资源服务器...</p></div><footer class=entry-footer><span title='2024-06-05 00:00:00 +0800 CST'>2024-06-05</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;3882 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to RFC6749 | OAuth2.0授权框架中文版" href=https://blog.chensoul.cc/posts/2024/06/05/oauth2/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://blog.chensoul.cc/tags/oauth2/page/2/>Next&nbsp;2/3&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>