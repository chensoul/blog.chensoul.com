<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Oauth2 | ChenSoul</title>
<meta name=keywords content><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/tags/oauth2/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/tags/oauth2/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/tags/oauth2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Oauth2"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/tags/oauth2/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Oauth2"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Oauth2
<a href=/tags/oauth2/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]如何在Spring Boot2中使用UserDetailsService实现安全性？</h2></header><div class=entry-content><p>继续上一篇关于实现 Spring Security 的两种不同方法的文章，在本文中，我们将学习第三种方法“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现 Security？”。经过上一篇文章后，我希望我们都非常熟悉安全性的基础知识，甚至是 Spring Boot 应用程序中的安全性基础知识。这次我们将创建一个用户注册表并将用户及其角色保存到数据库中。
然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
如果您正在寻找“如何在 Spring Boot 3 及以上版本中使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”，请访问有关使用 Spring Boot 3 的 Spring Security UserDetailsS​​ervice 的单独文章。
为了说明这一点，我们将把一些角色发挥作用，并在整个过程中围绕它们进行发挥，以使其变得清晰。此外，我们将有一些页面并限制它们仅可由某些特定角色访问。同样重要的是，我们必须创建一个小型 MVC Web 应用程序，以使注册过程向用户开放。用户在注册时将输入自己的角色。然后我们可以在其之上实现安全功能。
让我们开始相应的主题“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”。
总体而言，您对这篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 在 Spring Security 应用程序中如何内部工作并带有流程图？
另外，如何使用注解：@EnableWebSecurity、@Configuration、@Bean、@GetMapping、@Autowired、@Data、@Entity、@Table、@Id、@GenerateValue、@Column、@ElementCollection、@CollectionTable、@JoinColumn ， @服务
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 是做什么的？使用它有什么好处？ UserDetailsS​​ervice 是 Spring 中 org.springframework.security.core.userdetails 包下的预定义接口。我们的实现类实现了这个接口并重写了它的 loadUserByUsername(String username) 方法。此方法返回 UserDetails，它又是一个接口。预定义的 User 类（org.springframework.security.core.userdetails.User）是 UserDetails 接口的实现。总之，在 loadUserByUsername(String username) 方法中，我们传递用户名，它返回我们预定义的 User 对象（org....</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1597 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何在Spring Boot2中使用UserDetailsService实现安全性？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot2-using-userdetailsservice/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]如何在Spring Boot3中使用UserDetailsService实现安全性？</h2></header><div class=entry-content><p>作为有关 Spring Security 的系列文章的继续，在本文中我们将学习“如何在 Spring Boot 3 中使用 UserDetailsService 实现 Spring Boot 中的安全性？”。经过前面的文章，我希望我们都非常熟悉安全性的基础知识，甚至 Spring Boot 应用程序中的安全性基础知识。 Spring Boot 3 发布后，我们将在这里实现“使用 Spring Boot 3 的 Spring Security UserDetailsService”。
在本文中，我们将创建一个用户注册表单并将用户及其角色保存在数据库中。然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
您对整篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 Spring Boot 3 实现 Spring Security UserDetailsService？
如何在基于 Spring 的应用程序中实现基于角色的安全性？
此外，如何以及在哪里使用注释：@EnableWebSecurity，@Configuration，@Bean，@GetMapping，@Autowired，@Data，@Entity，@Table，@Id，@GenerateValue，@Column，@ElementCollection，@CollectionTable， @JoinColumn，@Service
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
示例中使用的软件/技术 有时某些版本与其他版本冲突。因此，列出经过测试可以相互协作的组合。下面是经过测试的软件组合，用于使用 Spring Boot 3 开发 Spring Security UserDetailsS​​ervice。它也使实现完美无缺。
Spring Boot 3.0.0
JDK 17 or later
Maven 3.8.1 3）Maven 3.8.1
IDE – STS 4.7.1. RELEASE
IDE – STS 4.7.1。发布
Jars Used 下面是这些示例中 maven 使用 pom....</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1651 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]如何在Spring Boot3中使用UserDetailsService实现安全性？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot3-using-userdetailsservice/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]没有WebSecurityConfigurerAdapter的Spring Security.md</h2></header><div class=entry-content><p>在 Spring Security 模块的上下文中，WebSecurityConfigurerAdapter 是一个抽象类，根据 Spring 官方网站 2022 年 2 月 21 日发布的公告，该类已从 Spring Security 5.7.0-M2 中弃用。它通常用于扩展 configure() 方法由自定义配置子类实现。因此，它鼓励用户转向基于组件的安全配置。为了支持对这种新配置设计的更改，我们将讨论常见用例列表和未来建议的替代方案。因此，我们将讨论没有 WebSecurityConfigurerAdapter 的 Spring Security 用例的实现。
了解这一变化很重要，因为迟早我们将使用最新版本的 Spring Security 来开发安全功能。让我们讨论“没有 WebSecurityConfigurerAdapter 的 Spring Security”主题及其相关概念。
什么是 WebSecurityConfigurerAdapter？ WebSecurityConfigurerAdapter 是 Spring Security 模块提供的一个抽象类。一般来说，我们使用它来重写它的 configure()方法来定义我们的安全配置类。通常，我们在应用程序中实现 Spring Security 时使用两个具有不同参数的 configure() 方法。一种用于声明与身份验证相关的配置，另一种用于声明与授权相关的配置。该代码类似于下面的代码片段。
@Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // configure Authentication ...... } @Override protected void configure(HttpSecurity http) throws Exception { // configure Authorization ...... } } 为什么我们需要学习这个改变？ 如果您使用 Spring Boot 2.7.0 和 maven，它将自动下载 Spring Security 5.7.0 或更高版本。在这种情况下，您会发现 WebSecurityConfigurerAdapter 已被弃用。如果您仍然想使用此类而不弃用，您可以在 pom.xml 中将 Spring Boot 版本更改为较低版本（例如 2.6.6 ），如下所示。它将自动下载低于 5....</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;882 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]没有WebSecurityConfigurerAdapter的Spring Security.md" href=https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security - OAuth2</h2></header><div class=entry-content><p>OAuth 2.0 基础知识 OAuth 2.0 由 IETF OAuth 工作组开发并于 2012 年 10 月发布。它作为一种开放授权协议，使第三方应用程序能够代表资源所有者对 HTTP 服务进行有限访问。它可以在不泄露用户身份或长期凭证的情况下做到这一点。第三方应用程序本身也可以代表其使用它。
OAuth 的工作原理包括将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问用户的帐户。
让我们考虑一个例子。假设我们要登录网站“clientsite.com”。我们可以通过 Facebook、Github、Google 或 Microsoft 登录。我们选择上面给出的选项中的任何选项，然后我们将被重定向到相应的网站进行登录。如果登录成功，系统会询问我们是否要授予 clientsite.com 访问其请求的特定数据的权限。
我们选择所需的选项，然后使用授权代码或错误代码重定向到 clientsite.com，登录是否成功取决于我们在第三方资源中的操作。这就是 OAuth 2 的基本工作原理。
OAuth 系统涉及五个关键角色。让我们把它们列出来 -
User / Resource Owner − 用户/资源所有者- 最终用户，负责身份验证并同意与客户端共享资源。 User-Agent − 用户代理- 用户使用的浏览器。 Client − 客户端 - 请求访问令牌的应用程序。 Authorization Server − 授权服务器- 用于验证用户/客户端的服务器。它颁发访问令牌并在其整个生命周期内对其进行跟踪。 Resource Server − 资源服务器- 提供对所请求资源的访问的 API。它验证访问令牌并提供授权。 入门 我们将使用 Spring Security 和 OAuth 2.0 开发一个 Spring Boot 应用程序来说明上述内容。我们现在将开发一个带有内存数据库的基本应用程序来存储用户凭据。该应用程序将使我们轻松了解 OAuth 2.0 与 Spring Security 的工作原理。
让我们使用 Spring 初始化程序在 Java 8 中创建一个 Maven 项目。让我们从 start.spring.io 开始。我们生成一个具有以下依赖项的应用程序 -
Spring Web Spring Security Cloud OAuth2 Spring Boot Devtools 通过上面的配置，我们点击 Generate 按钮生成一个项目。该项目将以 zip 文件形式下载。我们将 zip 解压到一个文件夹中。然后我们可以在我们选择的 IDE 中打开该项目。我在这里使用 Spring Tools Suite，因为它针对 Spring 应用程序进行了优化。我们也可以根据需要使用 Eclipse 或 IntelliJ Idea。...</p></div><footer class=entry-footer><span title='2023-08-16 00:00:00 +0000 UTC'>2023-08-16</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;720 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security - OAuth2" href=https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-oauth2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security 和 Spring Boot 入门</h2></header><div class=entry-content><p>Spring Security 是一个有助于保护企业应用程序安全的框架。通过与 Spring MVC、Spring Webflux 或 Spring Boot 集成，我们可以创建一个强大且高度可定制的身份验证和访问控制框架。在本文中，我们将解释核心概念并仔细研究 Spring Security 提供的默认配置及其工作原理。我们将进一步尝试自定义它们并分析它们对示例 Spring Boot 应用程序的影响。
示例代码 本文附有 GitHub 上的工作代码示例。
创建示例应用程序 让我们从头开始构建一个 Spring Boot 应用程序，看看 spring 如何配置和提供安全性。让我们从 spring starter 创建一个应用程序并添加所需的最少依赖项。
生成项目后，我们将其导入到 IDE 中并将其配置为在端口 8083 上运行。
mvnw clean verify spring-boot:run (for Windows) ./mvnw clean verify spring-boot:run (for Linux) 在应用程序启动时，我们应该看到一个登录页面。
控制台日志打印作为默认安全配置的一部分随机生成的默认密码：
使用默认用户名 user 和默认密码（来自日志），我们应该能够登录该应用程序。我们可以在 application.yml 中覆盖这些默认值：
spring: security: user: name: admin password: passw@rd 现在，我们应该能够使用用户 admin 和密码 passw@rd 登录。
依赖版本 在这里，我们使用了 Spring Boot 2.7.5 版本。基于此版本，Spring Boot 内部将 Spring Security 版本解析为 5.7.4。但是，如果需要，我们可以在 pom.xml 中覆盖这些版本，如下所示：
&lt;properties> &lt;spring-security.version>5.2.5.RELEASE&lt;/spring-security.version> &lt;/properties> 了解安全组件 要了解默认配置的工作原理，我们首先需要了解以下内容：
Servlet Filters 过滤器 Authentication 认证 Authorization 授权 Servlet Filters 让我们仔细看看应用程序启动时的控制台日志。我们看到 DefaultSecurityFilterChain 在请求到达 DispatcherServlet 之前触发一系列过滤器。 DispatcherServlet 是 Web 框架中的关键组件，用于处理传入的 Web 请求并将它们分派到适当的处理程序进行处理。...</p></div><footer class=entry-footer><span title='2023-08-16 00:00:00 +0000 UTC'>2023-08-16</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2064 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security 和 Spring Boot 入门" href=https://blog.chensoul.cc/posts/2023/08/16/spring-security/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring Security和OAuth2发展过程</h2></header><div class=entry-content><p>Spring Security 的发展过程 Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分，于 2004 年发布，现在已经成为 Spring 生态系统的核心组件。 Spring Security 的发展过程可以分为三个阶段：
第一阶段：Spring Security 起源于一个名为 Acegi Security 的开源项目，初期重点实现了 Spring 应用的身份认证和授权服务功能。2003 年，Acegi Security 作为一个孵化项目被捐献给 Spring 社区。2004 年，正式作为 Spring 框架的核心组件之一 Absorbed 进 Spring。并更名为 Spring Security。Spring Security 1.0 版本 Spring Security 1.0 版本发布于 2004 年。它提供了最基本的安全功能，包括身份验证和授权。身份验证是验证用户是否是他们所声称的人的过程。授权是确定用户是否有权访问特定资源的过程。 Spring Security 1.0 版本使用了以下技术来实现身份验证和授权：
表单身份验证：表单身份验证是通过用户提交表单来验证用户身份的过程。 基于角色的访问控制 (RBAC)：RBAC 是一种授权模型，它将用户分配到角色，然后这些角色被授予对特定资源的访问权限。 第二阶段：Spring Security 2.0 版本 Spring Security 2.0 版本发布于 2006 年。它提供了更多的安全功能，包括加密和会话管理。加密是将数据转换成无法被他人理解的形式的过程。会话管理是跟踪用户会话的状态的过程。 Spring Security 2.0 版本使用了以下技术来实现加密和会话管理：
安全套接字层 (SSL)：SSL 是一种加密协议，它可以保护数据在传输过程中不被窃听。 会话管理：Spring Security 提供了自己的会话管理实现，它可以跟踪用户会话的状态。 第三阶段：Spring Security 3.0 版本 Spring Security 3.0 版本发布于 2008 年。它是一个重大的版本更新，它提供了许多新的安全功能，包括 OAuth、SAML 和 OpenID。 OAuth 是一种授权框架，它允许第三方应用程序访问用户的资源。SAML 是一种单点登录 (SSO) 协议，它允许用户在一个地方登录，然后访问多个网站。OpenID 是一种开放的身份验证协议，它允许用户使用他们选择的身份提供商来验证他们的身份。 Spring Security 3.0 版本使用了以下技术来实现 OAuth、SAML 和 OpenID：...</p></div><footer class=entry-footer><span title='2023-08-15 00:00:00 +0000 UTC'>2023-08-15</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1163 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Spring Security和OAuth2发展过程" href=https://blog.chensoul.cc/posts/2023/08/15/spring-security-oauth2-history/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]在 Spring 中实现 OAuth2：使用范围（第 2 部分）</h2></header><div class=entry-content><p>我们在上一篇文章中了解了基本的 OAuth2 概念以及如何在 Spring 中实现和执行不同的授权。在这篇文章中，我们将介绍 OAuth2 的另一个重要概念：范围。
OAuth 范围 保护对应用程序的访问通常分两个步骤进行：身份验证和授权。要理解这两个概念，假设您在绝密政府大楼工作。在开始之前，你会得到一张卡片，可以让你进入建筑物。 OAuth 令牌可以看作是允许您访问的卡片。
一旦你进去，你决定去三楼见你的一位同事，在尝试使用你的卡打开三楼的门后，你听到一声嘟嘟声，告诉你你没有被授权。在 OAuth 中，范围是一种定义令牌可以访问哪些资源以及不能访问哪些资源的方法。范围允许访问控制，并且可以被视为相当于传统身份验证中的用户角色。
实现 为了演示范围，我们将使用第 1 部分中的示例。
在资源服务器的控制器中，我们有以下端点：
@RestController("/") public class ResourceController { @GetMapping("/hello") public String hello(){ return "hello"; } @GetMapping("/foo") public String foo(){ return "foo"; } @PostMapping("/bar") public String bar(){ return "bar"; } @DeleteMapping("/test") public String test(){ return "test"; } } 第一步是使用所需的范围配置授权服务器：
clients.inMemory().withClient("my-trusted-client") .authorizedGrantTypes("password", "refresh_token", "implicit", "client_credentials", "authorization_code") .authorities("CLIENT") .scopes("read", "write", "trust") .accessTokenValiditySeconds(60) .redirectUris("http://localhost:8081/test.html") .resourceIds("resource") .secret("mysecret"); 要在资源服务器中启用范围检查，我们有两个选项：使用安全配置或使用方法安全性。
使用安全配置： @Override public void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(HttpMethod.GET,"/hello").access("#oauth2.hasScope('read')") .antMatchers(HttpMethod.GET,"/foo").access("#oauth2.hasScope('read')") .antMatchers(HttpMethod.POST,"/bar").access("#oauth2.hasScope('write')") .antMatchers(HttpMethod.DELETE,"/test").access("#oauth2.hasScope('trust')") .anyRequest().authenticated(). and().csrf().disable(); } 使用方法安全性： @PreAuthorize("#oauth2.hasScope('read')") @GetMapping("/hello") public String hello(){ return "hello"; } @PreAuthorize("#oauth2.hasScope('read')") @GetMapping("/foo") public String foo(){ return "foo"; } @PreAuthorize("#oauth2....</p></div><footer class=entry-footer><span title='2023-07-26 00:00:00 +0000 UTC'>2023-07-26</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;258 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]在 Spring 中实现 OAuth2：使用范围（第 2 部分）" href=https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring-scopes/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]在 Spring 中实现 OAuth2：第 1 部分</h2></header><div class=entry-content><p>OAuth2 是一组规范，主要提供对 Rest API 的安全访问的方法。 OAuth 的主要目的是允许通过使用令牌来执行身份验证和授权，而不必为每个操作提供凭据。由于本文的重点是实现，并且为了不重新发明轮子，可以查看 OAuth RFC 或维基百科以获取更多理论背景。在这篇文章中，我们将深入探讨 Spring 中的 OAuth2 实现以及如何使用不同的授权类型，但在此之前值得提供一些重要概念的简要定义。
访问令牌和刷新令牌 身份验证成功后将提供访问令牌以及刷新令牌。访问令牌有一个有限的有效期（标准为 1 小时），之后需要刷新令牌才能获取新的访问令牌和新的刷新令牌。 Referesh 令牌通常会在使用后过期。
资源服务器和授权服务器 OAuth 引入了授权服务器的概念，授权服务器是发出访问和刷新令牌的实体，并在每个操作中进行咨询以查看令牌是否有效。资源服务器只是由不同客户端应用程序（前端应用程序、移动设备、其他后端服务……）访问的实际 Rest API。资源服务器和授权服务器可以是不同的实体，也可以是同一实体。
授权类型 OAuth 中最常用的授权有：客户端凭据、密码、授权码和隐式授权。每项资助都有特定的流程和用例，但由于本文的重点不是理论，因此我们将重点关注其实施。有关授权及其用途的更多详细信息，请参阅 OAuth RFC。
实现 在实现方面，我们将使用 Spring Boot 来利用其自动配置和引导功能，并更多地关注我们的核心主题。
资源服务器： 我们有一个资源服务器，其中包含我们希望保护的以下端点：
@RestController("/") public class ResourceController { @GetMapping("/hello") public String hello(){ return "hello"; } @GetMapping("/foo") public String foo(){ return "foo"; } @GetMapping("/bar") public String bar(){ return "bar"; } @GetMapping("/test") public String test(){ return "test"; } } 为此，我们需要配置一个用 @EnableResourceServer 注释的 ResourceServerConfigurerAdapter bean：
@Configuration @EnableResourceServer public class ResourceSecurityConfiguration extends ResourceServerConfigurerAdapter { @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId("resource"); } @Override public void configure(HttpSecurity http) throws Exception { http ....</p></div><footer class=entry-footer><span title='2023-07-26 00:00:00 +0000 UTC'>2023-07-26</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;464 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]在 Spring 中实现 OAuth2：第 1 部分" href=https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.chensoul.cc/tags/oauth2/page/2/>«&nbsp;Prev&nbsp;2/3</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>