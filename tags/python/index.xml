<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>python on ChenSoul</title>
    <link>https://blog.chensoul.com/tags/python/</link>
    <description>Recent content in python on ChenSoul</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 14 Jun 2023 15:00:00 +0800</lastBuildDate><atom:link href="https://blog.chensoul.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>周报-23｜读书、健身、定投、帮朋友、陪家人</title>
      <link>https://blog.chensoul.com/posts/2023/06/14/weekly_review_23/</link>
      <pubDate>Wed, 14 Jun 2023 15:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/06/14/weekly_review_23/</guid>
      <description>前言 本篇是对 2023-06-05 到 2023-06-11 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 读书、健身、投资、帮朋友、陪家人。 以后周报的主题</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-06-05</code> 到 <code>2023-06-11</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<blockquote>
<p>读书、健身、投资、帮朋友、陪家人。</p>
</blockquote>
<p>以后周报的主题，会包括这几个部分：读书、健身、投资、帮朋友、陪家人，再加上工作和本周分享两块内容。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-23-03.png" alt="weekly-review-23-03" style="width:50%;" />
<h2 id="读书">读书</h2>
<p>本周阅读统计，总计阅读31分钟：</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-23-01.jpeg" alt="weekly-review-23-01" style="width:50%;" />
<p>本周阅读摘抄：</p>
<ul>
<li>人是周围6个人的平均值，如果你身边没有特别出色的年轻人与你为伍，你就找先贤们的书籍，他们把一生的所有思考、智慧、经历和情感，都倾注在那些书里头了。 如果有一天跟你共鸣的，全都是古往今来、古今中外那些最智慧、最深刻、最敏锐、最丰富、最博学的大脑，你大概率不会太差，你的精神世界也大概率会非常丰富。 “we are all in the gutter ，but some of us are looking at stars。” 这句话来自一个爱尔兰的诗人，叫做奥斯卡·王尔德：“我们都身处在阴沟里，但总有人仰望星空。”</li>
<li>“ Three passions, simple but overwhelmingly strong, have governed my life: the longing for love, the search for knowledge, and unbearable pity for the suffering of mankind. ”  这是来自于罗素的一个演讲，叫做《我为什么而活着》，意思是：对知识的渴望，对爱情的追求，对人类苦难难以遏制的同情心，这三种简单而强烈的激情，苦苦支配我的一生</li>
</ul>
<h2 id="健身">健身</h2>
<blockquote>
<p>我跑过了一些地方，希望随着时间推移，地图点亮的地方越来越多。2 年里我跑过 2个省份 2个城市。更多跑步数据在我的 <a href="https://run.chensoul.com/">跑步</a> 主页。</p>
</blockquote>
<p>这周因为父亲住院需要照顾他，所以跑步暂停。</p>
<h2 id="理财">理财</h2>
<p>这周总计支出 5006 元，明细如下：</p>
<ul>
<li>
<p>6月11日：4057元，父亲出院支付3475元</p>
</li>
<li>
<p>6月10日：108元</p>
</li>
<li>
<p>6月9日：86元</p>
</li>
<li>
<p>6月8日：367元</p>
</li>
<li>
<p>6月7日：179元</p>
</li>
<li>
<p>6月6日：117元</p>
</li>
<li>
<p>6月5日：92元</p>
</li>
</ul>
<h2 id="陪家人">陪家人</h2>
<p>本周的工作和生活都因为老爸住院而打乱了原来的节奏。起因是老爸因为痛风关节疼痛而服用了双氯芬酸钠缓释片导致胃溃疡和出血，另外最近两个月大便呈黑色、血液流失过多，导致严重贫血。周六先是去武汉中心医院做胃镜检查，医生看到老爸的脸色苍白，建议做个血液检测。检查结果出来之后，心有余悸，如果再晚点带老爸来医院做检查，不知道老爸会因贫血而出现怎样的事情。根据检查结果，医生建议立即住院。在经过考虑之后，决定回阳逻住院。住院期间，需要亲属陪护，于是周一到周三请了三天假，周四和周五换老婆过来照顾。</p>
<p>住院期间，老爸心里烦，因为痛风发作，腿脚走路没力气，大小便不方便。作为儿子的我也在反思，老爸成这样，都怪我平时没有关心他的健康和生活。老爸今天让我吃的苦都是因为过去在老爸身上的付出不够。</p>
<h2 id="工作">工作</h2>
<p>最近在学习的内容清单：</p>
<ul>
<li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/tree/dev">Effective Java（第 3 版）</a></li>
<li><a href="https://java-design-patterns.com/zh/">Java Design Patterns (中文)</a></li>
<li><a href="https://realpython.com/">Real Python</a></li>
</ul>
<p>本周完成三篇博客：</p>
<ul>
<li><a href="/posts/2023/06/10/java-design-patterns-adapter/">Java设计模式：Adapter</a></li>
<li><a href="/posts/2023/06/10/python-data-type/">Python学习2：数据类型</a></li>
<li><a href="/posts/2023/06/11/python-operator-and-expression/">Python学习3：运算符和表达式</a></li>
</ul>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-23-02.png" alt="weekly-review-23-02"  />
</p>
<h2 id="本周分享">本周分享</h2>
<p>大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道或者我的 <a href="https://memos.chensoul.com/">Memos</a> 中。我写了一个 Python 脚本从 Memos 读取最近一周带有 <code>#memos</code> 标签的记录，分享到这里。</p>
<ul>
<li>
<p>📌<code>2023-06-10</code> 如何用 ChatGPT 助力开发: 已经有 15 万人看过的经验分享<code>#memos</code> <a href="http://luolei.org/chatgpt-in-development/">http://luolei.org/chatgpt-in-development/</a></p>
</li>
<li>
<p>📌<code>2023-06-09</code> Rust语言实战，视频和教程  <a href="https://www.youtube.com/watch?v=BpPEoZW5IiY">https://www.youtube.com/watch?v=BpPEoZW5IiY</a> <a href="https://zh.practice.rs/why-exercise.html">https://zh.practice.rs/why-exercise.html</a>  <code>#memos</code> <code>#rust</code></p>
</li>
<li>
<p>📌<code>2023-06-09</code> 基于 Spring Cloud 使用一致性哈希算法实现分布式 WebSocket. / 基于 RabbitMQ 广播实现分布式 WebSocket. <a href="https://lawrenceli.me/blog/websocket-cluster">https://lawrenceli.me/blog/websocket-cluster</a>    <code>#memos</code> <code>#java</code> <code>#skill</code></p>
</li>
<li>
<p>📌<code>2023-06-09</code> REST 和 gRPC 是 API 的两种最流行的实现方法，本文详细比较它们的差异。 <a href="https://kreya.app/blog/rest-vs-grpc/">https://kreya.app/blog/rest-vs-grpc/</a> <code>#memos</code></p>
</li>
<li>
<p>📌<code>2023-06-08</code> 痛苦是对的，焦虑也是对的，痛苦的本质来源于你对现状的不满，然后焦虑的本质来源于你成长速度太慢。<code>#memos</code></p>
</li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Python学习4：流程控制</title>
      <link>https://blog.chensoul.com/posts/2023/06/14/python-flow-control/</link>
      <pubDate>Wed, 14 Jun 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/06/14/python-flow-control/</guid>
      <description>在 Python 中，流程控制语句包括条件语句（if-elif-else）、循环语句（for 和 while）、跳转语句（break、continue 和 ret</description>
      <content:encoded><![CDATA[<p>在 Python 中，流程控制语句包括条件语句（if-elif-else）、循环语句（for 和 while）、跳转语句（break、continue 和 return）和异常处理语句。</p>
<h2 id="条件语句">条件语句</h2>
<p>条件语句用于在不同的条件下执行不同的代码块。Python 中的条件语句是 if-elif-else 结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 条件语句示例</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;x is negative&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;x is zero&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;x is positive&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="循环语句">循环语句</h2>
<p>循环语句用于重复执行一段代码，直到满足某个条件或达到某个条件次数为止。Python 中的循环语句包括 for 和 while 两种结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># for 循环示例</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># while 循环示例</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span></code></pre></div><p>遍历集合时修改集合的内容，会很容易生成错误的结果。因此不能直接进行循环，而是应遍历该集合的副本或创建新的集合：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Create a sample collection</span>
</span></span><span class="line"><span class="cl"><span class="n">users</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Hans&#39;</span><span class="p">:</span> <span class="s1">&#39;active&#39;</span><span class="p">,</span> <span class="s1">&#39;Éléonore&#39;</span><span class="p">:</span> <span class="s1">&#39;inactive&#39;</span><span class="p">,</span> <span class="s1">&#39;景太郎&#39;</span><span class="p">:</span> <span class="s1">&#39;active&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Strategy:  Iterate over a copy</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">user</span><span class="p">,</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">users</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;inactive&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">del</span> <span class="n">users</span><span class="p">[</span><span class="n">user</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Strategy:  Create a new collection</span>
</span></span><span class="line"><span class="cl"><span class="n">active_users</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">user</span><span class="p">,</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">users</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;active&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">active_users</span><span class="p">[</span><span class="n">user</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span>
</span></span></code></pre></div><h2 id="跳转语句">跳转语句</h2>
<p>跳转语句用于在循环或函数中跳过一些代码或终止循环。Python 中的跳转语句包括 break、continue 和 return。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># break 示例</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># continue 示例</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="c1"># return 示例</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
</span></span></code></pre></div><p>在这个示例中，我们使用 break 关键字来终止一个 for 循环，使用 continue 关键字来跳过一个循环迭代，使用 return 关键字来从函数中返回一个值。</p>
<h2 id="pass-语句"><code>pass</code> 语句</h2>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#pass"><code>pass</code></a> 语句不执行任何操作。语法上需要一个语句，但程序不实际执行任何动作时，可以使用该语句。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pass 语句</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>  <span class="c1"># Busy-wait for keyboard interrupt (Ctrl+C)</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">function</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># to be implemented</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyEmptyClass</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span></code></pre></div><h2 id="match-语句"><code>match</code> 语句</h2>
<p>match 语句接受一个表达式，并将其值与一个或多个case块中给定的模式进行比较。这在表面上类似于C、Java或JavaScript（以及许多其他语言）中的switch语句，但它更类似于Rust或Haskell等语言中的模式匹配。只有第一个匹配的模式会被执行，并且它还可以从值中提取组件（序列元素或对象属性）到变量中。</p>
<p>最简单的形式是将一个目标值与一个或多个字面值进行比较：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">http_error</span><span class="p">(</span><span class="n">status</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">match</span> <span class="n">status</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="mi">400</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s2">&#34;Bad request&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="mi">404</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s2">&#34;Not found&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="mi">418</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s2">&#34;I&#39;m a teapot&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="n">_</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s2">&#34;Something&#39;s wrong with the internet&#34;</span>
</span></span></code></pre></div><p>注意最后一个代码块：“变量名” <code>_</code> 被作为 <em>通配符</em> 并必定会匹配成功。 如果没有 case 语句匹配成功，则不会执行任何分支。</p>
<p>使用 <code>|</code> （“ or ”）在一个模式中可以组合多个字面值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">case</span> <span class="mi">401</span> <span class="o">|</span> <span class="mi">403</span> <span class="o">|</span> <span class="mi">404</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s2">&#34;Not allowed&#34;</span>
</span></span></code></pre></div><p>模式的形式类似解包赋值，并可被用于绑定变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># point is an (x, y) tuple</span>
</span></span><span class="line"><span class="cl"><span class="k">match</span> <span class="n">point</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Origin&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">_</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&#34;Not a point&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>请仔细研究此代码！ 第一个模式有两个字面值，可以看作是上面所示字面值模式的扩展。但接下来的两个模式结合了一个字面值和一个变量，而变量 <strong>绑定</strong> 了一个来自目标的值（<code>point</code>）。第四个模式捕获了两个值，这使得它在概念上类似于解包赋值 <code>(x, y) = point</code>。</p>
<p>如果使用类实现数据结构，可在类名后加一个类似于构造器的参数列表，这样做可以把属性放到变量里：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">where_is</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">match</span> <span class="n">point</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Origin&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="n">Point</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Somewhere else&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="n">_</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Not a point&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>可在 dataclass 等支持属性排序的内置类中使用位置参数。还可在类中设置 <code>__match_args__</code> 特殊属性为模式的属性定义指定位置。如果它被设为 (&ldquo;x&rdquo;, &ldquo;y&rdquo;)，则以下模式均为等价的，并且都把 <code>y</code> 属性绑定到 <code>var</code> 变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></div><p>读取模式的推荐方式是将它们看做是你会在赋值操作左侧放置的内容的扩展形式，以便理解各个变量将会被设置的值。 只有单独的名称（例如上面的 <code>var</code>）会被 match 语句所赋值。 带点号的名称 (例如 <code>foo.bar</code>)、属性名称（例如上面的 <code>x=</code> 和 <code>y=</code>）或类名称（通过其后的 &ldquo;(&hellip;)&rdquo; 来识别，例如上面的 <code>Point</code>）都绝不会被赋值。</p>
<p>模式可以任意地嵌套。例如，如果有一个由点组成的短列表，则可使用如下方式进行匹配：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">match</span> <span class="n">points</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="p">[]:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;No points&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;The origin&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Single point </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y2</span><span class="p">)]:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Two on the Y axis at </span><span class="si">{</span><span class="n">y1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">y2</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">_</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Something else&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>为模式添加成为守护项的 <code>if</code> 子句。如果守护项的值为假，则 <code>match</code> 继续匹配下一个 case 语句块。注意，值的捕获发生在守护项被求值之前：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">match</span> <span class="n">point</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Y=X at </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Not on the diagonal&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>match 语句的其他特性：</p>
<ul>
<li>
<p>与解包赋值类似，元组和列表模式具有完全相同的含义，并且实际上能匹配任意序列。 但它们不能匹配迭代器或字符串。</p>
</li>
<li>
<p>序列模式支持扩展解包操作：<code>[x, y, *rest]</code> 和 <code>(x, y, *rest)</code> 的作用类似于解包赋值。 在 <code>*</code> 之后的名称也可以为 <code>_</code>，因此，<code>(x, y, *_)</code> 可以匹配包含至少两个条目的序列，而不必绑定其余的条目。</p>
</li>
<li>
<p>映射模式：<code>{&quot;bandwidth&quot;: b, &quot;latency&quot;: l}</code> 从字典中捕获 <code>&quot;bandwidth&quot;</code> 和 <code>&quot;latency&quot;</code> 的值。与序列模式不同，额外的键会被忽略。<code>**rest</code> 等解包操作也支持。但 <code>**_</code> 是冗余的，不允许使用。</p>
</li>
<li>
<p>使用 <code>as</code> 关键字可以捕获子模式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">case</span> <span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="k">as</span> <span class="n">p2</span><span class="p">):</span> <span class="o">...</span>
</span></span></code></pre></div><p>将把输入的第二个元素捕获为 <code>p2</code> (只要输入是包含两个点的序列)</p>
</li>
<li>
<p>大多数字面值是按相等性比较的，但是单例对象 <code>True</code>, <code>False</code> 和 <code>None</code> 则是按标识号比较的。</p>
</li>
<li>
<p>模式可以使用命名常量。 这些命名常量必须为带点号的名称以防止它们被解读为捕获变量:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Color</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">RED</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="n">GREEN</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="n">BLUE</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&#34;Enter your choice of &#39;red&#39;, &#39;blue&#39; or &#39;green&#39;: &#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">match</span> <span class="n">color</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">Color</span><span class="o">.</span><span class="n">RED</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I see red!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">Color</span><span class="o">.</span><span class="n">GREEN</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Grass is green&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">Color</span><span class="o">.</span><span class="n">BLUE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I&#39;m feeling the blues :(&#34;</span><span class="p">)</span>
</span></span></code></pre></div></li>
</ul>
<h2 id="异常处理语句">异常处理语句</h2>
<p>异常处理语句：用于处理程序执行过程中可能出现的异常情况，Python 中的异常处理语句包括 try、except、finally 和 raise 语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&#34;Please enter a number: &#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Invalid input&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Cannot divide by zero&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;No exception occurred&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Execution completed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># raise 语句</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&#34;x must be non-negative&#34;</span><span class="p">)</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Python学习3：运算符和表达式</title>
      <link>https://blog.chensoul.com/posts/2023/06/11/python-operator-and-expression/</link>
      <pubDate>Sun, 11 Jun 2023 15:30:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/06/11/python-operator-and-expression/</guid>
      <description>在Python中，运算符是用于执行各种操作的符号或关键字；表达式是由操作符、变量、常量和函数调用等组成的，它们可以被计算求值并返回一个结果。</description>
      <content:encoded><![CDATA[<p>在Python中，运算符是用于执行各种操作的符号或关键字；表达式是由操作符、变量、常量和函数调用等组成的，它们可以被计算求值并返回一个结果。</p>
<p>以下是一些常用的运算符和表达式：</p>
<h2 id="算术运算符">算术运算符</h2>
<p>Python中的算术运算符用于执行基本的算术运算，包括加、减、乘、除、取模和幂运算。以下是一些常用的算术运算符：</p>
<ul>
<li><code>+</code>：加法运算</li>
<li><code>-</code>：减法运算</li>
<li><code>*</code>：乘法运算</li>
<li><code>/</code>：除法运算</li>
<li><code>%</code>：取模运算，返回两个数相除的余数</li>
<li><code>**</code>：幂运算，返回一个数的指定次幂</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>    <span class="c1"># 加法</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">-</span> <span class="n">y</span>    <span class="c1"># 减法</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">*</span> <span class="n">y</span>    <span class="c1"># 乘法</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">/</span> <span class="n">y</span>    <span class="c1"># 除法</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">%</span> <span class="n">y</span>    <span class="c1"># 取模</span>
</span></span></code></pre></div><p>在这个例子中，我们使用算术运算符执行基本的算术运算，例如将变量<code>x</code>和<code>y</code>相加、相减、相乘、相除和取模。</p>
<h2 id="比较运算符">比较运算符</h2>
<p>Python中的比较运算符用于比较两个值的大小关系，返回一个布尔值。以下是一些常用的比较运算符：</p>
<ul>
<li><code>==</code>：等于运算符，如果两个值相等，则返回<code>True</code>，否则返回<code>False</code></li>
<li><code>!=</code>：不等于运算符，如果两个值不相等，则返回<code>True</code>，否则返回<code>False</code></li>
<li><code>&gt;</code>：大于运算符，如果左边的值大于右边的值，则返回<code>True</code>，否则返回<code>False</code></li>
<li><code>&lt;</code>：小于运算符，如果左边的值小于右边的值，则返回<code>True</code>，否则返回<code>False</code></li>
<li><code>&gt;=</code>：大于等于运算符，如果左边的值大于等于右边的值，则返回<code>True</code>，否则返回<code>False</code></li>
<li><code>&lt;=</code>：小于等于运算符，如果左边的值小于等于右边的值，则返回<code>True</code>，否则返回<code>False</code></li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">==</span> <span class="n">y</span>    <span class="c1"># 等于</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span>    <span class="c1"># 不等于</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>     <span class="c1"># 大于</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>     <span class="c1"># 小于</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span>    <span class="c1"># 大于等于</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span>    <span class="c1"># 小于等于</span>
</span></span></code></pre></div><p>在这个例子中，我们使用比较运算符比较变量<code>x</code>和<code>y</code>的大小关系，例如判断<code>x</code>是否等于<code>y</code>、是否大于<code>y</code>等。</p>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>Python中的逻辑运算符用于执行逻辑操作，包括与、或和非运算。以下是一些常用的逻辑运算符：</p>
<ul>
<li><code>and</code>：逻辑与运算符，如果两个操作数都为<code>True</code>，则返回<code>True</code>，否则返回<code>False</code></li>
<li><code>or</code>：逻辑或运算符，如果两个操作数中至少有一个为<code>True</code>，则返回<code>True</code>，否则返回<code>False</code></li>
<li><code>not</code>：逻辑非运算符，如果操作数为<code>True</code>，则返回<code>False</code>，否则返回<code>True</code></li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="ow">and</span> <span class="n">y</span>    <span class="c1"># 与</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="ow">or</span> <span class="n">y</span>     <span class="c1"># 或</span>
</span></span><span class="line"><span class="cl"><span class="ow">not</span> <span class="n">x</span>      <span class="c1"># 非</span>
</span></span></code></pre></div><p>在这个例子中，我们使用逻辑运算符执行逻辑运算，例如判断变量<code>x</code>和<code>y</code>是否都为<code>True</code>、判断变量<code>x</code>和<code>y</code>是否至少一个为<code>True</code>等。</p>
<h2 id="赋值运算符">赋值运算符</h2>
<p>Python中的赋值运算符用于将一个值赋给一个变量。以下是一些常用的赋值运算符：</p>
<ul>
<li><code>=</code>：简单赋值运算符，将右边的值赋给左边的变量</li>
<li><code>+=</code>：加等于运算符，将右边的值加到左边的变量上，并将结果赋给左边的变量</li>
<li><code>-=</code>：减等于运算符，将右边的值从左边的变量上减去，并将结果赋给左边的变量</li>
<li><code>*=</code>：乘等于运算符，将左边的变量乘以右边的值，并将结果赋给左边的变量</li>
<li><code>/=</code>：除等于运算符，将左边的变量除以右边的值，并将结果赋给左边的变量</li>
<li><code>%=</code>：取模等于运算符，将左边的变量取模右边的值，并将结果赋给左边的变量</li>
<li><code>**=</code>：幂等于运算符，将左边的变量的值的指定次幂赋给左边的变量</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>    <span class="c1"># 等于号</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">+=</span> <span class="mi">5</span>    <span class="c1"># 加等于</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">-=</span> <span class="mi">5</span>    <span class="c1"># 减等于</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span>    <span class="c1"># 乘等于</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">/=</span> <span class="mi">3</span>    <span class="c1"># 除等于</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">%=</span> <span class="mi">2</span>    <span class="c1"># 取模等于</span>
</span></span></code></pre></div><p>在这个例子中，我们使用赋值运算符将一个值赋给变量<code>x</code>，以及使用加等于、减等于、乘等于、除等于和取模等于运算符对变量<code>x</code>进行更新。</p>
<h2 id="位运算符">位运算符</h2>
<p>Python中的位运算符用于对整数进行位运算，包括按位与、按位或、按位异或、按位取反和左右移位运算。以下是一些常用的位运算符：</p>
<ul>
<li><code>&amp;</code>：按位与运算符，对两个操作数的每个位执行逻辑与操作，返回一个新的整数</li>
<li><code>|</code>：按位或运算符，对两个操作数的每个位执行逻辑或操作，返回一个新的整数</li>
<li><code>^</code>：按位异或运算符，对两个操作数的每个位执行逻辑异或操作，返回一个新的整数</li>
<li><code>~</code>：按位取反运算符，对操作数的每个位执行逻辑取反操作，返回一个新的整数</li>
<li><code>&lt;&lt;</code>：左移位运算符，将一个整数的所有位向左移动指定的位数，返回一个新的整数</li>
<li><code>&gt;&gt;</code>：右移位运算符，将一个整数的所有位向右移动指定的位数，返回一个新的整数</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span>    <span class="c1"># 按位与</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">|</span> <span class="n">y</span>    <span class="c1"># 按位或</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">^</span> <span class="n">y</span>    <span class="c1"># 按位异或</span>
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">x</span>       <span class="c1"># 按位取反</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>   <span class="c1"># 左移2位</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span>   <span class="c1"># 右移2位</span>
</span></span></code></pre></div><p>在这个例子中，我们使用位运算符对二进制数进行位操作，例如将变量<code>x</code>和<code>y</code>进行按位与、按位或、按位异或，以及对变量<code>x</code>进行按位取反、左移和右移。</p>
<h2 id="三元运算符">三元运算符</h2>
<p>Python中的三元运算符可以用于在一行代码中实现简单的条件语句。它的语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">value_if_true</span> <span class="k">if</span> <span class="n">condition</span> <span class="k">else</span> <span class="n">value_if_false</span>
</span></span></code></pre></div><p>其中<code>condition</code>是一个布尔表达式，如果它的值为<code>True</code>，则返回<code>value_if_true</code>，否则返回<code>value_if_false</code>。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="n">max_value</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">max_value</span><span class="p">)</span>  <span class="c1"># 输出：10</span>
</span></span></code></pre></div><p>在这个例子中，我们使用三元运算符来比较<code>x</code>和<code>y</code>的值，并将较大的值赋给变量<code>max_value</code>。</p>
<h2 id="成员运算符">成员运算符</h2>
<p>Python中的成员运算符用于检查一个值是否是另一个值的成员，包括<code>in</code>和<code>not in</code>运算符。以下是一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;3 is in my_list&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>在这个例子中，我们使用<code>in</code>运算符来检查<code>3</code>是否是<code>my_list</code>中的成员。如果是，则打印出<code>3 is in my_list</code>。</p>
<h2 id="身份运算符">身份运算符</h2>
<p>Python中的身份运算符用于比较两个对象的内存地址，包括<code>is</code>和<code>is not</code>运算符。以下是一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;x and y have the same identity&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;x and y have different identities&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>在这个例子中，我们使用<code>is</code>运算符来比较<code>x</code>和<code>y</code>的内存地址。由于<code>x</code>和<code>y</code>是两个不同的列表对象，所以它们的内存地址不同，程序会打印出<code>x and y have different identities</code>。</p>
<h2 id="切片运算符">切片运算符</h2>
<p>Python中的切片运算符用于从序列中获取一个子序列，包括从开始位置到结束位置的切片和步长切片。以下是一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>  <span class="c1"># 输出：[2, 3, 4]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># 输出：[1, 3, 5]</span>
</span></span></code></pre></div><p>在这个例子中，我们使用切片运算符从列表<code>my_list</code>中获取一个子序列。第一个切片<code>my_list[1:4]</code>返回从下标<code>1</code>到下标<code>3</code>的元素，第二个切片<code>my_list[::2]</code>返回每隔一个元素的子序列。</p>
<h2 id="格式化运算符">格式化运算符</h2>
<p>Python中的格式化运算符用于将一个值插入到一个字符串中。它的语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="s2">&#34;format string&#34;</span> <span class="o">%</span> <span class="n">values</span>
</span></span></code></pre></div><p>其中<code>&quot;format string&quot;</code>是一个字符串，包含格式化代码，<code>values</code>是一个元组，包含要插入的值。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;Alice&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">age</span> <span class="o">=</span> <span class="mi">25</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;My name is </span><span class="si">%s</span><span class="s2">, and I am </span><span class="si">%d</span><span class="s2"> years old.&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">))</span>
</span></span></code></pre></div><p>在这个例子中，我们使用格式化运算符将变量<code>name</code>和<code>age</code>插入到字符串中，生成一条包含变量值的消息。</p>
<h2 id="拼接运算符">拼接运算符</h2>
<p>Python中的拼接运算符用于将两个字符串或序列连接起来，包括<code>+</code>运算符和<code>*</code>运算符。以下是一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str1</span> <span class="o">=</span> <span class="s2">&#34;Hello&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">str2</span> <span class="o">=</span> <span class="s2">&#34;world&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">str1</span> <span class="o">+</span> <span class="s2">&#34; &#34;</span> <span class="o">+</span> <span class="n">str2</span><span class="p">)</span>  <span class="c1"># 输出：Hello world</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 输出：[1, 2, 3, 1, 2, 3, 1, 2, 3]</span>
</span></span></code></pre></div><p>在这个例子中，我们使用拼接运算符将两个字符串连接起来，以及将一个列表复制多次生成一个新的列表。</p>
<h2 id="解包运算符">解包运算符</h2>
<p>Python中的解包运算符包括两种：<code>*</code>和<code>**</code>。</p>
<h3 id="解包运算符-1"><code>*</code>解包运算符</h3>
<p><code>*</code>解包运算符用于将可迭代对象（如列表、元组、集合等）解包成单独的元素。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">my_list</span><span class="p">)</span>   <span class="c1"># 输出: 1 2 3 4 5</span>
</span></span></code></pre></div><p>在这个例子中，我们使用<code>*</code>解包运算符将<code>my_list</code>列表解包成一个个单独的元素，然后通过<code>print</code>函数输出。</p>
<h3 id="解包运算符-2"><code>**</code>解包运算符</h3>
<p><code>**</code>解包运算符用于将字典解包成关键字参数。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;x&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;y&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;z&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="o">**</span><span class="n">my_dict</span><span class="p">)</span>   <span class="c1"># 输出: x=1 y=2 z=3</span>
</span></span></code></pre></div><p>在这个例子中，我们使用<code>**</code>解包运算符将<code>my_dict</code>字典解包成关键字参数，并通过<code>print</code>函数输出。</p>
<p>除了上面的用法，<code>*</code>和<code>**</code>解包运算符还可以用于函数定义和调用中。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">my_func</span><span class="p">(</span><span class="o">*</span><span class="n">my_list</span><span class="p">)</span>   <span class="c1"># 输出: 1 2 3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;a&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;c&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">my_func</span><span class="p">(</span><span class="o">**</span><span class="n">my_dict</span><span class="p">)</span>   <span class="c1"># 输出: 1 2 3</span>
</span></span></code></pre></div><p>在这个例子中，我们定义了一个函数<code>my_func</code>，然后使用<code>*</code>和<code>**</code>解包运算符将列表和字典中的值作为函数的参数传递进去。</p>
<h2 id="运算符">@运算符</h2>
<p><code>@</code>运算符用于执行矩阵乘法。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b</span>   <span class="c1"># 矩阵乘法</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>    <span class="c1"># 输出: [[19 22] [43 50]]</span>
</span></span></code></pre></div><p>在这个例子中，我们使用<code>@</code>运算符对两个矩阵进行乘法运算，并将结果保存在变量<code>c</code>中。</p>
<h2 id="lambda表达式">lambda表达式</h2>
<p>Python中的lambda表达式可以用于创建匿名函数。它的语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">lambda</span> <span class="n">arguments</span> <span class="p">:</span> <span class="n">expression</span>
</span></span></code></pre></div><p>其中<code>arguments</code>是函数的参数列表，<code>expression</code>是一个表达式，表示函数的返回值。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># 输出：5</span>
</span></span></code></pre></div><p>在这个例子中，我们使用lambda表达式创建了一个函数<code>f</code>，它接受两个参数<code>x</code>和<code>y</code>，并返回它们的和。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Python学习2：数据类型</title>
      <link>https://blog.chensoul.com/posts/2023/06/10/python-data-type/</link>
      <pubDate>Sat, 10 Jun 2023 15:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/06/10/python-data-type/</guid>
      <description>Python 中的数据类型包括： 数字类型：包括整型、浮点型、复数型和布尔类型：只有两个取值，True 和 False，用于表示逻辑值。 字符串类型：由一系列字</description>
      <content:encoded><![CDATA[<p>Python 中的数据类型包括：</p>
<ol>
<li>数字类型：包括整型、浮点型、复数型和布尔类型：只有两个取值，True 和 False，用于表示逻辑值。</li>
<li>字符串类型：由一系列字符组成，可以是单引号、双引号或三引号括起来的文本。</li>
<li>列表类型：由一系列有序的元素组成，可以包含任何类型的数据。</li>
<li>元组类型：与列表类似，但是<code>元素不能被修改</code>。</li>
<li>集合类型：由一组唯一的元素组成，支持集合的基本操作，如并集、交集和差集等。</li>
<li>字典类型：由一组键值对组成，其中键是唯一的，用于查找和存储值。</li>
<li>None 类型：表示空值或缺失值。</li>
</ol>
<h2 id="数字">数字</h2>
<p>在 Python 中，数字类型包括整数（int）、浮点数（float）、复数（complex）和布尔值（bool）。</p>
<ol>
<li>
<p>整数（int）是不带小数的数字，可以使用十进制、二进制、八进制或十六进制表示。<strong>在 Python 3 中，整数的长度不再受限于机器的位数，可以表示任意大的整数。</strong> 例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mi">123</span>       <span class="c1"># 十进制整数</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="mb">0b1010</span>    <span class="c1"># 二进制整数，等于十进制的 10</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="mo">0o12</span>      <span class="c1"># 八进制整数，等于十进制的 10</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="mh">0x0A</span>      <span class="c1"># 十六进制整数，等于十进制的 10</span>
</span></span></code></pre></div></li>
<li>
<p>浮点数（float）是带小数的数字，可以使用科学计数法表示。在 Python 中，浮点数采用 IEEE 754 标准表示，具有双精度（64 位）和单精度（32 位）两种形式。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mf">3.14e-2</span>   <span class="c1"># 科学计数法表示的浮点数，等于 0.0314</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="mf">1.23</span>      <span class="c1"># 普通的浮点数</span>
</span></span></code></pre></div></li>
<li>
<p>复数（complex）是具有实部和虚部的数字，可以使用 <code>a+bj</code> 或 <code>complex(a, b)</code> 的形式表示，其中 j 表示虚数单位。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span>      <span class="c1"># 复数</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>   <span class="c1"># 复数，等于 3+4j</span>
</span></span></code></pre></div></li>
<li>
<p>布尔值（bool）只有两个取值，<code>True</code> 和 <code>False</code>，用于表示真和假。在 Python 中，布尔值可以和数值进行运算，True 转换为 1，False 转换为 0。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="kc">True</span>   <span class="c1"># c 的值为 2</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="kc">False</span>  <span class="c1"># d 的值为 0</span>
</span></span></code></pre></div></li>
</ol>
<p>数字的操作和运算：</p>
<ol>
<li>整数除法、取模、幂运算</li>
</ol>
<p>在 Python 中，使用 <code>/</code> 运算符进行除法运算得到的结果是浮点数，如果想要得到整数结果，可以使用 <code>//</code> 运算符进行整数除法运算。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span>   <span class="c1"># a 的值为 3.5</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># b 的值为 3</span>
</span></span></code></pre></div><p>同时，使用 <code>%</code> 运算符可以进行取模运算，即计算除法的余数。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">%</span> <span class="mi">2</span>   <span class="c1"># c 的值为 1</span>
</span></span></code></pre></div><p><code>**</code>是一种运算符，称为“双星号运算符”或“幂运算符”。它可以用于计算一个数的幂。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span>  <span class="c1"># 计算2的3次方，结果为8</span>
</span></span></code></pre></div><ol start="2">
<li>数字类型的转换</li>
</ol>
<p>在 Python 中，可以使用<code> int()</code>、<code>float()</code> 和 <code>complex()</code> 函数将其他类型的数据转换为整数、浮点数和复数类型。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="s2">&#34;123&#34;</span><span class="p">)</span>  <span class="c1"># 将字符串 &#34;123&#34; 转换为整数类型</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&#34;3.14&#34;</span><span class="p">)</span>  <span class="c1"># 将字符串 &#34;3.14&#34; 转换为浮点数类型</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="s2">&#34;1+2j&#34;</span><span class="p">)</span>  <span class="c1"># 将字符串 &#34;1+2j&#34; 转换为复数类型</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># 123 3.14 (1+2j)</span>
</span></span></code></pre></div><p>同时，可以使用 <code>str()</code>、<code>repr()</code> 和 <code>format()</code> 函数将数字转换为字符串类型。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>                     <span class="c1"># 将整数 123 转换为字符串类型</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="mf">3.1415926</span><span class="p">)</span>              <span class="c1"># 将浮点数 3.1415926 转换为字符串类型，使用 repr() 函数可以保留小数点后的精度</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="s2">&#34;</span><span class="si">{:.2f}</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">3.1415926</span><span class="p">)</span>   <span class="c1"># 将浮点数 3.1415926 转换为字符串类型，保留小数点后两位</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># 123 3.1415926 3.14</span>
</span></span></code></pre></div><ol start="3">
<li>随机数生成</li>
</ol>
<p>在 Python 中，可以使用 random 模块中的函数生成随机数。常用的函数包括：</p>
<ul>
<li><code>random.random()</code>：生成一个 0 到 1 之间的随机浮点数。</li>
<li><code>random.randint(a, b)</code>：生成一个在 a 和 b 之间（包括 a 和 b）的随机整数。</li>
<li><code>random.choice(seq)</code>：从序列 seq 中随机选择一个元素并返回。</li>
<li><code>random.shuffle(seq)</code>：将序列 seq 中的元素随机排序。</li>
</ul>
<p>例如，可以使用 random 模块中的 <code>randint()</code> 函数生成一个随机整数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">random</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>   <span class="c1"># 生成一个在 1 和 10 之间的随机整数</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="字符串">字符串</h2>
<p>在 Python 中，<strong>字符串是一种不可变序列类型</strong> ，用于表示文本数据。字符串是由一系列 Unicode 字符组成的，可以包含任何字符，包括字母、数字、标点符号、空格等。</p>
<p>定义字符串可以使用 <strong>单引号、双引号或三引号</strong>。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str1</span> <span class="o">=</span> <span class="s1">&#39;Hello, world!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">str2</span> <span class="o">=</span> <span class="s2">&#34;Hello, Python!&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">str3</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;This is a long string that
</span></span></span><span class="line"><span class="cl"><span class="s2">spans multiple lines.&#34;&#34;&#34;</span>
</span></span></code></pre></div><p>字符串支持一些常用的操作，例如：</p>
<ul>
<li>
<p>拼接字符串：使用加号（<code>+</code>）运算符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str4</span> <span class="o">=</span> <span class="n">str1</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">str2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># str4 = &#39;Hello, world! Hello, Python!&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>访问字符串中的字符：使用 <code>下标（索引）</code>运算符或切片运算符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">ch</span> <span class="o">=</span> <span class="n">str1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="c1"># ch = &#39;H&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">substr</span> <span class="o">=</span> <span class="n">str2</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">13</span><span class="p">]</span>  <span class="c1"># substr = &#39;Python&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>获取字符串的长度：使用<code> len()</code> 函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">str3</span><span class="p">)</span>   <span class="c1"># length = 45</span>
</span></span></code></pre></div></li>
<li>
<p>查找子字符串：使用 <code>find()</code> 或 index() 函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">pos1</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span>   <span class="c1"># pos1 = 7</span>
</span></span><span class="line"><span class="cl"><span class="n">pos2</span> <span class="o">=</span> <span class="n">str2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;Python&#39;</span><span class="p">)</span> <span class="c1"># pos2 = 7</span>
</span></span></code></pre></div></li>
<li>
<p>替换子字符串：使用 <code>replace()</code> 函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">new_str</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">,</span> <span class="s1">&#39;Python&#39;</span><span class="p">)</span>   <span class="c1"># new_str = &#39;Hello, Python!&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>分割字符串：使用 <code>split()</code> 函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">words</span> <span class="o">=</span> <span class="n">str3</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>   <span class="c1"># words = [&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;long&#39;, &#39;string&#39;, &#39;that&#39;, &#39;spans&#39;, &#39;multiple&#39;, &#39;lines.&#39;]</span>
</span></span></code></pre></div></li>
<li>
<p>连接字符串列表：使用 <code>join()</code> 函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">new_str</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>   <span class="c1"># new_str = &#39;This-is-a-long-string-that-spans-multiple-lines.&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>判断字符串是否包含某个子字符串：使用 <code>in</code> 或 <code>not in</code> 运算符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">flag1</span> <span class="o">=</span> <span class="s1">&#39;world&#39;</span> <span class="ow">in</span> <span class="n">str1</span>   <span class="c1"># flag1 = True</span>
</span></span><span class="line"><span class="cl"><span class="n">flag2</span> <span class="o">=</span> <span class="s1">&#39;Python&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">str2</span>   <span class="c1"># flag2 = False</span>
</span></span></code></pre></div></li>
<li>
<p>判断字符串是否以某个子字符串开头或结尾：使用 <code>startswith()</code> 和 <code>endswith()</code> 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">flag3</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>   <span class="c1"># flag3 = True</span>
</span></span><span class="line"><span class="cl"><span class="n">flag4</span> <span class="o">=</span> <span class="n">str2</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>   <span class="c1"># flag4 = True</span>
</span></span></code></pre></div></li>
<li>
<p>大小写转换：使用 <code>upper()</code> 和 <code>lower()</code> 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">upper_str</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>   <span class="c1"># upper_str = &#39;HELLO, WORLD!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">lower_str</span> <span class="o">=</span> <span class="n">str2</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>   <span class="c1"># lower_str = &#39;hello, python!&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>去除字符串两端的空白字符：使用 <code>strip()</code>、<code>lstrip()</code> 和 <code>rstrip()</code> 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str5</span> <span class="o">=</span> <span class="s1">&#39;  Hello, Python!  &#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str1</span> <span class="o">=</span> <span class="n">str5</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>   <span class="c1"># new_str1 = &#39;Hello, Python!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str2</span> <span class="o">=</span> <span class="n">str5</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>   <span class="c1"># new_str2 = &#39;Hello, Python!  &#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str3</span> <span class="o">=</span> <span class="n">str5</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>   <span class="c1"># new_str3 = &#39;  Hello, Python!&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>字符串转换为数字类型：使用 <code>int()</code>、<code>float()</code> 或 <code>complex()</code> 函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">num1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>   <span class="c1"># num1 = 123</span>
</span></span><span class="line"><span class="cl"><span class="n">num2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;3.14&#39;</span><span class="p">)</span>   <span class="c1"># num2 = 3.14</span>
</span></span><span class="line"><span class="cl"><span class="n">num3</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="s1">&#39;1+2j&#39;</span><span class="p">)</span>   <span class="c1"># num3 = (1+2j)</span>
</span></span></code></pre></div></li>
<li>
<p>判断字符串是否全部由数字组成：使用 <code>isnumeric()</code> 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str6</span> <span class="o">=</span> <span class="s1">&#39;123456&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag5</span> <span class="o">=</span> <span class="n">str6</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span>   <span class="c1"># flag5 = True</span>
</span></span></code></pre></div></li>
<li>
<p>判断字符串是否全部由字母组成：使用 <code>isalpha()</code> 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str7</span> <span class="o">=</span> <span class="s1">&#39;HelloWorld&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag6</span> <span class="o">=</span> <span class="n">str7</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>   <span class="c1"># flag6 = True</span>
</span></span></code></pre></div></li>
<li>
<p>判断字符串是否全部由字母和数字组成：使用 <code>isalnum()</code> 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str8</span> <span class="o">=</span> <span class="s1">&#39;Hello123&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag7</span> <span class="o">=</span> <span class="n">str8</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>   <span class="c1"># flag7 = True</span>
</span></span></code></pre></div></li>
<li>
<p>计算字符串中某个字符出现的次数：使用 <code>count()</code> 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str9</span> <span class="o">=</span> <span class="s1">&#39;Hello, Python!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">count</span> <span class="o">=</span> <span class="n">str9</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>   <span class="c1"># count = 2</span>
</span></span></code></pre></div></li>
<li>
<p>将字符串按指定的宽度进行对齐：使用 <code>ljust()</code>、<code>rjust()</code> 和 <code>center()</code> 方</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str10</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str4</span> <span class="o">=</span> <span class="n">str10</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>   <span class="c1"># new_str4 = &#39;Hello     &#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str5</span> <span class="o">=</span> <span class="n">str10</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>   <span class="c1"># new_str5 = &#39;     Hello&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str6</span> <span class="o">=</span> <span class="n">str10</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>   <span class="c1"># new_str6 = &#39;  Hello   &#39;</span>
</span></span></code></pre></div></li>
<li>
<p>将字符串中的某个子字符串替换为另一个字符串：使用 <code>translate()</code> 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str11</span> <span class="o">=</span> <span class="s1">&#39;Hello, Python!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">table</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="s1">&#39;lo&#39;</span><span class="p">,</span> <span class="s1">&#39;12&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str7</span> <span class="o">=</span> <span class="n">str11</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>   <span class="c1"># new_str7 = &#39;He22, Pyth2n!&#39;</span>
</span></span></code></pre></div><blockquote>
<p>这段代码使用了字符串的 translate() 方法，用于将字符串中的某个子字符串替换为另一个字符串。具体来说，它的作用是将字符串 str11 中的所有字符 &rsquo;l&rsquo; 替换为 &lsquo;1&rsquo;，将所有字符 &lsquo;o&rsquo; 替换为 &lsquo;2&rsquo;，生成一个新的字符串 new_str7。</p>
<p>这里用到了 str.maketrans() 方法，它用于生成一个转换表，将字符串中的某些字符转换为其他字符。这个方法接受两个参数，两个参数都是字符串，第一个参数是需要被替换的字符，第二个参数是替换为的字符。生成的转换表可以用于字符串的 translate() 方法。</p>
<p>具体来说，这里的代码使用 str.maketrans(&rsquo;lo&rsquo;, &lsquo;12&rsquo;) 生成了一个转换表，将字符 &rsquo;l&rsquo; 转换为 &lsquo;1&rsquo;，将字符 &lsquo;o&rsquo; 转换为 &lsquo;2&rsquo;。然后使用 translate() 方法将字符串 str11 中的字符按照转换表进行替换，生成了一个新的字符串 new_str7，它的值为 &lsquo;He22, Pyth2n!&rsquo;。</p>
<p>需要注意的是，<strong>这种字符串的替换方式只是按照字符进行替换，不是按照子字符串进行替换</strong>。如果需要按照子字符串进行替换，可以使用字符串的 replace() 方法。</p>
</blockquote>
</li>
<li>
<p>将字符串从左侧或右侧填充指定的字符：使用<code> lstrip()</code> 和 <code>rstrip() </code>方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str12</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str8</span> <span class="o">=</span> <span class="n">str12</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>   <span class="c1"># new_str8 = &#39;ello&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str9</span> <span class="o">=</span> <span class="n">str12</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>   <span class="c1"># new_str9 = &#39;Hell&#39;</span>
</span></span></code></pre></div></li>
</ul>
<p>Python 中字符串的知识点还有很多，包括但不限于：</p>
<ul>
<li>
<p>格式化字符串：Python 3.6 以后的版本支持 <code>f-string</code>，可以在字符串中直接使用表达式和变量，非常方便。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;John&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">age</span> <span class="o">=</span> <span class="mi">25</span>
</span></span><span class="line"><span class="cl"><span class="n">greeting</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;My name is </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">, and I am </span><span class="si">{</span><span class="n">age</span><span class="si">}</span><span class="s1"> years old.&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># greeting = &#39;My name is John, and I am 25 years old.&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>字符串的格式化输出：Python 中的 <code>format()</code> 方法可以对字符串进行格式化输出，支持各种格式控制符和占位符。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">pi</span> <span class="o">=</span> <span class="mf">3.141592653589793</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pi = </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pi</span><span class="p">))</span>   <span class="c1"># 输出 &#39;pi = 3.14&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>正则表达式：Python 中内置了 <code>re</code> 模块，可以使用正则表达式进行字符串匹配和替换操作，非常强大。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">re</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">str13</span> <span class="o">=</span> <span class="s1">&#39;Hello, world!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;w\w+&#39;</span>
</span></span><span class="line"><span class="cl"><span class="k">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">str13</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="k">match</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="k">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>   <span class="c1"># 输出 &#39;world&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>字符串的编码和解码：Python 中的字符串是 <code>Unicode</code> 字符串，可以使用 <code>encode()</code> 方法将字符串编码成字节串，使用 <code>decode()</code> 方法将字节串解码成字符串。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str14</span> <span class="o">=</span> <span class="s1">&#39;你好，世界！&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">utf8_bytes</span> <span class="o">=</span> <span class="n">str14</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">gb2312_bytes</span> <span class="o">=</span> <span class="n">str14</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;gb2312&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">utf8_str</span> <span class="o">=</span> <span class="n">utf8_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">gb2312_str</span> <span class="o">=</span> <span class="n">gb2312_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;gb2312&#39;</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>
<p>字符串的比较和排序：Python 中的字符串可以进行比较和排序操作，使用的是按照 <code>Unicode</code> 码点进行比较和排序的规则。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;world&#39;</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;Python&#39;</span><span class="p">,</span> <span class="s1">&#39;java&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">str_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">str_list</span><span class="p">)</span>   <span class="c1"># 输出 [&#39;Python&#39;, &#39;hello&#39;, &#39;java&#39;, &#39;world&#39;]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 对列表进行降序排序</span>
</span></span><span class="line"><span class="cl"><span class="n">str_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">str_list</span><span class="p">)</span>   <span class="c1"># 输出 [&#39;world&#39;, &#39;java&#39;, &#39;hello&#39;, &#39;Python&#39;]</span>
</span></span></code></pre></div></li>
</ul>
<blockquote>
<p>这段代码用于对一个字符串列表进行排序，它使用了列表的 <code>sort()</code> 方法，将列表中的元素按照一定的规则进行排序。具体来说，它的作用是将字符串列表 <code>str_list</code> 按照字典序进行升序排序，生成一个新的排序后的列表。</p>
<p>在 Python 中，字符串是可以进行比较操作的，比较的规则是按照 Unicode 码点进行比较。因此，对于字符串列表的排序，实际上就是按照字符串的字典序进行排序。具体来说，对于两个字符串 s1 和 s2，按照字典序进行比较的规则是：</p>
<ul>
<li>如果 s1 在 s2 的前面，则 s1 &lt; s2；</li>
<li>如果 s1 在 s2 的后面，则 s1 &gt; s2；</li>
<li>如果 s1 和 s2 相等，则 s1 == s2。</li>
</ul>
<p>因此，对于这段代码中的字符串列表 str_list，它的排序结果为 [&lsquo;Python&rsquo;, &lsquo;hello&rsquo;, &lsquo;java&rsquo;, &lsquo;world&rsquo;]，其中 &lsquo;Python&rsquo; 在字典序中排在最前面，&lsquo;world&rsquo; 在字典序中排在最后面。</p>
<p>需要注意的是，列表的 <code>sort()</code> 方法会直接修改原有的列表，如果不想修改原有列表，可以使用 <code>sorted() </code>函数。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">str_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;world&#39;</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;Python&#39;</span><span class="p">,</span> <span class="s1">&#39;java&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">str_list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">new_str_list</span><span class="p">)</span>   <span class="c1"># 输出 [&#39;Python&#39;, &#39;hello&#39;, &#39;java&#39;, &#39;world&#39;]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 对列表生成器进行降序排序</span>
</span></span><span class="line"><span class="cl"><span class="n">new_str_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">str_list</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">new_str_list</span><span class="p">)</span>   <span class="c1"># 输出 [&#39;world&#39;, &#39;java&#39;, &#39;hello&#39;, &#39;Python&#39;]</span>
</span></span></code></pre></div><p>这样做可以生成一个新的排序后的列表，不会修改原有的列表。</p>
</blockquote>
<p>需要注意的是，<strong>由于字符串是不可变的，因此对字符串进行修改会创建一个新的字符串对象。</strong></p>
<h2 id="列表">列表</h2>
<p>在 Python 中，列表（list）是一种可变序列类型，用于存储一组有序的元素。列表中的元素可以是任意类型的数据，包括数字、字符串、布尔值、列表、元组、字典等。列表使用方括号 [] 表示，元素之间使用逗号分隔。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;hello&#34;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">{</span><span class="s2">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Alice&#34;</span><span class="p">,</span> <span class="s2">&#34;age&#34;</span><span class="p">:</span> <span class="mi">20</span><span class="p">}]</span>
</span></span></code></pre></div><p>列表中的元素可以通过索引（下标）进行访问和修改。列表的索引从 0 开始，可以使用正整数和负整数来表示。正整数表示从左往右数的索引，负整数表示从右往左数的索引，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>     <span class="c1"># 输出 1，第一个元素的索引为 0</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>    <span class="c1"># 输出 5，最后一个元素的索引为 -1</span>
</span></span></code></pre></div><p>可以使用切片运算符 <code>:</code> 来获取列表的子列表。切片运算符表示从起始索引到终止索引之间的所有元素，不包括终止索引对应的元素。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>   <span class="c1"># 输出 [2, 3]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>    <span class="c1"># 输出 [1, 2, 3]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>    <span class="c1"># 输出 [4, 5]</span>
</span></span></code></pre></div><p>列表是一种可变类型，可以通过索引和切片操作来修改列表中的元素。此外，还可以使用列表的方法来添加、删除和修改元素。常用的列表方法包括：</p>
<ul>
<li><code>append(x)</code>：在列表末尾添加元素 x。</li>
<li><code>insert(i, x)</code>：在列表的第 i 个位置插入元素 x。</li>
<li><code>extend(iterable)</code>：在列表末尾添加可迭代对象 <code>iterable</code> 中的所有元素。</li>
<li><code>remove(x)</code>：删除列表中第一个值为 x 的元素。</li>
<li><code>pop([i])</code>：删除列表中索引为 i 的元素，并返回该元素的值。如果省略 i，则默认删除最后一个元素。</li>
<li><code>clear()</code>：删除列表中的所有元素。</li>
<li><code>index(x)</code>：返回列表中第一个值为 x 的元素的索引。如果列表中不存在值为 x 的元素，则抛出 <code>ValueError</code> 异常。</li>
<li><code>count(x)</code>：返回列表中值为 x 的元素的个数。</li>
<li><code>sort()</code>：对列表中的元素进行排序。默认按照升序排列，可以使用 <code>reverse=True</code> 参数进行降序排列。</li>
<li><code>reverse()</code>：将列表中的元素反转。</li>
</ul>
<p>例如，可以使用 <code>append() </code>方法向列表中添加元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span>   <span class="c1"># 输出 [1, 2, 3, 4]</span>
</span></span></code></pre></div><p>需要注意的是，列表是一种可变类型，修改一个列表会影响到所有引用该列表的变量。如果需要复制一个列表并独立使用，可以使用 <code>copy() </code>方法或切片运算符进行复制。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">new_list</span> <span class="o">=</span> <span class="n">my_list</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>   <span class="c1"># 复制一个新的列表</span>
</span></span><span class="line"><span class="cl"><span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span>   <span class="c1"># 输出 [1, 2, 3]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">new_list</span><span class="p">)</span>  <span class="c1"># 输出 [1, 2, 3, 4]</span>
</span></span></code></pre></div><p>除了上面提到的基本操作和常用方法，Python 列表还有一些其他的特性和用法，如下：</p>
<ol>
<li>列表推导式</li>
</ol>
<p>列表推导式（list comprehension）是一种快速创建列表的方式。列表推导式由一对方括号和一个表达式构成，表达式可以包含一个或多个循环和条件语句。例如，下面的列表推导式生成了一个包含 1 到 10 的平方值的列表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">squares</span><span class="p">)</span>   <span class="c1"># 输出 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span>
</span></span></code></pre></div><ol start="2">
<li><code>zip()</code> 函数</li>
</ol>
<p><code>zip()</code> 函数用于将多个列表中对应位置的元素合并成元组。<code>zip()</code> 函数返回一个 zip 对象，可以使用 <code>tuple()</code> 函数将其转换为元组列表。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;Alice&#34;</span><span class="p">,</span> <span class="s2">&#34;Bob&#34;</span><span class="p">,</span> <span class="s2">&#34;Charlie&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">ages</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">ages</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">zipped</span><span class="p">))</span>   <span class="c1"># 输出 [(&#39;Alice&#39;, 20), (&#39;Bob&#39;, 25), (&#39;Charlie&#39;, 30)]</span>
</span></span></code></pre></div><ol start="3">
<li>列表的复制和浅拷贝</li>
</ol>
<p>当使用赋值语句将一个列表赋值给另一个变量时，实际上是将该列表的引用赋值给了新变量，两个变量指向同一个列表对象。如果修改其中一个变量对应的列表，另一个变量也会受到影响。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># 输出 [1, 2, 3, 4]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>   <span class="c1"># 输出 [1, 2, 3, 4]</span>
</span></span></code></pre></div><p>为了避免这种情况，可以使用 <code>copy()</code> 方法或切片运算符进行复制。但是需要注意的是，这种复制方式只是进行了浅拷贝，即只复制了列表中的元素的引用，而不是元素本身。如果列表中的元素是可变对象（如列表、字典等），修改其中一个元素的值会影响到所有引用该元素的变量。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># 输出 [[1, 2, 3], [3, 4]]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>   <span class="c1"># 输出 [[1, 2, 3], [3, 4]]</span>
</span></span></code></pre></div><p>可以看到，修改 b 中的第一个元素也影响到了 a 中的元素。如果需要完全独立的复制一个列表，需要使用深拷贝（deep copy）方式，可以使用 copy 模块中的 <code>deepcopy()</code> 函数。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">copy</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># 输出 [[1, 2], [3, 4]]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>   <span class="c1"># 输出 [[1, 2, 3], [3, 4]]</span>
</span></span></code></pre></div><ol start="4">
<li>列表解包</li>
</ol>
<p>列表解包（list unpacking）是一种快速将列表中的元素分别赋值给多个变量的方式。列表解包使用一对方括号和多个变量名构成，变量名之间使用逗号分隔。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">my_list</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>   <span class="c1"># 输出 1 2 3</span>
</span></span></code></pre></div><ol start="5">
<li>列表的判断和比较</li>
</ol>
<p>可以使用 <code>in</code> 和 <code>not in</code> 运算符判断一个元素是否在列表中，可以使用 <code>==</code> 和 <code>!=</code> 运算符比较两个列表是否相等。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="mi">2</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">)</span>    <span class="c1"># 输出 True</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="mi">4</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">)</span>   <span class="c1"># 输出 True</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">other_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span> <span class="o">==</span> <span class="n">other_list</span><span class="p">)</span>   <span class="c1"># 输出 True</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span> <span class="ow">is</span> <span class="n">other_list</span><span class="p">)</span>   <span class="c1"># 输出 False，两个列表不是同一个对象</span>
</span></span></code></pre></div><p>需要注意的是，列表的比较是按照元素的顺序和值进行的，如果两个列表包含相同的元素但顺序不同，则它们不相等。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>   <span class="c1"># 输出 False</span>
</span></span></code></pre></div><ol start="6">
<li>列表的迭代和生成器</li>
</ol>
<p>可以使用 <code>for</code> 循环对列表进行迭代，也可以使用列表推导式或生成器表达式生成一个生成器（generator）。生成器是一种特殊的迭代器，可以逐个产生列表中的元素，避免一次性加载整个列表到内存中。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 列表迭代</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 生成器表达式</span>
</span></span><span class="line"><span class="cl"><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span></code></pre></div><ol start="7">
<li>列表的高级排序</li>
</ol>
<p>除了 <code>sort() </code>方法之外，Python 还提供了一些高级的排序方法，如 <code>sorted()</code> 函数和 <code>sort() </code>方法的 key 参数和 cmp 参数。sorted() 函数可以对任意可迭代对象进行排序，返回一个新的有序列表。key 参数指定一个函数，用于对每个元素进行排序，cmp 参数可以指定一个比较函数，用于比较两个元素。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;apple&#34;</span><span class="p">,</span> <span class="s2">&#34;banana&#34;</span><span class="p">,</span> <span class="s2">&#34;orange&#34;</span><span class="p">,</span> <span class="s2">&#34;grape&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 按照字符串长度排序</span>
</span></span><span class="line"><span class="cl"><span class="n">sorted_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">my_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">sorted_list</span><span class="p">)</span>   <span class="c1"># 输出 [&#39;apple&#39;, &#39;grape&#39;, &#39;banana&#39;, &#39;orange&#39;]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 按照字母顺序排序</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span>   <span class="c1"># 输出 [&#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;orange&#39;]</span>
</span></span></code></pre></div><h2 id="元组">元组</h2>
<p>在 Python 中，元组（tuple）是一种不可变的序列类型，用于存储一组有序的对象。元组与列表类似，但元组一旦创建就不能被修改，也没有添加、删除、修改等操作的方法，因此元组更加轻量级，而且更加安全。元组使用一对圆括号和逗号分隔的对象列表构成，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span></code></pre></div><p>可以使用索引和切片运算符对元组进行访问和切片。元组支持所有的序列操作，如 len()、in、+、* 等。元组也可以包含任意类型的对象，包括其他元组。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&#34;apple&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="s2">&#34;banana&#34;</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>   <span class="c1"># 输出 ((&#39;apple&#39;, 1, True), &#39;banana&#39;, 2.5)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>   <span class="c1"># 输出 1</span>
</span></span></code></pre></div><p>元组的不可变性可以保证元组中的对象不会被修改，从而增强程序的安全性和稳定性。元组通常用于表示一些不可变的数据，如坐标、日期、时间等。元组也可以用于函数的返回值，将多个值打包成一个元组返回。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_rectangle_area_and_perimeter</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">area</span> <span class="o">=</span> <span class="n">length</span> <span class="o">*</span> <span class="n">width</span>
</span></span><span class="line"><span class="cl">    <span class="n">perimeter</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">width</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">area</span><span class="p">,</span> <span class="n">perimeter</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">area</span><span class="p">,</span> <span class="n">perimeter</span> <span class="o">=</span> <span class="n">get_rectangle_area_and_perimeter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">perimeter</span><span class="p">)</span>   <span class="c1"># 输出 50 30</span>
</span></span></code></pre></div><p>需要注意的是，如果元组中只有一个元素，需要在元素后面加上逗号，否则会被解释为其他类型。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>   <span class="c1"># 包含一个元素的元组</span>
</span></span><span class="line"><span class="cl"><span class="n">not_a_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># 一个整数，而不是元组</span>
</span></span></code></pre></div><p>下面是 Python 元组的一些其他特性和用法：</p>
<ol>
<li>元组解包</li>
</ol>
<p>和列表解包类似，可以使用元组解包（tuple unpacking）将元组中的元素依次赋值给多个变量，变量名之间使用逗号分隔。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">my_tuple</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>   <span class="c1"># 输出 1 2 3</span>
</span></span></code></pre></div><ol start="2">
<li>元组的比较和排序</li>
</ol>
<p>和列表一样，元组也支持比较运算符（==、!=、&lt;、&lt;=、&gt;、&gt;=）和排序方法（sorted()、sort()）。元组的比较是按照元素的顺序和值进行的，如果两个元组包含相同的元素但顺序不同，则它们不相等。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>   <span class="c1"># 输出 False</span>
</span></span></code></pre></div><ol start="3">
<li>元组作为不可变字典的键</li>
</ol>
<p>由于元组是不可变的，可以用作字典的键。如果要使用列表作为字典的键，则需要先将列表转换为元组。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{(</span><span class="s2">&#34;apple&#34;</span><span class="p">,</span> <span class="s2">&#34;banana&#34;</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s2">&#34;orange&#34;</span><span class="p">,</span> <span class="s2">&#34;grape&#34;</span><span class="p">):</span> <span class="mi">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[(</span><span class="s2">&#34;apple&#34;</span><span class="p">,</span> <span class="s2">&#34;banana&#34;</span><span class="p">)])</span>   <span class="c1"># 输出 1</span>
</span></span></code></pre></div><ol start="4">
<li><code>*</code> 运算符</li>
</ol>
<p>可以使用 <code>*</code> 运算符将多个元组合并成一个元组。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">t3</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">t1</span><span class="p">,</span> <span class="o">*</span><span class="n">t2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>   <span class="c1"># 输出 (1, 2, 3, 4, 5, 6)</span>
</span></span></code></pre></div><ol start="5">
<li>元组的生成器</li>
</ol>
<p>和列表一样，元组也可以使用生成器表达式生成一个生成器（generator）。生成器是一种特殊的迭代器，可以逐个产生元组中的元素，避免一次性加载整个元组到内存中。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 生成器表达式</span>
</span></span><span class="line"><span class="cl"><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_tuple</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="集合">集合</h2>
<p>Python中的集合类型是set（集合）和frozenset（不可变集合）。</p>
<p>set是一种无序、可变的集合类型，其中不允许有重复元素。可以使用大括号<code>{}</code>或<code>set()</code>函数来创建一个集合。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 3}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 3}</span>
</span></span></code></pre></div><p>可以使用add()方法向集合中添加元素，使用<code>remove()</code>方法删除元素。可以使用<code>in</code>关键字来检查元素是否在集合中。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">my_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 3, 4}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 {1, 3, 4}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="mi">2</span> <span class="ow">in</span> <span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 False</span>
</span></span></code></pre></div><p>集合支持各种集合运算，如并集、交集、差集等。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">set1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">set2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 并集</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">|</span> <span class="n">set2</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 3, 4, 5}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 交集</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">&amp;</span> <span class="n">set2</span><span class="p">)</span>   <span class="c1"># 输出 {3}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 差集</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 对称差集</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">^</span> <span class="n">set2</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 4, 5}</span>
</span></span></code></pre></div><p>frozenset是一种不可变的集合类型，可以使用<code>frozenset()</code>函数来创建。frozenset和set具有相似的操作，但是不支持添加、删除元素等操作。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_fset</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_fset</span><span class="p">)</span>   <span class="c1"># 输出 frozenset({1, 2, 3})</span>
</span></span></code></pre></div><p>下面是Python中集合类型的一些其他特性和用法：</p>
<ol>
<li>列表、元组转换为集合</li>
</ol>
<p>可以使用<code>set()</code>函数将列表或元组转换为集合。集合会自动去除重复元素。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 3}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">my_tuple</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 {4, 5, 6}</span>
</span></span></code></pre></div><ol start="2">
<li>集合的长度</li>
</ol>
<p>可以使用<code>len()</code>函数获取集合的长度（即集合中元素的个数）。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_set</span><span class="p">))</span>   <span class="c1"># 输出 3</span>
</span></span></code></pre></div><ol start="3">
<li>集合的迭代</li>
</ol>
<p>可以使用<code>for</code>循环迭代集合中的元素。由于集合是无序的，每次迭代的顺序可能不同。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_set</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span></code></pre></div><ol start="4">
<li>集合解析</li>
</ol>
<p>和列表解析类似，可以使用集合解析（set comprehension）快速生成一个集合。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 3, 4, 5}</span>
</span></span></code></pre></div><ol start="5">
<li>frozenset作为字典键</li>
</ol>
<p>由于<code>frozenset</code>是不可变的，可以作为字典的键。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}):</span> <span class="s2">&#34;A&#34;</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}):</span> <span class="s2">&#34;B&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">})])</span>   <span class="c1"># 输出 &#34;A&#34;</span>
</span></span></code></pre></div><ol start="6">
<li>集合的类型</li>
</ol>
<p>可以使用<code>type()</code>函数查看集合的类型，也可以使用<code>isinstance()</code>函数判断集合是否属于某种类型。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">my_set</span><span class="p">))</span>   <span class="c1"># 输出 &lt;class &#39;set&#39;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_set</span><span class="p">,</span> <span class="nb">set</span><span class="p">))</span>   <span class="c1"># 输出 True</span>
</span></span></code></pre></div><ol start="7">
<li>集合的复制</li>
</ol>
<p>集合可以使用<code>copy()</code>方法进行复制。复制后的集合和原集合具有不同的内存地址，互不影响。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">new_set</span> <span class="o">=</span> <span class="n">my_set</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">new_set</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 3}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">new_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">new_set</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 3, 4}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>    <span class="c1"># 输出 {1, 2, 3}</span>
</span></span></code></pre></div><ol start="8">
<li>集合的更新</li>
</ol>
<p>可以使用<code>update()</code>方法将一个集合的元素添加到另一个集合中。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">set1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">set2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">set1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span>   <span class="c1"># 输出 {1, 2, 3, 4, 5}</span>
</span></span></code></pre></div><ol start="9">
<li>集合的删除</li>
</ol>
<p>可以使用<code>discard()</code>方法或<code>remove()</code>方法来删除集合中的元素。如果要删除的元素不存在，<code>discard()</code>方法不会报错，而<code>remove()</code>方法会抛出KeyError异常。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">my_set</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 {1, 3}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 {1}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_set</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>   <span class="c1"># 不会报错</span>
</span></span><span class="line"><span class="cl"><span class="n">my_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>    <span class="c1"># 抛出KeyError异常</span>
</span></span></code></pre></div><ol start="10">
<li>集合的清空</li>
</ol>
<p>可以使用<code>clear()</code>方法清空集合中的所有元素。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">my_set</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>   <span class="c1"># 输出 set()</span>
</span></span></code></pre></div><h2 id="字典">字典</h2>
<p>在Python中，字典是一种可变的数据类型，用于存储键-值对。字典用大括号{}表示，每个键值对之间用逗号分隔。字典中的键必须是不可变的，如整数、字符串或元组，而值可以是任意的Python对象。</p>
<p>下面是一个简单的字典示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span></code></pre></div><p>在上面的例子中，键&rsquo;name&rsquo;、&lsquo;age&rsquo;和&rsquo;city&rsquo;分别与值&rsquo;John&rsquo;、30和&rsquo;New York&rsquo;相关联。可以使用键来访问字典中的值，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>  <span class="c1"># 输出：John</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">])</span>  <span class="c1"># 输出：30</span>
</span></span></code></pre></div><p>您还可以使用<code>dict()</code>函数从其他序列或映射创建字典，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;Mary&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;city&#39;</span><span class="p">,</span> <span class="s1">&#39;Los Angeles&#39;</span><span class="p">)])</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict2</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;Mary&#39;, &#39;age&#39;: 25, &#39;city&#39;: &#39;Los Angeles&#39;}</span>
</span></span></code></pre></div><p>字典支持许多有用的方法，如<code>keys()</code>、<code>values()</code>和<code>items()</code>，这些方法返回字典的键、值和键-值对的视图。字典的视图可用于按照特定的顺序访问字典中的元素，或对字典进行迭代操作。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 获取字典的键列表</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">my_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>  <span class="c1"># 输出：[&#39;name&#39;, &#39;age&#39;, &#39;city&#39;]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 获取字典的值列表</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">my_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>  <span class="c1"># 输出：[&#39;John&#39;, 30, &#39;New York&#39;]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 获取字典的键-值对列表</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">my_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>  <span class="c1"># 输出：[(&#39;name&#39;, &#39;John&#39;), (&#39;age&#39;, 30), (&#39;city&#39;, &#39;New York&#39;)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用for循环迭代字典的键和值</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">my_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span></span></code></pre></div><p>以下是一些进阶的字典操作：</p>
<ol>
<li>向字典中添加或更新键值对</li>
</ol>
<p>可以使用<code>[key]</code>索引或<code>update()</code>方法向字典中添加或更新键值对。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 添加新的键值对</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;gender&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;male&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;, &#39;gender&#39;: &#39;male&#39;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 更新现有的键值对</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 40, &#39;city&#39;: &#39;New York&#39;, &#39;gender&#39;: &#39;male&#39;}</span>
</span></span></code></pre></div><p>可以使用<code>update()</code>方法将一个字典合并到另一个字典中。如果键相同，则后一个字典的值将覆盖前一个字典的值。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gender&#39;</span><span class="p">:</span> <span class="s1">&#39;male&#39;</span><span class="p">,</span> <span class="s1">&#39;country&#39;</span><span class="p">:</span> <span class="s1">&#39;USA&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">my_dict2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;, &#39;gender&#39;: &#39;male&#39;, &#39;country&#39;: &#39;USA&#39;}</span>
</span></span></code></pre></div><ol start="2">
<li>删除字典中的键值对</li>
</ol>
<p>可以使用<code>del</code>语句或<code>pop()</code>方法从字典中删除键值对。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 使用del删除键值对</span>
</span></span><span class="line"><span class="cl"><span class="k">del</span> <span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;gender&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 40, &#39;city&#39;: &#39;New York&#39;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用pop删除键值对</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;city&#39;: &#39;New York&#39;}</span>
</span></span></code></pre></div><ol start="3">
<li>使用<code>items()</code>方法遍历字典的键值对</li>
</ol>
<p>可以使用<code>items()</code>方法遍历字典的键值对。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">my_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>在这个例子中，<code>items()</code>方法返回一个由键值对组成的元组，然后使用<code>for</code>循环遍历这个元组并打印出每个键值对。</p>
<ol start="3">
<li>使用字典推导式创建字典</li>
</ol>
<p>可以使用字典推导式从其他序列或字典创建新的字典。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 从列表创建字典</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;John&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;city&#39;</span><span class="p">,</span> <span class="s1">&#39;New York&#39;</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 从另一个字典创建字典</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gender&#39;</span><span class="p">:</span> <span class="s1">&#39;male&#39;</span><span class="p">,</span> <span class="s1">&#39;country&#39;</span><span class="p">:</span> <span class="s1">&#39;USA&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict3</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">my_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">my_dict2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict3</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;, &#39;gender&#39;: &#39;male&#39;, &#39;country&#39;: &#39;USA&#39;}</span>
</span></span></code></pre></div><ol start="4">
<li>使用<code>defaultdict</code>创建默认值字典</li>
</ol>
<p><code>defaultdict</code>是一个字典子类，它允许您指定一个默认值，以便在访问不存在的键时返回该值。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># 默认值为0</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;age&#39;: 1}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_dict2</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># 默认值为[]</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict2</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;John&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict2</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;names&#39;: [&#39;John&#39;]}</span>
</span></span></code></pre></div><ol start="5">
<li>使用<code>sorted()</code>函数按照键或值排序字典</li>
</ol>
<p>可以使用<code>sorted()</code>函数按照字典的键或值对字典进行排序。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 按照键排序字典</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">sorted_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">my_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">sorted_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;, &#39;name&#39;: &#39;John&#39;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 按照值排序字典</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">sorted_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">my_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">sorted_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;age&#39;: 30, &#39;name&#39;: &#39;John&#39;, &#39;city&#39;: &#39;New York&#39;}</span>
</span></span></code></pre></div><ol start="6">
<li>使用<code>zip()</code>函数将两个序列合并为字典</li>
</ol>
<p>可以使用<code>zip()</code>函数将两个序列合并为一个字典。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;New York&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;}</span>
</span></span></code></pre></div><ol start="7">
<li>使用<code>json</code>模块将字典转换为JSON格式</li>
</ol>
<p>可以使用<code>json</code>模块将Python字典转换为JSON格式的字符串。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">json</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">json_str</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">json_str</span><span class="p">)</span>  <span class="c1"># 输出：{&#34;name&#34;: &#34;John&#34;, &#34;age&#34;: 30, &#34;city&#34;: &#34;New York&#34;}</span>
</span></span></code></pre></div><ol start="8">
<li>使用<code>pprint</code>模块打印出漂亮的字典输出</li>
</ol>
<p>可以使用<code>pprint</code>模块打印出漂亮的、易于阅读的字典输出。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>
</span></span></code></pre></div><ol start="9">
<li>使用<code>copy()</code>方法或<code>dict()</code>构造函数创建字典副本</li>
</ol>
<p>可以使用<code>copy()</code>方法或<code>dict()</code>构造函数创建字典的副本。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict_copy</span> <span class="o">=</span> <span class="n">my_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># 使用copy()方法创建副本</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict_copy</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict_copy</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 40, &#39;city&#39;: &#39;New York&#39;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_dict2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 使用dict()构造函数创建副本</span>
</span></span><span class="line"><span class="cl"><span class="n">my_dict2</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Mary&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict2</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;Mary&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;}</span>
</span></span></code></pre></div><ol start="10">
<li>使用<code>setdefault()</code>方法获取字典的值</li>
</ol>
<p>可以使用<code>setdefault()</code>方法获取字典的值。如果键存在，则返回键的值。如果键不存在，则返回默认值并将其添加到字典中。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">name</span> <span class="o">=</span> <span class="n">my_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">gender</span> <span class="o">=</span> <span class="n">my_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;gender&#39;</span><span class="p">,</span> <span class="s1">&#39;male&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># 输出：John</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">gender</span><span class="p">)</span>  <span class="c1"># 输出：male</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：{&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;, &#39;gender&#39;: &#39;male&#39;}</span>
</span></span></code></pre></div><ol start="11">
<li>字典解包</li>
</ol>
<p>字典解包是一种将字典转换为关键字参数的技术。字典解包使用一个或两个星号运算符（<code>*</code>或<code>**</code>）来实现。</p>
<p>具体来说，当使用单个星号运算符<code>*</code>将一个字典解包时，它会将字典的键解包为一个可迭代对象，可以在函数调用中作为位置参数传递。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">city</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Name: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Age: </span><span class="si">{</span><span class="n">age</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;City: </span><span class="si">{</span><span class="n">city</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">print_info</span><span class="p">(</span><span class="o">*</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：TypeError: print_info() takes 3 positional arguments but 6 were given</span>
</span></span></code></pre></div><p>在这个例子中，由于<code>print_info()</code>函数需要3个关键字参数<code>name</code>、<code>age</code>和<code>city</code>，而字典<code>my_dict</code>中有3个键<code>name</code>、<code>age</code>和<code>city</code>，因此它们被解包为一个可迭代对象<code>('name', 'age', 'city')</code>，然后作为位置参数传递给<code>print_info()</code>函数。但是，由于<code>print_info()</code>函数需要的是关键字参数而不是位置参数，因此出现了<code>TypeError</code>异常。</p>
<p>为了解决这个问题，可以使用双星号运算符<code>**</code>将字典解包为关键字参数。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">city</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Name: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Age: </span><span class="si">{</span><span class="n">age</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;City: </span><span class="si">{</span><span class="n">city</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;city&#39;</span><span class="p">:</span> <span class="s1">&#39;New York&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">print_info</span><span class="p">(</span><span class="o">**</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># 输出：Name: John Age: 30 City: New York</span>
</span></span></code></pre></div><p>在这个例子中，双星号运算符<code>**</code>将字典<code>my_dict</code>解包为关键字参数<code>name='John'</code>、<code>age=30</code>和<code>city='New York'</code>，然后将它们作为关键字参数传递给<code>print_info()</code>函数，这样就能够成功地打印出字典中的值了。</p>
<p>需要注意的是，只有在函数定义中明确指定了这些关键字参数时，才能使用字典解包。否则，将会引发<code>TypeError</code>异常。</p>
<h2 id="none">None</h2>
<p>在Python中，<code>None</code>是一个特殊的对象，表示一个空值或缺失值。<code>None</code>是Python中唯一的空值对象，用于表示没有值的情况。它是一个单例对象，也就是说，Python中的所有<code>None</code>引用都指向同一个对象。</p>
<p><code>None</code>类型可以用于多种情况，例如：</p>
<ul>
<li>表示函数没有返回值</li>
<li>表示变量尚未被赋值</li>
<li>表示一个字典中没有指定的键</li>
<li>表示一个类的属性尚未被赋值</li>
</ul>
<p>以下是一些使用<code>None</code>的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">print_hello</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Hello, world!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 函数没有返回值，所以可以不写return语句</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;x is not defined&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">city</span> <span class="o">=</span> <span class="n">my_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;city&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">city</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;No city found in my_dict&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s2">&#34;John&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">age</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Age not specified&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>在这些例子中，我们可以看到<code>None</code>被用于表示函数没有返回值、变量尚未被赋值、一个字典中没有指定的键以及一个类的属性尚未被赋值等情况。</p>
<p>Python中<code>None</code>类型的一些补充说明：</p>
<ol>
<li>NoneType 类型</li>
</ol>
<p>在Python中，<code>None</code>是一个特殊的对象，其类型为<code>NoneType</code>。可以使用<code>type()</code>函数来检查一个对象的类型。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1"># 输出：&lt;class &#39;NoneType&#39;&gt;</span>
</span></span></code></pre></div><p>在这个例子中，<code>type()</code>函数返回变量<code>x</code>的类型，即<code>NoneType</code>。</p>
<ol start="2">
<li>避免与其他类型混淆</li>
</ol>
<p>在Python中，<code>None</code>类型只能与自身进行比较，不能与其他类型进行比较。如果不小心将<code>None</code>与其他类型混淆，可能会导致一些奇怪的行为。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;x is an empty string&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>在这个例子中，由于<code>==</code>操作符将<code>None</code>与空字符串进行比较，所以程序不会打印任何内容。如果想检查一个变量是否为字符串，应该使用<code>isinstance()</code>函数。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;x is a string&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>在这个例子中，<code>isinstance()</code>函数检查变量<code>x</code>是否为字符串类型。</p>
<ol start="3">
<li>使用<code>is not None</code>检查变量是否存在</li>
</ol>
<p>在Python中，如果想检查一个变量是否存在，应该使用<code>is not None</code>表达式。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;x is defined&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>在这个例子中，<code>is not None</code>表达式检查变量<code>x</code>是否存在。如果存在，则打印出<code>x is defined</code>。这种写法比使用<code>if x:</code>更明确，可以避免一些潜在的问题。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-22｜微信读书笔记助手</title>
      <link>https://blog.chensoul.com/posts/2023/06/09/weekly_review_22/</link>
      <pubDate>Fri, 09 Jun 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/06/09/weekly_review_22/</guid>
      <description>前言 本篇是对 2023-05-29 到 2023-06-04 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 读书、健身、定投、帮朋友、陪家人，本周周报增加一</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-05-29</code> 到 <code>2023-06-04</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>读书、健身、定投、帮朋友、陪家人，本周周报增加一块内容：读书，记录每周读书的时间。</p>
<h2 id="微信读书笔记助手">微信读书笔记助手</h2>
<p>最近注销了微信阅读账号，清空了历史数据。本着宁缺毋滥的原则，书架重新添加了几本书。计划是重新使用微信阅读养成读书的习惯。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-22-03.png" alt="weekly-review-22-03"  />
</p>
<p>在chrome浏览器添加了一个插件 <a href="https://chrome.google.com/webstore/detail/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%8A%A9%E6%89%8B/cmlenojlebcodibpdhmklglnbaghpdcg">微信读书笔记助手</a> ，可以将读书笔记一键导出为 markdown 格式。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-22-02.png" alt="weekly-review-22-02" style="width:50%;" />
<p>导出的内容标注是一个标注一个段落，段落之间有一个换行。段落后面可以添加自己的思考（比如，用红色标注颜色）。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-22-07.png" alt="weekly-review-22-07"  />
</p>
<h2 id="读书">读书</h2>
<p>本周阅读统计（图片来自微信阅读 app 分享）：</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-22-01.png" alt="weekly-review-22-01" style="width:50%;" />
<h2 id="理财">理财</h2>
<p>这周总计支出 2528 元，明细如下：</p>
<ul>
<li>6月4日：138元</li>
<li>6月3日：1650元，医院看病1600</li>
<li>6月2日：61元</li>
<li>6月1日：0元</li>
<li>5月31日：108元</li>
<li>5月30日：625元，公司停车场费用600</li>
<li>5月29日：41元</li>
</ul>
<h2 id="健身">健身</h2>
<blockquote>
<p>我跑过了一些地方，希望随着时间推移，地图点亮的地方越来越多。2 年里我跑过 2个省份 2个城市。更多跑步数据在我的 <a href="https://run.chensoul.com/">跑步</a> 主页。</p>
</blockquote>
<p>本周跑步 42.66 公里，最长跑步距离为 9.2 公里。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-22-04.png" alt="weekly-review-22-04"  />
</p>
<p>明细数据如下：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-22-05.png" alt="weekly-review-22-05"  />
</p>
<p>在朋友圈发了一个5月跑步500公里动态，一个高中同学建议我不要过度跑步，最好是跑步一天休息一天，以免伤了膝盖。受他影响，受他影响，6月1日没有跑步，6月3日和4日，带老爸去医院做检查，所以没有跑步。照此看来，6月连续跑步30天、累计200公里的目标铁定是完成不了，所以及时调整目标和计划，还是以长期主义的思路保持跑步的习惯，不求数量。</p>
<h2 id="工作">工作</h2>
<p>最近在学习的内容清单：</p>
<ul>
<li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/tree/dev">Effective Java（第 3 版）</a></li>
<li><a href="https://java-design-patterns.com/zh/">Java Design Patterns (中文)</a></li>
<li><a href="https://realpython.com/">Real Python</a></li>
</ul>
<p>本周完成四篇博客：</p>
<ul>
<li>
<p><a href="/posts/2023/06/02/java-design-patterns-visitor/">Java设计模式：Visitor</a></p>
</li>
<li>
<p><a href="/posts/2023/06/01/java-design-patterns-acyclic-visitor/">Java设计模式：Acyclic Visitor</a></p>
</li>
<li>
<p><a href="/posts/2023/06/01/what-is-pip/">[译]使用 Python 的 pip 管理项目的依赖关系</a></p>
</li>
<li>
<p><a href="/posts/2023/06/01/python-wheels/">[译]什么是 Python Wheels，你为什么要关心它？</a></p>
</li>
</ul>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-22-06.png" alt="weekly-review-22-06"  />
</p>
<h2 id="本周分享">本周分享</h2>
<p>大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道或者我的 <a href="https://memos.chensoul.com/">memos</a> 中。我写了一个 python 脚本从 memos读取最近一周的 memos 记录。</p>
<ul>
<li>📌<code>2023-05-31</code> 看到一个很适合新手入门「数据结构与算法」的开源书《Hello 算法》，通过动画图解结构化地讲解数据结构和算法知识，内容清晰易懂、学习曲线挺平滑，代码上支持 Java,C++, Python, Go, JS, TS, CSharp, Swift 一键运行看效果，比市面上卖的普通书好不少。 🤖 <a href="https://hello-algo.com">https://hello-algo.com</a> <code>#memos</code> <code>#skill</code></li>
<li>📌<code>2023-05-31</code> 今日重磅开源库推荐 - Plane  <a href="https://github.com/makeplane/plane">https://github.com/makeplane/plane</a>  Jira 的开源版平替，有很多人都讨厌 Jira，觉得它复杂难用。  Plane 完全开源，而且界面要简洁舒服易用很多。 部署方便快捷, 支持 Docker 部署。 还很贴心的支持从 Github 以及 Jira 直接导入。  想尝试新的项目管理工具的朋友可以尝试一下。<code>#memos</code> <code>#tool</code></li>
<li>📌<code>2023-05-31</code> 「Next.js 应用开发实践」 <a href="https://nextjs-in-action-cn.taonan.lu/">https://nextjs-in-action-cn.taonan.lu/</a>   <code>#memos</code> <code>#web</code></li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译]什么是 Python Wheels，你为什么要关心它？</title>
      <link>https://blog.chensoul.com/posts/2023/06/01/python-wheels/</link>
      <pubDate>Thu, 01 Jun 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/06/01/python-wheels/</guid>
      <description>Python .whl 文件或 wheels 是 Python 中很少被讨论的部分，但它们对 Python 包的安装过程大有裨益。如果您使用 pip 安装了 Python 包，那么 Wheels 很可能使安装更快、更高效。 Wheels 是 Python 生态系统的</description>
      <content:encoded><![CDATA[<p><img loading="lazy" src="https://files.realpython.com/media/What-are-Python-Wheels-and-Why-Should-You-Care_Watermarked.22246cad13be.jpg" alt="What Are Python Wheels and Why Should You Care?"  />
</p>
<p>Python <code>.whl</code> 文件或 <a href="https://packaging.python.org/glossary/#term-wheel">wheels</a> 是 Python 中很少被讨论的部分，但它们对 <a href="https://realpython.com/python-modules-packages/">Python 包</a>的安装过程大有裨益。如果您使用 <a href="https://realpython.com/what-is-pip/">pip</a> 安装了 Python 包，那么 Wheels 很可能使安装更快、更高效。</p>
<p>Wheels 是 Python 生态系统的一个组件，有助于使包安装正常工作。它们允许更快的安装和更稳定的包分发过程。在本教程中，您将深入了解 Wheels 是什么，它们有什么好处，以及它们如何获得牵引力并使 Python 使用起来更加愉快。</p>
<p><strong>在本教程中，您将学习：</strong></p>
<ul>
<li>什么是 Wheels 以及它们与源代码分发的比较</li>
<li>如何使用 Wheels 来控制包安装过程</li>
<li>如何为您自己的 Python 包创建和分发 Wheels</li>
</ul>
<p>您将从用户和开发人员的角度看到使用流行的开源 Python 包的示例。</p>
<blockquote>
<p>免费赠品：单击<a href="https://realpython.com/python-wheels/">此处</a>获取 Python 备忘单并学习 Python 3 的基础知识，例如使用数据类型、字典、列表和 Python 函数。</p>
</blockquote>
<h2 id="安装">安装</h2>
<p>接下来，激活虚拟环境并确保安装了最新版本的 <code>pip</code> 、 <code>wheel</code> 和 <code>setuptools</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m venv env <span class="o">&amp;&amp;</span> <span class="nb">source</span> ./env/bin/activate
</span></span><span class="line"><span class="cl">$ python -m pip install -U pip wheel setuptools
</span></span><span class="line"><span class="cl">Successfully installed pip 20.1 setuptools-46.1.3 wheel-0.34.2
</span></span></code></pre></div><p>这就是您尝试安装和构建 Wheels 所需的全部内容！</p>
<h2 id="python-打包变得更好python-wheels-简介">Python 打包变得更好：Python Wheels 简介</h2>
<p>在学习如何将项目打包到 wheel 之前，从用户的角度了解使用 wheel 的样子会很有帮助。这听起来可能有点落后，但了解 Wheels 如何工作的一个好方法是从安装一个不是 Wheels 的东西开始。</p>
<p>您可以像往常一样，通过将 Python 包安装到您的环境中来开始这个实验。在这种情况下，安装 <a href="https://github.com/unbit/uwsgi">uWSGI</a> 版本 2.0.x：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m pip install <span class="s1">&#39;uwsgi==2.0.*&#39;</span>
</span></span><span class="line"><span class="cl">Collecting <span class="nv">uwsgi</span><span class="o">==</span>2.0.*
</span></span><span class="line"><span class="cl">  Downloading uwsgi-2.0.18.tar.gz <span class="o">(</span><span class="m">801</span> kB<span class="o">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">|</span>████████████████████████████████<span class="p">|</span> <span class="m">801</span> kB 1.1 MB/s
</span></span><span class="line"><span class="cl">Building wheels <span class="k">for</span> collected packages: uwsgi
</span></span><span class="line"><span class="cl">  Building wheel <span class="k">for</span> uwsgi <span class="o">(</span>setup.py<span class="o">)</span> ... <span class="k">done</span>
</span></span><span class="line"><span class="cl">  Created wheel <span class="k">for</span> uwsgi ... uWSGI-2.0.18-cp38-cp38-macosx_10_15_x86_64.whl
</span></span><span class="line"><span class="cl">  Stored in directory: /private/var/folders/jc/8_hqsz0x1tdbp05 ...
</span></span><span class="line"><span class="cl">Successfully built uwsgi
</span></span><span class="line"><span class="cl">Installing collected packages: uwsgi
</span></span><span class="line"><span class="cl">Successfully installed uwsgi-2.0.18
</span></span></code></pre></div><p>为了完全安装 uWSGI， <code>pip</code> 通过几个不同的步骤进行：</p>
<ul>
<li>
<p>在第 3 行，它下载了一个名为 <code>uwsgi-2.0.18.tar.gz</code> 的 TAR 文件 (tarball)，该文件已使用 <a href="https://www.gnu.org/software/gzip/manual/gzip.html">gzip</a> 压缩。</p>
</li>
<li>
<p>在第 6 行，它获取 tarball 并通过调用 <code>setup.py</code> 构建一个 <code>.whl</code> 文件。</p>
</li>
<li>
<p>在第 7 行，它将 wheel 标记为 <code>uWSGI-2.0.18-cp38-cp38-macosx_10_15_x86_64.whl</code> 。</p>
</li>
<li>
<p>在第 10 行，它在构建 wheel 后安装实际的包。</p>
</li>
</ul>
<p><code>pip</code> 检索到的 <code>tar.gz</code> tarball 是源代码分发版或 <code>sdist</code> ，而不是 wheel。在某些方面， <code>sdist</code> 与wheel相反。</p>
<blockquote>
<p>注意：如果您看到 uWSGI 安装错误，您可能需要<a href="https://uwsgi-docs.readthedocs.io/en/latest/Install.html#installing-from-source">安装 Python 开发头文件</a>。</p>
</blockquote>
<p><a href="https://packaging.python.org/glossary/#term-source-distribution-or-sdist">源代码分发</a>包含源代码。这不仅包括 Python 代码，还包括与包捆绑在一起的任何扩展模块（通常是 C 或 C++）的源代码。对于源代码分发，扩展模块是在用户端而不是开发人员端编译的。</p>
<p>源分发版还包含一组元数据，位于名为 <code>&lt;package-name&gt;.egg-info</code> 的目录中。此元数据有助于构建和安装包，但用户实际上不需要对其执行任何操作。</p>
<p>从开发人员的角度来看，源代码分发是在您运行以下命令时创建的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python setup.py sdist
</span></span></code></pre></div><p>现在尝试安装不同的包 <a href="https://github.com/chardet/chardet/blob/master/docs/index.rst">chardet</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m pip install <span class="s1">&#39;chardet==3.*&#39;</span>
</span></span><span class="line"><span class="cl">Collecting chardet
</span></span><span class="line"><span class="cl">  Downloading chardet-3.0.4-py2.py3-none-any.whl <span class="o">(</span><span class="m">133</span> kB<span class="o">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">|</span>████████████████████████████████<span class="p">|</span> <span class="m">133</span> kB 1.5 MB/s
</span></span><span class="line"><span class="cl">Installing collected packages: chardet
</span></span><span class="line"><span class="cl">Successfully installed chardet-3.0.4
</span></span></code></pre></div><p>您可以看到与 uWSGI 安装明显不同的输出。</p>
<p>安装 chardet 会直接从 PyPI 下载一个 <code>.whl</code> 文件。 Wheels 名称 <code>chardet-3.0.4-py2.py3-none-any.whl</code> 遵循您稍后将看到的特定命名约定。从用户的角度来看，更重要的是当 <code>pip</code> 在 PyPI 上找到兼容的 wheel 时，没有构建阶段。</p>
<p>从开发人员的角度来看，wheel 是运行以下命令的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python setup.py bdist_wheel
</span></span></code></pre></div><p>为什么 uWSGI 给你一个源代码分发而 chardet 提供一个 wheel？您可以通过查看 PyPI 上每个项目的页面并导航到下载文件区域来了解其原因。本节将向您展示 <code>pip</code> 在 PyPI 索引服务器上实际看到的内容：</p>
<ul>
<li>
<p>出于与项目复杂性相关的原因，uWSGI 仅提供了一个<a href="https://pypi.org/project/uWSGI/2.0.18/#files">源代码分发</a>（ <code>uwsgi-2.0.18.tar.gz</code> ）。</p>
</li>
<li>
<p>chardet 提供了 <a href="https://pypi.org/project/chardet/3.0.4/#files">wheel 和源代码分发</a>，但如果它与您的系统兼容， <code>pip</code> 会更喜欢 wheel。稍后您将看到如何确定兼容性。</p>
</li>
</ul>
<p>用于 wheel 安装的兼容性检查的另一个示例是 <code>psycopg2</code> ，它为 Windows 提供了广泛的 wheels，但不为 Linux 或 macOS 客户端提供任何 wheels。这意味着 <code>pip install psycopg2</code> 可以根据您的特定设置获取 Wheels 或源代码分发。</p>
<p>为了避免这些类型的兼容性问题，一些包提供了多个 wheels，每个 wheels 都针对特定的 Python 实现和底层操作系统。</p>
<p>到目前为止，您已经看到了 wheel 和 <code>sdist</code> 之间的一些明显区别，但更重要的是这些差异对安装过程的影响。</p>
<h3 id="wheels-让事情变得快速">Wheels 让事情变得快速</h3>
<p>在上面，您看到了获取预制 wheels 的安装与下载 <code>sdist</code> 的安装的比较。 Wheels 使 Python 包的端到端安装更快，原因有二：</p>
<ul>
<li>在其他条件相同的情况下，wheels 的尺寸通常比源分发小，这意味着它们可以在网络中更快地移动。</li>
<li>直接从 wheels 安装避免了从源分发构建包的中间步骤。</li>
</ul>
<p>几乎可以保证 chardet 安装只用了 uWSGI 所需时间的一小部分。然而，这可以说是一个不公平的苹果与橘子的比较，因为 chardet 是一个小得多且不那么复杂的包。</p>
<p>使用不同的命令，您可以创建更直接的比较，以证明 wheels 的差异有多大。</p>
<p>您可以通过传递 <code>--no-binary</code> 选项让 <code>pip</code> 忽略它对 wheels 的倾斜：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">time</span> python -m pip install <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      --no-cache-dir <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      --force-reinstall <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      --no-binary<span class="o">=</span>:all: <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      cryptography
</span></span></code></pre></div><p>此命令计时 <a href="https://pypi.org/project/cryptography/">cryptography</a> 包的安装，告诉 <code>pip</code> 使用源代码分发，即使有合适的 Wheels 可用。包含 <code>:all:</code> 会使规则适用于 <code>cryptography</code> 及其所有<a href="https://realpython.com/courses/managing-python-dependencies/">依赖项</a>。</p>
<p>在我的机器上，这从开始到结束大约需要 32 秒。不仅安装需要很长时间，而且构建 <code>cryptography</code> 还需要您拥有 OpenSSL 开发标头并可供 Python 使用。</p>
<p>注意：对于 <code>--no-binary</code> ，您很可能会看到有关缺少 <code>cryptography</code> 安装所需的头文件的错误，这是使用源代码分发令人沮丧的部分原因。如果是这样， <code>cryptography</code> 文档的<a href="https://cryptography.io/en/latest/installation/#building-cryptography-on-linux">安装部分</a>会就特定操作系统需要哪些库和头文件提供建议。</p>
<p>现在您可以重新安装 <code>cryptography</code> ，但这次要确保 <code>pip</code> 使用 PyPI 的 Wheels 。因为 <code>pip</code> 更喜欢 Wheels ，这类似于不带任何参数调用 <code>pip install</code> 。但在这种情况下，您可以通过要求带有 <code>--only-binary</code> 的 Wheels 来明确意图：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">time</span> python -m pip install <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      --no-cache-dir <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      --force-reinstall <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      --only-binary<span class="o">=</span>cryptography <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      cryptography
</span></span></code></pre></div><p>此选项只需要四秒多一点，或者是仅使用 <code>cryptography</code> 及其依赖项的源代码分发时所用时间的八分之一。</p>
<h3 id="什么是-python-wheel">什么是 Python Wheel？</h3>
<p>Python <code>.whl</code> 文件本质上是一个 ZIP ( <code>.zip</code> ) 存档，带有特制的文件名，告诉安装者 Wheels 将支持哪些 Python 版本和平台。</p>
<p>Wheels 是一种<a href="https://packaging.python.org/glossary/#term-built-distribution">内置分发</a>。在这种情况下，built 意味着 wheel 以可立即安装的格式出现，并允许您跳过源代码分发所需的构建阶段。</p>
<blockquote>
<p>注意：值得一提的是，尽管使用了术语构建，但 Wheels 不包含 <code>.pyc</code> 文件或编译的 Python 字节码。</p>
</blockquote>
<p>wheel 文件名被分成由连字符分隔的部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">{</span>dist<span class="o">}</span>-<span class="o">{</span>version<span class="o">}(</span>-<span class="o">{</span>build<span class="o">})</span>?-<span class="o">{</span>python<span class="o">}</span>-<span class="o">{</span>abi<span class="o">}</span>-<span class="o">{</span>platform<span class="o">}</span>.whl
</span></span></code></pre></div><p><code>{brackets}</code> 中的每个部分都是一个标签，或者是 wheel 名称的一个组成部分，它带有一些关于 wheel 包含的内容以及 wheel 将在何处工作或不工作的含义。</p>
<p>这是一个使用 <code>cryptography</code>  Wheels 的说明性示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cryptography-2.9.2-cp35-abi3-macosx_10_9_x86_64.whl
</span></span></code></pre></div><p><code>cryptography</code> 分配多个 Wheels 。每个 Wheels 都是一个平台 Wheels ，这意味着它仅支持 Python 版本、Python ABI、操作系统和机器架构的特定组合。您可以将命名约定分解为多个部分：</p>
<ul>
<li><code>cryptography</code> 是包名。</li>
<li><code>2.9.2</code> 是 <code>cryptography</code> 的包版本。版本是符合 PEP 440 的字符串，例如 <code>2.9.2</code> 、 <code>3.4</code> 或 <code>3.9.0.a3</code> 。</li>
<li><code>cp35</code> 是 <a href="https://www.python.org/dev/peps/pep-0425/#python-tag">Python 标签</a>，表示 Wheels 需要的 Python 实现和版本。 <code>cp</code> 代表 <a href="https://realpython.com/cpython-source-code-guide/">CPython</a>，Python 的参考实现，而 <code>35</code> 代表 Python <a href="https://docs.python.org/3/whatsnew/3.5.html">3.5</a>。例如，这个 Wheels 与 <a href="https://www.jython.org/">Jython</a> 不兼容。</li>
<li><code>abi3</code> 是 ABI 标签。 ABI 代表<a href="https://docs.python.org/3/c-api/stable.html">应用程序二进制接口</a>。你真的不需要担心它需要什么，但是 <code>abi3</code> 是一个单独的版本，用于 Python C API 的二进制兼容性。</li>
<li><code>macosx_10_9_x86_64</code> 是平台标签，正好比较啰嗦。在这种情况下，它可以进一步细分为子部分：
<ul>
<li><code>macosx</code> 是 macOS 操作系统。</li>
<li><code>10_9</code> 是用于编译 Python 的 macOS 开发人员工具 SDK 版本，而 Python 又构建了这个 Wheels 。</li>
<li><code>x86_64</code> 是对 x86-64 指令集架构的引用。</li>
</ul>
</li>
</ul>
<p>最后一个组件在技术上不是标签，而是标准的 <code>.whl</code> 文件扩展名。组合起来，上述组件表明此 <code>cryptography</code>  Wheels 设计的目标机器。</p>
<p>现在让我们转向另一个例子。以下是您在上述 chardet 案例中看到的内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">chardet-3.0.4-py2.py3-none-any.whl
</span></span></code></pre></div><p>您可以将其分解为标签：</p>
<ul>
<li><code>chardet</code> 是包名。</li>
<li><code>3.0.4</code> 是 chardet 的包版本。</li>
<li><code>py2.py3</code> 是 Python 标签，这意味着 Wheels 支持 Python 2 和 3 以及任何 Python 实现。</li>
<li><code>none</code> 是 ABI 标签，意味着 ABI 不是一个因素。</li>
<li><code>any</code> 是平台。这个 Wheels 几乎可以在任何平台上运行。</li>
</ul>
<p>Wheels 名称的 <code>py2.py3-none-any.whl</code> 段很常见。这是一个万能  Wheels ，可以在具有任何 <a href="https://stackoverflow.com/a/2456882/7954504">ABI</a> 的任何平台上与 Python 2 或 3 一起安装。如果 Wheels 以 <code>none-any.whl</code> 结尾，那么它很可能是一个不关心特定 Python ABI 或 CPU 架构的纯 Python 包。</p>
<p>另一个例子是 <code>jinja2</code> 模板引擎。如果您导航到 Jinja 3.x alpha 版本的<a href="https://pypi.org/project/Jinja2/3.0.0a1/#files">下载页面</a>，您将看到以下 Wheels ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Jinja2-3.0.0a1-py3-none-any.whl
</span></span></code></pre></div><p>注意这里缺少 <code>py2</code> 。这是一个纯 Python 项目，可以在任何 Python 3.x 版本上运行，但它不是万能  Wheels ，因为它不支持 Python 2。相反，它被称为纯 Python   Wheels 。</p>
<blockquote>
<p>注意：在 2020 年，许多项目也放弃了对 Python 2 的支持，Python 2 于 2020 年 1 月 1 日达到生命周期结束 (EOL)。Jinja 版本 3.x 于 2020 年 2 月放弃了对 Python 2 的支持。</p>
</blockquote>
<p>以下是为一些流行的开源包分发的 <code>.whl</code> 名称的更多示例：</p>
<table>
<thead>
<tr>
<th>Wheel</th>
<th>What It Is 这是什么</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PyYAML-5.3.1-cp38-cp38-win_amd64.whl</code></td>
<td><a href="https://pypi.org/project/PyYAML/5.3.1/#files">PyYAML</a> for CPython 3.8 on Windows with AMD64 (x86-64) architecture</td>
</tr>
<tr>
<td><code>numpy-1.18.4-cp38-cp38-win32.whl</code></td>
<td><a href="https://pypi.org/project/numpy/1.18.4/#files">NumPy</a> for CPython 3.8 on Windows 32-bit</td>
</tr>
<tr>
<td><code>scipy-1.4.1-cp36-cp36m-macosx_10_6_intel.whl</code></td>
<td><a href="https://pypi.org/project/scipy/1.4.1/#files">SciPy</a> for CPython 3.6 on macOS 10.6 SDK with fat binary (multiple instruction sets)</td>
</tr>
</tbody>
</table>
<p>现在您已经彻底了解什么是 Wheels ，是时候谈谈它们有什么好处了。</p>
<h3 id="wheels-的优势">Wheels 的优势</h3>
<p>这是来自 <a href="https://www.pypa.io/en/latest/">Python Packaging Authority</a> (PyPA) 的 wheels 证明：</p>
<blockquote>
<p>并非所有开发人员都有正确的工具或经验来构建这些用这些编译语言编写的组件，因此 Python 创造了 wheel，这是一种旨在运送带有编译工件的库的包格式。事实上，Python 的包安装程序 <code>pip</code> 总是更喜欢 wheel，因为安装总是更快，所以即使是纯 Python 包也能更好地使用 wheel。 （ <a href="https://packaging.python.org/overview/#python-binary-distributions">来源</a>）</p>
</blockquote>
<p>更完整的描述是，wheels 在以下几个方面使 <a href="https://pythonwheels.com/#advantages">Python 包的用户和维护者</a>都受益：</p>
<ul>
<li>对于纯 Python 包和<a href="https://realpython.com/build-python-c-extension-module/">扩展模块</a>，Wheels 的安装速度比源代码分发快。</li>
<li>Wheels 比源分布小。例如， <a href="https://pypi.org/project/six/#files">six</a>    Wheels 大约是相应源分布<a href="https://pypi.org/project/six/#files">大小的三分之一</a>。当您考虑到单个包的 <code>pip install</code> 实际上可能会开始下载依赖项链时，这种差异变得更加重要。</li>
<li>Wheels 将 <code>setup.py</code> 执行排除在外。从源分发版安装会运行该项目的 <code>setup.py</code> 中包含的任何内容。正如 <a href="https://www.python.org/dev/peps/pep-0427/#rationale">PEP 427</a> 所指出的，这相当于任意代码执行。 Wheels 完全避免了这种情况。</li>
<li>编译器不需要安装包含已编译扩展模块的 Wheels 。扩展模块包含在针对特定平台和 Python 版本的 wheel 中。</li>
<li><code>pip</code> 自动在 wheel 中生成与正确的 Python 解释器匹配的 <code>.pyc</code> 文件。</li>
<li>Wheels 通过减少安装软件包时涉及的许多变量来提供一致性。</li>
</ul>
<p>您可以使用 PyPI 上项目的下载文件选项卡来查看可用的不同发行版。例如，<a href="https://pypi.org/project/pandas/#files">pandas</a> 分发了各种各样的 Wheels 。</p>
<h3 id="告诉-pip-要下载什么">告诉 <code>pip</code> 要下载什么</h3>
<p>可以对 <code>pip</code> 进行细粒度控制并告诉它首选或避免哪种格式。您可以使用 <code>--only-binary</code> 和 <code>--no-binary</code> 选项来执行此操作。您在前面有关安装 <code>cryptography</code> 包的部分中看到了它们的使用，但值得仔细研究一下它们的作用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">pushd</span> <span class="s2">&#34;</span><span class="k">$(</span>mktemp -d<span class="k">)</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">$ python -m pip download --only-binary :all: --dest . --no-cache six
</span></span><span class="line"><span class="cl">Collecting six
</span></span><span class="line"><span class="cl">  Downloading six-1.14.0-py2.py3-none-any.whl <span class="o">(</span><span class="m">10</span> kB<span class="o">)</span>
</span></span><span class="line"><span class="cl">  Saved ./six-1.14.0-py2.py3-none-any.whl
</span></span><span class="line"><span class="cl">Successfully downloaded six
</span></span></code></pre></div><p>在此示例中，您更改为一个临时目录以存储带有 <code>pushd &quot;$(mktemp -d)&quot;</code> 的下载。您使用 <code>pip download</code> 而不是 <code>pip install</code> 以便您可以检查生成的 Wheels ，但您可以将 <code>download</code> 替换为 <code>install</code> 同时保持相同的选项集。</p>
<p>您下载带有几个标志的 <code>six</code> 模块：</p>
<ul>
<li><code>--only-binary :all:</code> 告诉 <code>pip</code> 限制自己使用 Wheels 并忽略源代码分发。如果没有这个选项， <code>pip</code> 只会更喜欢 Wheels ，但在某些情况下会退回到源代码分发。</li>
<li><code>--dest .</code> 告诉 <code>pip</code> 将 <code>six</code> 下载到当前目录。</li>
<li><code>--no-cache</code> 告诉 <code>pip</code> 不要查看其本地下载缓存。你使用这个选项只是为了说明从 PyPI 的实时下载，因为你可能在某处有一个 <code>six</code> 缓存。</li>
</ul>
<p>我之前提到过，wheel 文件本质上是一个 <code>.zip</code> 存档。你可以从字面上理解这个陈述，并这样对待 Wheels 。例如，如果你想查看一个 Wheels 的内容，你可以使用 <code>unzip</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ unzip -l six*.whl
</span></span><span class="line"><span class="cl">Archive:  six-1.14.0-py2.py3-none-any.whl
</span></span><span class="line"><span class="cl">  Length      Date    Time    Name
</span></span><span class="line"><span class="cl">---------  ---------- -----   ----
</span></span><span class="line"><span class="cl">    <span class="m">34074</span>  01-15-2020 18:10   six.py
</span></span><span class="line"><span class="cl">     <span class="m">1066</span>  01-15-2020 18:10   six-1.14.0.dist-info/LICENSE
</span></span><span class="line"><span class="cl">     <span class="m">1795</span>  01-15-2020 18:10   six-1.14.0.dist-info/METADATA
</span></span><span class="line"><span class="cl">      <span class="m">110</span>  01-15-2020 18:10   six-1.14.0.dist-info/WHEEL
</span></span><span class="line"><span class="cl">        <span class="m">4</span>  01-15-2020 18:10   six-1.14.0.dist-info/top_level.txt
</span></span><span class="line"><span class="cl">      <span class="m">435</span>  01-15-2020 18:10   six-1.14.0.dist-info/RECORD
</span></span><span class="line"><span class="cl">---------                     -------
</span></span><span class="line"><span class="cl">    <span class="m">37484</span>                     <span class="m">6</span> files
</span></span></code></pre></div><p><code>six</code> 是一个特例：它实际上是一个单独的 Python 模块，而不是一个完整的包。 Wheel 文件也可以复杂得多，稍后您将看到。</p>
<p>与 <code>--only-binary</code> 相反，你可以使用 <code>--no-binary</code> 来做相反的事情：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m pip download --no-binary :all: --dest . --no-cache six
</span></span><span class="line"><span class="cl">Collecting six
</span></span><span class="line"><span class="cl">  Downloading six-1.14.0.tar.gz <span class="o">(</span><span class="m">33</span> kB<span class="o">)</span>
</span></span><span class="line"><span class="cl">  Saved ./six-1.14.0.tar.gz
</span></span><span class="line"><span class="cl">Successfully downloaded six
</span></span><span class="line"><span class="cl">$ <span class="nb">popd</span>
</span></span></code></pre></div><p>此示例中的唯一更改是切换到 <code>--no-binary :all:</code> 。这告诉 <code>pip</code> 忽略 Wheels ，即使它们可用，而是下载源分发。</p>
<p><code>--no-binary</code> 什么时候有用？以下是几个案例：</p>
<ul>
<li>对应的 Wheels 坏了。这是对 Wheels 的讽刺。它们旨在减少故障的发生，但在某些情况下， Wheels 可能会配置错误。在这种情况下，为自己下载和构建源代码分发可能是一个可行的选择。</li>
<li>您想要对项目应用一个小的更改或<a href="https://en.wikipedia.org/wiki/Patch_%28Unix%29">补丁文件</a>，然后安装它。这是从<a href="https://realpython.com/python-git-github-intro/#version-control">版本控制系统</a> URL 克隆项目的替代方法。</li>
</ul>
<p>您还可以将上述标志与 <code>pip install</code> 一起使用。此外，与 <code>:all:</code> 不同， <code>--only-binary</code> 规则不仅适用于您正在安装的包，还适用于它的所有依赖项，您可以传递特定包的列表 <code>--only-binary</code> 和 <code>--no-binary</code> 来应用该规则规则到。</p>
<p>下面是几个安装URL库 <a href="https://github.com/aio-libs/yarl/">yarl</a> 的例子。它包含 Cython 代码并依赖于 <a href="https://github.com/aio-libs/multidict">multidict</a> ，其中包含纯 C 代码。有几个选项可以严格使用或严格忽略 <code>yarl</code> 及其依赖项的 Wheels ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="c1"># Install `yarl` and use only wheels for yarl and all dependencies</span>
</span></span><span class="line"><span class="cl">$ python -m pip install --only-binary :all: yarl
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ <span class="c1"># Install `yarl` and use wheels only for the `multidict` dependency</span>
</span></span><span class="line"><span class="cl">$ python -m pip install --only-binary multidict yarl
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ <span class="c1"># Install `yarl` and don&#39;t use wheels for yarl or any dependencies</span>
</span></span><span class="line"><span class="cl">$ python -m pip install --no-binary :all: yarl
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ <span class="c1"># Install `yarl` and don&#39;t use wheels for the `multidict` dependency</span>
</span></span><span class="line"><span class="cl">$ python -m pip install --no-binary multidict yarl
</span></span></code></pre></div><p>在本节中，您大致了解了如何微调 <code>pip install</code> 将使用的分发类型。虽然常规的 <code>pip install</code> 应该没有任何选项，但了解这些用于特殊情况的选项会很有帮助。</p>
<h3 id="wheel-manylinux-标签">Wheel manylinux 标签</h3>
<p>Linux 有许多变体和风格，例如 Debian、CentOS、Fedora 和 Pacman。其中每一个都可能在共享库（例如 <code>libncurses</code> ）和核心 C 库（例如 <code>glibc</code> ）中使用细微的变化。</p>
<p>如果您正在编写 C/C++ 扩展，那么这可能会产生问题。用 C 编写并在 Ubuntu Linux 上编译的源文件不能保证在 CentOS 机器或 Arch Linux 发行版上可执行。</p>
<p>您是否需要为每个 Linux 变体构建一个单独的 Wheels ？</p>
<p>幸运的是，答案是否定的，这要归功于一组专门设计的标签，称为 <code>manylinux</code> 平台标签系列。目前有以下三种变体：</p>
<ol>
<li><code>manylinux1</code> 是 <a href="https://www.python.org/dev/peps/pep-0513/">PEP 513</a> 中指定的原始格式。</li>
<li><code>manylinux2010</code> 是 <a href="https://www.python.org/dev/peps/pep-0571/">PEP 571</a> 中指定的更新，它升级到 CentOS 6 作为 Docker 镜像所基于的底层操作系统。理由是 CentOS 5.11，即 <code>manylinux1</code> 中允许的库列表的来源，于 2017 年 3 月达到 EOL 并停止接收安全补丁和错误修复。</li>
<li><code>manylinux2014</code> 是 <a href="https://www.python.org/dev/peps/pep-0599/">PEP 599</a> 中指定的升级到 CentOS 7 的更新，因为 CentOS 6 计划于 2020 年 11 月达到 EOL。</li>
</ol>
<p>您可以在 pandas 项目中找到 <code>manylinux</code> 分布的示例。以下是 PyPI 的可用 pandas 下载列表中的两个（最多的）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pandas-1.0.3-cp37-cp37m-manylinux1_x86_64.whl
</span></span><span class="line"><span class="cl">pandas-1.0.3-cp37-cp37m-manylinux1_i686.whl
</span></span></code></pre></div><p>在这种情况下，pandas 为支持 x86-64 和 <a href="https://en.wikipedia.org/wiki/P6_(microarchitecture)">i686</a> 架构的 CPython 3.7 构建了 <code>manylinux1</code> wheels。</p>
<p><code>manylinux</code> 的核心是基于特定版本的 CentOS 操作系统构建的 Docker 镜像。它捆绑了一个编译器套件、多个版本的 Python 和 <code>pip</code> ，以及一组允许的共享库。</p>
<blockquote>
<p>注意：术语 allowed 表示<a href="https://www.python.org/dev/peps/pep-0513/#rationale">默认情况下假定存在</a>于几乎所有 Linux 系统上的低级库。这个想法是，依赖项应该存在于基本操作系统上，而不需要额外安装。</p>
</blockquote>
<p>截至 2020 年年中， <code>manylinux1</code> 仍然是主要的 <code>manylinux</code> 标签。原因之一可能只是习惯。另一个可能是客户端（用户）端对 <code>manylinux2010</code> 及更高版本的支持仅限于更新版本的 <code>pip</code> ：</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Requirement</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>manylinux1</code></td>
<td><code>pip</code> 8.1.0 或更高版本</td>
</tr>
<tr>
<td><code>manylinux2010</code></td>
<td><code>pip</code> 19.0 或更高版本</td>
</tr>
<tr>
<td><code>manylinux2014</code></td>
<td><code>pip</code> 19.3 或更高版本</td>
</tr>
</tbody>
</table>
<p>换句话说，如果您是构建 <code>manylinux2010</code> wheels 的包开发人员，那么使用您的包的人将需要 <code>pip</code> 19.0（2019 年 1 月发布）或更高版本才能让 <code>pip</code> 从 PyPI 找到并安装 <code>manylinux2010</code> wheels .</p>
<p>幸运的是，虚拟环境变得越来越普遍，这意味着开发人员可以在不接触系统 <code>pip</code> 的情况下更新虚拟环境的 <code>pip</code> 。然而，情况并非总是如此，一些 Linux 发行版仍然附带 <code>pip</code> 的过时版本。</p>
<p>这就是说，如果您要在 Linux 主机上安装 Python 包，那么如果包维护者不遗余力地创建 <code>manylinux</code>  Wheels ，您就认为自己很幸运。这几乎可以保证无论您的特定 Linux 变体或版本如何，都可以轻松安装软件包。</p>
<blockquote>
<p>警告：请注意 <a href="https://pythonspeed.com/articles/alpine-docker-python/">PyPI wheels 不能在 Alpine Linux</a>（或 <a href="https://hub.docker.com/_/busybox/">BusyBox</a>）上运行。这是因为 Alpine 使用 <a href="https://wiki.musl-libc.org/">musl</a> 代替标准的 <a href="https://www.gnu.org/software/libc/libc.html">glibc</a> 。 <code>musl libc</code> 库自称是“一个新的 <code>libc</code> ，力求快速、简单、轻量级、免费和正确”。不幸的是，说到 Wheels ， <code>glibc</code> 不是。</p>
</blockquote>
<h3 id="平台-wheels-的安全注意事项">平台 Wheels 的安全注意事项</h3>
<p>从用户安全的角度来看，wheels 的一个值得考虑的特性是 wheels <a href="https://github.com/asottile/no-manylinux#what-why">可能会受到版本腐烂</a>的影响，因为它们捆绑了二进制依赖项，而不是允许系统包管理器更新该依赖项。</p>
<p>例如，如果一个 wheel 合并了 <code>libfortran</code> 共享库，那么即使您使用包管理器（如 @ 3#、 <code>yum</code> 或 <code>brew</code> 。</p>
<p>如果您在安全防范措施得到加强的环境中进行开发，则需要注意某些平台  Wheels 的这一特性。</p>
<h2 id="召集所有开发人员构建您的-wheels">召集所有开发人员：构建您的 Wheels</h2>
<p>本教程的标题是“你为什么要关心？”作为一名开发人员，如果您打算向社区分发 Python 包，那么您应该非常关心为您的项目分发 Wheels ，因为它们使最终用户的安装过程更简洁、更简单。</p>
<p>您可以使用兼容的 Wheels 支持的目标平台越多，您看到的标题为“安装在 XYZ 平台上损坏”之类的 GitHub 问题就越少。为您的 Python 包分发 wheel 客观上降低了包的用户在安装过程中遇到问题的可能性。</p>
<p>要在本地构建 Wheels ，您需要做的第一件事是安装 <code>wheel</code> 。确保 <code>setuptools</code> 也是最新的也没什么坏处：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m pip install -U wheel setuptools
</span></span></code></pre></div><p>接下来的几节将引导您完成为各种不同场景构建 Wheels 的过程。</p>
<h3 id="不同类型的-wheels">不同类型的 Wheels</h3>
<p>正如本教程中提到的， Wheels 有几种不同的变体， Wheels 的类型反映在它的文件名中：</p>
<ul>
<li>万向  Wheels 包含 <code>py2.py3-none-any.whl</code> 。它在任何操作系统和平台上都支持 Python 2 和 Python 3。 Python Wheels 网站上列出的大多数 Wheels 都是通用 Wheels 。</li>
<li>纯 Python   Wheels 包含 <code>py3-none-any.whl</code> 或 <code>py2.none-any.whl</code> 。它支持 Python 3 或 Python 2，但不支持两者。它在其他方面与万向  Wheels 相同，但它会标有 <code>py2</code> 或 <code>py3</code> 而不是 <code>py2.py3</code> 标签。</li>
<li>平台  Wheels 支持特定的 Python 版本和平台。它包含指示特定 Python 版本、ABI、操作系统或体系结构的段。</li>
</ul>
<p>wheel 类型之间的差异取决于它们支持的 Python 版本以及它们是否针对特定平台。以下是 Wheels 变体之间差异的简要总结：</p>
<table>
<thead>
<tr>
<th>Wheel Type</th>
<th>支持 Python 2 和 3</th>
<th>支持每个 ABI、操作系统和平台</th>
</tr>
</thead>
<tbody>
<tr>
<td>Universal</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Pure-Python</td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>Platform</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>正如您接下来将看到的，您可以通过相对较少的设置构建通用 Wheels 和纯 Python  Wheels ，但平台 Wheels 可能需要一些额外的步骤。</p>
<h3 id="构建一个纯-python--wheels">构建一个纯 Python  Wheels</h3>
<p>您可以使用 <code>setuptools</code> 为任何项目构建纯 Python   Wheels 或通用  Wheels ，只需一个命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python setup.py sdist bdist_wheel
</span></span></code></pre></div><p>这将创建一个源代码分发 ( <code>sdist</code> ) 和一个 Wheels  ( <code>bdist_wheel</code> )。默认情况下，两者都会放在当前目录下的 <code>dist/</code> 中。要亲眼看看，您可以为 <a href="https://github.com/jakubroztocil/httpie">HTTPie</a> 构建一个 Wheels ，一个用 Python 编写的命令行 HTTP 客户端，以及一个 <code>sdist</code> 。</p>
<p>下面是为 HTTPie 包构建两种类型的发行版的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git clone -q git@github.com:jakubroztocil/httpie.git
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> httpie
</span></span><span class="line"><span class="cl">$ python setup.py -q sdist bdist_wheel
</span></span><span class="line"><span class="cl">$ ls -1 dist/
</span></span><span class="line"><span class="cl">httpie-2.2.0.dev0-py3-none-any.whl
</span></span><span class="line"><span class="cl">httpie-2.2.0.dev0.tar.gz
</span></span></code></pre></div><p>仅此而已。您克隆该项目，移至其根目录，然后调用 <code>python setup.py sdist bdist_wheel</code> 。您可以看到 <code>dist/</code> 包含一个 Wheels 和一个源代码分发。</p>
<p>默认情况下，生成的分布放在 <code>dist/</code> 中，但您可以使用 <code>-d</code> / <code>--dist-dir</code> 选项更改它。您可以将它们放在一个临时目录中，而不是用于构建隔离：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nv">tempdir</span><span class="o">=</span><span class="s2">&#34;</span><span class="k">$(</span>mktemp -d<span class="k">)</span><span class="s2">&#34;</span>  <span class="c1"># Create a temporary directory</span>
</span></span><span class="line"><span class="cl">$ file <span class="s2">&#34;</span><span class="nv">$tempdir</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">/var/folders/jc/8_kd8uusys7ak09_lpmn30rw0000gk/T/tmp.GIXy7XKV: directory
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ python setup.py sdist -d <span class="s2">&#34;</span><span class="nv">$tempdir</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">$ python setup.py bdist_wheel --dist-dir <span class="s2">&#34;</span><span class="nv">$tempdir</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">$ ls -1 <span class="s2">&#34;</span><span class="nv">$tempdir</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">httpie-2.2.0.dev0-py3-none-any.whl
</span></span><span class="line"><span class="cl">httpie-2.2.0.dev0.tar.gz
</span></span></code></pre></div><p>您可以将 <code>sdist</code> 和 <code>bdist_wheel</code> 步骤合二为一，因为 <code>setup.py</code> 可以采用多个子命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python setup.py sdist -d <span class="s2">&#34;</span><span class="nv">$tempdir</span><span class="s2">&#34;</span> bdist_wheel -d <span class="s2">&#34;</span><span class="nv">$tempdir</span><span class="s2">&#34;</span>
</span></span></code></pre></div><p>如此处所示，您需要将 <code>-d</code> 等选项传递给每个子命令。</p>
<h3 id="指定通用-wheel">指定通用 Wheel</h3>
<p>通用 Wheels 是用于同时支持 Python 2 和 3 的纯 Python 项目的 Wheels 。有多种方法可以告诉 <code>setuptools</code> 和 <code>distutils</code>  Wheels 应该是通用的。</p>
<p>选项 1 是在项目的 <a href="https://docs.python.org/3/distutils/configfile.html">setup.cfg</a> 文件中指定选项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">bdist_wheel</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">universal</span> <span class="p">=</span> <span class="mi">1</span>
</span></span></code></pre></div><p>选项 2 是在命令行传递恰当命名的 <code>--universal</code> 标志：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python setup.py bdist_wheel --universal
</span></span></code></pre></div><p>选项 3 是使用其 <code>options</code> 参数告诉 <code>setup()</code> 本身有关该标志的信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># setup.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">setup</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ....</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&#34;bdist_wheel&#34;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&#34;universal&#34;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ....</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>虽然这三个选项中的任何一个都应该有效，但前两个选项最常用。您可以在 <a href="https://github.com/chardet/chardet/blob/master/setup.cfg">chardet 设置配置</a>中看到这样的示例。之后，您可以使用 <code>bdist_wheel</code> 命令，如前所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python setup.py sdist bdist_wheel
</span></span></code></pre></div><p>无论您选择哪个选项，生成的 Wheels 都是等效的。选择在很大程度上取决于开发人员的偏好以及最适合您的工作流程。</p>
<h3 id="构建平台-wheels-macos-和-windows">构建平台 Wheels （macOS 和 Windows）</h3>
<p>二进制发行版是包含已编译扩展的构建发行版的子集。扩展是非 Python 依赖项或 Python 包的组件。</p>
<p>通常，这意味着您的包包含扩展模块或依赖于用静态类型语言（例如 C、C++、Fortran，甚至 Rust 或 Go）编写的库。平台 Wheels 的存在主要是因为它们包含或依赖于扩展模块。</p>
<p>综上所述，是时候构建平台 Wheels 了！</p>
<p>根据您现有的开发环境，您可能需要完成一个或两个额外的先决条件步骤来构建平台 Wheels 。下面的步骤将帮助您设置构建 C 和 C++ 扩展模块，这是迄今为止最常见的类型。</p>
<p>在 macOS 上，您需要通过 <a href="https://www.unix.com/man-page/OSX/1/xcode-select/">xcode</a> 获得的命令行开发人员工具：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ xcode-select --install
</span></span></code></pre></div><p>在 Windows 上，您需要安装 <a href="https://docs.microsoft.com/en-us/cpp/?view=vs-2019">Microsoft Visual C++</a>：</p>
<ul>
<li>在浏览器中打开 Visual Studio 下载页面。</li>
<li>选择 Visual Studio 工具 → Visual Studio 构建工具 → 下载。</li>
<li>运行生成的 <code>.exe</code> 安装程序。</li>
<li>在安装程序中，选择 C++ Build Tools → Install。</li>
<li>重新启动机器。</li>
</ul>
<p>在 Linux 上，您需要一个编译器，例如 <code>gcc</code> 或 <code>g++</code> / <code>c++</code> 。</p>
<p>有了这些，您就可以为 UltraJSON ( <code>ujson</code> ) 构建一个平台  Wheels ，UltraJSON 是一个用纯 C 语言编写并带有 Python 3 绑定的 <a href="https://realpython.com/python-json/">JSON</a> 编码器和解码器。使用 <code>ujson</code> 是一个很好的玩具示例，因为它涵盖了几个基础：</p>
<ul>
<li>它包含一个扩展模块， <a href="https://github.com/ultrajson/ultrajson/blob/master/python/ujson.c">ujson</a> 。</li>
<li>它依赖于 Python 开发标头进行编译 ( <code>#include &lt;Python.h&gt;</code> )，但并不过分复杂。 <code>ujson</code> 旨在做一件事并且做好，就是读写JSON！</li>
</ul>
<p>您可以从 GitHub 克隆该项目，导航到其目录并构建它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git clone -q --branch 2.0.3 git@github.com:ultrajson/ultrajson.git
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> ultrajson
</span></span><span class="line"><span class="cl">$ python setup.py bdist_wheel
</span></span></code></pre></div><p>您应该会看到大量输出。这是 macOS 上的精简版，其中使用了 Clang 编译器驱动程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">clang -Wno-unused-result -Wsign-compare -Wunreachable-code -DNDEBUG -g ...
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">creating <span class="s1">&#39;dist/ujson-2.0.3-cp38-cp38-macosx_10_15_x86_64.whl&#39;</span>
</span></span><span class="line"><span class="cl">adding <span class="s1">&#39;ujson.cpython-38-darwin.so&#39;</span>
</span></span></code></pre></div><p>以 <code>clang</code> 开头的行显示了对编译器的实际调用，其中包含大量编译标志。您可能还会看到诸如 <code>MSVC</code> (Windows) 或 <code>gcc</code> (Linux) 之类的工具，具体取决于操作系统。</p>
<p>如果在执行上述代码后遇到 <code>fatal error</code> ，请不要担心。您可以展开下面的框以了解如何处理此问题。</p>
<blockquote>
<p><code>setup.py bdist_wheel</code> 对 <code>ujson</code> 的调用需要 Python 开发头文件，因为 <code>ujson.c</code> 引入了 <code>&lt;Python.h&gt;</code> 。如果您没有将它们放在可搜索的位置，那么您可能会看到如下错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">fatal error: <span class="s1">&#39;Python.h&#39;</span> file not found
</span></span><span class="line"><span class="cl"><span class="c1">#include &lt;Python.h&gt;</span>
</span></span></code></pre></div><p>要编译扩展模块，您需要将开发标头保存在编译器可以找到的地方。</p>
<p>如果您使用的是最新版本的 Python 3 和虚拟环境工具（如 <code>venv</code> ），则 Python 开发标头可能会默认包含在编译和链接中。</p>
<p>如果没有，那么您可能会看到一个错误，表明找不到头文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">fatal error: <span class="s1">&#39;Python.h&#39;</span> file not found
</span></span><span class="line"><span class="cl"><span class="c1">#include &lt;Python.h&gt;</span>
</span></span></code></pre></div><p>在这种情况下，您可以通过设置 <code>CFLAGS</code> 来告诉 <code>setup.py</code> 还可以在哪里查找头文件。要查找头文件本身，可以使用 <code>python3-config</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python3-config --include
</span></span><span class="line"><span class="cl">-I/Users/&lt;username&gt;/.pyenv/versions/3.8.2/include/python3.8
</span></span></code></pre></div><p>这告诉您 Python 开发标头位于显示的目录中，您现在可以将其与 <code>python setup.py bdist_wheel</code> 一起使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">&#34;</span><span class="k">$(</span>python3-config --include<span class="k">)</span><span class="s2">&#34;</span> python setup.py bdist_wheel
</span></span></code></pre></div><p>更一般地说，您可以传递您需要的任何路径：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nv">CFLAGS</span><span class="o">=</span><span class="s1">&#39;-I/path/to/include&#39;</span> python setup.py bdist_wheel
</span></span></code></pre></div><p>在 Linux 上，您可能还需要单独安装头文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ apt-get install -y python3-dev  <span class="c1"># Debian, Ubuntu</span>
</span></span><span class="line"><span class="cl">$ yum install -y python3-devel  <span class="c1"># CentOS, Fedora, RHEL</span>
</span></span></code></pre></div></blockquote>
<p>如果你检查 UltraJSON 的 <a href="https://github.com/ultrajson/ultrajson/blob/master/setup.py">setup.py</a> ，你会看到它自定义了一些编译器标志，例如 <code>-D_GNU_SOURCE</code> 。通过 <code>setup.py</code> 控制编译过程的复杂性超出了本教程的范围，但您应该知道可以<a href="https://pythonextensionpatterns.readthedocs.io/en/latest/compiler_flags.html#setting-flags-automatically-in-setup-py">对编译和链接的发生方式进行细粒度控制</a>。</p>
<p>如果您查看 <code>dist</code> ，那么您应该会看到创建的 Wheels ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ ls dist/
</span></span><span class="line"><span class="cl">ujson-2.0.3-cp38-cp38-macosx_10_15_x86_64.whl
</span></span></code></pre></div><p>请注意，名称可能因您的平台而异。例如，您会在 64 位 Windows 上看到 <code>win_amd64.whl</code> 。</p>
<p>您可以查看 wheel 文件并看到它包含已编译的扩展名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ unzip -l dist/ujson-*.whl
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">  Length      Date    Time    Name
</span></span><span class="line"><span class="cl">---------  ---------- -----   ----
</span></span><span class="line"><span class="cl">   <span class="m">105812</span>  05-10-2020 19:47   ujson.cpython-38-darwin.so
</span></span><span class="line"><span class="cl">   ...
</span></span></code></pre></div><p>此示例显示 macOS 的输出， <code>ujson.cpython-38-darwin.so</code> ，这是一个共享对象 ( <code>.so</code> ) 文件，也称为动态库。</p>
<h3 id="构建-manylinux--wheels">构建 <code>manylinux</code>  Wheels</h3>
<p>作为软件包开发人员，您很少会希望为单个 Linux 变体构建 Wheels 。 Linux wheels 需要一套专门的约定和工具，以便它们可以跨不同的 Linux 环境工作。</p>
<p>与 macOS 和 Windows 的 wheel 不同，构建在一个 Linux 变体上的 wheel 不能保证在另一个 Linux 变体上工作，即使是具有相同机器架构的 Linux 变体。</p>
<p>事实上，如果您在开箱即用的 Linux 容器上构建一个 Wheels ，那么如果您尝试上传它，PyPI 甚至不会接受该 Wheels ！</p>
<p>如果您希望您的包在一系列 Linux 客户端上可用，那么您需要一个 <code>manylinux</code>  Wheels 。 <code>manylinux</code> wheel 是一种特殊类型的平台 wheel，被大多数 Linux 变体接受。它必须在特定环境中构建，并且需要一个名为 <code>auditwheel</code> 的工具来重命名 wheel 文件以表明它是一个 <code>manylinux</code> wheel。</p>
<blockquote>
<p>注意：即使您是从开发人员而不是用户的角度来学习本教程，请确保您在继续本节之前已阅读有关 <code>manylinux</code> wheel 标签的部分。</p>
</blockquote>
<p>构建一个 <code>manylinux</code>  Wheels 可以让你瞄准更广泛的用户平台。 PEP 513 指定了一个特定的（和古老的）CentOS 版本，其中包含一系列可用的 Python 版本。 CentOS 和 Ubuntu 或任何其他发行版之间的选择没有任何特殊区别。</p>
<p>重点是构建环境由一个普通的 Linux 操作系统和一组有限的外部共享库组成，这些共享库对于不同的 Linux 变体是通用的。</p>
<p>值得庆幸的是，您不必自己执行此操作。 PyPA 提供了一组 <a href="https://github.com/pypa/manylinux">Docker 镜像</a>，只需单击几下鼠标即可为您提供此环境：</p>
<ul>
<li>选项 1 是从您的开发机器运行 <code>docker</code> 并使用 Docker 卷挂载您的项目，以便它可以在容器文件系统中访问。</li>
<li>选项 2 是使用 CI/CD 解决方案，例如 CircleCI、GitHub Actions、Azure DevOps 或 Travis-CI，这将拉取您的项目并在推送或标记等操作上运行构建。</li>
</ul>
<p>为不同的 <code>manylinux</code> 风格提供了 Docker 镜像：</p>
<table>
<thead>
<tr>
<th><code>manylinux</code> Tag</th>
<th>Architecture</th>
<th>Docker Image</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>manylinux1</code></td>
<td>x86-64</td>
<td><a href="https://quay.io/pypa/manylinux1_x86_64">quay.io/pypa/manylinux1_x86_64</a></td>
</tr>
<tr>
<td><code>manylinux1</code></td>
<td>i686</td>
<td><a href="https://quay.io/pypa/manylinux1_i686">quay.io/pypa/manylinux1_i686</a></td>
</tr>
<tr>
<td><code>manylinux2010</code></td>
<td>x86-64</td>
<td><a href="https://quay.io/pypa/manylinux2010_x86_64">quay.io/pypa/manylinux2010_x86_64</a></td>
</tr>
<tr>
<td><code>manylinux2010</code></td>
<td>i686</td>
<td><a href="https://quay.io/pypa/manylinux2010_i686">quay.io/pypa/manylinux2010_i686</a></td>
</tr>
<tr>
<td><code>manylinux2014</code></td>
<td>x86-64</td>
<td><a href="https://quay.io/pypa/manylinux2014_x86_64">quay.io/pypa/manylinux2014_x86_64</a></td>
</tr>
<tr>
<td><code>manylinux2014</code></td>
<td>i686</td>
<td><a href="https://quay.io/pypa/manylinux2014_i686">quay.io/pypa/manylinux2014_i686</a></td>
</tr>
<tr>
<td><code>manylinux2014</code></td>
<td>aarch64</td>
<td><a href="https://quay.io/pypa/manylinux2014_aarch64">quay.io/pypa/manylinux2014_aarch64</a></td>
</tr>
<tr>
<td><code>manylinux2014</code></td>
<td>ppc64le</td>
<td><a href="https://quay.io/pypa/manylinux2014_ppc64le">quay.io/pypa/manylinux2014_ppc64le</a></td>
</tr>
<tr>
<td><code>manylinux2014</code></td>
<td>s390x</td>
<td><a href="https://quay.io/pypa/manylinux2014_s390x">quay.io/pypa/manylinux2014_s390x</a></td>
</tr>
</tbody>
</table>
<p>首先，PyPA 还提供了一个示例存储库 <a href="https://github.com/pypa/python-manylinux-demo">python-manylinux-demo</a>，这是一个用于与 Travis-CI 一起构建 <code>manylinux</code> wheels 的演示项目。</p>
<p>虽然构建 wheels 作为远程托管 CI 解决方案的一部分很常见，但您也可以在本地构建 <code>manylinux</code> wheels。为此，您需要安装 Docker。 Docker Desktop 适用于 macOS、Windows 和 Linux。</p>
<p>首先，克隆演示项目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git clone -q git@github.com:pypa/python-manylinux-demo.git
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> python-manylinux-demo
</span></span></code></pre></div><p>接下来，分别为 <code>manylinux1</code> Docker 镜像和平台定义几个 shell 变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nv">DOCKER_IMAGE</span><span class="o">=</span><span class="s1">&#39;quay.io/pypa/manylinux1_x86_64&#39;</span>
</span></span><span class="line"><span class="cl">$ <span class="nv">PLAT</span><span class="o">=</span><span class="s1">&#39;manylinux1_x86_64&#39;</span>
</span></span></code></pre></div><p><code>DOCKER_IMAGE</code> 变量是由 PyPA 维护的用于构建 <code>manylinux</code>  Wheels 的图像，托管在 <a href="https://quay.io/">Quay.io</a>。平台 ( <code>PLAT</code> ) 是提供给 <code>auditwheel</code> 的必要信息，让它知道要应用哪个平台标签。</p>
<p>现在您可以拉取 Docker 镜像并在容器中运行 wheel-builder 脚本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker pull <span class="s2">&#34;</span><span class="nv">$DOCKER_IMAGE</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">$ docker container run -t --rm <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      -e <span class="nv">PLAT</span><span class="o">=</span><span class="nv">$PLAT</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      -v <span class="s2">&#34;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&#34;</span>:/io <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      <span class="s2">&#34;</span><span class="nv">$DOCKER_IMAGE</span><span class="s2">&#34;</span> /io/travis/build-wheels.sh
</span></span></code></pre></div><p>这告诉 Docker 在 <code>manylinux1_x86_64</code> Docker 容器内运行 <code>build-wheels.sh</code> shell 脚本，将 <code>PLAT</code> 作为容器中可用的环境变量传递。由于您使用 <code>-v</code> （或 <code>--volume</code> ）绑定挂载卷，因此容器中生成的 Wheels 现在可以在主机上的 <code>wheelhouse</code> 目录中访问：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ ls -1 wheelhouse
</span></span><span class="line"><span class="cl">python_manylinux_demo-1.0-cp27-cp27m-manylinux1_x86_64.whl
</span></span><span class="line"><span class="cl">python_manylinux_demo-1.0-cp27-cp27mu-manylinux1_x86_64.whl
</span></span><span class="line"><span class="cl">python_manylinux_demo-1.0-cp35-cp35m-manylinux1_x86_64.whl
</span></span><span class="line"><span class="cl">python_manylinux_demo-1.0-cp36-cp36m-manylinux1_x86_64.whl
</span></span><span class="line"><span class="cl">python_manylinux_demo-1.0-cp37-cp37m-manylinux1_x86_64.whl
</span></span><span class="line"><span class="cl">python_manylinux_demo-1.0-cp38-cp38-manylinux1_x86_64.whl
</span></span></code></pre></div><p>在几个简短的命令中，您拥有一组适用于 CPython 2.7 到 3.8 的 <code>manylinux1</code>  Wheels 。一种常见的做法是迭代不同的架构。例如，您可以对 <code>quay.io/pypa/manylinux1_i686</code> Docker 映像重复此过程。这将构建针对 32 位 (i686) 架构的 <code>manylinux1</code>  Wheels 。</p>
<p>如果您想更深入地研究造 Wheels ，那么下一步就是向最好的人学习。从 Python Wheels 页面开始，选择一个项目，导航到它的源代码（在 GitHub、GitLab 或 Bitbucket 等地方），然后亲眼看看它是如何构建 Wheels 的。</p>
<p>Python Wheels 页面上的许多项目都是纯 Python 项目并分发通用 Wheels 。如果您正在寻找更复杂的案例，请留意使用扩展模块的包。这里有两个例子可以激发你的胃口：</p>
<ul>
<li><code>lxml</code> 使用从 <code>manylinux1</code> Docker 容器中调用的单独构建脚本。</li>
<li><code>ultrajson</code> 做同样的事情并使用 GitHub Actions 调用构建脚本。</li>
</ul>
<p>如果您有兴趣构建 <code>manylinux</code>  Wheels ，这两个都是著名的项目，它们提供了很好的示例供您学习。</p>
<h3 id="捆绑共享库">捆绑共享库</h3>
<p>另一个挑战是为依赖于外部共享库的包构建 Wheels 。 <code>manylinux</code> 图像包含一组预筛选的库，例如 <code>libpthread.so.0</code> 和 <code>libc.so.6</code> 。但是，如果您依赖该列表之外的东西怎么办，例如 ATLAS 或 GFortran？</p>
<p>在这种情况下，有几种解决方案可以解决问题：</p>
<ul>
<li><code>auditwheel</code> 会将外部库捆绑到一个已经构建好的 Wheels 中。</li>
<li><code>delocate</code> 在 macOS 上做同样的事情。</li>
</ul>
<p>方便的是， <code>auditwheel</code> 出现在 <code>manylinux</code> Docker 镜像上。使用 <code>auditwheel</code> 和 <code>delocate</code> 只需一个命令。只需告诉他们有关 wheel 文件的信息，他们就会完成剩下的工作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ auditwheel repair &lt;path-to-wheel.whl&gt;  <span class="c1"># For manylinux</span>
</span></span><span class="line"><span class="cl">$ delocate-wheel &lt;path-to-wheel.whl&gt;  <span class="c1"># For macOS</span>
</span></span></code></pre></div><p>这将通过项目的 <code>setup.py</code> 检测所需的外部库，并将它们捆绑到 wheel 中，就好像它们是项目的一部分一样。</p>
<p>利用 <code>auditwheel</code> 和 <code>delocate</code> 的项目示例是 <code>pycld3</code> ，它为Compact Language Detector v3 (CLD3) 提供Python 绑定。</p>
<p><code>pycld3</code> 包依赖于 <code>libprotobuf</code> ，它不是一个通常安装的库。如果你查看 <code>pycld3</code> macOS  Wheels 内部，你会看到 <code>libprotobuf.22.dylib</code> 包含在那里。这是一个捆绑到 Wheels 中的动态链接共享库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ unzip -l pycld3-0.20-cp38-cp38-macosx_10_15_x86_64.whl
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">       <span class="m">51</span>  04-10-2020 11:46   cld3/__init__.py
</span></span><span class="line"><span class="cl">   <span class="m">939984</span>  04-10-2020 07:50   cld3/_cld3.cpython-38-darwin.so
</span></span><span class="line"><span class="cl">  <span class="m">2375836</span>  04-10-2020 07:50   cld3/.dylibs/libprotobuf.22.dylib
</span></span><span class="line"><span class="cl">---------                     -------
</span></span><span class="line"><span class="cl">  <span class="m">3339279</span>                     <span class="m">8</span> files
</span></span></code></pre></div><p>Wheels 预包装有 <code>libprotobuf</code> 。 <code>.dylib</code> 类似于 Unix <code>.so</code> 文件或 Windows <code>.dll</code> 文件，但我承认我不知道除此之外的具体区别。</p>
<p><code>auditwheel</code> 和 <code>delocate</code> 知道包含 <code>libprotobuf</code> 因为 <code>setup.py</code> 通过 <code>libraries</code> 参数告诉他们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">setup</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ...</span>
</span></span><span class="line"><span class="cl">    <span class="n">libraries</span><span class="o">=</span><span class="p">[</span><span class="s2">&#34;protobuf&#34;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ...</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>这意味着 <code>auditwheel</code> 和 <code>delocate</code> 为用户省去了安装 <code>protobuf</code> 的麻烦，只要他们从具有匹配 Wheels 的平台和 Python 组合进行安装即可。</p>
<p>如果您要分发的包具有这样的外部依赖项，那么您可以通过使用 <code>auditwheel</code> 或 <code>delocate</code> 来帮您的用户一个忙，让他们省去自己安装依赖项的额外步骤。</p>
<h3 id="在持续集成中构建-wheels">在持续集成中构建 Wheels</h3>
<p>在本地机器上构建 Wheels 的替代方法是在项目的 <a href="https://realpython.com/python-continuous-integration/">CI 管道</a>中自动构建它们。</p>
<p>有无数与主要代码托管服务集成的 CI 解决方案。其中包括 <a href="https://www.appveyor.com/">Appveyor</a>、<a href="https://azure.microsoft.com/en-us/services/devops/">Azure DevOps</a>、<a href="https://bitbucket.org/product/features/pipelines">BitBucket Pipelines</a>、<a href="https://circleci.com/">Circle CI</a>、<a href="https://about.gitlab.com/stages-devops-lifecycle/continuous-integration/">GitLab</a>、<a href="https://github.com/features/actions">GitHub Actions</a>、<a href="https://www.jenkins.io/">Jenkins</a> 和 <a href="https://travis-ci.org/">Travis CI</a>，仅举几例。</p>
<p>本教程的目的不是要判断哪种 CI 服务最适合构建 Wheels ，以及考虑到 CI 支持的发展速度，任何支持哪些容器的 CI 服务列表很快就会过时。</p>
<p>但是，本节可以帮助您入门。</p>
<p>如果你正在开发一个纯 Python 包， <code>bdist_wheel</code> 一步是一个幸福的单行：它在很大程度上与你在哪个容器操作系统和平台上构建 Wheels 无关。几乎所有主要的 CI 服务都应该使您能够通过在项目内的特殊 YAML 文件中定义步骤来以简洁的方式执行此操作。</p>
<p>例如，这是您可以用于 GitHub Actions 的语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Python wheels</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">release</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">types</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">created</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">wheels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Set up Python 3.x</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/setup-python@v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">python-version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3.x&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Install dependencies</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">python -m pip install --upgrade setuptools wheel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build wheels</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">python setup.py bdist_wheel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/upload-artifact@v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dist</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">dist</span><span class="w">
</span></span></span></code></pre></div><p>在此配置文件中，您使用以下步骤构建一个 Wheels ：</p>
<ul>
<li>在第 8 行，您指定该作业应在 Ubuntu 机器上运行。</li>
<li>在第 10 行中，您使用 <code>checkout</code> 操作来设置您的项目存储库。</li>
<li>在第 14 行，您告诉 CI 运行器使用最新稳定版本的 Python 3。</li>
<li>在第 21 行中，您请求将生成的 Wheels 作为工件提供，您可以在作业完成后从 UI 下载该工件。</li>
</ul>
<p>但是，如果您有一个复杂的项目（可能是一个带有 C 扩展或 Cython 代码的项目）并且您正在努力构建一个 CI/CD 管道以自动构建 Wheels ，那么可能会涉及额外的步骤。以下是一些您可以通过示例学习的项目：</p>
<ul>
<li><a href="https://github.com/aio-libs/yarl"><code>yarl</code></a></li>
<li><a href="https://github.com/msgpack/msgpack-python"><code>msgpack</code></a></li>
<li><a href="https://github.com/pallets/markupsafe"><code>markupsafe</code></a></li>
<li><a href="https://github.com/pyca/cryptography"><code>cryptography</code></a></li>
</ul>
<p>许多项目推出了自己的 CI 配置。然而，一些解决方案已经出现，用于减少配置文件中指定的代码量来构建 Wheels 。您可以直接在 CI 服务器上使用 <a href="https://github.com/joerick/cibuildwheel">cibuildwheel</a> 工具来减少构建多个平台 Wheels 所需的代码行和配置。还有 <a href="https://github.com/matthew-brett/multibuild">multibuild</a>，它提供了一组 shell 脚本，用于协助在 Travis CI 和 AppVeyor 上构建 Wheels 。</p>
<h3 id="确保你的-wheels-旋转正确">确保你的 Wheels 旋转正确</h3>
<p>构建结构正确的 Wheels 可能是一项精细的操作。例如，如果您的 Python 包使用 <code>src</code> 布局而您忘记在 <code>setup.py</code> 中正确指定它，那么生成的 Wheels 可能包含错误位置的目录。</p>
<p>您可以在 <code>bdist_wheel</code> 之后使用的一项检查是 <code>check-wheel-contents</code> 工具。它查找常见问题，例如包目录结构异常或存在重复文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ check-wheel-contents dist/*.whl
</span></span><span class="line"><span class="cl">dist/ujson-2.0.3-cp38-cp38-macosx_10_15_x86_64.whl: OK
</span></span></code></pre></div><p>在本例中， <code>check-wheel-contents</code> 表示带 <code>ujson</code>   Wheels 的所有内容都已检出。如果不是， <code>stdout</code> 将显示可能问题的摘要，就像 <code>flake8</code> 之类的 linter。</p>
<p>另一种确认您构建的 Wheels 是否正确的方法是使用 TestPyPI。首先，您可以在那里上传包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m twine upload <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      --repository-url https://test.pypi.org/legacy/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      dist/*
</span></span></code></pre></div><p>然后，您可以下载相同的包进行测试，就好像它是真实的一样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m pip install <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      --index-url https://test.pypi.org/simple/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      &lt;pkg-name&gt;
</span></span></code></pre></div><p>这允许您通过上传然后下载您自己的项目来测试您的 Wheels 。</p>
<h3 id="将-python-wheels-上传到-pypi">将 Python Wheels 上传到 PyPI</h3>
<p>现在是时候上传你的 Python 包了。由于 <code>sdist</code> 和 wheel 默认情况下都放在 <code>dist/</code> 目录中，您可以使用 <code>twine</code> 工具上传它们，这是一个用于将包发布到 PyPI 的实用程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m pip install -U twine
</span></span><span class="line"><span class="cl">$ python -m twine upload dist/*
</span></span></code></pre></div><p>由于默认情况下 <code>sdist</code> 和 <code>bdist_wheel</code> 都输出到 <code>dist/</code> ，您可以安全地告诉 <code>twine</code> 使用shell 通配符( <code>dist/*</code> ) 上传 <code>dist/</code> 下的所有内容。</p>
<h2 id="结论">结论</h2>
<p>了解 Wheels 在 Python 生态系统中扮演的关键角色可以让您作为 Python 包的用户和开发人员的生活更轻松。</p>
<p>此外，在 Wheels 方面提高你的 Python 素养将帮助你更好地理解安装包时发生了什么，以及在越来越罕见的情况下，该操作何时出错。</p>
<p><strong>在本教程中，您学习了：</strong></p>
<ul>
<li>什么是 Wheels 以及它们与源代码分布的比较</li>
<li>如何使用 Wheels 来控制包安装过程</li>
<li>通用 Wheels 、纯 Python  Wheels 和平台 Wheels 之间有什么区别</li>
<li>如何为您自己的 Python 包创建和分发 Wheels</li>
</ul>
<p>您现在已经从用户和开发人员的角度对 Wheels 有了深入的了解。您完全有能力构建自己的 Wheels ，并使项目的安装过程快速、方便和稳定。</p>
<p>请参阅下面的部分以获取一些额外的阅读材料，以更深入地了解快速扩展的 wheel 生态系统。</p>
<h2 id="资源">资源</h2>
<p><a href="https://pythonwheels.com/">Python Wheels</a>页面专门跟踪 PyPI 上下载次数最多的 360 个包中对 wheels 的支持。在编写本教程时，采用率非常可观，为 360 分之 331，即 91% 左右。</p>
<p>已经有许多 Python 增强提案 (PEP) 帮助了 wheel 格式的规范和发展：</p>
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0425/">PEP 425 - Compatibility Tags for Built Distributions</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0427/">PEP 427 - The Wheel Binary Package Format 1.0</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0491/">PEP 491 - The Wheel Binary Package Format 1.9</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0513/">PEP 513 - A Platform Tag for Portable Linux Built Distributions</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0571/">PEP 571 - The manylinux2010 Platform Tag</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0599/">PEP 599 - The manylinux2014 Platform Tag</a></li>
</ul>
<p>以下是本教程中提到的各种 wheel 打包工具的候选清单：</p>
<ul>
<li><a href="https://github.com/pypa/wheel">pypa/wheel</a></li>
<li><a href="https://github.com/pypa/auditwheel">pypa/auditwheel</a></li>
<li><a href="https://github.com/pypa/manylinux">pypa/manylinux</a></li>
<li><a href="https://github.com/pypa/python-manylinux-demo">pypa/python-manylinux-demo</a></li>
<li><a href="https://github.com/jwodder/check-wheel-contents">jwodder/check-wheel-contents</a></li>
<li><a href="https://github.com/matthew-brett/delocate">matthew-brett/delocate</a></li>
<li><a href="https://github.com/matthew-brett/multibuild">matthew-brett/multibuild</a></li>
<li><a href="https://github.com/joerick/cibuildwheel">joerick/cibuildwheel</a></li>
</ul>
<p>Python 文档有几篇文章涵盖了 Wheels 和源代码分发：</p>
<ul>
<li><a href="https://packaging.python.org/tutorials/packaging-projects/#generating-distribution-archives">Generating Distribution Archives</a></li>
<li><a href="https://docs.python.org/3/distutils/sourcedist.html">Creating a Source Distribution</a></li>
</ul>
<p>最后，这里有一些来自 PyPA 的更有用的链接：</p>
<ul>
<li><a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/#packaging-your-project">Packaging your Project</a></li>
<li><a href="https://packaging.python.org/overview/">An Overview of Packaging for Python</a></li>
</ul>
<p>原文地址：<a href="https://realpython.com/python-wheels/">https://realpython.com/python-wheels/</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译]使用 Python 的 pip 管理项目的依赖关系</title>
      <link>https://blog.chensoul.com/posts/2023/06/01/what-is-pip/</link>
      <pubDate>Thu, 01 Jun 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/06/01/what-is-pip/</guid>
      <description>Python 的标准包管理器是 pip 。它允许您安装和管理不属于 Python 标准库的包。如果您正在寻找 pip 的介绍，那么您来对地方了！ 在本教程中，您将学习如何： 在您的工作环</description>
      <content:encoded><![CDATA[<p><img loading="lazy" src="https://files.realpython.com/media/What-is-PIP_Watermarked.4944e95d83ad.jpg" alt="Using Python&amp;rsquo;s pip to Manage Your Projects&amp;rsquo; Dependencies"  />
</p>
<p><a href="https://www.python.org/">Python</a> 的标准包管理器是 <a href="https://pip.pypa.io/en/stable/">pip</a> 。它允许您安装和管理不属于 Python <a href="https://docs.python.org/3/py-modindex.html">标准库</a>的包。如果您正在寻找 <code>pip</code> 的介绍，那么您来对地方了！</p>
<p><strong>在本教程中，您将学习如何：</strong></p>
<ul>
<li>在您的工作环境中设置 <code>pip</code></li>
<li>修复与使用 <code>pip</code> 相关的常见错误</li>
<li>使用 <code>pip</code> 安装和卸载包</li>
<li>使用需求文件管理项目的依赖关系</li>
</ul>
<p><code>pip</code> 可以做很多事情，但是 Python 社区非常活跃，已经创建了一些 <code>pip</code> 的巧妙替代品。您将在本教程的后面部分了解这些内容。</p>
<h2 id="从-pip-开始">从 <code>pip</code> 开始</h2>
<p>那么，<code>pip</code> 具体是做什么的呢？ <a href="https://pip.pypa.io/en/stable/">pip</a> 是 Python 的包管理器。这意味着它是一个允许您安装和管理未作为标准库的一部分分发的库和依赖项的工具。 pip 这个名字是由 Ian Bicking 在 2008 年引入的：</p>
<blockquote>
<p>我已经将 pyinstall 重命名为新名称：pip。pip 是 pip install package 首字母缩写。 （ <a href="https://www.ianbicking.org/blog/2008/10/pyinstall-is-dead-long-live-pip.html">来源</a>）</p>
</blockquote>
<p>包管理非常重要，Python 的安装程序从 3.4 版和 2.7.9 版开始分别为 Python 3 和 Python 2 包含了 <code>pip</code> 。许多 Python 项目都使用 <code>pip</code> ，这使它成为每个 Pythonista 的必备工具。</p>
<p>如果您来自另一种编程语言，您可能会熟悉包管理器的概念。 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript</a> 使用 <a href="https://www.npmjs.com/">npm</a> 进行包管理，<a href="https://www.ruby-lang.org/en/">Ruby</a> 使用 <a href="https://rubygems.org/">gem</a>，<a href="https://dotnet.microsoft.com/languages">.NET 平台</a>使用 <a href="https://www.nuget.org/">NuGet</a>。在 Python 中， <code>pip</code> 已成为标准包管理器。</p>
<h3 id="在您的系统上查找-pip">在您的系统上查找 pip</h3>
<p>Python 3 安装程序为您提供了在系统上安装 Python 时安装 <code>pip</code> 的选项。事实上， <code>pip</code> 与Python一起安装的选项默认是勾选的，所以 <code>pip</code> 应该在安装完Python之后就可以使用了。</p>
<blockquote>
<p>注意：在某些 Linux (Unix) 系统（如 Ubuntu）上， <code>pip</code> 位于一个名为 <code>python3-pip</code> 的单独包中，您需要使用 <code>sudo apt install python3-pip</code> 安装它。默认情况下，它不会随解释器一起安装。</p>
</blockquote>
<p>您可以通过在您的系统上查找 <code>pip3</code> 可执行文件来验证 <code>pip</code> 是否可用。在下面选择您的操作系统并相应地使用您的平台特定命令：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">C:<span class="se">\&gt;</span> where pip3
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ which pip3
</span></span></code></pre></div><p>Linux 系统和 macOS 上的 <code>which</code> 命令显示 <code>pip3</code> 二进制文件所在的位置。</p>
<p>在 Windows 和 Unix 系统上， <code>pip3</code> 可能位于多个位置。当您安装了多个 Python 版本时，可能会发生这种情况。如果您在系统的任何位置都找不到 <code>pip</code> ，那么您可以考虑重新安装 pip。</p>
<p>除了直接运行您的系统 <code>pip</code> ，您还可以将其作为 Python 模块运行。在下一节中，您将了解如何操作。</p>
<h3 id="作为模块运行-pip">作为模块运行 pip</h3>
<p>当您直接运行系统 <code>pip</code> 时，命令本身不会显示 <code>pip</code> 属于哪个 Python 版本。不幸的是，这意味着您可以在不注意的情况下使用 <code>pip</code> 将包安装到旧 Python 版本的站点包中。为防止这种情况发生，您可以将 <code>pip</code> 作为 Python 模块运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python3 -m pip
</span></span></code></pre></div><p>请注意，您使用 <code>python3 -m</code> 来运行 <code>pip</code> 。 <code>-m</code> 开关告诉 Python 将模块作为 <code>python3</code> 解释器的可执行文件运行。这样，您可以确保系统默认的 Python 3 版本运行 <code>pip</code> 命令。如果您想了解更多关于这种运行 <code>pip</code> 的方式，那么您可以阅读 Brett Cannon 关于<a href="https://snarky.ca/why-you-should-use-python-m-pip/">使用 python3 -m pip 的优势</a>的有见地的文章。</p>
<p>有时您可能希望更加明确并将包限制到特定项目。在这种情况下，您应该在虚拟环境中运行 <code>pip</code> 。</p>
<h3 id="在-python-虚拟环境中使用-pip">在 Python 虚拟环境中使用 pip</h3>
<p>为避免将包直接安装到系统 Python 安装中，您可以使用<a href="https://realpython.com/python-virtual-environments-a-primer/">虚拟环境</a>。虚拟环境为您的项目提供独立的 Python 解释器。您在此环境中使用的任何包都将独立于您的系统解释器。</p>
<p>这意味着您可以将项目的依赖项与其他项目和整个系统分开。</p>
<p>在虚拟环境中使用 <code>pip</code> 具有三个主要优点。你可以：</p>
<ul>
<li>确保您为手头的项目使用正确的 Python 版本</li>
<li>确保在运行 <code>pip</code> 或 <code>pip3</code> 时引用的是正确的 <code>pip</code> 实例</li>
<li>在不影响其他项目的情况下为您的项目使用特定的包版本</li>
</ul>
<p>Python 3 具有用于创建虚拟环境的内置 <code>venv</code> 模块。此模块可帮助您使用独立的 Python 安装创建虚拟环境。一旦你激活了虚拟环境，你就可以将包安装到这个环境中。</p>
<p>您安装到一个虚拟环境中的软件包与系统上的所有其他环境隔离开来。</p>
<p>您可以按照以下步骤创建虚拟环境并验证您是否在新创建的环境中使用 <code>pip</code> 模块：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">C:<span class="se">\&gt;</span> python -m venv venv
</span></span><span class="line"><span class="cl">C:<span class="se">\&gt;</span> venv<span class="se">\S</span>cripts<span class="se">\a</span>ctivate.bat
</span></span><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span>  pip3 --version
</span></span><span class="line"><span class="cl">pip 21.2.3 from ...<span class="se">\l</span>ib<span class="se">\s</span>ite-packages<span class="se">\p</span>ip <span class="o">(</span>python 3.10<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span>  pip --version
</span></span><span class="line"><span class="cl">pip 21.2.3 from ...<span class="se">\l</span>ib<span class="se">\s</span>ite-packages<span class="se">\p</span>ip <span class="o">(</span>python 3.10<span class="o">)</span>
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python3 -m venv venv
</span></span><span class="line"><span class="cl">$ <span class="nb">source</span> venv/bin/activate
</span></span><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ pip3 --version
</span></span><span class="line"><span class="cl">pip 21.2.3 from .../python3.10/site-packages/pip <span class="o">(</span>python 3.10<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ pip --version
</span></span><span class="line"><span class="cl">pip 21.2.3 from .../python3.10/site-packages/pip <span class="o">(</span>python 3.10<span class="o">)</span>
</span></span></code></pre></div><p>在这里，您使用 Python 的内置 <code>venv</code> 模块创建了一个名为 <code>venv</code> 的虚拟环境。然后使用 <code>source</code> 命令激活它。 <code>venv</code> 名称周围的括号 ( <code>()</code> ) 表示您已成功激活虚拟环境。</p>
<p>最后，您检查激活的虚拟环境中 <code>pip3</code> 和 <code>pip</code> 可执行文件的版本。两者都指向相同的 <code>pip</code> 模块，因此一旦您的虚拟环境被激活，您就可以使用 <code>pip</code> 或 <code>pip3</code> 。</p>
<h3 id="出现错误时重新安装-pip">出现错误时重新安装 pip</h3>
<p>当您运行 <code>pip</code> 命令时，在某些情况下您可能会遇到错误。您的特定错误消息将取决于您的操作系统：</p>
<table>
<thead>
<tr>
<th>Operating System</th>
<th>Error Message</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows</td>
<td><code>'pip' is not recognized as an internal or external command,</code> <code>operable program or batch file.</code></td>
</tr>
<tr>
<td>Linux</td>
<td><code>bash: pip: command not found</code></td>
</tr>
<tr>
<td>macOS</td>
<td><code>zsh: command not found: pip</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：在 <code>pip</code> 命令不起作用时开始任何故障排除之前，您可以尝试使用最后带有 3 的 <code>pip3</code> 命令。</p>
</blockquote>
<p>出现如上所示的错误可能会令人沮丧，因为 <code>pip</code> 对于安装和管理外部包至关重要。 <code>pip</code> 的一些常见问题与此工具在您的系统上的安装方式有关。</p>
<p>尽管各种系统的错误消息不同，但它们都指向同一个问题：您的系统无法在您的 <code>PATH</code> 变量中列出的位置找到 <code>pip</code> 。在 Windows 上， <code>PATH</code> 是系统变量的一部分。在 macOS 和 Linux 上， <code>PATH</code> 是环境变量的一部分。您可以使用以下命令检查 <code>PATH</code> 变量的内容：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">C:<span class="se">\&gt;</span> <span class="nb">echo</span> %PATH%
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="nv">$PATH</span>
</span></span></code></pre></div><p>此命令的输出将显示磁盘上操作系统查找可执行程序的位置（目录）列表。根据您的系统，位置可以用冒号 ( <code>:</code> ) 或分号 ( <code>;</code> ) 分隔。</p>
<p>默认情况下，在安装 Python 或创建虚拟环境后，包含 <code>pip</code> 可执行文件的目录应该出现在 <code>PATH</code> 中。但是，缺少 <code>pip</code> 是一个常见问题。两种支持的方法可以帮助您再次安装 <code>pip</code> 并将其添加到您的 <code>PATH</code> ：</p>
<ul>
<li><a href="https://docs.python.org/3/library/ensurepip.html#module-ensurepip">ensurepip</a> 模块</li>
<li><a href="https://github.com/pypa/get-pip">get-pip.py</a> 脚本</li>
</ul>
<p><code>ensurepip</code> 模块从 Python 3.4 开始就是标准库的一部分。添加它是为了提供一种直接的方式让您重新安装 <code>pip</code> ，例如，如果您在安装 Python 时跳过它或在某个时候卸载了 <code>pip</code> 。在下面选择您的操作系统并相应地运行 <code>ensurepip</code> ：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">C:<span class="se">\&gt;</span> python -m ensurepip --upgrade
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python3 -m ensurepip --upgrade
</span></span></code></pre></div><p>如果尚未安装 <code>pip</code> ，则此命令会将其安装在您当前的 Python 环境中。如果您处于活动的虚拟环境中，则该命令会将 <code>pip</code> 安装到该环境中。否则，它会在您的系统上全局安装 <code>pip</code> 。 <code>--upgrade</code> 选项确保 <code>pip</code> 版本与 <code>ensurepip</code> 中声明的版本相同。</p>
<blockquote>
<p>注意： <code>ensurepip</code> 模块不访问互联网。 <code>ensurepip</code> 可以安装的最新版本的 <code>pip</code> 是捆绑在您环境的 Python 安装中的版本。例如，使用 Python 3.10.0 运行 <code>ensurepip</code> 将安装 <code>pip</code> 21.2.3。如果你想要更新的 <code>pip</code> 版本，那么你需要先运行 <code>ensurepip</code> 。之后，您可以手动将 <code>pip</code> 更新到其最新版本。</p>
</blockquote>
<p>修复 <code>pip</code> 安装的另一种方法是使用 <code>get-pip.py</code> 脚本。 <code>get-pip.py</code> 文件包含作为编码 <a href="https://realpython.com/python-zip-import/">ZIP 文件</a>的 <code>pip</code> 的完整副本。您可以直接从 PyPA 引导页面下载 <code>get-pip.py</code> 。一旦你的机器上有了脚本，你就可以像这样<a href="https://realpython.com/run-python-scripts/">运行 Python 脚本</a>：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">C:<span class="se">\&gt;</span> python get-pip.py
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python3 get-pip.py
</span></span></code></pre></div><p>此脚本将在您当前的 Python 环境中安装最新版本的 <code>pip</code> 、 <code>setuptools</code> 和 <code>wheel</code> 。如果只想安装 <code>pip</code> ，则可以将 <code>--no-setuptools</code> 和 <code>--no-wheel</code> 选项添加到命令中。</p>
<p>如果上述方法都不起作用，那么可能值得尝试为您当前的平台下载最新的 Python 版本。您可以按照 <a href="https://realpython.com/installing-python/">Python 3 安装和设置指南</a>来确保 <code>pip</code> 已正确安装并且可以正常工作。</p>
<h2 id="使用-pip-安装包">使用 pip 安装包</h2>
<p>Python 被认为是一种<a href="https://www.python.org/dev/peps/pep-0206/#id3">包含电池</a>的语言。这意味着 Python 标准库包含一组广泛的包和模块来帮助开发人员完成他们的编码项目。</p>
<p>同时，Python 有一个活跃的社区，它贡献了更广泛的包集，可以帮助您满足您的开发需求。这些包发布到 Python 包索引，也称为 PyPI（发音为 Pie Pea Eye）。</p>
<blockquote>
<p>注意：当你安装第三方包时，你必须小心。查看如何评估 Python 包的质量以获得确保您的包值得信赖的完整指南。</p>
</blockquote>
<p>PyPI 拥有广泛的包集合，包括开发框架、工具和库。其中许多包都为 Python 标准库的功能提供了友好的接口。</p>
<h3 id="使用-python-包索引-pypi">使用 Python 包索引 (PyPI)</h3>
<p>PyPI 托管的众多包之一称为 <code>requests</code> 。 <code>requests</code> 库通过抽象化 HTTP 请求的复杂性来帮助您与 Web 服务交互。您可以在其官方文档站点上了解有关 <code>requests</code> 的所有信息。</p>
<p>当你想在你的项目中使用 <code>requests</code> 包时，你必须先将它安装到你的环境中。如果你不想把它安装在你的系统 Python site-packages 中，那么你可以先创建一个虚拟环境，如上所示。</p>
<p>创建虚拟环境并激活它后，命令行提示符会在括号内显示虚拟环境的名称。您从现在开始执行的任何 <code>pip</code> 命令都将在您的虚拟环境中执行。</p>
<p>要安装包， <code>pip</code> 提供了一个 <code>install</code> 命令。您可以运行它来安装 <code>requests</code> 包：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip install requests
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip install requests
</span></span></code></pre></div><p>在此示例中，您运行 <code>pip</code> 和 <code>install</code> 命令，后跟要安装的包的名称。 <code>pip</code> 命令在 PyPI 中查找包，解析其依赖关系，并在当前 Python 环境中安装所有内容，以确保 <code>requests</code> 能够正常工作。</p>
<p><code>pip install &lt;package&gt;</code> 命令总是寻找最新版本的包并安装它。它还搜索包元数据中列出的依赖项并安装它们以确保包具有所需的所有要求。</p>
<p>也可以在一个命令中安装多个包：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip install rptree codetiming
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip install rptree codetiming
</span></span></code></pre></div><p>通过在 <code>pip install</code> 命令中链接包 <code>rptree</code> 和 <code>codetiming</code> ，您可以同时安装这两个包。您可以向 <code>pip install</code> 命令添加任意数量的包。在这种情况下， <code>requirements.txt</code> 文件可以派上用场。在本教程的后面，您将学习如何使用 <code>requirements.txt</code> 文件一次安装多个包。</p>
<blockquote>
<p>注意：除非包的特定版本号与本教程相关，否则您会注意到版本字符串采用通用形式 <code>x.y.z</code> 。这是一种占位符格式，可以代表 <code>3.1.4</code> 、 <code>2.9</code> 或任何其他版本号。当您继续操作时，终端中的输出将显示您的实际包版本号。</p>
</blockquote>
<p>您可以使用 <code>list</code> 命令显示环境中安装的包及其版本号：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip list
</span></span><span class="line"><span class="cl">Package            Version
</span></span><span class="line"><span class="cl">------------------ ---------
</span></span><span class="line"><span class="cl">certifi            x.y.z
</span></span><span class="line"><span class="cl">charset-normalizer x.y.z
</span></span><span class="line"><span class="cl">codetiming         x.y.z
</span></span><span class="line"><span class="cl">idna               x.y.z
</span></span><span class="line"><span class="cl">pip                x.y.z
</span></span><span class="line"><span class="cl">requests           x.y.z
</span></span><span class="line"><span class="cl">rptree             x.y.z
</span></span><span class="line"><span class="cl">setuptools         x.y.z
</span></span><span class="line"><span class="cl">urllib3            x.y.z
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip list
</span></span><span class="line"><span class="cl">Package            Version
</span></span><span class="line"><span class="cl">------------------ ---------
</span></span><span class="line"><span class="cl">certifi            x.y.z
</span></span><span class="line"><span class="cl">charset-normalizer x.y.z
</span></span><span class="line"><span class="cl">idna               x.y.z
</span></span><span class="line"><span class="cl">pip                x.y.z
</span></span><span class="line"><span class="cl">requests           x.y.z
</span></span><span class="line"><span class="cl">setuptools         x.y.z
</span></span><span class="line"><span class="cl">urllib3            x.y.z
</span></span></code></pre></div><p><code>pip list</code> 命令呈现一个表格，显示当前环境中所有已安装的包。上面的输出显示了使用 <code>x.y.z</code> 占位符格式的包的版本。当您在您的环境中运行 <code>pip list</code> 命令时， <code>pip</code> 会显示您为每个包安装的特定版本号。</p>
<p>现在您已经安装了 <code>requests</code> 及其依赖项，您可以像导入 Python 代码中的任何其他常规包一样导入它。启动交互式 Python 解释器并导入 <code>requests</code> 包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">requests</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">requests</span><span class="o">.</span><span class="n">__version__</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;x.y.z&#34;</span>
</span></span></code></pre></div><p>启动交互式 Python 解释器后，您导入了 <code>requests</code> 模块。通过调用 <code>requests.__version__</code> ，您验证了您在虚拟环境中使用了 <code>requests</code> 模块。</p>
<h3 id="使用自定义包索引">使用自定义包索引</h3>
<p>默认情况下， <code>pip</code> 使用 PyPI 来查找包。但 <code>pip</code> 还为您提供了定义自定义包索引的选项。</p>
<p>当 PyPI 域在您的网络上被阻止或者如果您想要使用非公开可用的包时，将 <code>pip</code> 与自定义索引一起使用会很有帮助。</p>
<p>有时系统管理员还创建自己的内部包索引，以更好地控制哪些包版本可供公司网络上的 <code>pip</code> 用户使用。</p>
<p>自定义包索引必须符合 <a href="https://www.python.org/dev/peps/pep-0503/">PEP 503 – 简单存储库 API</a> 才能与 <code>pip</code> 一起使用。您可以通过访问 <a href="https://pypi.org/simple/">PyPI 简单索引</a>了解这样一个 <a href="https://en.wikipedia.org/wiki/API">API（应用程序编程接口）</a>的外观——但请注意，这是一个包含大量难以解析内容的大页面。任何遵循相同 API 的自定义索引都可以使用 <code>--index-url</code> 选项作为目标。除了输入 <code>--index-url</code> ，您还可以使用 <code>-i</code> 速记。</p>
<p>例如，要从 TestPyPI 包索引安装 <code>rptree</code> 工具，您可以运行以下命令：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip install -i https://test.pypi.org/simple/ rptree
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip install -i https://test.pypi.org/simple/ rptree
</span></span></code></pre></div><p>使用 <code>-i</code> 选项，您告诉 <code>pip</code> 查看不同的包索引而不是默认的 PyPI。在这里，您从 TestPyPI 而不是 PyPI 安装 <code>rptree</code> 。您可以使用 TestPyPI 微调 Python 包的发布过程，而不会弄乱 PyPI 上的生产包索引。</p>
<p>如果需要永久使用替代索引，则可以在 <code>pip</code> <a href="https://pip.pypa.io/en/stable/topics/configuration/">配置文件</a>中设置 <code>index-url</code> 选项。该文件名为 <code>pip.conf</code> ，您可以通过运行以下命令找到它的位置：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip config list -vv
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip config list -vv
</span></span></code></pre></div><p>使用 <code>pip config list</code> 命令，您可以列出活动配置。当您设置了自定义配置时，此命令仅输出一些内容。否则，输出为空。这就是加法 <code>--verbose</code> 或 <code>-vv</code> 选项会有所帮助的时候。添加 <code>-vv</code> 时， <code>pip</code> 会向您显示它在何处查找不同的配置级别。</p>
<p>如果要添加 <code>pip.conf</code> 文件，则可以选择 <code>pip config list -vv</code> 列出的位置之一。带有自定义包索引的 <code>pip.conf</code> 文件如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pip.conf</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">global</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">index-url</span> <span class="p">=</span> <span class="nx">https</span><span class="err">://</span><span class="nx">test</span><span class="p">.</span><span class="nx">pypi</span><span class="p">.</span><span class="nx">org</span><span class="err">/</span><span class="nx">simple</span><span class="err">/</span>
</span></span></code></pre></div><p>当你有一个这样的 <code>pip.conf</code> 文件时， <code>pip</code> 将使用定义的 <code>index-url</code> 来查找包。使用此配置，您无需在 <code>pip install</code> 命令中使用 <code>--index-url</code> 选项来指定您只需要可以在 TestPyPI 的<a href="https://test.pypi.org/simple/">简单 API</a> 中找到的包。</p>
<h3 id="从-github-存储库安装包">从 GitHub 存储库安装包</h3>
<p>您不限于托管在 PyPI 或其他包索引上的包。 <code>pip</code> 还提供了从 <a href="https://realpython.com/python-git-github-intro/">GitHub 存储库</a>安装包的选项。但即使包托管在 PyPI 上，如 <a href="https://pypi.org/project/rptree/">Real Python 目录树生成器</a>，您也可以选择从其 Git 存储库安装它：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip install git+https://github.com/realpython/rptree
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip install git+https://github.com/realpython/rptree
</span></span></code></pre></div><p>使用 <code>git+https</code> 方案，您可以指向包含可安装包的 Git 存储库。您可以通过运行交互式 Python 解释器并导入 <code>rptree</code> 来验证您是否正确安装了包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">rptree</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">rptree</span><span class="o">.</span><span class="n">__version__</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;x.y.z&#34;</span>
</span></span></code></pre></div><p>启动交互式 Python 解释器后，导入 <code>rptree</code> 模块。通过调用 <code>rptree.__version__</code> ，您可以验证您正在使用基于虚拟环境的 <code>rptree</code> 模块。</p>
<blockquote>
<p>注意：如果您使用的是 Git 以外的版本控制系统 (VCS)， <code>pip</code> 可以满足您的要求。要了解如何将 <code>pip</code> 与 Mercurial、Subversion 或 Bazaar 一起使用，请查看 <code>pip</code> 文档的 VCS 支持章节。</p>
</blockquote>
<p>如果包未托管在 PyPI 上但具有远程 Git 存储库，则从 Git 存储库安装包会很有帮助。您指向 <code>pip</code> 的远程存储库甚至可以托管在您公司内部网上的内部 Git 服务器上。当您位于防火墙后面或对您的 Python 项目有其他限制时，这会很有用。</p>
<h3 id="以可编辑模式安装包以简化开发">以可编辑模式安装包以简化开发</h3>
<p>在您自己的包上工作时，以可编辑模式安装它是有意义的。通过这样做，您可以像在任何其他包中一样使用命令行来处理源代码。典型的工作流程是首先克隆存储库，然后使用 <code>pip</code> 将其作为可编辑包安装在您的环境中：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">C:<span class="se">\&gt;</span> git clone https://github.com/realpython/rptree
</span></span><span class="line"><span class="cl">C:<span class="se">\&gt;</span> <span class="nb">cd</span> rptree
</span></span><span class="line"><span class="cl">C:<span class="se">\r</span>ptree&gt; python3 -m venv venv
</span></span><span class="line"><span class="cl">C:<span class="se">\r</span>ptree&gt; venv<span class="se">\S</span>cripts<span class="se">\a</span>ctivate.bat
</span></span><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\r</span>ptree&gt; python -m pip install -e .
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git clone https://github.com/realpython/rptree
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> rptree
</span></span><span class="line"><span class="cl">$ python3 -m venv venv
</span></span><span class="line"><span class="cl">$ <span class="nb">source</span> venv/bin/activate
</span></span><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip install -e .
</span></span></code></pre></div><p>使用上面的命令，您将 <code>rptree</code> 包安装为可编辑模块。以下是您刚刚执行的操作的逐步细分：</p>
<ul>
<li>
<p>第 1 行克隆了 <code>rptree</code> 包的 Git 存储库。</p>
</li>
<li>
<p>第 2 行将工作目录更改为 <code>rptree/</code> 。</p>
</li>
<li>
<p>第 3 行和第 4 行创建并激活了一个虚拟环境。</p>
</li>
<li>
<p>第 5 行将当前目录的内容安装为一个可编辑的包。</p>
</li>
</ul>
<p><code>-e</code> 选项是 <code>--editable</code> 选项的简写。当您将 <code>-e</code> 选项与 <code>pip install</code> 一起使用时，您告诉 <code>pip</code> 您想要以可编辑模式安装包。您不使用包名称，而是使用点 ( <code>.</code> ) 将 <code>pip</code> 指向当前目录。</p>
<p>如果您没有使用 <code>-e</code> 标志， <code>pip</code> 会正常将包安装到您环境的 <code>site-packages/</code> 文件夹中。当您以可编辑模式安装包时，您将在站点包中创建一个指向本地项目路径的链接：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"> ~/rptree/venv/lib/python3.10/site-packages/rptree.egg-link
</span></span></code></pre></div><p>使用带有 <code>-e</code> 标志的 <code>pip install</code> 命令只是 <code>pip install</code> 提供的众多选项之一。您可以查看 <code>pip</code> 文档中的 <a href="https://pip.pypa.io/en/stable/cli/pip_install/#examples">pip install 示例</a>。在那里，您将学习如何安装包的特定版本或将 <code>pip</code> 指向非 PyPI 的不同索引。</p>
<p>在下一节中，您将了解需求文件如何帮助您完成 <code>pip</code> 工作流。</p>
<h2 id="使用需求文件">使用需求文件</h2>
<p><code>pip install</code> 命令始终安装包的最新发布版本，但有时您的代码需要特定的包版本才能正常工作。</p>
<p>您想要创建用于开发和测试应用程序的依赖项和版本的规范，以便在生产中使用该应用程序时不会出现意外。</p>
<h3 id="固定需求">固定需求</h3>
<p>当您与其他开发人员共享您的 Python 项目时，您可能希望他们使用您正在使用的相同版本的外部包。</p>
<p>也许某个特定版本的软件包包含您所依赖的新功能，或者您正在使用的软件包版本与以前的版本不兼容。</p>
<p>这些外部依赖项也称为需求。您经常会发现 Python 项目将其需求固定在名为 <code>requirements.txt</code> 或类似文件的文件中。<a href="https://pip.pypa.io/en/stable/reference/requirements-file-format/">需求文件格式</a>允许您精确指定应安装哪些包和版本。</p>
<p>运行 <code>pip help</code> 显示有一个 <code>freeze</code> 命令以需求格式输出已安装的包。您可以使用此命令，将输出重定向到文件以生成需求文件：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip freeze &gt; requirements.txt
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip freeze &gt; requirements.txt
</span></span></code></pre></div><p>此命令在您的工作目录中创建一个 <code>requirements.txt</code> 文件，其中包含以下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">certifi</span><span class="o">==</span>x.y.z
</span></span><span class="line"><span class="cl">charset-normalizer<span class="o">==</span>x.y.z
</span></span><span class="line"><span class="cl"><span class="nv">idna</span><span class="o">==</span>x.y.z
</span></span><span class="line"><span class="cl"><span class="nv">requests</span><span class="o">==</span>x.y.z
</span></span><span class="line"><span class="cl"><span class="nv">urllib3</span><span class="o">==</span>x.y.z
</span></span></code></pre></div><p>请记住，上面显示的 <code>x.y.z</code> 是包版本的占位符格式。您的 <code>requirements.txt</code> 文件将包含真实的版本号。</p>
<p><code>freeze</code> 命令将当前安装的包的名称和版本转储到标准输出。您可以将输出重定向到一个文件，稍后您可以使用该文件将您的确切要求安装到另一个系统中。您可以随意命名需求文件。</p>
<p>但是，广泛采用的约定是将其命名为 <code>requirements.txt</code> 。</p>
<p>当你想在另一个系统中复制环境时，你可以运行 <code>pip install</code> ，使用 <code>-r</code> 开关来指定需求文件：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip install -r requirements.txt
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(venv) $ python3 -m pip install -r requirements.txt
</span></span></code></pre></div><p>在上面的命令中，您告诉 <code>pip</code> 将 <code>requirements.txt</code> 中列出的包安装到您当前的环境中。包版本将匹配 <code>requirements.txt</code> 文件包含的版本约束。您可以运行 <code>pip list</code> 来显示您刚刚安装的包及其版本号：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip list
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Package            Version
</span></span><span class="line"><span class="cl">------------------ ---------
</span></span><span class="line"><span class="cl">certifi            x.y.z
</span></span><span class="line"><span class="cl">charset-normalizer x.y.z
</span></span><span class="line"><span class="cl">idna               x.y.z
</span></span><span class="line"><span class="cl">pip                x.y.z
</span></span><span class="line"><span class="cl">requests           x.y.z
</span></span><span class="line"><span class="cl">setuptools         x.y.z
</span></span><span class="line"><span class="cl">urllib3            x.y.z
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip list
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Package            Version
</span></span><span class="line"><span class="cl">------------------ ---------
</span></span><span class="line"><span class="cl">certifi            x.y.z
</span></span><span class="line"><span class="cl">charset-normalizer x.y.z
</span></span><span class="line"><span class="cl">idna               x.y.z
</span></span><span class="line"><span class="cl">pip                x.y.z
</span></span><span class="line"><span class="cl">requests           x.y.z
</span></span><span class="line"><span class="cl">setuptools         x.y.z
</span></span><span class="line"><span class="cl">urllib3            x.y.z
</span></span></code></pre></div><p>现在您可以分享您的项目了！您可以将 <code>requirements.txt</code> 提交到像 Git 这样的版本控制系统中，并使用它在其他机器上复制相同的环境。但是等等，如果为这些软件包发布新的更新会怎样？</p>
<h3 id="微调需求">微调需求</h3>
<p>对包的版本和依赖项进行硬编码的问题在于，包会经常更新错误和安全修复程序。您可能希望在更新发布后立即利用这些更新。</p>
<p>需求文件格式允许您使用比较运算符指定依赖项版本，这为您提供了一些灵活性，以确保更新包，同时仍然定义包的基本版本。</p>
<p>在您喜欢的编辑器中打开 <code>requirements.txt</code> ，并将相等运算符 ( <code>==</code> ) 转换为大于或等于运算符 ( <code>&gt;=</code> )，如下例所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># requirements.txt</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">certifi&gt;<span class="o">=</span>x.y.z
</span></span><span class="line"><span class="cl">charset-normalizer&gt;<span class="o">=</span>x.y.z
</span></span><span class="line"><span class="cl">idna&gt;<span class="o">=</span>x.y.z
</span></span><span class="line"><span class="cl">requests&gt;<span class="o">=</span>x.y.z
</span></span><span class="line"><span class="cl">urllib3&gt;<span class="o">=</span>x.y.z
</span></span></code></pre></div><p>您可以将比较运算符更改为 <code>&gt;=</code> 以告知 <code>pip</code> 安装已发布的精确或更高版本。当您使用 <code>requirements.txt</code> 文件设置新环境时， <code>pip</code> 会查找满足要求的最新版本并进行安装。</p>
<p>接下来，您可以通过运行带有 <code>--upgrade</code> 开关或 <code>-U</code> 简写的 <code>install</code> 命令来升级需求文件中的包：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip install -U -r requirements.txt
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip install -U -r requirements.txt
</span></span></code></pre></div><p>如果列出的软件包有新版本可用，则该软件包将被升级。</p>
<p>在理想的世界中，新版本的包将向后兼容并且永远不会引入新的错误。不幸的是，新版本可能会引入会破坏您的应用程序的更改。为了微调您的需求，需求文件语法支持额外的<a href="https://www.python.org/dev/peps/pep-0440/#version-specifiers">版本说明符</a>。</p>
<p>想象一下， <code>requests</code> 的新版本 <code>3.0</code> 已发布，但引入了破坏应用程序的不兼容更改。您可以修改需求文件以防止安装 <code>3.0</code> 或更高版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># requirements.txt</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">certifi</span><span class="o">==</span>x.y.z
</span></span><span class="line"><span class="cl">charset-normalizer<span class="o">==</span>x.y.z
</span></span><span class="line"><span class="cl"><span class="nv">idna</span><span class="o">==</span>x.y.z
</span></span><span class="line"><span class="cl">requests&gt;<span class="o">=</span>x.y.z, &lt;3.0
</span></span><span class="line"><span class="cl"><span class="nv">urllib3</span><span class="o">==</span>x.y.z
</span></span></code></pre></div><p>更改 <code>requests</code> 包的版本说明符可确保不会安装任何大于或等于 <code>3.0</code> 的版本。 <code>pip</code> 文档提供了有关<a href="https://pip.pypa.io/en/stable/reference/requirements-file-format/">需求文件格式</a>的大量信息，您可以查阅它以了解更多信息。</p>
<h3 id="分离生产和开发依赖">分离生产和开发依赖</h3>
<p>并非您在应用程序开发期间安装的所有包都是生产依赖项。例如，您可能想要测试您的应用程序，因此您需要一个测试框架。一个流行的测试框架是 <code>pytest</code> 。你想在开发环境中安装它，但不想在生产环境中安装它，因为它不是生产依赖项。</p>
<p>您创建第二个需求文件 <code>requirements_dev.txt</code> ，以列出用于设置开发环境的其他工具：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># requirements_dev.txt</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pytest&gt;<span class="o">=</span>x.y.z
</span></span></code></pre></div><p>拥有两个需求文件将要求您使用 <code>pip</code> 来安装它们， <code>requirements.txt</code> 和 <code>requirements_dev.txt</code> 。幸运的是， <code>pip</code> 允许您在需求文件中指定其他参数，因此您可以修改 <code>requirements_dev.txt</code> 以同时安装来自生产环境的 <code>requirements.txt</code> 文件中的需求：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># requirements_dev.txt</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-r requirements.txt
</span></span><span class="line"><span class="cl">pytest&gt;<span class="o">=</span>x.y.z
</span></span></code></pre></div><p>请注意，您使用相同的 <code>-r</code> 开关来安装生产 <code>requirements.txt</code> 文件。现在，在您的开发环境中，您只需运行这条命令即可安装所有要求：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip install -r requirements_dev.txt
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip install -r requirements_dev.txt
</span></span></code></pre></div><p>因为 <code>requirements_dev.txt</code> 包含 <code>-r requirements.txt</code> 行，所以您不仅要安装 <code>pytest</code> ，还要安装 <code>requirements.txt</code> 的固定要求。在生产环境中，仅安装生产要求就足够了：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip install -r requirements.txt
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip install -r requirements.txt
</span></span></code></pre></div><p>使用此命令，您可以安装 <code>requirements.txt</code> 中列出的要求。与您的开发环境相比，您的生产环境不会安装 <code>pytest</code> 。</p>
<h3 id="为生产环境冷冻需求">为生产环境冷冻需求</h3>
<p>您创建了生产和开发需求文件并将它们添加到源代码管理中。这些文件使用灵活的版本说明符来确保您利用依赖项发布的错误修复。</p>
<p>您还测试了您的应用程序，现在可以将其部署到生产环境中了。</p>
<p>您知道所有测试都通过了并且应用程序可以使用您在开发过程中使用的依赖项，因此您可能希望确保将相同版本的依赖项部署到生产环境中。</p>
<p>当前的版本说明符不能保证将相同的版本部署到生产环境中，因此您希望在发布项目之前冻结生产需求。</p>
<p>根据当前需求完成开发后，创建当前项目新版本的工作流程如下所示：</p>
<table>
<thead>
<tr>
<th>Step</th>
<th>Command</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>pytest</code></td>
<td>运行您的测试并验证您的代码是否正常工作。</td>
</tr>
<tr>
<td>2</td>
<td><code>pip install -U -r requirements.txt</code></td>
<td>将您的要求升级到与 <code>requirements.txt</code> 文件中的约束相匹配的版本。</td>
</tr>
<tr>
<td>3</td>
<td><code>pytest</code></td>
<td>运行您的测试并考虑降级任何向您的代码引入错误的依赖项。</td>
</tr>
<tr>
<td>4</td>
<td><code>pip freeze &gt; requirements_lock.txt</code></td>
<td>项目正常运行后，将依赖项冻结到 <code>requirements_lock.txt</code> 文件中。</td>
</tr>
</tbody>
</table>
<p>使用这样的工作流程， <code>requirements_lock.txt</code> 文件将包含准确的版本说明符，可用于复制您的环境。您已确保当您的用户将 <code>requirements_lock.txt</code> 中列出的软件包安装到他们自己的环境中时，他们将使用您希望他们使用的版本。</p>
<p>冻结您的需求是确保您的 Python 项目在您的用户环境中以与在您的环境中相同的方式工作的重要步骤。</p>
<h2 id="使用-pip-卸载软件包">使用 pip 卸载软件包</h2>
<p>有时，您必须卸载一个包。要么你找到了一个更好的库来替换它，要么它是你不需要的东西。卸载软件包可能有点棘手。</p>
<p>请注意，当您安装 <code>requests</code> 时，您也获得了 <code>pip</code> 来安装其他依赖项。安装的包越多，多个包依赖相同依赖项的可能性就越大。这就是 <code>pip</code> 中的 <code>show</code> 命令派上用场的地方。</p>
<p>在卸载包之前，请确保为该包运行 <code>show</code> 命令：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip show requests
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Name: requests
</span></span><span class="line"><span class="cl">Version: 2.26.0
</span></span><span class="line"><span class="cl">Summary: Python HTTP <span class="k">for</span> Humans.
</span></span><span class="line"><span class="cl">Home-page: https://requests.readthedocs.io
</span></span><span class="line"><span class="cl">Author: Kenneth Reitz
</span></span><span class="line"><span class="cl">Author-email: me@kennethreitz.org
</span></span><span class="line"><span class="cl">License: Apache 2.0
</span></span><span class="line"><span class="cl">Location: .../python3.9/site-packages
</span></span><span class="line"><span class="cl">Requires: certifi, idna, charset-normalizer, urllib3
</span></span><span class="line"><span class="cl">Required-by:
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip show requests
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Name: requests
</span></span><span class="line"><span class="cl">Version: 2.26.0
</span></span><span class="line"><span class="cl">Summary: Python HTTP <span class="k">for</span> Humans.
</span></span><span class="line"><span class="cl">Home-page: https://requests.readthedocs.io
</span></span><span class="line"><span class="cl">Author: Kenneth Reitz
</span></span><span class="line"><span class="cl">Author-email: me@kennethreitz.org
</span></span><span class="line"><span class="cl">License: Apache 2.0
</span></span><span class="line"><span class="cl">Location: .../python3.9/site-packages
</span></span><span class="line"><span class="cl">Requires: certifi, idna, charset-normalizer, urllib3
</span></span><span class="line"><span class="cl">Required-by:
</span></span></code></pre></div><p>注意最后两个字段， <code>Requires</code> 和 <code>Required-by</code> 。 <code>show</code> 命令告诉您 <code>requests</code> 需要 <code>certifi</code> 、 <code>idna</code> 、 <code>charset-normalizer</code> 和 <code>urllib3</code> 。您可能也想卸载它们。请注意， <code>requests</code> 不是任何其他包所必需的。所以卸载它是安全的。</p>
<p>您应该针对所有 <code>requests</code> 依赖项运行 <code>show</code> 命令，以确保没有其他库也依赖于它们。一旦了解了要卸载的包的依赖顺序，就可以使用 <code>uninstall</code> 命令删除它们：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip uninstall certifi
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip uninstall certifi
</span></span></code></pre></div><p><code>uninstall</code> 命令显示将要删除的文件并要求确认。如果您确定要删除该包，因为您已经检查了它的依赖关系并且知道没有其他东西在使用它，那么您可以传递一个 <code>-y</code> 开关来抑制文件列表和确认对话框：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip uninstall certifi -y
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip uninstall certifi -y
</span></span></code></pre></div><p>这里卸载 <code>urllib3</code> 。使用 <code>-y</code> 开关，您可以取消询问您是否要卸载此包的确认对话框。</p>
<p>在一次调用中，您可以指定要卸载的所有包：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip uninstall -y charset-normalizer idna requests
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip uninstall -y charset-normalizer idna requests
</span></span></code></pre></div><p>您可以将多个包传递给 <code>pip uninstall</code> 命令。如果您没有添加任何额外的开关，那么您需要确认卸载每个包。通过 <code>-y</code> 开关，您可以在没有任何确认对话框的情况下将它们全部卸载。</p>
<p>您还可以通过提供 <code>-r &lt;requirements file&gt;</code> 选项来卸载需求文件中列出的所有包。此命令将提示对每个包的确认请求，但您可以使用 <code>-y</code> 开关抑制它：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> C:<span class="se">\&gt;</span> python -m pip uninstall -r requirements.txt -y
</span></span></code></pre></div><p>Linux + macOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>venv<span class="o">)</span> $ python3 -m pip uninstall -r requirements.txt -y
</span></span></code></pre></div><p>请记住始终检查要卸载的软件包的依赖项。您可能想卸载所有依赖项，但卸载其他人使用的包会破坏您的工作环境。因此，您的项目可能无法再正常工作。</p>
<p>如果您在虚拟环境中工作，那么创建一个新的虚拟环境可能会更省力。然后你可以安装你需要的包而不是尝试卸载你不需要的包。但是，当您需要从系统 Python 安装中卸载包时， <code>pip uninstall</code> 会非常有用。如果您不小心在系统范围内安装了软件包，使用 <code>pip uninstall</code> 是整理系统的好方法。</p>
<h2 id="探索-pip-的替代品">探索 pip 的替代品</h2>
<p>Python 社区提供了出色的工具和库，供您在 <code>pip</code> 之外使用。这些包括尝试简化和改进包管理的 <code>pip</code> 的替代方案。</p>
<p>以下是一些可用于 Python 的其他包管理工具：</p>
<table>
<thead>
<tr>
<th>Tool</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://conda.io/en/latest/">Conda</a></td>
<td>Conda 是许多语言（包括 Python）的包、依赖项和环境管理器。它来自 Anaconda，Anaconda 最初是 Python 的数据科学包。因此，它被广泛用于数据科学和机器学习应用程序。 Conda 运行自己的索引来托管兼容包。</td>
</tr>
<tr>
<td><a href="https://python-poetry.org/">Poetry</a></td>
<td>如果您来自 JavaScript 和 npm，Poetry 对您来说会非常熟悉。 Poetry 超越了包管理，帮助您为您的应用程序和库构建分发并将它们部署到 PyPI。</td>
</tr>
<tr>
<td><a href="https://github.com/pypa/pipenv">Pipenv</a></td>
<td>Pipenv 是另一个包管理工具，它将虚拟环境和包管理合并到一个工具中。 <a href="https://realpython.com/pipenv-guide/">Pipenv：新 Python 打包工具指南</a>是开始学习 Pipenv 及其包管理方法的好地方。</td>
</tr>
</tbody>
</table>
<p>只有 <code>pip</code> 捆绑在标准 Python 安装中。如果您想使用上面列出的任何替代方案，则必须按照其文档中的安装指南进行操作。有这么多选项，您一定会找到适合您的编程之旅的工具！</p>
<h2 id="结论">结论</h2>
<p>许多 Python 项目使用 <code>pip</code> 包管理器来管理它们的依赖项。它包含在 Python 安装程序中，是 Python 中依赖管理的重要工具。</p>
<p><strong>在本教程中，您学习了如何：</strong></p>
<ul>
<li>在您的工作环境中设置并运行 <code>pip</code></li>
<li>修复与使用 <code>pip</code> 相关的常见错误</li>
<li>使用 <code>pip</code> 安装和卸载包</li>
<li>定义项目和应用程序的要求</li>
<li>在需求文件中固定依赖项</li>
</ul>
<p>此外，您还了解了使依赖项保持最新的重要性以及可以帮助您管理这些依赖项的 <code>pip</code> 的替代方法。</p>
<p>通过仔细查看 <code>pip</code> ，您已经探索了 Python 开发工作流中的一个基本工具。使用 <code>pip</code> ，您可以安装和管理您在 <a href="https://pypi.org/">PyPI</a> 上找到的任何其他包。您可以使用来自其他开发人员的外部包作为需求，并专注于使您的项目独一无二的代码。</p>
<p>原文链接：<a href="https://realpython.com/what-is-pip">https://realpython.com/what-is-pip</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-21｜Python之禅、产品经理被优化、端午节送节</title>
      <link>https://blog.chensoul.com/posts/2023/05/31/weekly_review_21/</link>
      <pubDate>Wed, 31 May 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/31/weekly_review_21/</guid>
      <description>前言 公司价值观 本篇是对 2023-05-22 到 2023-05-28 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 周一，休产假的产品经理回来上班，得知她</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-21-00.jpg" alt="weekly-review-21-00"  />
</p>
<p>
  <center><i>公司价值观</i></center>
</p>
<p>本篇是对 <code>2023-05-22</code> 到 <code>2023-05-28</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>周一，休产假的产品经理回来上班，得知她被优化之后，内心有些不舍和伤感。中午，组长请大家一起吃了饭。晚上，产品经理交割完办公用户之后，就没来上班了。自此，过完年后，公司至少有三位女同事修完产假之后就离职了，有的是主动，更多的应该是被动。虽然有N+1赔偿，但是，这个社会对女性还是不够公平。</p>
<p>还有3个月就要到端午节，老婆买了粽叶包粽子，我也动手包了一部分。虽然包的不好看，但心里还是很满足的。自己包的粽子送节，显然更有意义。结婚之后的第一个端午节，周末开车去给长辈送了端午节。看着长辈们的头发日渐斑白，不禁感叹岁月无情。趁着年轻的时候，要对身边的亲人好一些。不要等到来不及了才知道后悔。</p>
<p>这周在 docker 里部署了 Plausible ，使用过程中发现 Plausible 架构过于复杂，使用了 postgres 和 clickhouse 数据库，docker-compose 启动了4个容器，所以最后还是放弃了使用 Plausible。umami 的 postgres 数据库只包括几张表，操作起来比较容易，比如：时不时地，我会把来自 localhost 的访问记录删除掉，这样统计数据更加真实准确。</p>
<h2 id="python之禅">Python之禅</h2>
<p>这是最近的一个 PyTricks：在 python REPL 里面输入 <code>import this</code> 会输出 <code>The Zen of Python, by Tim Peters</code>：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-21-03.png" alt="weekly-review-21-03"  />
</p>
<p>英文：</p>
<blockquote>
<p>The Zen of Python, by Tim Peters</p>
<p>Beautiful is better than ugly.</p>
<p>Explicit is better than implicit.</p>
<p>Simple is better than complex.</p>
<p>Complex is better than complicated.</p>
<p>Flat is better than nested.</p>
<p>Sparse is better than dense.</p>
<p>Readability counts.</p>
<p>Special cases aren&rsquo;t special enough to break the rules.</p>
<p>Although practicality beats purity.</p>
<p>Errors should never pass silently.</p>
<p>Unless explicitly silenced.</p>
<p>In the face of ambiguity, refuse the temptation to guess.</p>
<p>There should be one&ndash; and preferably only one &ndash;obvious way to do it.</p>
<p>Although that way may not be obvious at first unless you&rsquo;re Dutch.</p>
<p>Now is better than never.</p>
<p>Although never is often better than <em>right</em> now.</p>
<p>If the implementation is hard to explain, it&rsquo;s a bad idea.</p>
<p>If the implementation is easy to explain, it may be a good idea.</p>
<p>Namespaces are one honking great idea &ndash; let&rsquo;s do more of those!</p>
</blockquote>
<p>中文：</p>
<blockquote>
<p>Python之禅，作者为Tim Peters</p>
<p>美丽胜于丑陋。</p>
<p>明确胜于含蓄。</p>
<p>简单胜于复杂。</p>
<p>复杂胜于繁琐。</p>
<p>扁平胜于嵌套。</p>
<p>宽松胜于紧凑。</p>
<p>可读性很重要。</p>
<p>特例并不足以打破规则。</p>
<p>虽然实用性优先于纯粹性。</p>
<p>错误绝不能悄悄地通过。</p>
<p>除非明确地沉默。</p>
<p>面对模棱两可，拒绝猜测。</p>
<p>应该有一种&ndash; 最好只有一种 &ndash;显而易见的方法来做到这一点。</p>
<p>虽然这种方法可能一开始并不明显，除非你是荷兰人。</p>
<p>现在比永远好。</p>
<p>虽然永远不如 <em>现在就做</em> 好。</p>
<p>如果实现很难解释，那这是个坏主意。</p>
<p>如果实现容易解释，那可能是个好主意。</p>
<p>名称空间是一个非常好的想法 &ndash; 让我们做更多的这样的事情！</p>
</blockquote>
<p>Python之禅是一组编写Python语言程序的指导原则，由著名Python开发者Tim Peters撰写而成，这些格言反映了Python社区的哲学。</p>
<p>第一原则“美丽胜于丑陋”强调编写美学上令人愉悦且易于阅读的代码的重要性，包括使用适当的缩进、命名规范和格式化。</p>
<p>第二原则“明确胜于含蓄”强调在代码中要清晰明确，避免捷径并尽可能具体地定义代码。</p>
<p>第三原则“简单胜于复杂”强调编写易于理解和维护的代码的重要性，包括避免不必要的复杂性并尽可能使用简单的解决方案。</p>
<p>第四原则“复杂胜于繁琐”强调在必要时使用复杂的解决方案，但避免过度复杂。</p>
<p>第五原则“扁平胜于嵌套”强调保持代码简单，避免深度嵌套结构。</p>
<p>第六原则“宽松胜于紧凑”强调使用空格和格式化使代码更易读。</p>
<p>第七原则“可读性很重要”强调编写易于阅读和理解的代码的重要性。</p>
<p>第八原则“特例并不足以打破规则”强调即使在可能会偏离规则的情况下，也要遵循最佳实践和已有约定。</p>
<p>第九原则“虽然实用性优先于纯粹性”强调平衡实用考虑与对优雅和纯粹代码的渴望。</p>
<p>第十原则“错误绝不能悄悄地通过”强调捕捉和处理代码中的错误，而不是忽略它们。</p>
<p>第十一原则“除非明确地沉默”强调在适当情况下允许有意地消除错误信息。</p>
<p>第十二原则“面对模棱两可，拒绝猜测”强调要在代码中清晰明确，即使在存在歧义或不确定性的情况下也要如此。</p>
<p>第十三原则“应该有一种&ndash; 最好只有一种 &ndash;显而易见的方法来做到这一点”强调遵循已有的约定和规范，避免不必要的复杂或曲折的解决方案。</p>
<p>第十四原则“虽然这种方法可能一开始并不明显，除非你是荷兰人”是对Python的创建者Guido van Rossum是荷兰人这一事实的玩味性致敬。</p>
<p>第十五原则“现在比永远好”强调采取行动并推进你的代码，而不是拖延或拖沓。</p>
<p>第十六原则“虽然永远不如 <em>现在就做</em> 好”强调要花时间仔细考虑你的代码，避免匆忙解决可能不是最优解的问题。</p>
<p>第十七原则“如果实现很难解释，那这是个坏主意”强调编写易于理解和解释给他人的代码的重要性。</p>
<p>第十八原则“如果实现容易解释，那可能是个好主意”强调编写简单明了、易于解释的代码的重要性。</p>
<p>第十九原则“名称空间是一个非常好的想法 &ndash; 让我们做更多的这样的事情！”强调使用名称空间以清晰易懂的方式组织和结构化你的代码。名称空间有助于避免命名冲突，并使查找和重用代码更容易。</p>
<h2 id="理财">理财</h2>
<p>这周总计支出 1939 元，明细如下：</p>
<ul>
<li>5月28日：1064元，加油充值1000元</li>
<li>5月27日：642元，端午节送节买酒540元</li>
<li>5月26日：173元</li>
<li>5月25日：17元</li>
<li>5月24日：7元</li>
<li>5月23日：20元</li>
<li>5月22日：16元</li>
</ul>
<h2 id="健身">健身</h2>
<blockquote>
<p>我跑过了一些地方，希望随着时间推移，地图点亮的地方越来越多。2 年里我跑过 2个省份 2个城市。更多跑步数据在<a href="https://run.chensoul.com/">跑步</a>主页。</p>
</blockquote>
<p>本周跑步 39 公里，最长跑步距离为 6 公里。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-21-05.png" alt="weekly-review-21-05"  />
</p>
<p>明细数据如下：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-21-06.png" alt="weekly-review-21-06"  />
</p>
<p>5月份即将结束，目前这个月跑了 24天，累计 178 公里，比 4月的125公里多了 53 公里。再跑个12公里，这个月跑步里程就可以达到190公里了，给自己加油！最长连续跑步时间为 7 天，每次都是到了周末就中断了，有点遗憾。回过头来想想，跑步是一个长期的事情，比起跑的远，更重要的是跑的久。争取每天都跑，不管跑几公里，只要坚持下去就是成功。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-21-04.png" alt="weekly-review-21-04"  />
</p>
<h2 id="工作">工作</h2>
<p>最近在学习的内容清单：</p>
<ul>
<li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/tree/dev">Effective Java（第 3 版）</a></li>
<li><a href="https://java-design-patterns.com/zh/">Java Design Patterns (中文)</a></li>
<li><a href="https://realpython.com/">Real Python</a></li>
</ul>
<p>本周完成四篇博客：</p>
<ul>
<li><a href="/posts/2023/05/26/always-override-tostring/">《Effective Java 3》笔记12：当覆盖 equals 方法时，总要覆盖 hashCode 方法</a></li>
<li><a href="/posts/2023/05/26/override-clone-judiciously/">《Effective Java 3》笔记13：明智地覆盖 clone 方法</a></li>
<li><a href="/posts/2023/05/26/consider-implementing-comparable/">《Effective Java 3》笔记14：考虑实现 Comparable 接口</a></li>
<li><a href="/posts/2023/05/26/java-design-patterns-active-object/">Java设计模式：Active Object</a></li>
</ul>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-21-07.png" alt="weekly-review-21-07"  />
</p>
<p>至此，《Effective Java 3》第三章学习完了。第三章介绍了Java中对象的创建和销毁，其中第三章讲述了所有对象通用的方法，主要内容如下：</p>
<ol>
<li>equals方法：用于比较两个对象是否相等，需要遵循一些通用约定，包括自反性、对称性、传递性、一致性和非空性等。</li>
<li>hashCode方法：用于返回对象的哈希码，需要与equals方法一起实现，保证相等的对象具有相等的哈希码。</li>
<li>toString方法：用于返回对象的字符串表示形式，方便调试和日志记录等。</li>
<li>clone方法：用于复制对象，需要实现Cloneable接口，并覆盖Object类中的clone方法。</li>
<li>finalize方法：用于在对象被垃圾回收前执行一些清理操作，但是该方法的使用非常危险，应该尽量避免使用。</li>
</ol>
<p>本章重点介绍了所有对象通用的方法，这些方法在Java中非常重要，需要程序员掌握。equals和hashCode方法是一对重要的方法，需要同时实现，保证对象的相等和哈希码的正确性。toString方法可以方便地输出对象的信息，方便调试和日志记录等。clone方法可以用于复制对象，但需要注意实现Cloneable接口，并覆盖Object类中的clone方法。最后，finalize方法虽然可以用于对象清理，但是使用非常危险，应该尽量避免使用。</p>
<h2 id="本周分享">本周分享</h2>
<p>大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道或者我的 <a href="https://memos.chensoul.com/">memos</a> 中。我写了一个 python 脚本从 memos读取最近一周的 memos 记录。</p>
<ul>
<li>📌<code>2023-05-27</code> 365资讯简报，每天精选15条热点新闻简报1条微语，每天一分钟，知晓天下事！  2023年5月26日 星期五 农历四月初八  1、工信部等十四部门：部署推进新一轮电信基础设施共建共享工作。  2、两高两部：对在校园等场所对未成年人实施猥亵等犯罪的，加重处罚。  3、国家疾控局：4月全国报告法定传染病超210万例。  4、集体婚礼走红，民政部推行婚俗改革，高价彩礼得到有效遏制。  5、广东出台办法：失信联合惩戒对象不得报名参加事业单位招聘。  6、北京：新冠连续4周列传染病榜首，上周报告发病数是4月底的近4倍。  7、天津：在津无房家庭首次公积金贷款还清后，仍可按首套房贷款。  8、上海部分社区开打mRNA新冠疫苗，可通过“健康云”预约。  9、17级超强台风&quot;玛娃&quot;已成今年以来全球风王，下周将影响我国南方。  10、长城汽车公开举报比亚迪：两款车型污染物排放不达标，比亚迪回应：检测报告无效，反对任何形式不正当竞争。  11、微信电脑版新增锁定功能，只能通过手机端解锁。  12、韩自研运载火箭“世界”号载星发射成功。  13、造假数量超2亿件！最长可追溯40年前！本田合资零部件厂商承认造假。  14、普京：俄罗斯正减少不友好国家货币在贸易结算中的份额。  15、美情报披露：克宫遭无人机袭击幕后黑手为乌克兰。  【微语】真正的贫穷，不是金钱上的匮乏，而是认知上的贫瘠。  新闻来源：<a href="https://www.163.com/dy/article/I5L6PQL30534QBVQ.html?spss=dy_author">https://www.163.com/dy/article/I5L6PQL30534QBVQ.html?spss=dy_author</a>  <code>#每日早报</code> <code>#memos</code></li>
<li>📌<code>2023-05-26</code> 365资讯简报，每天精选15条热点新闻简报1条微语，每天一分钟，知晓天下事！  2023年5月25日 星期四 农历四月初七  1、教育部：2023年为中西部乡镇定向免费培养本科医学生6150人。  2、中国互联网协会：警惕AI换脸新骗局，远程转账务必多重验证。  3、交通运输部在南沙群岛火艾礁、牛轭礁和南薰礁附近海域布设3座灯浮标。  4、数据显示：今年以来全国已有超40城调整首套房贷利率下限至4%以下。  5、财政部：4月份全国共销售彩票503.26亿元，同比增长62.0%。  6、吉林省印发公务接待新办法：不得安排群众迎送，公务接待工作餐每人不超120元。  7、香港：调整签证及进入许可申请流程，外佣及学生等须申报刑事记录。  8、广东海珠：举报电动车进出租屋充电等，最高奖励1万元。  9、韩国三大运营商夸大5G网速被罚336亿韩元：号称20G实际800M。  10、51岁马斯克公开回应：已确定特斯拉接班人，若我出现意外，可以确保公司继续运营下去。  11、微软发布重磅更新：Windows系统全面接入AI助手，ChatGPT内置必应搜索最新答案。  12、岸田文雄称日本正考虑设立北约联络处但不会加入北约，中方回应：不欢迎军事集团。  13、俄罗斯：俄中之间70％的跨境结算已用本币完成。  14、英国首相苏纳克拒绝停火呼吁，称乌克兰应该继续战斗。  15、俄媒：乌克兰最高将领在俄军攻击中受重伤，可能将无法继续指挥。  【微语】放弃不难，但坚持一定很酷。撑住，才有后来的一切。  新闻来源：<a href="https://www.163.com/dy/article/I5IJEHQK0534QBVQ.html?spss=dy_author">https://www.163.com/dy/article/I5IJEHQK0534QBVQ.html?spss=dy_author</a>  <code>#每日早报</code> <code>#memos</code></li>
<li>📌<code>2023-05-25</code> 365资讯简报，每天精选15条热点新闻简报1条微语，每天一分钟，知晓天下事！  2023年5月25日 星期四 农历四月初七  1、教育部：2023年为中西部乡镇定向免费培养本科医学生6150人。  2、中国互联网协会：警惕AI换脸新骗局，远程转账务必多重验证。  3、交通运输部在南沙群岛火艾礁、牛轭礁和南薰礁附近海域布设3座灯浮标。  4、数据显示：今年以来全国已有超40城调整首套房贷利率下限至4%以下。  5、财政部：4月份全国共销售彩票503.26亿元，同比增长62.0%。  6、吉林省印发公务接待新办法：不得安排群众迎送，公务接待工作餐每人不超120元。  7、香港：调整签证及进入许可申请流程，外佣及学生等须申报刑事记录。  8、广东海珠：举报电动车进出租屋充电等，最高奖励1万元。  9、韩国三大运营商夸大5G网速被罚336亿韩元：号称20G实际800M。  10、51岁马斯克公开回应：已确定特斯拉接班人，若我出现意外，可以确保公司继续运营下去。  11、微软发布重磅更新：Windows系统全面接入AI助手，ChatGPT内置必应搜索最新答案。  12、岸田文雄称日本正考虑设立北约联络处但不会加入北约，中方回应：不欢迎军事集团。  13、俄罗斯：俄中之间70％的跨境结算已用本币完成。  14、英国首相苏纳克拒绝停火呼吁，称乌克兰应该继续战斗。  15、俄媒：乌克兰最高将领在俄军攻击中受重伤，可能将无法继续指挥。  【微语】放弃不难，但坚持一定很酷。撑住，才有后来的一切。  新闻来源：<a href="https://www.163.com/dy/article/I5IJEHQK0534QBVQ.html?spss=dy_author">https://www.163.com/dy/article/I5IJEHQK0534QBVQ.html?spss=dy_author</a>  <code>#每日早报</code> <code>#memos</code></li>
<li>📌<code>2023-05-25</code>  前后端均基于 vercel 的每日早报项目 <a href="https://icodeq.com/2022/5fe2010403bb/">https://icodeq.com/2022/5fe2010403bb/</a>  <code>#memos</code></li>
<li>📌<code>2023-05-24</code> GitHub - resumejob/awesome-resume: Resume，Resume Templates，程序员简历例句，简历模版<code>#memos</code> <a href="https://github.com/resumejob/awesome-resume">https://github.com/resumejob/awesome-resume</a></li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-20｜自动生成每日早报、周末团建</title>
      <link>https://blog.chensoul.com/posts/2023/05/25/weekly_review_20/</link>
      <pubDate>Thu, 25 May 2023 17:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/25/weekly_review_20/</guid>
      <description>前言 乐农湖畔生态园 本篇是对 2023-05-15 到 2023-05-21 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 不知不觉，这已经是第20篇周报了。</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-20-00.jpeg" alt="weekly-review-20-00"  />
</p>
<center><i>乐农湖畔生态园</i></center>
<br/>
<p>本篇是对 <code>2023-05-15</code> 到 <code>2023-05-21</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>不知不觉，这已经是第20篇周报了。这周依旧是健身、理财、学习和写博客。</p>
<h2 id="自动生成每日早报">自动生成每日早报</h2>
<p>最近在朋友圈看到这样一个早报，就在想能否通过代码自动抓取新闻并生成这样一个早报图片？</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-20-04.jpeg" alt="weekly-review-20-04" style="width:50%;" />
<p>于是，在网上找到一篇文章：<a href="https://icodeq.com/2022/5fe2010403bb/">前后端均基于 vercel 的每日早报项目</a></p>
<p>参考源代码，做了一些修改，代码见：<a href="https://github.com/chensoul/chensoul/blob/main/fetch_news.py">fetch_news.py</a>。修改后的逻辑是将抓取的新闻发送到 memos，例如：<a href="https://memos.chensoul.com/m/349">https://memos.chensoul.com/m/349</a> 。可以在 github action 设置每天早上7点自动发送到 memos，然后再通过 n8n 同步到 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-20-01.png" alt="weekly-review-20-01" style="width: 50%;" />
<p>在memos中导出的图片如下：</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-20-05.png" alt="weekly-review-20-05" style="width:50%;" />
<p>如果能够通过 python 自动生成图片，那就更好了。记录一下，待以后实现。</p>
<h2 id="团建">团建</h2>
<p>公司团建选择在周六，而且还是520这一天，真是会挑日子。很多人请假，最后只有13人参加团建，其中有8人是我们开发组的🤣。挑两张照片发到这里～</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-20-03.jpeg" alt="weekly-review-20-03"  />
</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-20-02.jpeg" alt="weekly-review-20-02"  />
</p>
<h2 id="理财">理财</h2>
<p>这周总计支出 1861 元，明细如下：</p>
<ul>
<li>5月15日：1027元，武功山旅游，加油327</li>
<li>5月16日：42元</li>
<li>5月17日：12元</li>
<li>5月18日：16元</li>
<li>5月19日：25元</li>
<li>5月20日：562元，看望六舅</li>
<li>5月21日：177元</li>
</ul>
<h2 id="健身">健身</h2>
<p>本周跑步 36 公里，最长跑步距离为 10 公里。明细数据如下：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-20-08.png" alt="weekly-review-20-08"  />
</p>
<p>我跑过了一些地方，希望随着时间推移，地图点亮的地方越来越多。2 年里我跑过 2个省份 2个城市。更多跑步数据在<a href="https://run.chensoul.com/">跑步</a>主页。</p>
<h2 id="工作">工作</h2>
<h4 id="博客">博客</h4>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-20-07.png" alt="weekly-review-20-07"  />
</p>
<p>本周完成五篇博客：</p>
<ul>
<li>
<p><a href="/posts/2023/05/22/java-design-patterns-abstract-document/">Java设计模式：Abstract Document</a></p>
</li>
<li>
<p><a href="/posts/2023/05/22/java-design-patterns-abstract-factory/">Java设计模式：Abstract Factory</a></p>
</li>
<li>
<p><a href="/posts/2023/05/23/always-override-hashcode-when-you-override-equals/">《Effective Java 3》笔记11：当覆盖 equals 方法时，总要覆盖 hashCode 方法</a></p>
</li>
<li>
<p><a href="/posts/2023/05/22/docker-continuous-integration/">[译]Build Robust Continuous Integration With Docker and Friends</a></p>
</li>
<li>
<p><a href="/posts/2023/05/23/python-comment-and-variable/">Python学习1：注释、变量和常量</a></p>
</li>
</ul>
<h2 id="本周分享">本周分享</h2>
<p>大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道或者我的 <a href="https://memos.chensoul.com/">memos</a> 中。我写了一个 python 脚本从 memos读取最近一周的 memos 记录。</p>
<ul>
<li><strong>2023-05-19</strong> 陈皓（左耳朵耗子）前年做过一次直播访谈，谈到了技术、行业、创业的各个方面。本文是访谈内容的文字整理，以此纪念他。  <a href="https://mp.weixin.qq.com/s/bOnW8gDJ-dXp4KbAjhDw9A">https://mp.weixin.qq.com/s/bOnW8gDJ-dXp4KbAjhDw9A</a>  <code>#memos</code> <code>#skill</code> <code>#tool</code></li>
<li><strong>2023-05-17</strong> 用 Material for MkDocs 来生成专业的技术文档 <a href="https://vra.github.io/2023/05/17/mkdocs-material-tutorial/">https://vra.github.io/2023/05/17/mkdocs-material-tutorial/</a>  <code>#memos</code> <code>#tool</code></li>
<li><strong>2023-05-17</strong> 基于  Popsy 创建自己的个人主页 <a href="https://popsy.co/">https://popsy.co/</a> <code>#memos</code> <code>#tool</code></li>
<li><strong>2023-05-17</strong> Hellonext是一种反馈管理平台，它可以帮助组织、企业和开发团队更好地管理用户反馈和需求。它提供了一个用户友好的界面，使用户可以轻松地提交反馈和建议，而管理人员可以使用该平台来跟踪和组织这些反馈，并确定哪些反馈应该优先考虑实现。Hellonext还提供了数据分析和报告功能，帮助管理人员了解用户反馈的趋势和优先级，以便更好地满足用户需求。 <a href="https://hellonext.co/">https://hellonext.co/</a> <code>#memos</code> <code>#tool</code></li>
<li><strong>2023-05-17</strong> Dify 是一个简单且能力丰富的自然语言编程工具。你可以用它搭建商用级应用，个人助理。如果你想自己开发应用，Dify 也能为你省下接入 OpenAI 的后端工作，但使用我们逐步提供高的可视化运营能力，你可以持续的改进和训练你的 GPT 模型。 <a href="https://docs.dify.ai/v/zh-hans/getting-started/intro-to-dify">https://docs.dify.ai/v/zh-hans/getting-started/intro-to-dify</a> <code>#tool</code> <code>#memos</code></li>
<li><strong>2023-05-17</strong> 用200行python代码实现dns服务器的教程 <a href="https://implement-dns.wizardzines.com/">https://implement-dns.wizardzines.com/</a>  <code>#memos</code> <code>#tool</code></li>
<li><strong>2023-05-17</strong> postman 推出了postbot，使用人工智能帮助您调试和理解 API、更快地编写测试  <a href="https://blog.postman.com/introducing-postbot-postmans-new-ai-assistant/">https://blog.postman.com/introducing-postbot-postmans-new-ai-assistant/</a>  <code>#tool</code> <code>#memos</code></li>
<li><strong>2023-05-17</strong> <a href="https://imgg.gg/">https://imgg.gg/</a> 是一个可以将任意 sms 内容转换成为图片的工具，不用担心在 APP 上截图会泄漏隐私。生成的图片的样式很像 <a href="https://poet.so/">https://poet.so/</a> ，不过Poet.so 只能生成推特、linkedin、shopify 的分享图。 <code>#tool</code> <code>#memos</code></li>
<li><strong>2023-05-17</strong> 都知道 ffmpeg 是媒体文件处理的瑞士军刀，但命令行的操作对大部分人来说确实会面临迷茫和繁琐。FFmpeg.guide 就是一个图形化生成 ffmpeg 命令的工具。  网站地址：<a href="https://ffmpeg.guide/">https://ffmpeg.guide/</a> <code>#tool</code> <code>#memos</code></li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Python学习1：注释、变量和常量</title>
      <link>https://blog.chensoul.com/posts/2023/05/23/python-comment-and-variable/</link>
      <pubDate>Tue, 23 May 2023 18:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/23/python-comment-and-variable/</guid>
      <description>Python 注释、变量和常量是编写 Python 代码时非常重要的概念，下面分别介绍它们的基本用法和语法。 Hello World 创建一个 00_helloworld.py 文件，打印 hello world： print(&amp;#34</description>
      <content:encoded><![CDATA[<p>Python 注释、变量和常量是编写 Python 代码时非常重要的概念，下面分别介绍它们的基本用法和语法。</p>
<h2 id="hello-world">Hello World</h2>
<p>创建一个 00_helloworld.py 文件，打印 hello world：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Hello，World!&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>执行该文件，会输出结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python 00_helloworld.py
</span></span><span class="line"><span class="cl">Hello，World!
</span></span></code></pre></div><p>一般在python文件的开头第一行，我们都会看到下面的代码行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># python2</span>
</span></span><span class="line"><span class="cl"><span class="c1">#!/usr/bin/env python</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 或者</span>
</span></span><span class="line"><span class="cl"><span class="c1">#!/usr/bin/python</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># python3</span>
</span></span><span class="line"><span class="cl"><span class="c1">#!/usr/bin/env python3</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 或者</span>
</span></span><span class="line"><span class="cl"><span class="c1">#!/usr/bin/python3</span>
</span></span></code></pre></div><p>这行代码用来指定本脚本用什么解释器来执行。</p>
<p><code>#!/usr/bin/python</code> 是告诉操作系统执行这个脚本的时候，调用 /usr/bin 下的 python 解释器。</p>
<p><code>#!/usr/bin/env python</code> 这种用法是为了防止操作系统用户没有将 python 装在默认的 /usr/bin 路径里。当系统看到这一行的时候，首先会到 env 设置里查找 python 的安装路径，再调用对应路径下的解释器程序完成操作。为了增强代码的可移植性，<strong>推荐这种写法</strong>。</p>
<p>在 00_helloworld.py 添加这行代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env python</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Hello，World!&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>然后，修改该文件为可执行属性：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">chmod +x 00_helloworld.py
</span></span></code></pre></div><p>就可以这样执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">. 00_helloworld.py
</span></span></code></pre></div><h2 id="编码格式">编码格式</h2>
<p>Python3 默认的编码格式是UTF-8（Unicode Transformation Format - 8 bit）。这是一种通用的字符编码，支持几乎所有的字符集，包括 ASCII、Latin、中文、日文、韩文等。</p>
<p>在 Python 3.x 中，所有的字符串都是以 Unicode 编码存储的。当你在 Python 中创建一个字符串时，你可以使用任何 Unicode 字符，而不必担心编码问题。</p>
<p>当你打开一个文本文件时，Python 会自动尝试使用 UTF-8 编码来解析文件内容。如果文件使用其他编码格式，你需要使用相应的编码格式来打开文件，或者在读取文件内容后将其解码为 Unicode。</p>
<p>在 Python 中，你可以使用编码声明（coding declaration）来指定文件的编码格式。编码声明是一个特殊的注释，出现在 Python 文件的第一行或第二行（如果文件的第一行是 shebang，则编码声明必须出现在第二行），格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># -*- coding: encoding -*-</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 或者</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># coding=utf-8</span>
</span></span></code></pre></div><p>其中，<code>encoding</code> 是文件的编码格式，可以是 UTF-8、ISO-8859-1 或其他编码格式的名称。编码声明告诉 Python 解释器应该使用指定的编码格式来解析该文件中的文本内容。如果没有编码声明，Python3 默认使用 UTF-8 编码来解析文件内容。</p>
<p>Python 2.x 的默认编码格式是 ASCII，这是一种 7-bit 的字符编码，只能表示最基本的 ASCII 字符集，无法支持多语言和 Unicode 字符。</p>
<p>在 Python 2.x 中，如果你需要使用 Unicode 字符，你需要在字符串前面添加一个 <code>u</code> 字符，以表示该字符串是一个 Unicode 字符串。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># -*- coding: utf-8 -*-</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;你好，世界！&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">s</span>
</span></span></code></pre></div><p>在 Python 2.x 中，如果你需要打开一个非 ASCII 编码的文本文件，你需要在打开文件时指定文件的编码格式。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;filename.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;gbk&#39;</span><span class="p">)</span>  <span class="c1"># 读取并解码文件内容</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>在 Python 2.x 中，你可以使用编码声明来指定文件的编码格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># -*- coding: encoding -*-</span>
</span></span></code></pre></div><p>其中，<code>encoding</code> 是文件的编码格式，可以是 UTF-8、GBK、ISO-8859-1 或其他编码格式的名称。编码声明告诉 Python 解释器应该使用指定的编码格式来解析该文件中的文本内容。如果没有编码声明，Python 2.x 默认使用 ASCII 编码来解析文件内容。</p>
<p>在终端输入如下命令，查看编码格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python
</span></span><span class="line"><span class="cl">Python 3.11.3 <span class="o">(</span>main, Apr  <span class="m">7</span> 2023, 20:13:31<span class="o">)</span> <span class="o">[</span>Clang 14.0.0 <span class="o">(</span>clang-1400.0.29.202<span class="o">)]</span> on darwin
</span></span><span class="line"><span class="cl">Type <span class="s2">&#34;help&#34;</span>, <span class="s2">&#34;copyright&#34;</span>, <span class="s2">&#34;credits&#34;</span> or <span class="s2">&#34;license&#34;</span> <span class="k">for</span> more information.
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; import sys
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; sys.getdefaultencoding<span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;utf-8&#39;</span>
</span></span></code></pre></div><h2 id="注释">注释</h2>
<p>在 Python 中，注释用于在代码中添加注释、解释或说明。注释通常用于提高代码的可读性，帮助其他人理解你的代码。</p>
<p>Python 支持两种类型的注释：单行注释和多行注释。</p>
<h3 id="单行注释">单行注释</h3>
<p>在 Python 中，单行注释以井号(<code>#</code>)开头，用于在代码行的末尾或者独立一行中添加注释。任何紧随井号后的文本都将被解释器忽略。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 这是一个单行注释</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Hello, World!&#34;</span><span class="p">)</span>  <span class="c1"># 这也是一个单行注释</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">text</span> <span class="o">=</span> <span class="s2">&#34;# This is not a comment because it&#39;s inside quotes.&#34;</span>
</span></span></code></pre></div><p>在这个例子中，第一行是一个独立的单行注释，第二行则是在代码行的末尾添加的单行注释。这些注释不会影响程序的执行，但是可以帮助其他人理解你的代码。</p>
<h3 id="多行注释">多行注释</h3>
<p>Python中使用以三个单引号或者三个双引号括起来的注释被视为多行注释。多行注释通常用于注释函数、类、模块等。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">这是一个多行注释，
</span></span></span><span class="line"><span class="cl"><span class="s1">它可以用于描述函数、类或模块的功能和使用方法。
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">add_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    这是一个用于计算两个数字之和的函数。
</span></span></span><span class="line"><span class="cl"><span class="s2">    参数：
</span></span></span><span class="line"><span class="cl"><span class="s2">    a -- 第一个数字
</span></span></span><span class="line"><span class="cl"><span class="s2">    b -- 第二个数字
</span></span></span><span class="line"><span class="cl"><span class="s2">    返回值：
</span></span></span><span class="line"><span class="cl"><span class="s2">    两个数字的和
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span></code></pre></div><blockquote>
<p>注意：</p>
<p>Python的多行注释实际上是一个字符串字面值，因此如果不被赋值给任何变量，它们将不会对程序产生任何影响。</p>
</blockquote>
<h2 id="变量">变量</h2>
<p>在 Python 中，变量是用来存储数据的标识符。它们是程序中的一种基本元素，用于操作数据并在程序中引用它们。</p>
<p>Python 中的变量可以存储各种数据类型，包括数字、字符串、列表、元组、字典等。变量的值可以随时更改，因此它们是动态的。</p>
<p>变量的命名规则如下：</p>
<ul>
<li>变量名必须以字母或下划线开头。</li>
<li>变量名可以包含字母、数字和下划线。</li>
<li>变量名区分大小写。</li>
<li>变量名不能与 Python 的关键字相同。</li>
</ul>
<blockquote>
<p>以下是 Python 3.x 版本中的所有关键字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">False  class   finally is      <span class="k">return</span>
</span></span><span class="line"><span class="cl">None   <span class="k">continue</span>    <span class="k">for</span>     lambda  try
</span></span><span class="line"><span class="cl">True   def     from    nonlocal    <span class="k">while</span>
</span></span><span class="line"><span class="cl">and    del     global  not     with
</span></span><span class="line"><span class="cl">as     <span class="k">elif</span>    <span class="k">if</span>      or      yield
</span></span><span class="line"><span class="cl">assert <span class="k">else</span>    import  pass    
</span></span><span class="line"><span class="cl"><span class="nb">break</span>  except  in      raise   
</span></span></code></pre></div><p>在 Python 2.x 中，还有两个额外的关键字 <code>exec</code> 和 <code>print</code>，但它们在 Python 3.x 中已经被移除。</p>
<p>如果你不确定某个标识符是否是关键字，你可以使用 Python 的 <code>keyword</code> 模块来检查：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">keyword</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span><span class="p">)</span>
</span></span></code></pre></div></blockquote>
<h3 id="变量定义和使用">变量定义和使用</h3>
<p>在 Python 中，可以使用赋值语句来创建变量。赋值语句使用等号(<code>=</code>)将变量名和要存储在变量中的值分开。</p>
<p>Python是动态类型的语言，无须声明变量类型，直接对变量赋值即可使用。</p>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 创建一个整型变量 x</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 创建一个字符串变量 name</span>
</span></span><span class="line"><span class="cl"><span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;John&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 创建一个列表变量 my_list</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 引用变量 x 的值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 输出 5</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 引用变量 name 的值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;My name is&#34;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>  <span class="c1"># 输出 My name is John</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 引用变量 my_list 的值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span>  <span class="c1"># 输出 [1, 2, 3]</span>
</span></span></code></pre></div><p>在 Python 中，变量是动态类型的。这意味着变量的类型可以随时更改。例如，一个变量可以在一个时刻存储一个整数，而在下一个时刻存储一个字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 动态类型示例</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># x 是一个整数</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 输出 5</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="s2">&#34;Hello, world!&#34;</span>  <span class="c1"># x 是一个字符串</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 输出 Hello, world!</span>
</span></span></code></pre></div><blockquote>
<p>在 Python 中，变量是对象的引用。当一个变量被赋值为一个对象时，它实际上是将这个对象的引用存储到变量中。Python 的内存管理器会自动跟踪和回收不再使用的对象。</p>
</blockquote>
<h3 id="一行定义多个变量">一行定义多个变量</h3>
<p>在 Python 中可以一行定义多个变量。可以使用逗号将多个变量名分开，并使用等号将它们与相应的值分开。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 在 Python 中可以一行定义多个变量。可以使用逗号将多个变量名分开，并使用等号将它们与相应的值分开。</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&#34;John&#34;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出变量值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 输出 5</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># 输出 John</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># 输出 [1, 2, 3]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 一行定义多个变量，使用相同的值</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出变量值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># 输出 0</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># 输出 0</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># 输出 0</span>
</span></span></code></pre></div><h3 id="变量的作用域">变量的作用域</h3>
<p>在 Python 中，变量的作用域是指变量在程序中可见和可访问的范围。Python 中有四种作用域：</p>
<ul>
<li>局部作用域：变量在函数内部定义，只能在函数内部访问。</li>
<li>嵌套作用域：变量在嵌套函数内部定义，可以在嵌套函数内部和外部函数内部访问。</li>
<li>全局作用域：变量在模块内部定义，可以在模块内的任何函数或类中访问。</li>
<li>内置作用域：变量是 Python 内置的函数和对象，可以在任何地方访问。</li>
</ul>
<p>如果在函数内部访问全局变量，你需要使用 <code>global</code> 关键字来指示变量的作用域。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># 全局变量</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">my_func</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">global</span> <span class="n">x</span>  <span class="c1"># 使用 global 关键字指示变量的作用域</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>   <span class="c1"># 将全局变量 x 的值修改为 20</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 输出 20</span>
</span></span></code></pre></div><h3 id="变量解包">变量解包</h3>
<p>在 Python 中，可以使用变量解包（unpacking）语法将一个序列或元组中的值分配给多个变量。变量解包语法使用等号(<code>=</code>)将变量名与序列或元组中的值分开，并使用逗号将变量名分开。</p>
<p>对元组解包</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 定义一个元组</span>
</span></span><span class="line"><span class="cl"><span class="n">my_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 注意：左侧变量的个数必须和待展开的列表长度相等，否则会报错</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 变量解包，将元组中的值分配给多个变量</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">my_tuple</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出变量值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 输出 1</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># 输出 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># 输出 3</span>
</span></span></code></pre></div><p>可以将变量解包语法与其他 Python 的语言特性结合使用，例如函数返回值和列表推导式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 定义一个函数，返回两个值</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_name_and_age</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s2">&#34;John&#34;</span><span class="p">,</span> <span class="mi">30</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 变量解包，将函数返回的值分配给多个变量</span>
</span></span><span class="line"><span class="cl"><span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="n">get_name_and_age</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出变量值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># 输出 John</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>   <span class="c1"># 输出 30</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用列表推导式创建一个列表，然后进行变量解包</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出变量值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># 输出 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># 输出 4</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># 输出 6</span>
</span></span></code></pre></div><p>变量解包语法可以用于嵌套的序列或元组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 定义一个嵌套元组</span>
</span></span><span class="line"><span class="cl"><span class="n">my_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 变量解包，将元组中的值分配给多个变量</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_tuple</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出变量值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 输出 1</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># 输出 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># 输出 3</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>  <span class="c1"># 输出 4</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 定义一个嵌套列表</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 变量解包，将列表中的值分配给多个变量</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_list</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出变量值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 输出 1</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># 输出 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># 输出 3</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>  <span class="c1"># 输出 4</span>
</span></span></code></pre></div><p>使用变量解包语法进行动态解包。动态解包是指在运行时确定要解包的序列或元组，并将其分配给多个变量。</p>
<p>这通常涉及到使用函数或方法返回的序列或元组，以及不确定序列或元组的长度的情况。</p>
<p>使用一个星号(<code>*</code>)作为变量名称的前缀可以指定一个变量来接收除了已分配变量之外的所有值。这个变量将是一个列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 定义一个元组</span>
</span></span><span class="line"><span class="cl"><span class="n">my_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用动态解包，将元组前两个值分配给变量 x 和 y，后两个值分配给变量 a 和 b，其他值分配给变量 rest</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">my_tuple</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出变量值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>     <span class="c1"># 输出 1</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>     <span class="c1"># 输出 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>  <span class="c1"># 输出 [3, 4]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>     <span class="c1"># 输出 5</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>     <span class="c1"># 输出 6</span>
</span></span></code></pre></div><h3 id="单下划线变量名">单下划线变量名</h3>
<p>在 Python 中，以单个下划线(<code>_</code>)开头的变量名通常表示一个私有变量或占位符变量。</p>
<ol>
<li>
<p>私有变量：在 Python 中，没有真正的私有变量，但是以单个下划线开头的变量名通常被视为私有变量。这意味着这些变量不应该在模块或类的外部使用，因为它们可能会发生变化或不再存在。但是，它们仍然可以在模块或类的内部使用。</p>
</li>
<li>
<p>占位符变量：有时候，在编写代码时，需要使用一个变量来占据一个位置，但是不需要引用变量的值。在这种情况下，可以使用以单个下划线开头的变量名来表示一个占位符变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 忽略展开时的第二个变量</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>  <span class="c1"># 输出 1 2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用占位符变量</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
</span></span></code></pre></div></li>
</ol>
<h3 id="可变和不可变对象">可变和不可变对象</h3>
<p>在 Python 中，有些对象是可变的，有些对象是不可变的。可变对象是可以修改的，而不可变对象是不能修改的。例如，数字、字符串和元组是不可变的，而列表和字典是可变的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 可变对象示例</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">my_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span>  <span class="c1"># 输出 [1, 2, 3, 4]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 不可变对象示例</span>
</span></span><span class="line"><span class="cl"><span class="n">my_string</span> <span class="o">=</span> <span class="s2">&#34;Hello&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">my_string</span> <span class="o">+=</span> <span class="s2">&#34;, world!&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_string</span><span class="p">)</span>  <span class="c1"># 输出 Hello, world!</span>
</span></span></code></pre></div><h2 id="常量">常量</h2>
<p>在 Python 中，常量是指在程序中定义的不可变的值。常量通常用大写字母表示，以便与变量区分开来。Python 中没有内置的常量类型，但是你可以使用以下方式定义常量：</p>
<ol>
<li>使用普通变量表示常量。例如：</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14159265358979323846</span>
</span></span></code></pre></div><p>在程序中使用 <code>PI</code> 来表示圆周率，这个值不会被修改。</p>
<ol start="2">
<li>使用枚举类（Enum）表示常量。枚举类是 Python 中的一种特殊类型，用于定义一组有限的常量。例如：</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Color</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">RED</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">GREEN</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="n">BLUE</span> <span class="o">=</span> <span class="mi">3</span>
</span></span></code></pre></div><p>在程序中使用 <code>Color.RED</code>、<code>Color.GREEN</code> 和 <code>Color.BLUE</code> 来表示三种颜色，这些值不会被修改。</p>
<p>常量是编写可读性好、易于理解和维护的代码的重要组成部分。在编写代码时，应该将常量定义为不可变的值，并尽可能使用常量来表示不变的数据。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译]Build Robust Continuous Integration With Docker and Friends</title>
      <link>https://blog.chensoul.com/posts/2023/05/22/docker-continuous-integration/</link>
      <pubDate>Mon, 22 May 2023 15:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/22/docker-continuous-integration/</guid>
      <description>持续集成 (CI) 已成为软件开发的关键，它允许团队频繁合并代码更改并及早发现错误。 Docker 容器通过提供一致的环境帮助促进持续集成过程，您可以在其中测试和发</description>
      <content:encoded><![CDATA[<p><img loading="lazy" src="https://files.realpython.com/media/UPDATE-Docker-in-Action-Fitter-Happier-More-Productive_Watermarked.479cfb791c17.jpg" alt="Build Robust Continuous Integration With Docker and Friends"  />
</p>
<p>持续集成 (CI) 已成为软件开发的关键，它允许团队频繁合并代码更改并及早发现错误。</p>
<p>Docker 容器通过提供一致的环境帮助促进持续集成过程，您可以在其中测试和发送每次提交的代码。</p>
<p>在本教程中，您将学习如何使用 Docker 为 Flask Web 应用程序创建强大的持续集成管道。</p>
<p>您将完成在本地开发和测试应用程序、将其容器化、使用 Docker Compose 编排容器以及使用 GitHub Actions 定义 CI 管道的步骤。</p>
<p>在本教程结束时，您将能够为您的 Web 应用程序创建一个完全自动化的 CI 管道。</p>
<p><strong>在本教程中，您将</strong>：</p>
<ul>
<li>在 Docker 容器中本地运行 Redis 服务器</li>
<li>用 Docker 编排 Flask 编写的 Python Web 应用程序</li>
<li>构建 Docker 镜像并将它们推送到 Docker Hub 仓库</li>
<li>使用 Docker Compose 编排多容器应用程序</li>
<li>在任何地方复制类似生产的基础设施</li>
<li>使用 GitHub Actions 定义持续集成工作流</li>
</ul>
<p>理想情况下，您应该具有使用 Python 进行 <a href="https://realpython.com/learning-paths/become-python-web-developer/">Web 开发</a>、<a href="https://realpython.com/learning-paths/test-your-python-apps/">测试自动化</a>、将 <a href="https://realpython.com/python-redis/">Redis 与 Python 结合使用</a>以及<a href="https://realpython.com/python-git-github-intro/">使用 Git 和 GitHub 进行源代码版本控制</a>的经验。以前接触过 <a href="https://realpython.com/python-versions-docker/">Docker</a> 会更好，但不是必需的。您还应该拥有一个 Git 客户端和一个 GitHub 帐户，以便跟随并复制本教程的步骤。</p>
<blockquote>
<p>注意：本教程大致基于名为 Docker in Action - Fitter, Happier, More Productive 的旧教程，该教程由 Michael Herman 编写，他于 2015 年 2 月 8 日在 PyTennessee 展示了他的 CI 工作流程。如果你有兴趣，您可以查看展示的相应幻灯片在会议上。</p>
<p>不幸的是，原始教程中描述的许多工具不再受支持或免费提供。在此更新的教程中，您将使用最新的工具和技术，例如 GitHub Actions。</p>
</blockquote>
<p>如果您想跳过在计算机上设置 Docker 和构建示例 Web 应用程序的初始步骤，那么直接跳到定义持续集成管道。无论哪种方式，您都需要下载支持材料，它们与完成的 Flask Web 应用程序和相关资源一起提供，它们将帮助您学习本教程：</p>
<blockquote>
<p>免费下载：单击<a href="https://realpython.com/bonus/docker-continuous-integration-code/">此处</a>下载您的 Flask 应用程序和相关资源，以便您可以使用 Docker 定义持续集成管道。</p>
</blockquote>
<h2 id="项目架构概览">项目架构概览</h2>
<p>在本教程结束时，您将拥有一个 Flask Web 应用程序，用于跟踪持久存储在 Redis 数据存储中的页面视图。</p>
<p>它将是一个由 Docker Compose 编排的多容器应用程序，您将能够在本地和云端构建和测试，为持续集成铺平道路：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/page_tracker_architecture.drawio_2.1c8cf20462ae.png" alt="The Architecture of the Page Tracker Application"  />
</p>
<p>该应用程序由两个 Docker 容器组成。第一个容器将在 Gunicorn 之上运行一个 Flask 应用程序，响应 HTTP 请求并更新页面浏览量。</p>
<p>第二个容器将运行一个 Redis 实例，用于将页面视图数据持久存储在主机上的本地卷中。</p>
<p>Docker 是运行此应用程序所需的全部，您现在将对其进行设置。</p>
<h2 id="在您的计算机上设置-docker">在您的计算机上设置 Docker</h2>
<p>Docker 是一个总称，根据上下文，它对不同的人有不同的含义。例如，当有人提到 docker 时，他们可能指以下之一：</p>
<ul>
<li>Docker, Inc.：平台和相关工具背后的公司</li>
<li>Docker：开源容器平台</li>
<li>Docker CLI： <code>docker</code> 客户端命令行程序</li>
<li><code>dockerd</code> : 管理容器的 Docker 守护进程</li>
</ul>
<p>还有一些与 Docker 平台相关的工具和项目，例如：</p>
<ul>
<li>Docker Compose</li>
<li>Docker Desktop</li>
<li>Docker Engine</li>
<li>Docker Hub</li>
<li>Docker Swarm Mode Docker 集群模式</li>
</ul>
<p>在本教程中，您将使用上面列表中除最后一个之外的所有内容。顺便说一句，不要将遗留的 <a href="https://github.com/docker-archive/classicswarm">Docker Classic Swarm</a> 与 1.12 版以来内置于 Docker 引擎中的 Docker Swarm Mode 混淆，后者是一个外部工具。</p>
<blockquote>
<p>注意：您可能听说过 Docker Machine 和 Docker Toolbox。这些是不再维护的旧工具。</p>
</blockquote>
<p>Docker 解决的主要问题是能够在几乎没有或没有配置的情况下在一致且可重现的环境中的任何地方运行应用程序。它可以将您的应用程序代码、二进制文件和依赖项（例如语言运行时和库）打包到一个工件中。您将在开发期间和持续集成服务器上使用 Docker 在本地计算机上模拟假设的生产环境。</p>
<p>安装 Docker 有两种选择：</p>
<ol>
<li><a href="https://docs.docker.com/engine/">Docker Engine</a></li>
<li><a href="https://docs.docker.com/desktop/">Docker Desktop</a></li>
</ol>
<p>如果您熟悉终端并喜欢额外的控制级别，那么开源 Docker 引擎就是您的最佳选择，它提供核心运行时和用于管理容器的命令行界面。另一方面，如果您更喜欢具有直观图形用户界面的一站式解决方案，那么您应该考虑使用 Docker Desktop。</p>
<blockquote>
<p>注意：开箱即用的桌面应用程序附带 <a href="https://docs.docker.com/compose/">Docker Compose</a>，稍后在<a href="https://realpython.com/docker-continuous-integration/#orchestrate-containers-using-docker-compose">编排容器</a>以进行持续集成时将需要它。</p>
</blockquote>
<p>当您浏览 <a href="https://docs.docker.com/">Docker 官方文档</a>时，您可能会觉得 Docker Desktop 占据了聚光灯下。这是一个非常棒的工具，但您必须记住，Docker Desktop 仍然免费供个人使用。自 2021 年 8 月起，您需要<a href="https://www.docker.com/pricing/">付费订阅</a>才能在商业项目中使用它。</p>
<p>虽然在技术上可以并排安装这两种工具，但您通常应该避免同时使用它们，以尽量减少虚拟网络或端口绑定之间任何潜在干扰的风险。您可以通过停止其中之一并在 Docker Engine 和 Docker Desktop 之间<a href="https://docs.docker.com/desktop/faqs/linuxfaqs/#context">切换上下文</a>来实现。</p>
<blockquote>
<p>注意：Docker Desktop 过去只能在 Windows 和 macOS 上使用，但现在情况发生了变化，您现在也可以在某些 Linux 发行版上安装它，包括 <a href="https://docs.docker.com/desktop/install/ubuntu/">Ubuntu</a>、<a href="https://docs.docker.com/desktop/install/debian/">Debian</a> 和 <a href="https://docs.docker.com/desktop/install/fedora/">Fedora</a>。但是，Linux 版本的 Docker Desktop 运行在<a href="https://docs.docker.com/desktop/faqs/linuxfaqs/#why-does-docker-desktop-for-linux-run-a-vm">虚拟机</a>之上，以模仿在其他操作系统上使用它的用户体验。</p>
</blockquote>
<p>要验证您是否已在系统上成功安装 Docker（作为 Docker Engine 或 Docker Desktop 包装器应用程序），请打开终端并键入以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker --version
</span></span><span class="line"><span class="cl">Docker version 23.0.4, build f480fb1
</span></span></code></pre></div><p>您应该会看到您的 Docker 版本以及内部版本号。如果您使用的是 Linux，那么您可能希望按照<a href="https://docs.docker.com/engine/install/linux-postinstall/">安装后的步骤</a>使用 <code>docker</code> 命令，而无需在其前面加上 <code>sudo</code> 以获得管理权限。</p>
<p>在开始使用 Docker 来帮助进行持续集成之前，您需要创建一个基本的 Web 应用程序。</p>
<h2 id="在-flask-中开发页面视图跟踪器">在 Flask 中开发页面视图跟踪器</h2>
<p>在接下来的几节中，您将使用 <a href="https://realpython.com/tutorials/flask/">Flask</a> 框架实现一个基本的 Web 应用程序。您的应用程序将跟踪页面浏览总数，并在每次请求时向用户显示该数字：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/screenshot-browser.5036973f0aae.png" alt="A web application for tracking page views"  />
</p>
<p>应用程序的当前状态将保存在 <a href="https://redis.io/">Redis</a> 数据存储中，该存储通常用于缓存和其他类型的数据持久化。这样，停止您的网络服务器不会重置观看次数。您可以将 Redis 视为一种数据库。</p>
<p>如果您对从头开始构建此应用程序不感兴趣，请随时通过单击下面的链接下载其完整源代码，然后跳到对您的 Flask Web 应用程序<a href="https://realpython.com/docker-continuous-integration/#dockerize-your-flask-web-application">进行 docker 化</a>：</p>
<p>即使您打算自己编写代码，下载完成的项目并将其用作参考与您的实现进行比较仍然是个好主意，以防您遇到困难。</p>
<blockquote>
<p>免费下载：单击<a href="https://realpython.com/bonus/docker-continuous-integration-code/">此处</a>下载您的 Flask 应用程序和相关资源，以便您可以使用 Docker 定义持续集成管道。</p>
</blockquote>
<p>在开始开发应用程序之前，您需要设置工作环境。</p>
<h3 id="准备环境">准备环境</h3>
<p>与每个 <a href="https://realpython.com/tutorials/projects/">Python 项目</a>一样，您在开始时应该遵循大致相同的步骤，包括创建一个新目录，然后为您的项目创建并激活一个隔离的<a href="https://realpython.com/python-virtual-environments-a-primer/">虚拟环境</a>。您可以直接从您最喜欢的<a href="https://realpython.com/python-ides-code-editors-guide/">代码编辑器</a>（如 <a href="https://realpython.com/python-development-visual-studio-code/">Visual Studio Code</a>）或功能齐全的 IDE（如 <a href="https://realpython.com/pycharm-guide/">PyCharm</a>）执行此操作，或者您可以在终端中键入一些命令：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">PS&gt; mkdir page-tracker
</span></span><span class="line"><span class="cl">PS&gt; <span class="nb">cd</span> page-tracker
</span></span><span class="line"><span class="cl">PS&gt; python -m venv venv --prompt page-tracker
</span></span><span class="line"><span class="cl">PS&gt; venv<span class="se">\S</span>cripts<span class="se">\a</span>ctivate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; python -m pip install --upgrade pip
</span></span></code></pre></div><p>Linux + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ mkdir page-tracker/
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> page-tracker/
</span></span><span class="line"><span class="cl">$ python3 -m venv venv/ --prompt page-tracker
</span></span><span class="line"><span class="cl">$ <span class="nb">source</span> venv/bin/activate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --upgrade pip
</span></span></code></pre></div><p>首先，创建一个名为 <code>page-tracker/</code> 的新目录，然后在其中创建一个名为 <code>venv/</code> 的Python 虚拟环境。为虚拟环境提供描述性提示，使其易于识别。最后，激活新建的虚拟环境后，将 <a href="https://realpython.com/what-is-pip/"><code>pip</code></a> 升级到最新版本，以免以后安装<a href="https://realpython.com/python-modules-packages/">Python包</a>时出现问题。</p>
<blockquote>
<p>注意：在 Windows 上，您可能需要先以管理员身份运行 <a href="https://realpython.com/python-coding-setup-windows/#discovering-the-windows-terminal">Windows Terminal</a> 并在创建虚拟环境之前<a href="https://realpython.com/python-coding-setup-windows/#loosening-your-execution-policy">放宽脚本执行策略</a>。</p>
</blockquote>
<p>在本教程中，您将使用现代方式通过 <a href="https://realpython.com/courses/packaging-with-pyproject-toml/">pyproject.toml</a> 配置文件和 <a href="https://setuptools.pypa.io/en/latest/">setuptools</a> 指定项目的依赖项和元数据<a href="https://peps.python.org/pep-0517/">作为构建后端</a>。此外，您将遵循 <a href="https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/">src 布局</a>，将应用程序的源代码放在单独的 <code>src/</code> 子目录中，以更好地组织项目中的文件。这将使您可以直接打包代码，而无需稍后添加的自动化测试。</p>
<p>继续使用以下命令构建您的 Python 项目占位符：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; mkdir src<span class="se">\p</span>age_tracker
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; ni src<span class="se">\p</span>age_tracker<span class="se">\_</span>_init__.py
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; ni src<span class="se">\p</span>age_tracker<span class="se">\a</span>pp.py
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; ni constraints.txt
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; ni pyproject.toml
</span></span></code></pre></div><p>Linux + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ mkdir -p src/page_tracker
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ touch src/page_tracker/__init__.py
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ touch src/page_tracker/app.py
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ touch constraints.txt
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ touch pyproject.toml
</span></span></code></pre></div><p>完成后，您应该具有以下目录结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>如您所见，您将只有一个 Python 模块， <code>app</code> ，定义在一个名为 <code>page_tracker</code> 的包中，位于 <code>src/</code> 目录中。 <code>constraints.txt</code> 文件将指定项目依赖项的固定版本，以实现可<a href="https://pip.pypa.io/en/stable/topics/repeatable-installs/">重复安装</a>。</p>
<p>该项目将依赖于两个外部库， <a href="https://pypi.org/project/Flask/">Flask</a> 和 <a href="https://pypi.org/project/redis/">Redis</a> ，您可以在 <code>pyproject.toml</code> 文件中声明它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>请注意，您通常不会在此处指定依赖项版本。相反，您可以将它们与<a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files">需求</a>或<a href="https://pip.pypa.io/en/stable/user_guide/#constraints-files">约束文件</a>中的任何<a href="https://en.wikipedia.org/wiki/Transitive_dependency">传递依赖项</a>一起<a href="https://pip.pypa.io/en/stable/cli/pip_freeze/#pip-freeze">冻结</a>。第一个告诉 <code>pip</code> 要安装什么包，后者强制执行传递依赖项的特定包版本，类似于 <a href="https://realpython.com/pipenv-guide/">Pipenv</a> 或 <a href="https://realpython.com/dependency-management-python-poetry/">Poetry</a> 锁定文件。</p>
<p>要生成约束文件，您必须首先将您的 <code>page-tracker</code> 项目安装到活动的虚拟环境中，这将从 <a href="https://pypi.org/">Python 包索引 (PyPI)</a> 中获取所需的外部库。确保您已经创建了所需的文件夹结构，然后发出以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable .
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip freeze --exclude-editable &gt; constraints.txt
</span></span></code></pre></div><p>即使您还没有输入一行代码，Python 也会识别并安装您的包占位符。因为您的包遵循 <code>src</code> 布局，所以在开发期间以<a href="https://setuptools.pypa.io/en/latest/userguide/development_mode.html">可编辑模式</a>安装它很方便。这将允许您更改源代码并立即将它们反映在虚拟环境中，而无需重新安装。但是，您想从约束文件中排除可编辑包。</p>
<blockquote>
<p>注意：如果您打算共享您的项目，生成的约束文件非常有价值。这意味着其他人可以在他们的终端中运行以下命令来重现与您相同的环境：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install -c constraints.txt .
</span></span></code></pre></div><p>因为您通过 <code>-c</code> 选项提供了一个约束文件， <code>pip</code> 安装了固定的依赖项而不是最新的可用依赖项。这意味着您有可重复的安装。稍后您将使用类似的命令来构建 Docker 镜像。</p>
</blockquote>
<p>好的。您几乎已经准备好开始编写您的 Flask Web 应用程序了。在执行此操作之前，您将切换一下方式并准备一个本地 Redis 服务器以通过网络连接。</p>
<h3 id="通过-docker-运行-redis-服务器">通过 Docker 运行 Redis 服务器</h3>
<p>Redis 这个名字是单词远程字典服务器的合成词，它非常准确地表达了它作为远程内存数据结构存储的目的。作为一个键值存储，Redis 就像一个远程 <a href="https://realpython.com/python-dicts/">Python 字典</a>，您可以从任何地方连接到它。它也被认为是在许多不同环境中使用的最流行的 NoSQL 数据库之一。通常，它用于关系数据库之上的<a href="https://realpython.com/caching-in-django-with-redis/">缓存</a>。</p>
<blockquote>
<p>注意：虽然 Redis 将其所有数据保存在易失性内存中，这使其速度极快，但该服务器具有多种持久性选项。在断电或重启的情况下，它们可以确保不同级别的数据持久性。然而，正确配置 Redis 通常很困难，这就是为什么许多团队决定使用外包给云提供商的托管服务的原因。</p>
</blockquote>
<p>在您的计算机上安装 Redis 非常简单，但假设您之前已经安装和配置了 Docker，通过 Docker 运行它会更加简单和优雅。当您在 Docker 容器中运行诸如 Redis 之类的服务时，它会与系统的其余部分保持隔离，而不会造成混乱或占用有限的网络端口号等系统资源。</p>
<p>要在不将 Redis 安装在主机上的情况下运行 Redis，您可以通过调用以下命令从<a href="https://hub.docker.com/_/redis">官方 Redis 镜像</a>运行新的 Docker 容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d --name redis-server redis
</span></span><span class="line"><span class="cl">Unable to find image <span class="s1">&#39;redis:latest&#39;</span> locally
</span></span><span class="line"><span class="cl">latest: Pulling from library/redis
</span></span><span class="line"><span class="cl">26c5c85e47da: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">39f79586dcf2: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">79c71d0520e5: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">60e988668ca1: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">873c3fc9fdc6: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">50ce7f9bf183: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">Digest: sha256:f50031a49f41e493087fb95f96fdb3523bb25dcf6a3f0b07c588ad3cdb...
</span></span><span class="line"><span class="cl">Status: Downloaded newer image <span class="k">for</span> redis:latest
</span></span><span class="line"><span class="cl">09b9842463c78a2e9135add810aba6c4573fb9e2155652a15310009632c40ea8
</span></span></code></pre></div><p>这将基于最新版本的 <code>redis</code> 镜像创建一个新的 Docker 容器，自定义名称为 <code>redis-server</code> ，稍后您将引用它。容器以分离模式 ( <code>-d</code> ) 在后台运行。当您第一次运行此命令时，Docker 会从 Docker Hub 中拉取相应的 Docker 镜像，这是 Docker 镜像的官方存储库，类似于 PyPI。</p>
<p>只要一切按计划进行，您的 Redis 服务器就应该启动并运行。因为您以分离模式 ( <code>-d</code> ) 启动了容器，所以它将在后台保持活动状态。要验证这一点，您可以使用 <code>docker container ls</code> 命令或等效的 <code>docker ps</code> 别名列出您的 Docker 容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker ps
</span></span><span class="line"><span class="cl">CONTAINER ID   IMAGE   ...   STATUS              PORTS      NAMES
</span></span><span class="line"><span class="cl">09b9842463c7   redis   ...   Up About a minute   6379/tcp   redis-server
</span></span></code></pre></div><p>在这里，您可以看到一个 ID 前缀与您在运行 <code>docker run</code> 命令时获得的 ID 前缀匹配的容器从大约一分钟前开始启动。该容器基于 <code>redis</code> 镜像，已命名为 <code>redis-server</code> ，并使用TCP 端口号 <code>6379</code> ，这是Redis 的默认端口。</p>
<p>接下来，您将尝试以各种方式连接到该 Redis 服务器。</p>
<h3 id="测试与-redis-的连接">测试与 Redis 的连接</h3>
<p>在 Docker Hub 上官方 Redis 镜像的概述页面上，您将找到有关如何连接到在 Docker 容器中运行的 Redis 服务器的说明。具体而言，此页面讨论了如何使用 Docker 镜像附带的专用交互式命令行界面 Redis CLI 。</p>
<p>您可以从同一个 <code>redis</code> 镜像启动另一个 Docker 容器，但这一次，将容器的入口点设置为 <code>redis-cli</code> 命令而不是默认的 Redis 服务器二进制文件。当您设置多个容器一起工作时，您应该使用 Docker 网络，这需要一些额外的配置步骤。</p>
<p>首先，新建一个以你的项目命名的自定义桥接网络，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network create page-tracker-network
</span></span><span class="line"><span class="cl">c942131265bf097da294edbd2ac375cd5410d6f0d87e250041827c68a3197684
</span></span></code></pre></div><p>通过定义这样的虚拟网络，您可以连接任意数量的 Docker 容器，并让它们通过描述性名称相互发现。您可以通过运行以下命令列出您创建的网络：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network ls
</span></span><span class="line"><span class="cl">NETWORK ID     NAME                   DRIVER    SCOPE
</span></span><span class="line"><span class="cl">1bf8d998500e   bridge                 bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">d5cffd6ea76f   host                   host      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">a85d88fc3abe   none                   null      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">c942131265bf   page-tracker-network   bridge    <span class="nb">local</span>
</span></span></code></pre></div><p>接下来，将现有的 <code>redis-server</code> 容器连接到这个新的虚拟网络，并在启动相应容器时为 Redis CLI 指定相同的网络：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network connect page-tracker-network redis-server
</span></span><span class="line"><span class="cl">$ docker run --rm -it <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --name redis-client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --network page-tracker-network <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             redis redis-cli -h redis-server
</span></span></code></pre></div><p><code>--rm</code> 标志告诉 Docker 在您终止它后立即删除创建的容器，因为这是一个您不需要再次启动的临时或临时容器。 <code>-i</code> 和 <code>-t</code> 标志，缩写为 <code>-it</code> ，以交互方式运行容器，让您通过连接到终端的标准流来键入命令。使用 <code>--name</code> 选项，您可以为新容器指定一个描述性名称。</p>
<p><code>--network</code> 选项将你的新 <code>redis-client</code> 容器连接到之前创建的虚拟网络，允许它与 <code>redis-server</code> 容器通信。这样，两个容器都将收到与 <code>--name</code> 选项给定的名称相对应的主机名。请注意，通过使用 <code>-h</code> 参数，您告诉 Redis CLI 连接到由其容器名称标识的 Redis 服务器。</p>
<blockquote>
<p>注意：有一种更快的方法可以通过虚拟网络连接两个容器，而无需显式创建容器。您可以在运行新容器时指定 <code>--link</code> 选项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run --rm -it <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --name redis-client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --link redis-server:redis-client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             redis redis-cli -h redis-server
</span></span></code></pre></div><p>但是，此选项已被弃用，并且可能会在某个时候从 Docker 中删除。</p>
</blockquote>
<p>当您的新 Docker 容器启动时，您将进入一个交互式 Redis CLI，它类似于带有以下提示的 Python REPL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">redis-server:6379&gt; SET pi 3.14
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-server:6379&gt; GET pi
</span></span><span class="line"><span class="cl"><span class="s2">&#34;3.14&#34;</span>
</span></span><span class="line"><span class="cl">redis-server:6379&gt; DEL pi
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">redis-server:6379&gt; KEYS *
</span></span><span class="line"><span class="cl"><span class="o">(</span>empty array<span class="o">)</span>
</span></span></code></pre></div><p>在那里，您可以测试一些 Redis 命令，例如，设置键值对、获取相应键的值、删除该键值对或检索当前存储在服务器中的所有键的列表。要退出交互式 Redis CLI，请按键盘上的 Ctrl+C。</p>
<blockquote>
<p>如果您安装了 Docker Desktop，那么在大多数情况下，它不会将流量从您的主机路由到容器。你的本地网络和默认的 Docker 网络之间没有连接：</p>
<ul>
<li>
<p>Docker Desktop for Mac 无法将流量路由到容器。</p>
</li>
<li>
<p>适用于 Windows 的 Docker Desktop 无法将流量路由到 Linux 容器。但是，您可以对 Windows 容器执行 ping 操作。</p>
</li>
</ul>
<p>Linux 上的 Docker Desktop 也是如此。另一方面，如果您使用 Docker 引擎或在 Windows 主机上运行 Windows 容器，那么您将能够通过它们的 IP 地址访问这些容器。</p>
<p>因此，有时您可以直接从主机与 Redis 服务器通信。首先，找出对应的Docker容器的IP地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker inspect redis-server <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  -f <span class="s1">&#39;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{println}}{{end}}&#39;</span>
</span></span><span class="line"><span class="cl">172.17.0.2
</span></span><span class="line"><span class="cl">172.18.0.2
</span></span></code></pre></div><p>如果您看到多个 IP 地址，则表示您的容器连接到多个网络。当您启动容器时，容器会自动连接到默认的 Docker 网络。</p>
<p>记下其中一个地址，您可能会有所不同。现在，您可以将此 IP 地址用作 <code>-h</code> 参数的值，而不是 <code>redis-cli</code> 中的链接容器名称。您还可以使用此 IP 地址通过 <code>netcat</code> 或 Telnet 客户端连接到 Redis，例如 PuTTY 或 <code>telnet</code> 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ telnet 172.17.0.2 <span class="m">6379</span>
</span></span><span class="line"><span class="cl">Trying 172.17.0.2...
</span></span><span class="line"><span class="cl">Connected to 172.17.0.2.
</span></span><span class="line"><span class="cl">Escape character is <span class="s1">&#39;^]&#39;</span>.
</span></span><span class="line"><span class="cl">SET pi 3.14
</span></span><span class="line"><span class="cl">+OK
</span></span><span class="line"><span class="cl">GET pi
</span></span><span class="line"><span class="cl"><span class="nv">$4</span>
</span></span><span class="line"><span class="cl">3.14
</span></span><span class="line"><span class="cl">DEL pi
</span></span><span class="line"><span class="cl">:1
</span></span><span class="line"><span class="cl">KEYS *
</span></span><span class="line"><span class="cl">*0
</span></span><span class="line"><span class="cl">^<span class="o">]</span>
</span></span><span class="line"><span class="cl">telnet&gt; Connection closed.
</span></span></code></pre></div><p>请记住提供默认为 <code>6379</code> 的端口号，Redis 会在该端口上侦听传入连接。您可以在此处以明文形式键入 Redis 命令，因为服务器使用未加密的协议，除非您在配置中明确启用 TLS 支持。</p>
</blockquote>
<p>最后，您可以利用端口映射使 Redis 在 Docker 容器之外可用。在开发过程中，您将希望直接连接到 Redis，而不是通过来自另一个容器的虚拟网络，因此您不必将它连接到任何网络。</p>
<p>要使用端口映射，请停止并删除现有的 <code>redis-server</code> ，然后使用定义如下的 <code>-p</code> 选项运行一个新容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker stop redis-server
</span></span><span class="line"><span class="cl">$ docker rm redis-server
</span></span><span class="line"><span class="cl">$ docker run -d --name redis-server -p 6379:6379 redis
</span></span></code></pre></div><p>冒号左边的数字（ <code>:</code> ）代表主机或你电脑上的端口号，而右边的数字代表即将运行的Docker容器内的映射端口。</p>
<p>在两侧使用相同的端口号可以有效地转发它，这样您就可以连接到 Redis，就像它在您的计算机上本地运行一样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ telnet localhost <span class="m">6379</span>
</span></span><span class="line"><span class="cl">Trying 127.0.0.1...
</span></span><span class="line"><span class="cl">Connected to localhost.
</span></span><span class="line"><span class="cl">Escape character is <span class="s1">&#39;^]&#39;</span>.
</span></span><span class="line"><span class="cl">INCR page_views
</span></span><span class="line"><span class="cl">:1
</span></span><span class="line"><span class="cl">INCR page_views
</span></span><span class="line"><span class="cl">:2
</span></span><span class="line"><span class="cl">INCR page_views
</span></span><span class="line"><span class="cl">:3
</span></span><span class="line"><span class="cl">^<span class="o">]</span>
</span></span><span class="line"><span class="cl">telnet&gt; Connection closed.
</span></span></code></pre></div><p>连接到现在在本地主机和默认端口上可见的 Redis 后，您可以使用 <code>INCR</code> 命令增加页面浏览量。如果底层键尚不存在，则 Redis 将使用值 <code>1</code> 对其进行初始化。</p>
<blockquote>
<p>注意：如果您在本地安装了 Redis，或者某些系统进程也在您的主机上使用端口 <code>6379</code> ，那么您需要使用未占用的端口以不同方式映射您的端口号。例如，您可以执行以下操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d --name redis-server -p 9736:6379 redis
</span></span></code></pre></div><p>这将允许您连接到端口 <code>9736</code> 上的本地主机（如果该端口尚未被其他服务占用）。只要可用，使用哪个端口并不重要。</p>
</blockquote>
<p>现在您已经知道如何从命令行连接到 Redis，您可以继续看看如何通过 Python 程序执行相同的操作。</p>
<h3 id="从-python-连接到-redis">从 Python 连接到 Redis</h3>
<p>此时，您有一个在 Docker 容器中运行的 Redis 服务器，您可以使用 Redis 的默认端口号在本地主机上访问它。</p>
<p>如果您想了解有关您的容器或任何其他 Docker 资源的更多信息，那么您始终可以通过检查手头的对象来检索有价值的信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker inspect redis-server
</span></span><span class="line"><span class="cl"><span class="o">[</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;Id&#34;</span>: <span class="s2">&#34;09b9842463c78a2e9135add810aba6...2a15310009632c40ea8&#34;</span>,
</span></span><span class="line"><span class="cl">        ⋮
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;NetworkSettings&#34;</span>: <span class="o">{</span>
</span></span><span class="line"><span class="cl">            ⋮
</span></span><span class="line"><span class="cl">            <span class="s2">&#34;Ports&#34;</span>: <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;6379/tcp&#34;</span>: null
</span></span><span class="line"><span class="cl">            <span class="o">}</span>,
</span></span><span class="line"><span class="cl">            ⋮
</span></span><span class="line"><span class="cl">            <span class="s2">&#34;IPAddress&#34;</span>: <span class="s2">&#34;172.17.0.2&#34;</span>,
</span></span><span class="line"><span class="cl">            ⋮
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">]</span>
</span></span></code></pre></div><p>在这种情况下，您要询问有关 <code>redis-server</code> 容器的信息，其中包括大量详细信息，例如容器的网络配置。 <code>docker inspect</code> 命令默认返回 JSON 格式的数据，您可以使用 Go 模板进一步过滤。</p>
<p>接下来，打开终端，激活项目的虚拟环境，并启动一个新的 Python REPL：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">PS&gt; venv<span class="se">\S</span>cripts<span class="se">\a</span>ctivate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; python
</span></span></code></pre></div><p>Linux + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">source</span> venv/bin/activate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python
</span></span></code></pre></div><p>假设您之前在此虚拟环境中安装了 <code>redis</code> 包，您应该能够导入 Python 的 Redis 客户端并调用其中一种方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>
</span></span></code></pre></div><p>当您在不指定任何参数的情况下创建新的 <code>Redis</code> 实例时，它将尝试连接到在本地主机和默认端口 <code>6379</code> 上运行的 Redis 服务器。在这种情况下，调用 <code>.incr()</code> 确认您已成功与位于 Docker 容器中的 Redis 建立连接，因为它记住了 <code>page_views</code> 键的最后一个值。</p>
<p>如果您需要连接到位于远程计算机上的 Redis，请提供自定义主机和端口号作为参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s2">&#34;127.0.0.1&#34;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span>
</span></span></code></pre></div><p>请注意，您应该将端口号作为整数传递，但如果您传递一个字符串，库也不会抱怨。</p>
<p>连接到 Redis 的另一种方法是使用特殊格式的字符串，它代表一个 URL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span><span class="s2">&#34;redis://localhost:6379/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span>
</span></span></code></pre></div><p>如果您想将 Redis 配置存储在文件或环境变量中，这会特别方便。</p>
<p>好极了！您可以获取这些代码片段之一并将其与您的 Flask Web 应用程序集成。在下一节中，您将看到如何做到这一点。</p>
<h3 id="在本地实现并运行-flask-应用程序">在本地实现并运行 Flask 应用程序</h3>
<p>返回代码编辑器，打开 <code>page-tracker</code> 项目中的 <code>app</code> 模块，并编写以下几行 Python 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@app.get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">page_views</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;This page has been seen </span><span class="si">{</span><span class="n">page_views</span><span class="si">}</span><span class="s2"> times.&#34;</span>
</span></span></code></pre></div><p>您首先从项目各自列为依赖项的第三方库中导入 <code>Flask</code> 和 <code>Redis</code> 。接下来，您使用默认参数实例化 Flask 应用程序和 Redis 客户端，这意味着客户端将尝试连接到本地 Redis 服务器。</p>
<p>最后，您定义一个控制器函数来处理到达 Web 服务器根地址 ( <code>/</code> ) 的 HTTP GET 请求。</p>
<p>您的端点会增加 Redis 中的页面浏览量，并在客户端的 Web 浏览器中显示合适的消息。就是这样！您拥有一个完整的 Web 应用程序，它可以使用不到十行的代码处理 HTTP 流量并将状态持久保存在远程数据存储中。</p>
<p>要验证您的 Flask 应用程序是否按预期工作，请在终端中发出以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ flask --app page_tracker.app run
</span></span><span class="line"><span class="cl"> * Serving Flask app <span class="s1">&#39;page_tracker.app&#39;</span>
</span></span><span class="line"><span class="cl"> * Debug mode: off
</span></span><span class="line"><span class="cl">WARNING: This is a development server. Do not use it in a production
</span></span><span class="line"><span class="cl">⮑ deployment. Use a production WSGI server instead.
</span></span><span class="line"><span class="cl"> * Running on http://127.0.0.1:5000
</span></span><span class="line"><span class="cl">Press CTRL+C to quit
</span></span></code></pre></div><p>你可以在你的文件系统的任何地方运行这个命令，只要你已经激活了正确的虚拟环境并安装了你的 <code>page-tracker</code> 包。这应该在禁用调试模式的情况下在本地主机和端口 <code>5000</code> 上运行 Flask 开发服务器。</p>
<p>如果你想从同一网络上的另一台计算机访问你的服务器，那么你必须使用特殊地址 <code>0.0.0.0</code> 而不是默认的 localhost 将它绑定到所有网络接口，它代表环回接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ flask --app page_tracker.app run --host<span class="o">=</span>0.0.0.0 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                                                  --port<span class="o">=</span><span class="m">8080</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                                                  --debug
</span></span><span class="line"><span class="cl"> * Serving Flask app <span class="s1">&#39;page_tracker.app&#39;</span>
</span></span><span class="line"><span class="cl"> * Debug mode: on
</span></span><span class="line"><span class="cl">WARNING: This is a development server. Do not use it in a production
</span></span><span class="line"><span class="cl">⮑ deployment. Use a production WSGI server instead.
</span></span><span class="line"><span class="cl"> * Running on all addresses <span class="o">(</span>0.0.0.0<span class="o">)</span>
</span></span><span class="line"><span class="cl"> * Running on http://127.0.0.1:8080
</span></span><span class="line"><span class="cl"> * Running on http://192.168.0.115:8080
</span></span><span class="line"><span class="cl">Press CTRL+C to quit
</span></span><span class="line"><span class="cl"> * Restarting with stat
</span></span><span class="line"><span class="cl"> * Debugger is active!
</span></span><span class="line"><span class="cl"> * Debugger PIN: 123-167-546
</span></span></code></pre></div><p>如果需要，您还可以使用适当的命令行选项或标志更改端口号并启用调试模式。</p>
<p>启动服务器后，您可以点击终端中显示的链接，并在您的网络浏览器中查看包含浏览量的页面。每次刷新此页面时，计数器应加一：</p>
<p>做得很好！您已经成功创建了一个基本的 Flask 应用程序，它使用 Redis 跟踪页面浏览量。接下来，您将学习如何测试和保护您的 Web 应用程序。</p>
<h2 id="测试和保护您的-web-应用程序">测试和保护您的 Web 应用程序</h2>
<p>在将任何项目打包并部署到生产环境之前，您应该彻底测试、检查和保护底层源代码。在本教程的这一部分，您将练习单元测试、集成测试和端到端测试。您还将执行静态代码分析和安全扫描，以在修复成本仍然低廉的情况下识别潜在的问题和漏洞。</p>
<h3 id="用单元测试覆盖源代码">用单元测试覆盖源代码</h3>
<p>单元测试涉及测试程序的各个单元或组件，以确保它们按预期工作。如今，它已成为软件开发的必要组成部分。许多工程师甚至更进一步，严格遵循<a href="https://realpython.com/python-hash-table/#take-a-crash-course-in-test-driven-development">测试驱动开发</a>方法，首先编写单元测试来驱动代码设计。</p>
<p>在编写单元测试时，Python 社区中的人们选择 <a href="https://realpython.com/pytest-python-testing/">pytest</a> 而不是标准库的 <code>unittest</code> 模块是很常见的。由于 <code>pytest</code> 相对简单，这个测试框架上手很快。继续并将 <code>pytest</code> 添加为项目的可选依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>您可以将以某种方式相关的可选依赖项分组在一个通用名称下。例如，在这里，您创建了一个名为 <code>dev</code> 的组来收集您将在开发过程中使用的工具和库。通过将 <code>pytest</code> 与主要依赖项分开，您将能够仅在需要时按需安装它。毕竟，将您的测试或相关的测试框架与构建的分发包捆绑在一起是没有意义的。</p>
<p>不要忘记重新安装带有可选依赖项的 Python 包，以使 <code>pytest</code> 进入项目的虚拟环境：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;.[dev]&#34;</span>
</span></span></code></pre></div><p>您可以使用方括号列出在您的 <code>pyproject.toml</code> 文件中定义的可选依赖组的名称。在这种情况下，您要求安装用于开发目的的依赖项，包括测试框架。请注意，建议在方括号周围使用引号 ( <code>&quot;&quot;</code> ) 以防止 shell 中潜在的文件名扩展。</p>
<p>因为您在项目中遵循了 <code>src</code> 布局，所以您不必将测试模块保存在与被测代码相同的文件夹或相同的命名空间包中。您可以为测试创建一个单独的目录分支，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│   └── unit/
</span></span><span class="line"><span class="cl">│       └── test_app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>您已将测试模块放在 <code>test/unit/</code> 文件夹中以保持井井有条。 <code>pytest</code> 框架将在您为测试添加前缀 <code>test</code> 时发现您的测试。虽然您可以更改它，但通常在使用相应的测试模块镜像每个 Python 模块时保持默认约定。例如，您将在 <code>test/unit/</code> 文件夹中用 <code>test_app</code> 覆盖 <code>app</code> 模块。</p>
<p>您将从测试 Web 应用程序的成功路径开始，这通常意味着向服务器发送请求。每个 Flask 应用程序都带有一个方便的测试客户端，您可以使用它来发出模拟的 HTTP 请求。因为测试客户端不需要运行实时服务器，所以你的单元测试执行得更快并且会变得更加孤立。</p>
<p>您可以获得测试客户端并将其方便地包装在测试装置中，以使其可用于您的测试功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/unit/test_app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">page_tracker.app</span> <span class="kn">import</span> <span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">http_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</span></span></code></pre></div><p>首先，您导入 <code>pytest</code> 包以针对您的自定义函数利用其 <code>@fixture</code> 装饰器。仔细选择您的函数名称，因为它也会成为您可以作为参数传递给各个测试函数的夹具的名称。您还可以从 <code>page_tracker</code> 包中导入 Flask 应用程序以获取相应的测试客户端实例。</p>
<p>当您打算编写单元测试时，您必须始终通过消除代码单元可能具有的任何依赖关系来隔离它。这意味着您应该模拟或存根您的代码所依赖的任何外部服务、数据库或库。在您的情况下，Redis 服务器就是这样的依赖项。</p>
<p>不幸的是，您的代码目前使用硬编码的 Redis 客户端，这会阻止模拟。这是从一开始就遵循测试驱动开发的一个很好的论据，但这并不意味着您必须返回并重新开始。相反，您将通过实施依赖注入设计模式来<a href="https://realpython.com/python-refactoring/">重构</a>您的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"># src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gi">+from functools import cache
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>
</span></span><span class="line"><span class="cl"> from flask import Flask
</span></span><span class="line"><span class="cl"> from redis import Redis
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> app = Flask(__name__)
</span></span><span class="line"><span class="cl"><span class="gd">-redis = Redis()
</span></span></span><span class="line"><span class="cl"><span class="gd"></span>
</span></span><span class="line"><span class="cl"> @app.get(&#34;/&#34;)
</span></span><span class="line"><span class="cl"> def index():
</span></span><span class="line"><span class="cl"><span class="gd">-    page_views = redis.incr(&#34;page_views&#34;)
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+    page_views = redis().incr(&#34;page_views&#34;)
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>     return f&#34;This page has been seen {page_views} times.&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gi">+@cache
</span></span></span><span class="line"><span class="cl"><span class="gi">+def redis():
</span></span></span><span class="line"><span class="cl"><span class="gi">+    return Redis()
</span></span></span></code></pre></div><p>本质上，您将 Redis 客户端创建代码从<a href="https://realpython.com/python-scope-legb-rule/#modules-the-global-scope">全局范围</a>移动到一个新的 <code>redis()</code> 函数，您的控制器函数会在运行时针对每个传入请求调用该函数。这将允许您的测试用例在正确的时间用模拟对应物替换返回的 Redis 实例。但是，为了确保内存中只有一个客户端实例，有效地使其成为一个单例，您还<a href="https://realpython.com/lru-cache-python/">缓存</a>了新函数的结果。</p>
<p>现在回到您的测试模块并实施以下单元测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/unit/test_app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">unittest.mock</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">page_tracker.app</span> <span class="kn">import</span> <span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">http_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@unittest.mock.patch</span><span class="p">(</span><span class="s2">&#34;page_tracker.app.redis&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_should_call_redis_incr</span><span class="p">(</span><span class="n">mock_redis</span><span class="p">,</span> <span class="n">http_client</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Given</span>
</span></span><span class="line"><span class="cl">    <span class="n">mock_redis</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">incr</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># When</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span> <span class="o">=</span> <span class="n">http_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Then</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&#34;This page has been seen 5 times.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mock_redis</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">incr</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>您使用 Python 的 <code>@patch</code> 装饰器包装您的测试函数，以将模拟的 Redis 客户端作为参数注入其中。您还告诉 <code>pytest</code> 将您的 HTTP 测试客户端装置作为另一个参数注入。测试函数有一个描述性名称，以动词 should 开头并遵循 Given-When-Then 模式。这两个常用于行为驱动开发的约定，使您的测试被解读为行为规范。</p>
<p>在您的测试用例中，您首先将模拟 Redis 客户端设置为在其 <code>.incr()</code> 方法被调用时始终返回 <code>5</code> 。然后，您向根端点 ( <code>/</code> ) 发出伪造的 HTTP 请求并检查服务器的响应状态和正文。因为模拟可以帮助您测试单元的行为，所以您只需验证服务器是否使用预期参数调用了正确的方法，并相信 Redis 客户端库可以正常工作。</p>
<p>要执行单元测试，您可以使用代码编辑器中集成的测试运行器，也可以在终端中键入以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest -v test/unit/
</span></span></code></pre></div><p>您从虚拟环境中将 <code>pytest</code> 作为 Python 模块运行，指示它扫描 <code>test/unit/</code> 目录以便在那里查找测试模块。 <code>-v</code> 开关增加了测试报告的详细程度，以便您可以看到有关各个测试用例的更多详细信息。</p>
<p>在所有单元测试都通过后盯着绿色报告会感到满足。它使您对代码有一定程度的信心，但不足以做出任何形式的保证。许多模因说明了即使在单元测试通过后运行集成测试的重要性。</p>
<p>例如，其中一个经典模因显示有两个抽屉，但一次只能打开一个。虽然每个单独的抽屉或单元都经过测试并独立工作，但当您尝试将它们集成到一件家具中时，就会出现问题。接下来，您将向您的项目添加一个基本的集成测试。</p>
<h3 id="通过集成测试检查组件交互">通过集成测试检查组件交互</h3>
<p>集成测试应该是运行单元测试后的下一个阶段。集成测试的目标是检查您的组件作为更大系统的一部分如何相互交互。</p>
<p>例如，您的页面跟踪器 Web 应用程序可能具有集成测试，用于检查与真正的 Redis 服务器而不是模拟服务器的通信。</p>
<p>您可以重复使用 <code>pytest</code> 来实施和运行集成测试。但是，您将安装一个额外的 <code>pytest-timeout</code> 插件，以允许您强制运行时间过长的测试用例失败：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest-timeout&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>理想情况下，您不必担心单元测试超时，因为它们应该针对速度进行优化。另一方面，集成测试将需要更长的时间来运行，并且可能会在停滞的网络连接上无限挂起，从而阻止您的测试套件完成。因此，在这种情况下有办法中止它们很重要。</p>
<p>请记住再次重新安装带有可选依赖项的包，以使 <code>pytest-timeout</code> 插件可用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;.[dev]&#34;</span>
</span></span></code></pre></div><p>在继续之前，为您的集成测试添加另一个子文件夹，并在您的 <code>test/</code> 文件夹中定义一个 <code>conftest.py</code> 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│   ├── integration/
</span></span><span class="line"><span class="cl">│   │   └── test_app_redis.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── unit/
</span></span><span class="line"><span class="cl">│   │   └── test_app.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   └── conftest.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>您将在 <code>conftest.py</code> 中放置公共装置，不同类型的测试将共享这些装置。</p>
<p>虽然您的 Web 应用程序只有一个组件，但您可以将 Redis 视为 Flask 需要使用的另一个组件。因此，集成测试可能看起来与您的单元测试类似，只是不再模拟 Redis 客户端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/integration/test_app_redis.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.mark.timeout</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_should_update_redis</span><span class="p">(</span><span class="n">redis_client</span><span class="p">,</span> <span class="n">http_client</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Given</span>
</span></span><span class="line"><span class="cl">    <span class="n">redis_client</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># When</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span> <span class="o">=</span> <span class="n">http_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Then</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&#34;This page has been seen 5 times.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">redis_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&#34;5&#34;</span>
</span></span></code></pre></div><p>从概念上讲，您的新测试用例包含与以前相同的步骤，但它与真正的 Redis 服务器交互。这就是为什么你给测试最多 <code>1.5</code> 秒来完成使用 <code>@pytest.mark.timeout</code> 装饰器。测试函数将两个夹具作为参数：</p>
<ul>
<li>连接到本地数据存储的 Redis 客户端</li>
<li>Flask 的测试客户端连接到您的 Web 应用程序</li>
</ul>
<p>为了使第二个在您的集成测试中也可用，您必须将 <code>http_client()</code> 夹具从 <code>test_app</code> 模块移动到 <code>conftest.py</code> 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/conftest.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">redis</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">page_tracker.app</span> <span class="kn">import</span> <span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">http_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&#34;module&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">redis</span><span class="o">.</span><span class="n">Redis</span><span class="p">()</span>
</span></span></code></pre></div><p>由于此文件位于文件夹层次结构的上一层， <code>pytest</code> 将选取其中定义的所有灯具，并使它们在整个嵌套文件夹中可见。除了您从另一个 Python 模块移动的熟悉的 <code>http_client()</code> 夹具之外，您还定义了一个返回默认 Redis 客户端的新夹具。请注意，您为它指定了 <code>module</code> 范围，以便为测试模块中的所有函数重用相同的 Redis 客户端实例。</p>
<p>要执行集成测试，您必须仔细检查 Redis 服务器是否在本地默认端口 <code>6379</code> 上运行，然后像以前一样启动 <code>pytest</code> ，但将其指向包含集成测试的文件夹：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest -v test/integration/
</span></span></code></pre></div><p>因为您的集成测试连接到实际的 Redis 服务器，所以它会覆盖您之前可能存储在 <code>page_views</code> 键下的值。但是，如果在执行集成测试时 Redis 服务器未运行，或者如果 Redis 在其他地方运行，那么您的测试将失败。这种失败可能是出于错误的原因，使结果成为假阴性错误，因为您的代码实际上可能按预期工作。</p>
<p>要观察此问题，请立即停止 Redis 并重新运行集成测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ docker stop redis-server
</span></span><span class="line"><span class="cl">redis-server
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest -v test/integration/
</span></span><span class="line"><span class="cl">⋮
</span></span><span class="line"><span class="cl"><span class="o">=========================</span> short <span class="nb">test</span> summary <span class="nv">info</span> <span class="o">==========================</span>
</span></span><span class="line"><span class="cl">FAILED test/integration/test_app_redis.py::test_should_update_redis -
</span></span><span class="line"><span class="cl">⮑redis.exceptions.ConnectionError: Error <span class="m">111</span> connecting to localhost:6379.
</span></span><span class="line"><span class="cl">⮑Connection <span class="nv">refused</span>
</span></span><span class="line"><span class="cl"><span class="o">============================</span> <span class="m">1</span> failed in 0.19s <span class="o">=============================</span>
</span></span></code></pre></div><p>这揭示了您的代码中的一个问题，该问题目前无法妥善处理 Redis 连接错误。本着测试驱动开发的精神，您可以首先编写一个重现该问题的测试用例，然后修复它。切换一下，使用模拟的 Redis 客户端在 <code>test_app</code> 模块中添加以下单元测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/unit/test_app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">unittest.mock</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="ne">ConnectionError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@unittest.mock.patch</span><span class="p">(</span><span class="s2">&#34;page_tracker.app.redis&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_should_handle_redis_connection_error</span><span class="p">(</span><span class="n">mock_redis</span><span class="p">,</span> <span class="n">http_client</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Given</span>
</span></span><span class="line"><span class="cl">    <span class="n">mock_redis</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">incr</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="ne">ConnectionError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># When</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span> <span class="o">=</span> <span class="n">http_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Then</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">500</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&#34;Sorry, something went wrong </span><span class="se">\N{pensive face}</span><span class="s2">&#34;</span>
</span></span></code></pre></div><p>您设置模拟的 <code>.incr()</code> 方法的副作用，以便调用该方法将引发 <code>redis.ConnectionError</code> 异常，这是您在集成测试失败时观察到的。您的新单元测试是负面测试的一个示例，它期望 Flask 以 HTTP 状态代码 500 和描述性消息进行响应。以下是满足该单元测试的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span><span class="p">,</span> <span class="n">RedisError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@app.get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">page_views</span> <span class="o">=</span> <span class="n">redis</span><span class="p">()</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="n">RedisError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&#34;Redis error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;Sorry, something went wrong </span><span class="se">\N{pensive face}</span><span class="s2">&#34;</span><span class="p">,</span> <span class="mi">500</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;This page has been seen </span><span class="si">{</span><span class="n">page_views</span><span class="si">}</span><span class="s2"> times.&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@cache</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Redis</span><span class="p">()</span>
</span></span></code></pre></div><p>您拦截顶级异常类 <code>redis.RedisError</code> ，它是 Redis 客户端引发的所有异常类型的祖先。如果出现任何问题，您将返回预期的 HTTP 状态代码和一条消息。为方便起见，您还使用 Flask 内置的<a href="https://realpython.com/python-logging/">记录</a>器记录异常。</p>
<blockquote>
<p>注意：虽然父类是子类直接扩展的直接基类，但祖先类可以位于<a href="https://realpython.com/python-classes/#using-inheritance-and-building-class-hierarchies">继承</a>层次结构中更上层的任何位置。</p>
</blockquote>
<p>好极了！由于测试，您修改了单元测试，实施了集成测试，并在发现代码中的缺陷后修复了它。</p>
<p>尽管如此，当您将应用程序部署到远程环境时，您如何知道所有部分都组合在一起并且一切都按预期工作？</p>
<p>在下一节中，您将通过对实际 Flask 服务器而不是测试客户端执行端到端测试来模拟真实场景。</p>
<h3 id="测试真实场景端到端">测试真实场景端到端</h3>
<p>端到端测试，也称为广泛堆栈测试，包含多种测试，可以帮助您验证整个系统。他们通过模拟实际用户通过应用程序的流程来测试完整的软件堆栈。因此，端到端测试需要一个尽可能模拟生产环境的部署环境。通常还需要专门的测试工程师团队。</p>
<blockquote>
<p>注意：由于端到端测试的维护成本很高，而且往往需要花费大量时间来设置和运行，因此它们位于 Google 测试金字塔的顶端。换句话说，您的目标应该是进行更多的集成测试，甚至在您的项目中进行更多的单元测试。</p>
</blockquote>
<p>由于您最终希望为您的 Docker 应用程序构建一个成熟的持续集成管道，因此进行一些端到端测试将变得至关重要。首先为您的 E2E 测试添加另一个子文件夹：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│   ├── e2e/
</span></span><span class="line"><span class="cl">│   │   └── test_app_redis_http.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── integration/
</span></span><span class="line"><span class="cl">│   │   └── test_app_redis.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── unit/
</span></span><span class="line"><span class="cl">│   │   └── test_app.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   └── conftest.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>您将要实施的测试场景将类似于您的集成测试。不过，主要区别在于您将通过网络将实际的 HTTP 请求发送到实时 Web 服务器，而不是依赖 Flask 的测试客户端。</p>
<p>为此，您将使用第三方 <a href="https://realpython.com/python-requests/">requests</a> 库，您必须首先在 <code>pyproject.toml</code> 文件中将其指定为另一个可选依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest-timeout&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;requests&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>您不会使用 <code>requests</code> 在生产环境中运行服务器，因此无需将其作为常规依赖项。同样，使用可编辑模式重新安装带有可选依赖项的 Python 包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;.[dev]&#34;</span>
</span></span></code></pre></div><p>您现在可以在端到端测试中使用已安装的 <code>requests</code> 库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"> <span class="c1"># test/e2e/test_app_redis_http.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">requests</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.mark.timeout</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_should_update_redis</span><span class="p">(</span><span class="n">redis_client</span><span class="p">,</span> <span class="n">flask_url</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Given</span>
</span></span><span class="line"><span class="cl">    <span class="n">redis_client</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># When</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">flask_url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Then</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&#34;This page has been seen 5 times.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">redis_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&#34;5&#34;</span>
</span></span></code></pre></div><p>除了负责发送 HTTP GET 请求的第 12 行之外，此代码与您的集成测试几乎相同。之前，您将该请求发送到测试客户端的根地址，用斜杠字符 ( <code>/</code> ) 表示。现在，您不知道可能在远程主机上运行的 Flask 服务器的确切域或 IP 地址。因此，您的函数接收一个 Flask URL 作为参数， <code>pytest</code> 将其作为固定装置注入。</p>
<p>您可以通过命令行提供特定的网络服务器地址。同样，您的 Redis 服务器可能在不同的主机上运行，因此您也需要提供其地址作为命令行参数。可是等等！您的 Flask 应用程序当前期望 Redis 始终在本地主机上运行。继续并更新您的代码以使其可配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span><span class="p">,</span> <span class="n">RedisError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@app.get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">page_views</span> <span class="o">=</span> <span class="n">redis</span><span class="p">()</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="n">RedisError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&#34;Redis error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;Sorry, something went wrong </span><span class="se">\N{pensive face}</span><span class="s2">&#34;</span><span class="p">,</span> <span class="mi">500</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;This page has been seen </span><span class="si">{</span><span class="n">page_views</span><span class="si">}</span><span class="s2"> times.&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@cache</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Redis</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&#34;REDIS_URL&#34;</span><span class="p">,</span> <span class="s2">&#34;redis://localhost:6379&#34;</span><span class="p">))</span>
</span></span></code></pre></div><p>通常使用环境变量来设置敏感数据，例如数据库 URL，因为它提供了额外级别的安全性和灵活性。在这种情况下，您的程序需要一个自定义的 <code>REDIS_URL</code> 变量。如果在给定环境中未指定该变量，则您将回退到默认主机和端口。</p>
<p>要使用自定义命令行参数扩展 <code>pytest</code> ，您必须编辑 <code>conftest.py</code> 并按以下方式连接到框架的参数解析器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># test/conftest.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pytest</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">redis</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">page_tracker.app</span> <span class="kn">import</span> <span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">pytest_addoption</span><span class="p">(</span><span class="n">parser</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">parser</span><span class="o">.</span><span class="n">addoption</span><span class="p">(</span><span class="s2">&#34;--flask-url&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">parser</span><span class="o">.</span><span class="n">addoption</span><span class="p">(</span><span class="s2">&#34;--redis-url&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&#34;session&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">flask_url</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&#34;--flask-url&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&#34;session&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis_url</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&#34;--redis-url&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">http_client</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&#34;module&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis_client</span><span class="p">(</span><span class="n">redis_url</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">redis_url</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">redis</span><span class="o">.</span><span class="n">Redis</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span><span class="n">redis_url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">redis</span><span class="o">.</span><span class="n">Redis</span><span class="p">()</span>
</span></span></code></pre></div><p>您使用类似于 Python 的 <code>argparse</code> 模块的语法定义两个可选参数， <code>--flask-url</code> 和 <code>--redis-url</code> 。然后，您将这些参数包装在会话范围的固定装置中，您将能够将其注入到您的测试函数和其他固定装置中。具体来说，您现有的 <code>redis_client()</code> fixture 现在可以利用可选的 Redis URL。</p>
<blockquote>
<p>注意：因为您的端到端测试和集成测试依赖于相同的 <code>redis_client()</code> fixture，所以您可以通过在两种类型的测试中指定 <code>--redis-url</code> 选项来连接到远程 Redis 服务器。</p>
</blockquote>
<p>这是通过指定 Flask Web 服务器和相应的 Redis 服务器的 URL 来使用 <code>pytest</code> 运行端到端测试的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest -v test/e2e/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --flask-url http://127.0.0.1:5000 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --redis-url redis://127.0.0.1:6379
</span></span></code></pre></div><p>在这种情况下，您可以通过本地主机 ( <code>127.0.0.1</code> ) 访问 Flask 和 Redis，但您的应用程序可能会部署到由多台远程计算机组成的地理分布式环境中。当你在本地执行此命令时，确保 Redis 正在运行并首先单独启动你的 Flask 服务器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ docker start redis-server
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ flask --app page_tracker.app run
</span></span></code></pre></div><p>为了提高代码质量，如果您有能力，可以不断向您的应用程序添加更多类型的测试。不过，这通常需要一个全职软件质量保证工程师团队。另一方面，执行代码审查或其他类型的静态代码分析是相当容易实现的，可以发现许多令人惊讶的问题。您现在将查看此过程。</p>
<h3 id="执行静态代码分析和安全扫描">执行静态代码分析和安全扫描</h3>
<p>现在您的应用程序已按预期运行，是时候在不执行底层代码的情况下执行静态代码分析了。这是软件开发行业的一种常见做法，可帮助开发人员识别其代码中的潜在软件缺陷和安全风险。</p>
<p>虽然静态分析的某些步骤可以自动完成，但其他步骤通常需要手动完成，例如同行评审。</p>
<p>您将使用以下自动化工具，因此请将它们作为可选依赖项添加到您的 <code>pyproject.toml</code> 文件中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;bandit&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;black&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;flake8&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;isort&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pylint&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest-timeout&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;requests&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>之后不要忘记重新安装并固定您的依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;.[dev]&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip freeze --exclude-editable &gt; constraints.txt
</span></span></code></pre></div><p>这会将一些命令行实用工具带入您的虚拟环境。首先，您应该通过一致地格式化代码、对 <code>import</code> 语句进行排序并检查 PEP 8 合规性来清理代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m black src/ --check
</span></span><span class="line"><span class="cl">would reformat /home/realpython/page-tracker/src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Oh no! 💥 💔 💥
</span></span><span class="line"><span class="cl"><span class="m">1</span> file would be reformatted, <span class="m">1</span> file would be left unchanged.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m isort src/ --check
</span></span><span class="line"><span class="cl">ERROR: /home/.../app.py Imports are incorrectly sorted and/or formatted.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m flake8 src/
</span></span><span class="line"><span class="cl">src/page_tracker/app.py:23:1: E302 expected <span class="m">2</span> blank lines, found <span class="m">1</span>
</span></span></code></pre></div><p>您使用 <code>black</code> 标记代码中的任何格式不一致，使用 <code>isort</code> 确保您的 <code>import</code> 语句根据官方建议保持组织，使用 <code>flake8</code> 检查任何其他 PEP 8 样式违规。</p>
<p>如果您在运行这些工具后没有看到任何输出，则意味着没有什么可以修复的。另一方面，如果出现警告或错误，那么您可以手动更正任何报告的问题，或者让这些工具在您删除 <code>--check</code> 标志时自动执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m black src/
</span></span><span class="line"><span class="cl">reformatted /home/realpython/page-tracker/src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">All <span class="k">done</span>! ✨ 🍰 ✨
</span></span><span class="line"><span class="cl"><span class="m">1</span> file reformatted, <span class="m">1</span> file left unchanged.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m isort src/
</span></span><span class="line"><span class="cl">Fixing /home/realpython/page-tracker/src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m flake8 src/
</span></span></code></pre></div><p>如果没有 <code>--check</code> 标志， <code>black</code> 和 <code>isort</code> 都会继续并在不询问的情况下重新格式化受影响的文件。运行这两个命令还解决了 PEP 8 合规性问题，因为 <code>flake8</code> 不再返回任何样式违规。</p>
<blockquote>
<p>注意：遵循整个团队的通用代码风格约定有助于保持代码整洁。这样，当一个人更新源文件时，团队成员就不必对不相关代码部分（例如空格）的更改进行分类。</p>
</blockquote>
<p>一旦一切都干净了，您就可以对代码进行 lint 以查找潜在的代码异味或改进它的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pylint src/
</span></span></code></pre></div><p>当您针对 Web 应用程序的源代码运行 <code>pylint</code> 时，它可能会开始抱怨或多或少有用的东西。它通常发出属于几个类别的消息，包括：</p>
<ul>
<li><strong>E:</strong> Errors</li>
<li><strong>W:</strong> Warnings</li>
<li><strong>C:</strong> 违反公约</li>
<li><strong>R:</strong> 重构建议</li>
</ul>
<p>每条评论都有一个唯一的标识符，例如 <code>C0116</code> ，如果您觉得它没有帮助，您可以将其隐藏。您可以在全局配置文件中包含抑制的标识符以获得永久效果，或者使用命令行开关忽略给定运行中的某些错误。</p>
<p>您还可以在给定行上添加特殊格式的 Python 注释以说明特殊情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span><span class="p">,</span> <span class="n">RedisError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@app.get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">page_views</span> <span class="o">=</span> <span class="n">redis</span><span class="p">()</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s2">&#34;page_views&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="n">RedisError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&#34;Redis error&#34;</span><span class="p">)</span>  <span class="c1"># pylint: disable=E1101</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;Sorry, something went wrong </span><span class="se">\N{pensive face}</span><span class="s2">&#34;</span><span class="p">,</span> <span class="mi">500</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;This page has been seen </span><span class="si">{</span><span class="n">page_views</span><span class="si">}</span><span class="s2"> times.&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@cache</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">redis</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Redis</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&#34;REDIS_URL&#34;</span><span class="p">,</span> <span class="s2">&#34;redis://localhost:6379&#34;</span><span class="p">))</span>
</span></span></code></pre></div><p>在这种情况下，您告诉 <code>pylint</code> 忽略错误 E1101 的特定实例，而不是完全抑制它。这是一个误报，因为 <code>.logger</code> 是 Flask 在运行时生成的动态属性，在静态分析过程中不可用。</p>
<blockquote>
<p>注意：如果您打算使用 <code>pylint</code> 作为自动化持续集成管道的一部分，那么您可能需要指定它何时应该退出并显示错误代码，这通常会停止管道的后续步骤。例如，您可以将其配置为始终返回中性退出代码零：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pylint src/ --exit-zero
</span></span></code></pre></div><p>这永远不会停止管道运行，即使 <code>pylint</code> 在代码中发现一些问题。或者，使用 <code>--fail-under</code> ，您可以指定任意分数阈值， <code>pylint</code> 将在该阈值时退出并显示错误代码。</p>
</blockquote>
<p>您会注意到 <code>pylint</code> 为您的代码打分并对其进行跟踪。当您以某种方式解决问题并再次运行该工具时，它会报告一个新分数并告诉您它改善或恶化了多少。使用您的最佳判断来决定 <code>pylint</code> 报告的问题是否值得修复。</p>
<p>最后，无意中通过源代码泄露敏感数据或暴露其他安全漏洞的情况非常普遍。它甚至发生在最好的软件工程师身上。最近，GitHub 在一个公共存储库中<a href="https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/#what-happened-and-what-actions-have-we-taken">暴露了它的私钥</a>，这可能让攻击者冒充这个巨头。为了降低此类事件的风险，您应该在将源代码部署到任何地方之前对其进行安全或漏洞扫描。</p>
<p>要扫描您的代码，您可以使用 <a href="https://bandit.readthedocs.io/en/latest/">bandit</a> ，它是您之前作为可选依赖项安装的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m bandit -r src/
</span></span></code></pre></div><p>当您指定文件夹路径而不是文件路径时，还必须包含 <code>-r</code> 标志以递归扫描它。此时， <code>bandit</code> 应该不会在您的代码中发现任何问题。但是，如果您在 Flask 应用程序底部添加以下两行后再次运行它，那么该工具将报告不同严重级别的问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># src/page_tracker/app.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s2">&#34;0.0.0.0&#34;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span></code></pre></div><p>这种 <a href="https://realpython.com/if-name-main-python/">name-main 惯用语</a>是许多 Flask 应用程序中常见的模式，因为它使开发更方便，让您直接运行 Python 模块。另一方面，它暴露了 Flask 的调试器，允许执行任意代码，并通过地址 <code>0.0.0.0</code> 绑定到所有网络接口，为公共流量打开您的服务。</p>
<p>因此，为了确保您的 Flask 应用程序是安全的，您应该始终在将代码部署到生产环境之前运行 <code>bandit</code> 或类似工具。</p>
<p>好的。您的 Web 应用程序包含单元、集成和端到端测试。这意味着许多自动化工具已经静态分析和修改了它的源代码。</p>
<p>接下来，您将继续通过将应用程序包装在 Docker 容器中来实现持续集成，这样您就可以将整个项目部署到远程环境或忠实地将其复制到本地计算机上。</p>
<h2 id="将您的-flask-web-应用程序-docker-化">将您的 Flask Web 应用程序 Docker 化</h2>
<p>在本节中，您将以 Docker 容器的形式运行您的页面跟踪器 Web 应用程序，该容器可以与在另一个容器中运行的 Redis 通信。这样的设置对于开发和测试以及将应用程序部署到远程环境很有用。</p>
<p>即使您的计算机上没有安装 Python 或 Redis，您仍然可以通过 Docker 运行您的项目。</p>
<h3 id="理解-docker-术语">理解 Docker 术语</h3>
<p>对应用程序进行 Docker 化涉及创建 Dockerfile，它是对环境所需状态的声明性描述。它为运行时环境、配置以及运行应用程序所需的所有依赖项和库提供模板。</p>
<p>要为您的应用程序注入活力，您必须根据该描述构建一个 Docker 镜像。您可以将 Docker 镜像视为操作系统在给定时间的快照。当您与世界或公司内部共享您的 Docker 镜像时，其他人可以重现与您完全相同的环境并运行相同的应用程序。</p>
<p>这回避了经典，但它适用于我的机器问题。</p>
<p>Docker 镜像是 Docker 容器的蓝图。每个 Docker 容器都是 Docker 镜像的一个实例。一个容器有独立的状态和资源，包括它自己的文件系统、环境变量和网络接口。单个 Docker 容器通常运行单个进程，使其成为托管特定<a href="https://realpython.com/python-microservices-grpc/">微服务</a>的理想选择。</p>
<p>通过添加更多容器，您可以临时扩展一个或多个微服务以处理流量高峰，例如，这在假期期间可能很常见。但是，您的微服务必须架构良好并保持无状态才能使其有效。</p>
<blockquote>
<p>注意：Docker 容器类似于 Vagrant 或 VirtualBox 等虚拟机，但更轻巧且启动速度更快。因此，您可以同时在主机上运行比虚拟机更多的容器。</p>
<p>这样做的原因是容器的开销较小，因为它们共享操作系统的内核，而虚拟机运行在模拟完整硬件堆栈的管理程序上。另一方面，容器不那么安全，它们也不提供与虚拟机相同级别的隔离。</p>
</blockquote>
<p>典型的应用程序包括在隔离的 Docker 容器中运行的多个服务，这些容器可以相互通信。您的页面跟踪器应用程序有以下两个：</p>
<ol>
<li>Web service</li>
<li>Redis service</li>
</ol>
<p>您已经知道如何通过 Docker 运行 Redis。现在，是时候将您的 Flask Web 应用程序沙盒化到 Docker 容器中，以简化这两种服务的开发和部署过程。</p>
<h3 id="了解-dockerfile-的剖析">了解 Dockerfile 的剖析</h3>
<p>首先，您将定义一个适用于开发阶段的相对较短的 Dockerfile。在项目根文件夹中创建一个名为 <code>Dockerfile</code> 的文件，该文件与文件层次结构中的 <code>src/</code> 子文件夹和 <code>pyproject.toml</code> 配置文件处于同一级别：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">├── Dockerfile
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>您可以随意命名此文件，但坚持默认命名约定将使您不必在每次构建镜像时都指定文件名。 Docker 期望的默认文件名是 <code>Dockerfile</code> ，没有文件扩展名。请注意，它以大写字母 <code>D</code> 开头。</p>
<p>Dockerfile 是一个纯文本文档，其中列出了组装镜像所需的步骤。它遵循特定格式，定义了一套固定的说明供您使用。</p>
<blockquote>
<p>注意：您必须将 Dockerfile 中的每条指令放在单独的一行中，但看到非常长的行被行连续字符 ( <code>\</code> ) 多次打断的情况并不少见。事实上，通常需要在一行中塞入多个操作，以利用您现在将要了解的缓存机制。</p>
</blockquote>
<p>当您从 Dockerfile 构建镜像时，您依赖于一系列层。每条指令都会在前一层之上创建一个只读层，封装对镜像底层文件系统的一些修改。图层具有全局唯一标识符，这允许 Docker 将图层存储在缓存中。这有两个主要优点：</p>
<ul>
<li>速度：Docker 可以跳过自上次构建以来未更改的层，而是从缓存中加载它们，从而显着加快镜像构建速度。</li>
<li>大小：多个镜像可以共享公共图层，从而减小它们各自的大小。除此之外，层数越少，镜像尺寸越小。</li>
</ul>
<p>现在您已经了解了 Dockerfile 的这种分层结构，您可以开始向其中添加指令，同时了解创建高效 Docker 镜像的最佳实践。</p>
<h3 id="选择基础-docker-镜像">选择基础 Docker 镜像</h3>
<p>每个 Dockerfile 中的第一条指令 <code>FROM</code> 必须始终定义用于构建新镜像的基础镜像。这意味着您不必从头开始，而是可以选择一个已经构建的合适镜像。例如，您可以使用 Python 解释器附带的镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span></code></pre></div><p>在这里，您使用名为 <code>python</code> 的官方 Python 镜像，它托管在 Docker Hub 上。官方镜像由相应语言或技术的官方维护者构建和维护。它们不属于 Docker Hub 上的任何特定用户或团队，但在全局命名空间中可用，隐式称为 <code>library/</code> ，而不是更专业的变体，如 <code>circleci/python</code> 。</p>
<p>您还可以在冒号 ( <code>:</code> ) 后指定一个可选的标签或标签名称，以缩小基本镜像的特定版本。您可以通过单击相应 Docker Hub 页面上的“标签”选项卡来浏览给定 Docker 镜像的所有可用标签。</p>
<p>注意：标签不是强制性的，但将它们包含在 <code>FROM</code> 指令中被认为是最佳实践。您应该尽可能具体，以避免不必要的意外。如果您省略该标记，那么 Docker 将拉取一个标记为 <code>latest</code> 的镜像，其中可能包含不合适的操作系统或影响您的应用程序的运行时意外更改。</p>
<p>标签 <code>3.11.2-slim-bullseye</code> 表示您的基础镜像将是 Debian Bullseye 的精简变体，仅包含基本要素，让您稍后可以根据需要安装任何其他软件包。这减小了镜像的大小并加快了下载时间。此镜像的常规变体和超薄变体之间的大小差异高达八百兆字节！</p>
<p>该标记还表明您的基础镜像将随已安装的 Python 3.11.2 一起提供，因此您可以立即开始使用它。</p>
<p>在拉取基础镜像后，您可能想要立即执行的下一个任务是使用最新的安全更新和错误修复对其进行修补，这些更新和错误修复可能是自镜像在 Docker Hub 上发布以来发布的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span></code></pre></div><p>在 Debian 中，您可以使用 <code>apt-get</code> 命令获取最新的软件包列表并升级任何有可用更新的软件包。请注意，这两个命令都作为一个 <code>RUN</code> 指令的一部分执行，以最大限度地减少文件系统中的层数，从而避免占用过多的磁盘空间。</p>
<blockquote>
<p>注意：Dockerfile 中指令的顺序很重要，因为它会影响构建镜像所需的时间。</p>
<p>特别是，您应该将其层经常更改的指令放在 Dockerfile 的底部，因为它们最有可能使缓存中的所有后续层无效。</p>
</blockquote>
<p>好的。您已经选择了基本镜像并安装了最新的安全更新。您几乎已经准备好设置您的 Flask 应用程序，但还有几个步骤。</p>
<h3 id="隔离你的-docker-镜像">隔离你的 Docker 镜像</h3>
<p>使用 Dockerfiles 时的另一个好习惯是，一旦不再需要它们，就创建并切换到没有管理权限的普通用户。默认情况下，Docker 以超级用户身份运行您的命令，恶意攻击者可以利用它来不受限制地访问您的主机系统。是的，Docker 提供了对容器和主机的根级访问权限！</p>
<p>以下是避免这种潜在安全风险的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Dockerfile</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">FROM</span> <span class="n">python</span><span class="p">:</span><span class="mf">3.11.2</span><span class="o">-</span><span class="n">slim</span><span class="o">-</span><span class="n">bullseye</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">&amp;&amp;</span> \
</span></span><span class="line"><span class="cl">    <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">upgrade</span> <span class="o">--</span><span class="n">yes</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RUN</span> <span class="n">useradd</span> <span class="o">--</span><span class="n">create</span><span class="o">-</span><span class="n">home</span> <span class="n">realpython</span>
</span></span><span class="line"><span class="cl"><span class="n">USER</span> <span class="n">realpython</span>
</span></span><span class="line"><span class="cl"><span class="n">WORKDIR</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">realpython</span>
</span></span></code></pre></div><p>您创建一个名为 <code>realpython</code> 的新用户，并告诉 Docker 从现在起在 Dockerfile 中使用该用户。您还将当前工作目录设置为此用户的主目录，这样您就不必在后面的命令中明确指定完整的文件路径。</p>
<p>即使您的 Docker 容器将运行单个 Flask 应用程序，也请考虑在容器本身内部设置一个专用的虚拟环境。虽然您无需担心将多个 Python 项目彼此隔离，并且 Docker 为您的主机提供了一个合理的隔离层，但您仍然存在干扰容器自身系统工具的风险。</p>
<p>不幸的是，许多 Linux 发行版都依赖于全局 Python 安装才能顺利运行。如果您开始将包直接安装到全局 Python 环境中，那么您就为潜在的版本冲突打开了大门。这甚至可能导致破坏您的系统。</p>
<blockquote>
<p>注意：如果您仍然不相信在 Docker 容器内创建虚拟环境，那么这条警告消息可能会改变您的想法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">WARNING: Running pip as the <span class="s1">&#39;root&#39;</span> user can result in broken permissions
</span></span><span class="line"><span class="cl">and conflicting behaviour with the system package manager. It is
</span></span><span class="line"><span class="cl">⮑recommended to use a virtual environment instead:
</span></span><span class="line"><span class="cl">⮑https://pip.pypa.io/warnings/venv
</span></span></code></pre></div><p>在 Debian 或 Ubuntu 等衍生发行版上尝试使用系统的全局 <code>pip</code> 命令安装 Python 包后，您可能会看到这一点。</p>
</blockquote>
<p>在 Docker 镜像中创建和激活虚拟环境的最可靠方法是直接修改其 <code>PATH</code> 环境变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span></code></pre></div><p>首先，定义一个辅助变量 <code>VIRTUALENV</code> ，其中包含项目虚拟环境的路径，然后使用 Python 的 <code>venv</code> 模块在那里创建该环境。但是，不是使用 shell 脚本激活新环境，而是通过覆盖 <code>python</code> 可执行文件的路径来更新 <code>PATH</code> 变量。</p>
<p>为什么？这是必要的，因为以通常的方式激活您的环境只是暂时的，不会影响从您的镜像派生的 Docker 容器。此外，如果您使用 Dockerfile 的 <code>RUN</code> 指令激活虚拟环境，那么它只会持续到 Dockerfile 中的下一条指令，因为每条指令都会启动一个新的 shell 会话。</p>
<p>一旦你有了项目的虚拟环境，你就可以安装必要的依赖项。</p>
<h3 id="缓存你的项目依赖">缓存你的项目依赖</h3>
<p>与在主机本地工作相比，在 Dockerfile 中安装依赖项看起来略有不同。通常，您会安装依赖项，然后立即安装 Python 包。</p>
<p>相比之下，当您构建 Docker 镜像时，值得将该过程分为两个步骤以利用层缓存，从而减少构建镜像所需的总时间。</p>
<p>首先， <code>COPY</code> 将带有项目元数据的两个文件从您的主机导入到 Docker 镜像中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython pyproject.toml constraints.txt ./<span class="err">
</span></span></span></code></pre></div><p>您只需将包含有关项目依赖项信息的 <code>pyproject.toml</code> 和 <code>constraints.txt</code> 文件复制到 Docker 镜像中 <code>realpython</code> 用户的主目录中。默认情况下，文件归超级用户所有，因此您可能希望使用 <code>--chown</code> 将其所有者更改为您之前创建的普通用户。 <code>--chown</code> 选项类似于 <code>chown</code> 命令，它代表更改所有者。</p>
<p>您可以在网上找到的许多 Dockerfile 示例会一次性复制所有内容，但那很浪费！</p>
<p>可能有大量额外文件，例如包含项目整个历史的本地 Git 存储库、代码编辑器设置或项目根文件夹中的其他临时文件。</p>
<p>它们不仅会使生成的镜像膨胀，而且还会增加过早使 Docker 层缓存失效的可能性。</p>
<blockquote>
<p>注意：您应该只复制您目前需要的单个文件到您的 Dockerfile 中。否则，即使是不相关文件中的最细微变化也会导致剩余图层重建。或者，您可以定义一个 <code>.dockerignore</code> 文件，其工作方式与 <code>.gitignore</code> 副本类似，但明确说明要复制的内容更安全。</p>
</blockquote>
<p>另一个容易遗漏的难题是当您在尝试安装项目依赖项之前忘记升级 <code>pip</code> 本身。在极少数情况下， <code>pip</code> 的旧版本实际上可以阻止安装其他软件包的最新版本！在您的情况下，还值得升级 <code>setuptools</code> ，您将其用作构建后端，以获取最新的安全补丁。</p>
<p>您可以将以下两个命令组合在一条 <code>RUN</code> 指令中以安装您的依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython pyproject.toml constraints.txt ./<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install --upgrade pip setuptools <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pip install --no-cache-dir -c constraints.txt <span class="s2">&#34;.[dev]&#34;</span><span class="err">
</span></span></span></code></pre></div><p>您将 <code>pip</code> 和 <code>setuptools</code> 升级到最新版本。然后，安装项目所需的第三方库，包括用于开发的可选依赖项。您限制它们的版本以确保一致的环境，并告诉 <code>pip</code> 使用 <code>--no-cache-dir</code> 禁用缓存。您在虚拟环境之外不需要这些包，因此无需缓存它们。这样，您就可以使 Docker 镜像更小。</p>
<blockquote>
<p>注意：因为您安装了依赖项而没有在 Docker 镜像中安装 <code>page-tracker</code> 包，所以它们将保留在缓存层中。因此，对源代码的任何更改都不需要重新安装这些依赖项。</p>
</blockquote>
<p>您的 Dockerfile 正在增长并变得越来越复杂，但请不要担心。只需要完成几个步骤，就快完成了。</p>
<h3 id="作为构建过程的一部分运行测试">作为构建过程的一部分运行测试</h3>
<p>最后，是时候将您的源代码复制到 Docker 镜像中，并与 linters 和其他静态分析工具一起运行您的测试了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython pyproject.toml constraints.txt ./<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install --upgrade pip setuptools <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pip install --no-cache-dir -c constraints.txt <span class="s2">&#34;.[dev]&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython src/ src/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython test/ test/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install . -c constraints.txt <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pytest test/unit/ <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m flake8 src/ <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m isort src/ --check <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m black src/ --check --quiet <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pylint src/ --disable<span class="o">=</span>C0114,C0116,R1705 <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m bandit -r src/ --quiet<span class="err">
</span></span></span></code></pre></div><p>从主机复制 <code>src/</code> 和 <code>test/</code> 文件夹后，将 <code>page-tracker</code> 包安装到虚拟环境中。通过将自动化测试工具融入构建过程，您可以确保如果其中任何一个工具返回非零退出状态代码，则构建您的 Docker 镜像将失败。这正是您在实施持续集成管道时想要的。</p>
<p>请注意，您必须禁用严重性低的 <code>pylint</code> 问题 C0114 、 C0116 和 R1705 ，它们现在并不重要。否则，它们会阻止您的 Docker 镜像成功构建。</p>
<p>将各个命令组合在一个 <code>RUN</code> 指令中的原因是为了减少要缓存的层数。请记住，您拥有的层越多，生成的 Docker 镜像就越大。</p>
<blockquote>
<p>注意：此时，您无法执行需要 Redis 的集成或端到端测试，因为您的 Docker 镜像只涉及 Flask 应用程序。在将应用程序部署到某个环境后，您将能够执行它们。</p>
</blockquote>
<p>当所有测试都通过并且没有任何静态分析工具报告任何问题时，您的 Docker 镜像就差不多完成了。但是，当您从镜像创建新容器时，您仍然需要告诉 Docker 要运行什么命令。</p>
<h3 id="指定要在-docker-容器中运行的命令">指定要在 Docker 容器中运行的命令</h3>
<p>最后一步是指定要在从 Docker 镜像派生的每个新 Docker 容器中执行的命令。在此阶段，您可以在 Flask 的内置开发服务器上启动您的 Web 应用程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython pyproject.toml constraints.txt ./<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install --upgrade pip setuptools <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pip install --no-cache-dir -c constraints.txt <span class="s2">&#34;.[dev]&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython src/ src/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --chown<span class="o">=</span>realpython test/ test/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install . -c constraints.txt <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pytest test/unit/ <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m flake8 src/ <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m isort src/ --check <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m black src/ --check --quiet <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pylint src/ --disable<span class="o">=</span>C0114,C0116,R1705 <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m bandit -r src/ --quiet<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="o">[</span><span class="s2">&#34;flask&#34;</span>, <span class="s2">&#34;--app&#34;</span>, <span class="s2">&#34;page_tracker.app&#34;</span>, <span class="s2">&#34;run&#34;</span>, <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>     <span class="s2">&#34;--host&#34;</span>, <span class="s2">&#34;0.0.0.0&#34;</span>, <span class="s2">&#34;--port&#34;</span>, <span class="s2">&#34;5000&#34;</span><span class="o">]</span><span class="err">
</span></span></span></code></pre></div><p>在这里，您使用 <code>CMD</code> 指令的三种形式之一，它类似于 Python 的 <code>subprocess.run()</code> 函数的语法。请注意，您必须将主机绑定到 <code>0.0.0.0</code> 地址，以便从 Docker 容器外部访问您的应用程序。</p>
<p>您现在可以基于现有的 Dockerfile 构建 Docker 镜像，并开始运行从中派生的 Docker 容器。以下命令会将您的 Dockerfile 转换为名为 <code>page-tracker</code> 的 Docker 镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker build -t page-tracker .
</span></span></code></pre></div><p>它将在当前工作目录中查找 Dockerfile，用点 ( <code>.</code> ) 表示，并使用默认标签 <code>latest</code> 标记生成的镜像。因此，完整的镜像名称将是 <code>page-tracker:latest</code> 。</p>
<p>不幸的是，您的镜像目前包含很多杂物，例如您在生产中永远不需要的源代码、测试和 linter。</p>
<p>它们会增加镜像的大小，使下载和部署速度变慢，如果您没有正确维护它们，它们还会导致安全漏洞。此外，这些额外的组件可能会在排除错误时引起问题。</p>
<p>幸运的是，有一种更好的方法来组织您的 Dockerfile，允许您分多个阶段构建一个镜像，您现在将探索它。</p>
<h3 id="为多阶段构建重新组织-dockerfile">为多阶段构建重新组织 Dockerfile</h3>
<p>到目前为止，您创建的 Dockerfile 相当简单，应该适合开发。保留它，因为稍后您将需要它来使用 Docker Compose 运行端到端测试。您现在可以复制此文件并为其指定一个不同的名称。例如，您可以将 <code>.dev</code> 后缀附加到两个副本之一：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/
</span></span><span class="line"><span class="cl">│   └── page_tracker/
</span></span><span class="line"><span class="cl">│       ├── __init__.py
</span></span><span class="line"><span class="cl">│       └── app.py
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── test/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── venv/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── constraints.txt
</span></span><span class="line"><span class="cl">├── Dockerfile
</span></span><span class="line"><span class="cl">├── Dockerfile.dev
</span></span><span class="line"><span class="cl">└── pyproject.toml
</span></span></code></pre></div><p>现在，编辑名为 <code>Dockerfile</code> 的文件并在将构建过程分解为多个阶段时保持打开状态。</p>
<blockquote>
<p>注意：要在构建镜像时指定自定义文件名而不是默认的 <code>Dockerfile</code> ，请使用 <code>-f</code> 或 <code>--file</code> 选项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker build -f Dockerfile.dev -t page-tracker .
</span></span></code></pre></div><p>这个文件名可以是任何你想要的。只需确保在 <code>docker build</code> 命令中正确引用它即可。</p>
</blockquote>
<p>多阶段构建背后的想法是将 Dockerfile 划分为多个阶段，每个阶段都可以基于完全不同的镜像。当您的应用程序的开发环境和运行时环境不同时，这尤其有用。</p>
<p>例如，您可以在仅用于构建和测试应用程序的临时镜像中安装必要的构建工具，然后将生成的可执行文件复制到最终镜像中。</p>
<p>多阶段构建可以使您的镜像更小、更高效。这是使用当前 Dockerfile 构建的同一镜像与您将要编写的镜像的比较：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker images
</span></span><span class="line"><span class="cl">REPOSITORY     TAG       IMAGE ID       CREATED          SIZE
</span></span><span class="line"><span class="cl">page-tracker   prod      9cb2e3233522   <span class="m">5</span> minutes ago    204MB
</span></span><span class="line"><span class="cl">page-tracker   dev       f9918cb213dc   <span class="m">5</span> minutes ago    244MB
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span></code></pre></div><p>在这种情况下，大小差异并不显着，但当您有多个镜像要管理和移动时，它会迅速增加。</p>
<p>Dockerfile 中的每个阶段都以其自己的 <code>FROM</code> 指令开始，因此您将有两个。第一个阶段看起来与您当前的 Dockerfile 几乎完全相同，除了您将为这个阶段命名 <code>builder</code> ，您可以稍后参考：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"># Dockerfile
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gd">-FROM python:3.11.2-slim-bullseye
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+FROM python:3.11.2-slim-bullseye AS builder
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>
</span></span><span class="line"><span class="cl"> RUN apt-get update &amp;&amp; \
</span></span><span class="line"><span class="cl">     apt-get upgrade --yes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> RUN useradd --create-home realpython
</span></span><span class="line"><span class="cl"> USER realpython
</span></span><span class="line"><span class="cl"> WORKDIR /home/realpython
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ENV VIRTUALENV=/home/realpython/venv
</span></span><span class="line"><span class="cl"> RUN python3 -m venv $VIRTUALENV
</span></span><span class="line"><span class="cl"> ENV PATH=&#34;$VIRTUALENV/bin:$PATH&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> COPY --chown=realpython pyproject.toml constraints.txt ./
</span></span><span class="line"><span class="cl"> RUN python -m pip install --upgrade pip setuptools &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m pip install --no-cache-dir -c constraints.txt &#34;.[dev]&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> COPY --chown=realpython src/ src/
</span></span><span class="line"><span class="cl"> COPY --chown=realpython test/ test/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> RUN python -m pip install . -c constraints.txt &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m pytest test/unit/ &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m flake8 src/ &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m isort src/ --check &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m black src/ --check --quiet &amp;&amp; \
</span></span><span class="line"><span class="cl">     python -m pylint src/ --disable=C0114,C0116,R1705 &amp;&amp; \
</span></span><span class="line"><span class="cl"><span class="gd">-    python -m bandit -r src/ --quiet
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+    python -m bandit -r src/ --quiet &amp;&amp; \
</span></span></span><span class="line"><span class="cl"><span class="gi">+    python -m pip wheel --wheel-dir dist/ . -c constraints.txt
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>
</span></span><span class="line"><span class="cl"><span class="gd">-CMD [&#34;flask&#34;, &#34;--app&#34;, &#34;page_tracker.app&#34;, &#34;run&#34;, \
</span></span></span><span class="line"><span class="cl"><span class="gd">-     &#34;--host&#34;, &#34;0.0.0.0&#34;, &#34;--port&#34;, &#34;5000&#34;]
</span></span></span></code></pre></div><p>因为您要将打包的页面跟踪器应用程序从一个镜像传输到另一个镜像，所以您必须添加使用 Python wheel 格式构建分发包的额外步骤。 <code>pip wheel</code> 命令将在 <code>dist/</code> 子文件夹中创建一个名为 <code>page_tracker-1.0.0-py3-none-any.whl</code> 的文件。您还可以从此阶段删除 <code>CMD</code> 指令，因为它将成为下一阶段的一部分。</p>
<p>第二个也是最后一个阶段，隐式命名为 <code>stage-1</code> ，看起来有点重复，因为它基于相同的镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c"># Dockerfile</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye AS builder</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># ...</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> python:3.11.2-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    apt-get upgrade --yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> useradd --create-home realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /home/realpython</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">VIRTUALENV</span><span class="o">=</span>/home/realpython/venv<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python3 -m venv <span class="nv">$VIRTUALENV</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$VIRTUALENV</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>builder /home/realpython/dist/page_tracker*.whl /home/realpython<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> python -m pip install --upgrade pip setuptools <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    python -m pip install --no-cache-dir page_tracker*.whl<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="o">[</span><span class="s2">&#34;flask&#34;</span>, <span class="s2">&#34;--app&#34;</span>, <span class="s2">&#34;page_tracker.app&#34;</span>, <span class="s2">&#34;run&#34;</span>, <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>     <span class="s2">&#34;--host&#34;</span>, <span class="s2">&#34;0.0.0.0&#34;</span>, <span class="s2">&#34;--port&#34;</span>, <span class="s2">&#34;5000&#34;</span><span class="o">]</span><span class="err">
</span></span></span></code></pre></div><p>您首先按照熟悉的步骤升级系统包、创建用户和创建虚拟环境。然后，突出显示的行负责从 <code>builder</code> 阶段复制 wheel 文件。你像以前一样用 <code>pip</code> 安装它。最后，您添加 <code>CMD</code> 指令以使用 Flask 启动您的 Web 应用程序。</p>
<p>当您使用这样的多阶段 Dockerfile 构建镜像时，您会注意到第一阶段需要更长的时间才能完成，因为它必须安装所有依赖项、运行测试并创建 wheel 文件。</p>
<p>但是，构建第二阶段会快很多，因为它只需要复制并安装完成的 wheel 文件。另外请注意， <code>builder</code> 阶段是临时的，因此之后不会在您的 Docker 镜像中留下任何痕迹。</p>
<p>好的。你终于准备好构建你的多阶段 Docker 镜像了！</p>
<h3 id="构建和版本控制你的-docker-镜像">构建和版本控制你的 Docker 镜像</h3>
<p>在构建镜像之前，强烈建议您为 Docker 镜像选择一个版本控制方案，并始终使用唯一标签对其进行标记。这样，您就会知道在任何给定环境中部署了什么，并能够在需要时回滚到之前的稳定版本。</p>
<p>对 Docker 镜像进行版本控制有几种不同的策略。例如，一些流行的包括：</p>
<ul>
<li>语义版本控制使用以点分隔的三个数字来指示主要版本、次要版本和补丁版本。</li>
<li>Git 提交哈希使用绑定到镜像中源代码的 Git 提交的 SHA-1 哈希。</li>
<li>时间戳使用时间信息（例如 Unix 时间）来指示镜像的构建时间。</li>
</ul>
<p>没有什么能阻止您结合其中的一些策略来创建一个有效的版本控制系统，该系统将帮助您跟踪镜像中的更改。</p>
<p>在本教程中，您将坚持使用 Git 提交哈希方法，因为它可以确保您的 Docker 镜像的标签是唯一且不可变的。花点时间在您的 <code>page-tracker/</code> 文件夹中初始化一个本地 Git 存储库，并使用与您的工作环境相关的文件模式定义一个 <code>.gitignore</code> 。您可以通过使用 <code>pwd</code> 命令打印您的工作目录来仔细检查您是否在正确的文件夹中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">pwd</span>
</span></span><span class="line"><span class="cl">/home/realpython/page-tracker
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git init
</span></span><span class="line"><span class="cl">Initialized empty Git repository in /home/realpython/page-tracker/.git/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ curl -sL https://www.gitignore.io/api/python,pycharm+all &gt; .gitignore
</span></span></code></pre></div><p>在这里，您使用 <code>curl</code> 从 gitignore.io 下载内容，请求 Git 从跟踪中排除 Python 和 PyCharm 相关的文件模式。 <code>-L</code> 标志是跟随重定向所必需的，因为该网站最近移动到具有更长域的不同地址。或者，您可以从 GitHub 的 <code>gitignore</code> 存储库中获取其中一个模板，某些代码编辑器会使用该模板。</p>
<p>初始化本地 Git 存储库后，您可以进行第一次提交并获取相应的哈希值，例如，使用 <code>git rev-parse</code> 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git add .
</span></span><span class="line"><span class="cl">$ git commit -m <span class="s2">&#34;Initial commit&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>master <span class="o">(</span>root-commit<span class="o">)</span> dde1dc9<span class="o">]</span> Initial commit
</span></span><span class="line"><span class="cl"> <span class="m">11</span> files changed, <span class="m">535</span> insertions<span class="o">(</span>+<span class="o">)</span>
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> .gitignore
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> Dockerfile
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> Dockerfile.dev
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> constraints.txt
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> pyproject.toml
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> src/page_tracker/__init__.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> src/page_tracker/app.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> test/conftest.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> test/e2e/test_app_redis_http.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> test/integration/test_app_redis.py
</span></span><span class="line"><span class="cl"> create mode <span class="m">100644</span> test/unit/test_app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git rev-parse HEAD
</span></span><span class="line"><span class="cl">dde1dc9303a2a9f414d470d501572bdac29e4075
</span></span></code></pre></div><p>如果你不喜欢长输出，那么你可以在命令中添加 <code>--short</code> 标志，这将为你提供相同提交哈希的缩写版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git rev-parse --short HEAD
</span></span><span class="line"><span class="cl">dde1dc9
</span></span></code></pre></div><p>默认情况下，它将返回可以唯一标识该特定提交而不会产生歧义的最短前缀。</p>
<p>现在您已经有了 Git 提交哈希，您可以将它用作 Docker 镜像的标签。要构建镜像，请在指定 <code>-t</code> 或 <code>--tag</code> 选项的同时运行 <code>docker build</code> 命令，以便为新镜像添加标签。尾随点表示您当前的工作目录是查找 Dockerfile 的位置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker build -t page-tracker:<span class="k">$(</span>git rev-parse --short HEAD<span class="k">)</span> .
</span></span></code></pre></div><p>冒号之前的第一部分 <code>page-tracker</code> 是您的 Docker 镜像的助记名称。请注意，在现实生活中，您可能会附加某种后缀来传达此服务的角色。例如，因为这是一个 Flask 网络应用程序，您可以将镜像命名为 <code>page-tracker-web</code> 或类似的名称。冒号后面的是实际标记，在本例中，它是当前提交的 Git 提交哈希。</p>
<p>如果您之前构建 Docker 镜像时没有给它明确的标签，或者如果您以其他方式标记它，那么您可能会注意到现在构建它只需要几分之一秒！</p>
<p>那是因为 Docker 缓存了每个文件系统层，只要项目中的重要文件没有更改，就不需要重建这些层。</p>
<p>另一点值得注意的是，在表面之下，Docker 仅存储您的镜像的一个副本。它有一个唯一的标识符，例如 <code>9cb2e3233522</code> ，多个标签可以引用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker images
</span></span><span class="line"><span class="cl">REPOSITORY     TAG                    IMAGE ID       CREATED       SIZE
</span></span><span class="line"><span class="cl">page-tracker   dde1dc9                9cb2e3233522   <span class="m">1</span> hour ago    204MB
</span></span><span class="line"><span class="cl">page-tracker   prod                   9cb2e3233522   <span class="m">1</span> hour ago    204MB
</span></span><span class="line"><span class="cl">page-tracker   dev                    f9918cb213dc   <span class="m">1</span> hour ago    244MB
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span></code></pre></div><p>这就是标记 Docker 镜像的力量。它允许您使用不同的标签引用同一镜像，例如 <code>page-tracker:prod</code> 或 <code>page-tracker:dde1dc9</code> ，同时保留唯一标识。每个标签都包含存储库名称（您将在下一节中了解）和一个特定的标签名称。</p>
<p>您现在可以使用您从 Dockerfile 构建的闪亮的新 Docker 镜像来启动一个成熟的 Docker 容器。具体来说，您可以在笔记本电脑或支持 Docker 的远程基于云的服务器上本地运行容器。</p>
<p>这可能是您进行端到端测试的唯一方法。</p>
<p>但是如何将容器放到远程环境中呢？你会在下一节中找到答案。</p>
<h3 id="将镜像推送到-docker-registry">将镜像推送到 Docker Registry</h3>
<p>当您与他人协作处理一段代码时，您通常会使用 Git 等版本控制来跟踪所有相关人员所做的所有更改。虽然 Git 本身是一个分布式版本控制系统，允许您集成任何两个人之间的贡献，但它缺乏集中托管服务来促进多方之间的同时协作。这就是为什么大多数人选择 GitHub 或竞争对手的原因。</p>
<p>GitHub 是您通常上传源代码的地方，而 Docker Registry 是存储构建的 Docker 镜像的常用位置。从事商业产品的公司将希望在私有云或本地建立自己的 Docker Registry，以获得额外级别的控制和安全性。许多流行的云提供商以托管服务的形式提供高度安全的 Docker 注册表。</p>
<p>您也可以使用私有注册表，例如，通过 Docker 运行开源分发容器。</p>
<p>或者，如果这太麻烦，那么您会很高兴得知 Docker Hub 提供了一个安全的托管注册表，您可以开始免费使用它。虽然免费层为您提供了无限数量的公共存储库，但您将只有一个私有存储库，并且对外界不可见。考虑到您不必支付一分钱，这对于个人或业余爱好项目来说是一笔不错的交易。</p>
<blockquote>
<p>注意：您的 Docker Hub 帐户上的存储库是用户可以上传或下载的 Docker 镜像的集合。每个存储库可以包含同一镜像的多个标记版本。</p>
<p>在这方面，Docker Hub 存储库类似于 GitHub 存储库，但专门用于 Docker 镜像而不是代码。私有存储库允许您仅允许授权用户访问，而公共存储库可供所有人使用。</p>
</blockquote>
<p>为什么要使用 Docker Registry？</p>
<p>好吧，您不必这样做，但它有助于在整个组织内共享 Docker 镜像或设置持续集成管道。例如，将提交推送到 GitHub 或其他源代码修订系统可以通过自动构建功能启动构建过程。反过来，注册中心会宣布新的 Docker 镜像已成功构建或使用 webhook 开始部署到远程环境以进行进一步测试。</p>
<p>如果还没有，请立即在 Docker Hub 上注册一个帐户。请注意，除了电子邮件地址和密码外，您还需要提供唯一的用户名，就像在 GitHub 上一样：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/docker_hub.912fd6ac373d.png" alt="img"  />
</p>
<p>选择一个好记的用户名至关重要，因为它将成为您在 Docker Hub 上的独特句柄。为了避免不同用户拥有的镜像之间的名称冲突，Docker Hub 通过用户名和存储库名称的组合来识别每个存储库。</p>
<p>例如，如果您的用户名是 <code>realpython</code> ，那么您的一个存储库可以由字符串 <code>realpython/page-tracker</code> 标识，它类似于 GitHub 上存储库的名称。</p>
<p>在 Web 浏览器中注册并登录到您的新 Docker Hub 帐户后，您应该做的第一件事是为您的镜像创建一个存储库。单击“创建存储库”磁贴或转到顶部导航栏中的“存储库”选项卡，然后单击“创建存储库”按钮。然后，将您的存储库命名为 <code>page-tracker</code> ，如果需要，请为其提供有意义的描述，然后选择 Private 选项以使其仅对您可见：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/docker_hub2.359dd2359251.png" alt="img"  />
</p>
<p>之后，您将看到带有终端命令的说明，这些命令将允许您将 Docker 镜像推送到您的存储库。但首先，您必须从命令行登录 Docker Hub，提供您的用户名和密码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker login -u realpython
</span></span><span class="line"><span class="cl">Password:
</span></span></code></pre></div><p>即使您打算仅使用公共存储库，也需要使用 <code>docker login</code> 进行身份验证。</p>
<blockquote>
<p>注意：如果您在 Docker Hub 帐户的安全设置中启用了双因素身份验证，那么您将需要生成一个具有适当权限的访问令牌，以便在命令行中使用 <code>docker</code> 登录。当它要求您输入密码时，只需提供您的令牌即可。</p>
<p>否则，如果您没有配置双因素身份验证，那么您将能够使用您的 Docker Hub 密码登录。尽管如此，如文档所述，仍然值得生成一个令牌以获得更好的安全性。</p>
</blockquote>
<p>当你使用 Git 将代码推送到远程存储库时，你必须首先从某个地方克隆它或手动设置默认源，它配置本地存储库的元数据。</p>
<p>相比之下，使用 Docker Hub 或任何其他 Docker 注册表，将本地镜像映射到远程镜像的过程有点不同——您使用标记。具体来说，您使用 Docker Hub 的用户名和存储库名称作为前缀来标记构建的镜像。</p>
<p>首先，您必须提供要发布的本地 Docker 镜像的源标签，例如 <code>page-tracker:dde1dc9</code> 。要找到您刚刚构建的 <code>page-tracker</code> 镜像的确切标签，请检查您当前的 Git 提交哈希或列出您现有的 <code>docker images</code> 。</p>
<p>一旦知道如何标记镜像，就可以使用相同的提交哈希来构建目标标签，该标签将在 Docker 注册表中标识您的存储库。请记住在创建新标签之前将 <code>realpython</code> 替换为您自己的 Docker Hub 用户名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker tag page-tracker:dde1dc9 realpython/page-tracker:dde1dc9
</span></span></code></pre></div><p>这会将新标签 <code>realpython/page-tracker:dde1dc9</code> 添加到标记为 <code>page-tracker:dde1dc9</code> 的本地镜像。目标标签的完整形式如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">registry/username/repository:tag
</span></span></code></pre></div><p>当你想推送到默认的 Docker Hub 时，可以省略注册表部分。否则，它可以是域地址，例如 <code>docker.io</code> ，或带有私有注册表实例的可选端口号的 IP 地址。用户名和存储库必须与您在 Docker Hub 或您使用的任何注册表上创建的用户名和存储库相对应。如果您不提供标签，那么 Docker 将隐式应用标签 <code>latest</code> ，这可能是未定义的。</p>
<p>您可以使用多个标签来标记同一镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker tag page-tracker:dde1dc9 realpython/page-tracker:latest
</span></span></code></pre></div><p>正确标记镜像后，您可以使用 <code>docker push</code> 将它们发送到所需的注册表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker push realpython/page-tracker:dde1dc9
</span></span><span class="line"><span class="cl">$ docker push realpython/page-tracker:latest
</span></span></code></pre></div><p>不要担心发送相同的镜像两次。 Docker 足够聪明，可以知道您之前何时推送过镜像，如果它在注册表中检测到该镜像，则只会传输必要的元数据。</p>
<p>当您在 Docker Hub 上刷新您的配置文件时，它应该反映您刚刚推送到存储库中的两个标签：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/docker_hub3.69a099d38e54.png" alt="Tagged Docker Images on Docker Hub"  />
</p>
<p>现在，当您将协作者添加到您的私有存储库时，他们将能够推送或拉取镜像。请记住，这需要在 Docker Hub 上升级订阅计划。</p>
<p>另一种方法是生成一个对所有存储库具有只读权限的访问令牌，或者创建一个公共存储库。</p>
<p>好的。终于到了通过在 Docker 容器中运行您的 dockerized Flask web 应用程序的机会了。</p>
<h3 id="运行一个-docker-容器">运行一个 Docker 容器</h3>
<p>如果你从一个干净的 Docker 环境开始，也许在另一台计算机上，那么你可以通过从 Docker Hub 拉取它来下载你的镜像，只要你有读取该存储库的权限：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker pull realpython/page-tracker
</span></span><span class="line"><span class="cl">Using default tag: latest
</span></span><span class="line"><span class="cl">latest: Pulling from realpython/page-tracker
</span></span><span class="line"><span class="cl">f1f26f570256: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">2d2b01660885: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">e4e8e4c0b0e1: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">1ba60f086308: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">3c2fccf90be1: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">15e9066b1610: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">e8271c9a01cc: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">4f4fb700ef54: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">bb211d339643: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">8690f9a37c37: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">7404f1e120d1: Pull <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">Digest: sha256:cc6fe40a1ac73e6378d0660bf386a1599880a30e422dc061680769bc4d501164
</span></span><span class="line"><span class="cl">Status: Downloaded newer image <span class="k">for</span> realpython/page-tracker:latest
</span></span><span class="line"><span class="cl">docker.io/realpython/page-tracker:latest
</span></span></code></pre></div><p>由于您没有为镜像指定任何标签，因此 Docker 会拉取标记为 <code>latest</code> 的标签。请注意，输出还包括镜像各个层的标识符，对应于用于构建该镜像的原始 Dockerfile 中的 11 条指令。</p>
<p>不过，您不必手动拉取镜像，因为 Docker 会在您第一次尝试运行它们时为您完成。如果指定的镜像已经在缓存中，那么一个新的容器将立即启动，而不会等到下载完成。</p>
<p>下面是基于新镜像运行新 Docker 容器的命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -p 80:5000 --name web-service realpython/page-tracker
</span></span><span class="line"><span class="cl"> * Serving Flask app <span class="s1">&#39;page_tracker.app&#39;</span>
</span></span><span class="line"><span class="cl"> * Debug mode: off
</span></span><span class="line"><span class="cl">WARNING: This is a development server. Do not use it in a production
</span></span><span class="line"><span class="cl">⮑ deployment. Use a production WSGI server instead.
</span></span><span class="line"><span class="cl"> * Running on all addresses <span class="o">(</span>0.0.0.0<span class="o">)</span>
</span></span><span class="line"><span class="cl"> * Running on http://127.0.0.1:5000
</span></span><span class="line"><span class="cl"> * Running on http://172.17.0.3:5000
</span></span><span class="line"><span class="cl">Press CTRL+C to quit
</span></span></code></pre></div><p>当您在本地开发项目时，使用端口转发通过主机的 localhost 访问 Web 服务器通常很方便。在这种情况下， <code>-p</code> 选项可让您导航到地址 <code>http://localhost:80</code> 或只是 <code>http://localhost</code> ，而无需知道正在运行的 Docker 容器的确切 IP 地址。端口 <code>80</code> 是 HTTP 协议的默认端口，这意味着您可以在 Web 浏览器中键入地址时省略它。</p>
<p>此外，此端口映射将确保在 <code>http://localhost:5000</code> 处没有网络端口冲突，以防您没有停止本地 Flask 实例。请记住，您之前启动了一个来执行端到端测试。如果进程仍在后台某处运行，它将占用 Flask 的默认端口 <code>5000</code> 。</p>
<blockquote>
<p>注意：为您的 Docker 容器提供一个描述性名称也很有用，例如 <code>web-service</code> ，这样您就可以通过名称重新启动或删除它，而无需查找相应的容器标识符。如果你不这样做，那么 Docker 会给你的容器一个愚蠢的名字，比如随机选择的 <code>admiring_jang</code> 或 <code>frosty_almeida</code> 。</p>
<p>如果您不想手动操作，请考虑添加 <code>--rm</code> 标志以在容器停止时自动删除它。</p>
</blockquote>
<p>正如您在上面的输出中看到的，Flask 服务器正在其容器内的所有网络接口 ( <code>0.0.0.0</code> ) 上运行，正如您在 Dockerfile 的 <code>CMD</code> 层中指示的那样。</p>
<p>继续并在您的 Web 浏览器中访问地址 <code>http://localhost</code> 或使用 <code>curl</code> 之类的命令行工具来访问 dockerized 页面跟踪器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ curl http://localhost
</span></span><span class="line"><span class="cl">Sorry, something went wrong 😔
</span></span></code></pre></div><p>由于 Redis 连接失败，您将看到预期的错误消息，但至少您可以访问在 Docker 容器中运行的 Flask 应用程序。要修复错误，您需要通过传递给 <code>web-service</code> 容器的环境变量指定正确的 Redis URL。</p>
<p>现在通过按键盘上的 Ctrl+C 或 Cmd+C 停止该容器。然后，找到容器的标识符并删除关联的容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker ps -a
</span></span><span class="line"><span class="cl">CONTAINER ID   IMAGE                     COMMAND                  CREATED
</span></span><span class="line"><span class="cl">dd446a1b72a7   realpython/page-tracker   <span class="s2">&#34;flask --app page_tr…&#34;</span>   <span class="m">1</span> minute ago
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker rm dd446a1b72a7
</span></span></code></pre></div><p><code>-a</code> 标志确保显示所有容器，包括已停止的容器。否则，你不会看到你的。</p>
<p>通过 Docker 将 Flask Web 应用程序连接到 Redis 的正确方法是创建专用虚拟网络。首先，列出可用网络以检查您是否已经创建了 <code>page-tracker-network</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network ls
</span></span><span class="line"><span class="cl">NETWORK ID     NAME                   DRIVER    SCOPE
</span></span><span class="line"><span class="cl">46e9ff2ec568   bridge                 bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">4795b850cb58   host                   host      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">f8f99d305c5e   none                   null      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">84b134794660   page-tracker-network   bridge    <span class="nb">local</span>
</span></span></code></pre></div><p>如果它不存在，那么您现在可以通过发出以下命令来创建一个：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network create page-tracker-network
</span></span></code></pre></div><p>以类似的方式，您可以为 Redis 服务器创建一个卷，以将其数据持久存储在您的主机上。这样，您可以重新启动甚至删除并从头开始创建一个新容器，Redis 将可以访问其之前的状态。这是使用 Docker 创建命名卷的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker volume create redis-volume
</span></span></code></pre></div><p>接下来，停止并移除任何可能挂起的 Redis 容器，然后启动一个新容器。这一次，您将容器连接到 <code>page-tracker-network</code> 并将其 <code>/data</code> 文件夹绑定到您刚刚创建的名为 <code>redis-volume</code> 的卷：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             -v redis-volume:/data <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --network page-tracker-network <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --name redis-service <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             redis:7.0.10-bullseye
</span></span></code></pre></div><p>当您在 GitHub 上查看 Redis 的官方 Docker 镜像时，您会看到一个在 <code>/data</code> 文件夹中定义挂载点的层。 Redis 会不时地将其状态转储到该文件夹中。通过将目录从您的主机挂载到此挂载点，即使容器重新启动，您也可以保持状态。</p>
<p>通过给你的容器一个描述性的名称， <code>redis-service</code> ，你将能够从同一网络上的另一个容器连接到它。就是这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             -p 80:5000 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             -e <span class="nv">REDIS_URL</span><span class="o">=</span>redis://redis-service:6379 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --network page-tracker-network <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             --name web-service <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>             realpython/page-tracker
</span></span></code></pre></div><p>您启动一个从 <code>page-tracker</code> 镜像派生的新容器，其中包含相当多的参数。以下是上述 <code>docker run</code> 命令中各个标志和选项的快速细分：</p>
<ul>
<li><code>-d</code> ：在后台运行容器，与终端分离。这意味着您将看不到 Flask 服务器的任何输出，并且您将无法再使用 Ctrl+C 或 Cmd+C 停止容器。</li>
<li><code>-p 80:5000</code> ：将容器的端口 <code>5000</code> 暴露在主机的端口 <code>80</code> 上，这样你就可以通过本地主机访问你的web应用程序。</li>
<li><code>-e REDIS_URL=...</code> : 将容器的环境变量设置为在同一网络上的另一个容器中运行的 Redis 服务器的地址。</li>
<li><code>--network page-tracker-network</code> : 指定容器使用的虚拟网络。这将允许同一网络上的其他容器通过抽象名称而不是 IP 地址与该容器通信。</li>
<li><code>--name web-service</code> : 为容器分配一个有意义的名称，这样更容易从 Docker 命令中引用容器。</li>
</ul>
<p>现在，当您在 Web 浏览器或终端中访问 Flask Web 应用程序时，您应该观察到正确的行为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ curl http://localhost
</span></span><span class="line"><span class="cl">This page has been seen <span class="m">1</span> times.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ curl http://localhost
</span></span><span class="line"><span class="cl">This page has been seen <span class="m">2</span> times.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ curl http://localhost
</span></span><span class="line"><span class="cl">This page has been seen <span class="m">3</span> times.
</span></span></code></pre></div><p>每次发送请求时，服务器都会以不同数量的页面浏览量进行响应。请注意，您正在通过本地主机访问服务器。如果您在 <code>web-service</code> 之前启动了 <code>redis-service</code> ，那么容器的 IP 地址可能已更改。</p>
<p>哇！光是启动和运行两项服务就需要做大量工作。如您所见，手动管理 Docker 镜像、容器、卷、网络、端口和环境变量会让人感到不知所措。而这只是表面现象！</p>
<p>想象一下，管理一个包含数十种服务的复杂应用程序需要付出多少努力，其中包括生产就绪监控、负载平衡、自动缩放等。</p>
<p>幸运的是，有更好的方法可以达到同样的效果。在下一节中，您将研究 Docker 之上的一个方便的抽象层，让您在定义持续集成管道之前使用单个命令编排这两种服务。</p>
<h2 id="使用-docker-compose-编排容器">使用 Docker Compose 编排容器</h2>
<p>大多数现实世界的应用程序由多个组件组成，这些组件自然会转化为 Docker 容器。例如，一个涉及更多的 Web 应用程序可能具有以下内容：</p>
<ul>
<li><strong>Back end:</strong> <a href="https://realpython.com/learning-paths/django-web-development/">Django</a>, <a href="https://realpython.com/fastapi-python-web-apis/">FastAPI</a>, <a href="https://realpython.com/learning-paths/flask-by-example/">Flask</a></li>
<li><strong>Front end:</strong> <a href="https://realpython.com/flask-by-example-integrating-flask-and-angularjs/">Angular</a>, <a href="https://realpython.com/the-ultimate-flask-front-end/#react-explained">React</a>, <a href="https://realpython.com/python-django-blog/#step-5-set-up-vuejs">Vue</a></li>
<li><strong>Cache:</strong> Couchbase, <a href="https://realpython.com/python-memcache-efficient-caching/">Memcached</a>, <a href="https://realpython.com/python-redis/">Redis</a></li>
<li><strong>Queue:</strong> ActiveMQ, <a href="https://realpython.com/queue-in-python/#apache-kafka-kafka-python3">Kafka</a>, <a href="https://realpython.com/queue-in-python/#rabbitmq-pika">RabbitMQ</a></li>
<li><strong>Database:</strong> <a href="https://realpython.com/python-mysql/">MySQL</a>, <a href="https://realpython.com/python-sql-libraries/#postgresql">PostgreSQL</a>, <a href="https://realpython.com/python-sqlite-sqlalchemy/">SQLite</a></li>
</ul>
<p>更大的应用程序可能会选择将其后端或前端组件细分为更多的微服务，负责身份验证、用户管理、订单处理、支付或消息传递等。</p>
<p>为了帮助管理并在某种程度上编排此类应用程序的多个 Docker 容器，您可以使用 Docker Compose。它是一种在 Docker 之上运行的工具，可简化运行多容器 Docker 应用程序。 Docker Compose 允许您根据相互依赖的服务及其配置和要求来定义您的应用程序。然后它将协调它们并将它们作为一个连贯的应用程序运行。</p>
<blockquote>
<p>注意：容器编排自动化分布式应用程序的部署、扩展和配置管理。虽然 Docker Compose 可以帮助进行基本形式的编排，但您最好在更复杂的大型系统中使用 Kubernetes 等工具。</p>
</blockquote>
<p>您将使用 Docker Compose 以声明方式描述您的多容器页面跟踪器应用程序，以及它的服务、网络和卷，使用单个配置文件。通过这样做，您将能够跟踪更改并将您的应用程序部署到任何环境。</p>
<p>不过，在深入研究之前，请确保您的计算机上安装了 Docker Compose。</p>
<h3 id="在您的计算机上设置-docker-compose">在您的计算机上设置 Docker Compose</h3>
<p>如果您按照有关设置 Docker Desktop 的说明进行操作，那么您应该已经安装了 Docker Compose。在您的终端中运行以下命令以确认这一点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose version
</span></span><span class="line"><span class="cl">Docker Compose version v2.17.2
</span></span></code></pre></div><p>使用捆绑了 Docker Compose 和一些其他组件的 Docker Desktop，目前是在 macOS 和 Windows 上获取 Docker Compose 的推荐方式。如果您使用的是 Linux，那么您可以尝试通过手动安装 Compose 插件或从您的发行版的软件包存储库安装替代路径。不幸的是，此方法可能不适用于最新和推荐的 Docker Compose 版本。</p>
<blockquote>
<p>注意：在过去，Docker Compose 是一个独立于 Docker 单独维护的项目。它最初是作为 Python 脚本实现的，最终被重写为 Go。</p>
<p>要使用 Docker Compose，您必须在命令行中调用 <code>docker-compose</code> （带连字符）可执行文件。但是，它现在已集成到 Docker 平台中，因此您可以将 Docker Compose 作为 <code>docker compose</code> 插件调用。这两个命令的工作原理应该相同，因为该插件是一种直接替代品。</p>
</blockquote>
<p>一旦您确认 Docker Compose 在您的终端中可用，您就可以开始了！</p>
<h3 id="定义多容器-docker-应用程序">定义多容器 Docker 应用程序</h3>
<p>由于您将定义一个多容器 Docker 应用程序，该应用程序可能会在未来增长以包含更多服务，因此有必要重新安排项目中的文件夹结构。在项目根文件夹中创建一个名为 <code>web/</code> 的新子文件夹，您将在其中存储与 Flask Web 服务相关的所有文件。</p>
<p>您的虚拟环境也属于这个新的子文件夹，因为其他服务可能是用完全外国的编程语言（如 C++ 或 Java）实现的。不幸的是，移动 <code>venv/</code> 文件夹可能会破坏相应激活脚本中硬编码的绝对路径。因此，移除旧的虚拟环境并在 <code>web/</code> 子文件夹中创建一个新的虚拟环境以确保安全：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; deactivate
</span></span><span class="line"><span class="cl">PS&gt; <span class="nb">cd</span> page-tracker<span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>PS&gt; rmdir venv<span class="se">\ </span>/s
</span></span><span class="line"><span class="cl">PS&gt; python -m venv web<span class="se">\v</span>env<span class="se">\ </span>--prompt page-tracker
</span></span><span class="line"><span class="cl">PS&gt; web<span class="se">\v</span>env<span class="se">\S</span>cripts<span class="se">\a</span>ctivate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> PS&gt; python -m pip install --upgrade pip
</span></span></code></pre></div><p>Linux + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ deactivate
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> page-tracker/
</span></span><span class="line"><span class="cl">$ rm -rf venv/
</span></span><span class="line"><span class="cl">$ python3 -m venv web/venv/ --prompt page-tracker
</span></span><span class="line"><span class="cl">$ <span class="nb">source</span> web/venv/bin/activate
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --upgrade pip
</span></span></code></pre></div><p>然后，将 Flask 应用程序移动到新的 <code>web/</code> 子文件夹，只留下 <code>.git/</code> 文件夹、 <code>.gitignore</code> 和任何其他与编辑器相关的配置文件。您可以将它们保存在项目根文件夹中，因为它们对项目中所有可能的服务都是通用的。之后，您的项目结构应如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── web/
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── src/
</span></span><span class="line"><span class="cl">│   │   └── page_tracker/
</span></span><span class="line"><span class="cl">│   │       ├── __init__.py
</span></span><span class="line"><span class="cl">│   │       └── app.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── test/
</span></span><span class="line"><span class="cl">│   │   ├── e2e/
</span></span><span class="line"><span class="cl">│   │   │   └── test_app_redis_http.py
</span></span><span class="line"><span class="cl">│   │   │
</span></span><span class="line"><span class="cl">│   │   ├── integration/
</span></span><span class="line"><span class="cl">│   │   │   └── test_app_redis.py
</span></span><span class="line"><span class="cl">│   │   │
</span></span><span class="line"><span class="cl">│   │   ├── unit/
</span></span><span class="line"><span class="cl">│   │   │   └── test_app.py
</span></span><span class="line"><span class="cl">│   │   │
</span></span><span class="line"><span class="cl">│   │   └── conftest.py
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── venv/
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── constraints.txt
</span></span><span class="line"><span class="cl">│   ├── Dockerfile
</span></span><span class="line"><span class="cl">│   ├── Dockerfile.dev
</span></span><span class="line"><span class="cl">│   └── pyproject.toml
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .git/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .gitignore
</span></span><span class="line"><span class="cl">└── docker-compose.yml
</span></span></code></pre></div><p>上面文件树的一个新添加是位于顶层的 <code>docker-compose.yml</code> 文件，您现在将编写该文件。</p>
<p>Docker Compose 使用 YAML 格式以声明方式描述应用程序的服务，这些服务将成为 Docker 容器、它们的网络、卷、端口映射、环境变量等。</p>
<p>以前，您必须手动定义应用程序架构的每一部分，但使用 Docker Compose，您可以在一个文件中定义所有内容。该工具甚至可以为您拉取或构建镜像！</p>
<blockquote>
<p>注意：如果您以前从未使用过 YAML，但熟悉 JSON，那么它的语法应该很熟悉，因为 YAML 是 JSON 的超集。查看 YAML：Python 中丢失的电池了解更多详细信息。</p>
</blockquote>
<p>Docker Compose 文件是您定义服务、网络和卷的地方。这是完整的 <code>docker-compose.yml</code> 文件，它反映了您在前面部分中为页面跟踪器应用程序手动定义的所有内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># docker-compose.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis:7.0.10-bullseye&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;redis-volume:/data&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">web-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;80:5000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">backend-network</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-volume</span><span class="p">:</span><span class="w">
</span></span></span></code></pre></div><p>你现在要逐行剖析它：</p>
<ul>
<li>第 3 行标志着两个服务 <code>redis-service</code> 和 <code>web-service</code> 声明的开始，它们包含一个多容器 Docker 应用程序。请注意，您可以扩展每个服务，因此 Docker 容器的实际数量可能大于此处声明的服务数量。</li>
<li>第 4 行到第 9 行定义了 <code>redis-service</code> 的配置，包括要运行的 Docker 镜像、要连接的网络以及要挂载的卷。</li>
<li>第 10 到 19 行通过指定包含要构建的 Dockerfile 的文件夹、要公开的端口、要设置的环境变量以及要连接的网络来配置 <code>web-service</code> 。 <code>depends_on</code> 语句要求 <code>redis-service</code> 在 <code>web-service</code> 开始之前可用。</li>
<li>第 21 和 22 行为您的两个服务定义了一个虚拟网络。此声明并非绝对必要，因为 Docker Compose 会自动创建容器并将其连接到新网络。但是，如果需要，显式网络声明可以让您更好地控制其设置和地址范围。</li>
<li>第 24 和 25 行为您的 Redis 服务器定义了一个持久卷。</li>
</ul>
<p>上面配置文件中的一些值被引用，而另一些则没有。这是针对旧 YAML 格式规范中已知怪癖的预防措施，该规范将某些字符视为特殊字符，如果它们出现在未加引号的字符串中。例如，冒号 ( <code>:</code> ) 可以使一些 YAML 解析器将文字解释为六十进制数字而不是字符串。</p>
<blockquote>
<p>注意：此文件符合最新和推荐的 Compose 规范，该规范不再需要顶级 <code>version</code> 字段，而早期的模式版本需要。阅读官方文档中的 Compose 文件版本控制以了解更多信息。</p>
</blockquote>
<p>停止任何可能仍在运行的与您的项目相关的 Docker 容器，并立即删除它们的关联资源：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker stop -t <span class="m">0</span> web-service redis-service
</span></span><span class="line"><span class="cl">$ docker container rm web-service redis-service
</span></span><span class="line"><span class="cl">$ docker network rm page-tracker-network
</span></span><span class="line"><span class="cl">$ docker volume rm redis-volume
</span></span></code></pre></div><p>这将删除您之前创建的两个容器、一个网络和一个卷。请注意，您可以将 <code>docker container rm</code> 命令缩写为更短的 <code>docker rm</code> 别名。</p>
<p>要优雅地删除容器，您应该首先停止它。默认情况下， <code>docker stop</code> 命令将在终止容器之前等待十秒钟，使其有足够的时间在退出之前执行任何必要的清理操作。因为您的 Flask 应用程序在停止运行后不需要做任何事情，您可以使用 <code>-t</code> 选项将此超时设置为零秒，这将立即终止列出的容器。</p>
<p>要删除所有关联的 Docker 镜像标签，您必须首先找到它们的公共标识符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker images
</span></span><span class="line"><span class="cl">REPOSITORY                TAG              IMAGE ID       CREATED      SIZE
</span></span><span class="line"><span class="cl">page-tracker              dde1dc9          9cb2e3233522   <span class="m">1</span> hour ago   204MB
</span></span><span class="line"><span class="cl">page-tracker              latest           9cb2e3233522   <span class="m">1</span> hour ago   204MB
</span></span><span class="line"><span class="cl">realpython/page-tracker   dde1dc9          9cb2e3233522   <span class="m">1</span> hour ago   204MB
</span></span><span class="line"><span class="cl">realpython/page-tracker   latest           9cb2e3233522   <span class="m">1</span> hour ago   204MB
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span></code></pre></div><p>在这种情况下， <code>page-tracker</code> 镜像的所有标签共有的短 ID 等于 <code>9cb2e3233522</code> ，您可以使用它来取消标记和删除底层 Docker 镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker rmi -f 9cb2e3233522
</span></span><span class="line"><span class="cl">Untagged: page-tracker:dde1dc9
</span></span><span class="line"><span class="cl">Untagged: page-tracker:latest
</span></span><span class="line"><span class="cl">Untagged: realpython/page-tracker:dde1dc9
</span></span><span class="line"><span class="cl">Untagged: realpython/page-tracker:latest
</span></span><span class="line"><span class="cl">Deleted: sha256:9cb2e3233522e020c366880867980232d747c4c99a1f60a61b9bece40...
</span></span></code></pre></div><p><code>docker rmi</code> 命令是 <code>docker image rm</code> 和 <code>docker image remove</code> 的别名。</p>
<blockquote>
<p>注意：如果你想从头开始使用全新的 Docker 环境，并且不介意丢失数据，那么你可以使用以下命令修剪所有系统资源：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker system prune --all --volumes
</span></span></code></pre></div><p>警告！这将删除您到目前为止使用 Docker 创建的所有内容，包括可能在本教程之外创建的资源，因此请谨慎操作。</p>
</blockquote>
<p>确认删除 Docker 资源后，您可以通过一条指令立即恢复您的页面跟踪器应用程序。在与 <code>docker-comopse.yml</code> 文件相同的文件夹中发出以下命令以避免指定其路径：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose up -d
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 4/4
</span></span><span class="line"><span class="cl"> ⠿ Network page-tracker_backend-network    Created                      0.1s
</span></span><span class="line"><span class="cl"> ⠿ Volume <span class="s2">&#34;page-tracker_redis-volume&#34;</span>      Created                      0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Started                      1.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Started                      1.3s
</span></span></code></pre></div><p>第一次运行此命令时，可能需要更长的时间，因为 Docker Compose 必须从 Docker Hub 下载 Redis 镜像并再次从 Dockerfile 构建另一个镜像。但在那之后，它应该感觉几乎是瞬间的。</p>
<p>您可以在上面的输出中看到 Docker Compose 创建了请求的网络、卷和两个容器。请注意，它始终在此类资源名称前加上您的 Docker Compose 项目名称前缀，该名称默认为包含您的 <code>docker-compose.yml</code> 文件的文件夹名称。在这种情况下，项目名称是 <code>page-tracker</code> 。此功能有助于防止不同 Docker Compose 项目的资源名称发生冲突。</p>
<p>此外，如果您想启动同一服务的多个副本，Docker Compose 会将连续的数字附加到您的容器名称中。</p>
<p>Docker Compose 插件提供了几个有用的命令来管理您的多容器应用程序。这里只是其中的几个：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose ps
</span></span><span class="line"><span class="cl">NAME                           COMMAND                  SERVICE        ...
</span></span><span class="line"><span class="cl">page-tracker-redis-service-1   <span class="s2">&#34;docker-entrypoint.s…&#34;</span>   redis-service  ...
</span></span><span class="line"><span class="cl">page-tracker-web-service-1     <span class="s2">&#34;flask --app page_tr…&#34;</span>   web-service    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose logs --follow
</span></span><span class="line"><span class="cl"><span class="o">(</span>...<span class="o">)</span>
</span></span><span class="line"><span class="cl">page-tracker-web-service-1    <span class="p">|</span>  * Running on all addresses <span class="o">(</span>0.0.0.0<span class="o">)</span>
</span></span><span class="line"><span class="cl">page-tracker-web-service-1    <span class="p">|</span>  * Running on http://127.0.0.1:5000
</span></span><span class="line"><span class="cl">page-tracker-web-service-1    <span class="p">|</span>  * Running on http://172.20.0.3:5000
</span></span><span class="line"><span class="cl">page-tracker-web-service-1    <span class="p">|</span> Press CTRL+C to quit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose stop
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/2
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Stopped                     10.3s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Stopped                      0.4s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose restart
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/2
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Started                      0.4s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Started                      0.5s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose down --volumes
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 4/4
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Removed                      6.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Removed                      0.4s
</span></span><span class="line"><span class="cl"> ⠿ Volume page-tracker_redis-volume        Removed                      0.0s
</span></span><span class="line"><span class="cl"> ⠿ Network page-tracker_backend-network    Removed                      0.1s
</span></span></code></pre></div><p>例如，您可以列出 Docker Compose 项目中的容器而不显示任何其他容器。使用相关命令，您可以查看它们的实时输出、停止、启动和重新启动它们。</p>
<p>完成项目后，您可以将其拆除，Docker Compose 将删除关联的容器和网络。但是，它不会触及持久数据存储，除非您使用 <code>--volumes</code> 标志明确请求。</p>
<p>您可能已经在日志中注意到一件事，Flask 已经抱怨了很长时间，那就是使用其不安全、低效且不稳定的开发 Web 服务器来运行您的应用程序。您现在将使用 Docker Compose 来解决这个问题。</p>
<h3 id="将-flask-的开发-web-服务器替换为-gunicorn">将 Flask 的开发 Web 服务器替换为 Gunicorn</h3>
<p>Docker 允许您在运行新容器时覆盖 Dockerfile 中列出的默认命令或入口点。例如， <code>redis</code> 镜像中的默认命令启动 Redis 服务器。但是，您之前使用相同的镜像在另一个容器中启动 <code>redis-cli</code> 。同样，您可以在 <code>docker-compose.yml</code> 文件中为您的 Docker 镜像指定自定义命令。您将使用此功能通过生产级 Web 服务器运行 Flask。</p>
<blockquote>
<p>注意：有时，您想要调查现有容器。要在正在运行的容器中运行命令而不是启动新容器，可以使用 <code>docker exec</code> 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker <span class="nb">exec</span> -it -u root page-tracker-web-service-1 /bin/bash
</span></span><span class="line"><span class="cl">root@6e23f154a5b9:/home/realpython#
</span></span></code></pre></div><p>通过运行 Bash 可执行文件 <code>/bin/bash</code> 并使用 <code>-u</code> 选项指定用户，您可以有效地访问容器，就像通过 SSH 登录远程服务器一样。 <code>-it</code> 标志是运行交互式终端会话所必需的。否则，该命令将立即退出。</p>
</blockquote>
<p>有几个选项可以替换 Flask 的内置开发 Web 服务器，官方文档在部署到生产时推荐使用这些选项。最受欢迎的选择之一是 Gunicorn (Green Unicorn)，它是 Web 服务器网关接口 (WSGI) 协议的纯 Python 实现。要开始使用它，您必须将 <code>gunicorn</code> 包添加为项目中的另一个依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="c"># web/pyproject.toml</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">build-system</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">requires</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;setuptools&gt;=67.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;wheel&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">build-backend</span> <span class="p">=</span> <span class="s2">&#34;setuptools.build_meta&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;page-tracker&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dependencies</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Flask&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;gunicorn&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;redis&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">optional-dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">dev</span> <span class="p">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;bandit&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;black&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;flake8&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;isort&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pylint&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;pytest-timeout&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;requests&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></div><p>请注意，您将 <code>gunicorn</code> 添加到常规依赖项列表中，因为它将成为您应用程序不可或缺的一部分。您希望在构建最终 Docker 镜像后它可用。</p>
<p>像往常一样，在本地重新安装您的 <code>page-tracker</code> 包并将其依赖项固定在约束文件中。请记住，您可能需要先激活您的虚拟环境，因为您之前在 <code>web/</code> 子文件夹中重新创建了它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip install --editable <span class="s2">&#34;web/[dev]&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pip freeze --exclude-editable &gt; web/constraints.txt
</span></span></code></pre></div><p>请注意，当您从项目的根文件夹中执行这些命令时，它们看起来会略有不同。在这种情况下，您必须将指示当前工作目录的点 ( <code>.</code> ) 替换为您的 <code>web/</code> 子文件夹的路径。</p>
<p>现在您已经安装了 Gunicorn，您可以开始使用它了。通过在 <code>web-service</code> 键下添加新的 <code>command</code> 属性来修改 <code>docker-compose.yml</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># docker-compose.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis:7.0.10-bullseye&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;redis-volume:/data&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">web-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;80:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;gunicorn page_tracker.app:app --bind 0.0.0.0:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">backend-network</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-volume</span><span class="p">:</span><span class="w">
</span></span></span></code></pre></div><p>此命令将优先于 Dockerfile 的默认命令，后者依赖于 Flask 的开发服务器。从现在开始，Docker Compose 将改为使用 Gunicorn 运行您的 Web 应用程序。为了显示差异，您将在端口 <code>8000</code> 而不是 <code>5000</code> 上运行服务器，因此您还更改了端口映射。</p>
<p>通过在主机上公开端口 <code>80</code> ，您仍然可以在不指定端口号的情况下访问 <code>http://localhost</code> 上的应用程序。</p>
<p>不要忘记提交更改以将您的工作保存在本地 Git 存储库中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git add .
</span></span><span class="line"><span class="cl">$ git commit -m <span class="s2">&#34;Refactor folders and add Docker Compose&#34;</span>
</span></span></code></pre></div><p>进行小而频繁的提交总是一个好主意，这样您就可以随着时间的推移跟踪增量更改并更好地了解您的工作历史。如果您不确定如何描述您的提交，请尝试解释为什么您进行了特定更改，因为 Git 已经跟踪更改的内容。</p>
<p>好的。如果您现在尝试重新启动 Docker Compose 应用程序，那么它将失败，因为 Docker 在容器启动期间找不到请求的 <code>gunicorn</code> 可执行文件。您已经添加了您之前构建的 Docker 镜像中缺少的额外依赖项。因此，你必须告诉 Docker Compose 重建你的镜像。您可以使用以下任一命令执行此操作：</p>
<ul>
<li>docker compose build</li>
<li>docker compose up &ndash;build</li>
</ul>
<p>在第一种情况下，您会明确告诉 Docker 预先构建镜像。每当您更改项目依赖项或 Dockerfile 时，您都必须再次运行 <code>docker compose build</code> 以应用这些更改。</p>
<p>在第二种情况下， <code>docker compose up --build</code> 将指示 Docker 在每次启动容器时即时构建镜像。如果您试图快速迭代对源代码或 Dockerfile 的更改，这将特别有用。</p>
<p>无论哪种方式，这两个命令都应该在启动相应容器之前在任何受影响的 Docker 镜像中成功构建修改后的层。然后，您可以放心，当您的 Docker Compose 应用程序再次启动时，所有依赖项都将可用。</p>
<p>继续并立即运行这些命令之一。</p>
<p>因为您了解如何使用 Docker Compose 来管理应用程序的服务，所以您现在可以了解如何在接近生产的环境中运行端到端测试。</p>
<h3 id="针对服务运行端到端测试">针对服务运行端到端测试</h3>
<p>在第一次尝试中，您将从主机本地执行端到端测试。请注意，必须可以从您的本地网络访问所有必要的服务才能使其正常工作。</p>
<p>虽然这并不理想，因为您不想向公众公开任何敏感服务（如数据库），但稍后您将了解更好的方法。同时，您可以更新您的 <code>docker-compose.yml</code> 配置以转发 Redis 端口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># docker-compose.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis:7.0.10-bullseye&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;6379:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;redis-volume:/data&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">web-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;80:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;gunicorn page_tracker.app:app --bind 0.0.0.0:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">backend-network</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-volume</span><span class="p">:</span><span class="w">
</span></span></span></code></pre></div><p>如果您有一个用于 <code>redis-service</code> 的现有 Docker 容器，那么您需要先删除该容器，即使它当前已停止，以反映新的端口转发规则。幸运的是，Docker Compose 会自动检测 <code>docker-compose.yml</code> 文件中的更改，并在您发出 <code>docker compose up</code> 命令时根据需要重新创建容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose up -d
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/2
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Started                      1.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Started                      1.2s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose ps
</span></span><span class="line"><span class="cl">NAME                           ...   PORTS
</span></span><span class="line"><span class="cl">page-tracker-redis-service-1   ...   0.0.0.0:6379-&gt;6379/tcp
</span></span><span class="line"><span class="cl">page-tracker-web-service-1     ...   0.0.0.0:80-&gt;8000/tcp
</span></span></code></pre></div><p>列出新容器后，您应该会看到 Redis 容器上的端口 <code>6379</code> 被转发到主机。有了这个，您现在可以使用安装在开发机器上的虚拟环境中的 <code>pytest</code> 运行端到端测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>page-tracker<span class="o">)</span> $ python -m pytest web/test/e2e/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --flask-url http://localhost <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --redis-url redis://localhost:6379
</span></span></code></pre></div><p>由于端口映射，您可以使用 localhost 连接到容器，而无需知道它们各自的 IP 地址。</p>
<blockquote>
<p>注意：如果您的测试成功，那么它将覆盖 Redis 中的页面浏览量。根据经验，您永远不应该在带有客户数据的实时环境中运行测试，以避免破坏它。通常建议使用带有虚假或匿名数据的暂存或认证环境来安全地执行全面的端到端测试。</p>
</blockquote>
<p>要模拟故障，您可以在测试执行期间暂时暂停容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose pause
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/0
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Paused                       0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Paused                       0.0s
</span></span></code></pre></div><p>这将使 Redis 和您的 Flask 应用程序无法再访问。与停止容器不同，暂停它不会终止底层进程，因此暂停会保持容器的状态并导致更快的恢复。</p>
<p>之后不要忘记取消暂停容器以避免以后出现错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose unpause
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 2/0
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Unpaused                     0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Unpaused                     0.0s
</span></span></code></pre></div><p>或者，您可以从同一网络上的另一个容器运行它，而不是在本地针对公开服务运行端到端测试。您可以手动制作这样的容器。</p>
<p>然而，最近版本的 Docker Compose 提供了一个更优雅的解决方案，它允许您有条件地运行服务的子集。为此，您可以将所需的服务分配给可按需激活的自定义配置文件。</p>
<p>首先，打开你的 <code>docker-compose.yml</code> 文件并从 Redis 中删除端口转发，因为你不想再将它暴露给外界。然后，基于您的旧 <code>Dockerfile.dev</code> 添加一个新服务，它捆绑了测试框架、测试装置和您的测试代码。您将使用相应的 Docker 镜像来执行端到端测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="w"> </span><span class="c"># docker-compose.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis:7.0.10-bullseye&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;redis-volume:/data&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">web-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;80:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;gunicorn page_tracker.app:app --bind 0.0.0.0:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">test-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">profiles</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">testing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">context</span><span class="p">:</span><span class="w"> </span><span class="l">./web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">dockerfile</span><span class="p">:</span><span class="w"> </span><span class="l">Dockerfile.dev</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REDIS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis://redis-service:6379&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">FLASK_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;http://web-service:8000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">backend-network</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">redis-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">web-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="p">&gt;</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">      sh -c &#39;python -m pytest test/e2e/ -vv
</span></span></span><span class="line"><span class="cl"><span class="sd">      --redis-url $$REDIS_URL
</span></span></span><span class="line"><span class="cl"><span class="sd">      --flask-url $$FLASK_URL&#39;</span><span class="w">      
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">backend-network</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">redis-volume</span><span class="p">:</span><span class="w">
</span></span></span></code></pre></div><p><code>docker-compose.yml</code> 文件的大部分内容保持不变，因此您可以将注意力集中在突出显示的行上：</p>
<ul>
<li>
<p>第 22 行定义了您的新服务将属于的配置文件列表。只有一个配置文件，称为 <code>testing</code> ，您将启用它来运行测试。</p>
</li>
<li>
<p>第 24 到 26 行指定包含要构建的 Dockerfile 的目录的路径。由于该文件有一个非标准名称，您需要明确提供它。</p>
</li>
<li>
<p>第 27 到 29 行定义了两个环境变量，您的测试将使用它们连接到在 Gunicorn 服务器后面运行的 Redis 和 Flask。请注意，您使用 Docker Compose 服务名称作为主机名。</p>
</li>
<li>
<p>第 30 和 31 行将服务连接到与其他两个服务相同的网络。</p>
</li>
<li>
<p>第 32 到 34 行确保 Redis 和 Flask 在端到端测试之前启动。</p>
</li>
<li>
<p>第 35 到 38 行定义了在服务启动时运行的命令。请注意，您使用 YAML 的多行文字折叠 ( <code>&gt;</code> ) 以更具可读性的方式格式化长 shell 命令。</p>
</li>
</ul>
<p>因为 Docker Compose 可以访问您主机的 shell，所以它会尝试插入对环境变量的任何引用，例如 <code>$REDIS_URL</code> 或 <code>$FLASK_URL</code> ，一旦文件被解析，就会出现在您的 <code>docker-compose.yml</code> 中。不幸的是，这些变量很可能尚未定义。您通过服务的 <code>environment</code> 部分指定它们，这意味着您的容器稍后将获取这些变量。</p>
<p>要禁用 Docker Compose 过早替换环境变量，您可以使用两个美元符号 ( <code>$$</code> ) 转义美元符号。这反过来会在将在生成的容器中执行的命令中生成文字字符串 <code>$REDIS_URL</code> 和 <code>$FLASK_URL</code> 。要在容器启动时插入这些变量，您必须将整个命令用单引号 ( <code>'</code> ) 括起来，并将其传递给 shell ( <code>sh</code> )。</p>
<p>当您使用 Docker Compose 启动多容器应用程序时，只有不属于任何配置文件的核心服务会启动。如果您还希望启动分配给一个或多个配置文件的服务，则必须使用 <code>--profile</code> 选项列出这些配置文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose --profile testing up -d
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Running 3/3
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-redis-service-1  Running                      0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-web-service-1    Running                      0.0s
</span></span><span class="line"><span class="cl"> ⠿ Container page-tracker-test-service-1   Started                      0.6s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker compose ps -a
</span></span><span class="line"><span class="cl">NAME                           ...   SERVICE             STATUS       ...
</span></span><span class="line"><span class="cl">page-tracker-redis-service-1   ...   redis-service       running      ...
</span></span><span class="line"><span class="cl">page-tracker-test-service-1    ...   test-service        exited <span class="o">(</span>0<span class="o">)</span>   ...
</span></span><span class="line"><span class="cl">page-tracker-web-service-1     ...   web-service         running      ...
</span></span></code></pre></div><p>请注意，这是 <code>docker compose</code> 命令的一个选项，而不是它的 <code>up</code> 子命令，因此请注意参数顺序。输出显示启动了一个额外的服务，但是当您调查它时，您会注意到 <code>test-service</code> 以成功状态零快速退出。</p>
<p>要显示有关此服务的更多信息，您可以查看其日志：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker compose logs test-service
</span></span><span class="line"><span class="cl"><span class="o">=============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">==========================</span>
</span></span><span class="line"><span class="cl">platform linux -- Python 3.11.2, pytest-7.2.2, pluggy-1.0.0 -- /home/realp..
</span></span><span class="line"><span class="cl">cachedir: .pytest_cache
</span></span><span class="line"><span class="cl">rootdir: /home/realpython
</span></span><span class="line"><span class="cl">plugins: timeout-2.1.0
</span></span><span class="line"><span class="cl">collecting ... collected <span class="m">1</span> item
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">test/e2e/test_app_redis_http.py::test_should_update_redis ... PASSED <span class="o">[</span>100%<span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">==============================</span> <span class="m">1</span> passed in 0.10s <span class="o">===========================</span>
</span></span></code></pre></div><p>这将向您显示有关该服务的详细信息，包括 <code>pytest</code> 报告形式的测试结果，以及可能发生的任何错误。在这种情况下，测试成功通过。请注意，为简洁起见，对上面的输出进行了编辑。</p>
<p>到目前为止，您已经使用 Git 对源代码进行了版本控制。您自动化了各种级别的测试并使用 Docker 构建了您的应用程序。最后，您使用 Docker Compose 编排了多个容器。</p>
<p>此时，您已准备好继续下一步，即使用 Docker 构建持续集成管道。</p>
<h2 id="定义一个基于-docker-的持续集成管道">定义一个基于 Docker 的持续集成管道</h2>
<p>持续集成 (CI) 的目标是通过尽可能频繁地集成团队中多个开发人员的代码更改来实现更快、更可预测的软件发布。</p>
<p>在过去，集成是一项重大任务，通常需要数周甚至数月才能完成，有时还需要专门的集成工程师团队。</p>
<p>这种方法的问题是团队中的每个人都在自己的项目副本上工作。集成阶段延迟的时间越长，项目的不同版本就越有可能出现分歧，从而难以将它们结合起来。</p>
<p>在某些情况下，集成可能比项目的实际开发花费更多的时间！</p>
<p>连续这个词意味着集成应该经常进行，以最小化更改的范围并降低将缺陷引入代码库的风险。团队每天至少整合一次开发人员的工作，最好是一天多次，这已成为标准做法。</p>
<p>为了使这成为可能，持续集成需要构建和测试自动化以及具有相对较小功能的短期代码分支来实现。功能切换可以帮助实现需要更长时间开发的更大功能。此外，在尝试集成更改失败后修复失败的构建应该是团队的优先事项，以保持流程真正连续。</p>
<p>要在您的项目中引入持续集成，您需要以下元素：</p>
<ul>
<li>版本控制系统</li>
<li>分支策略</li>
<li>自动构建</li>
<li>自动化测试</li>
<li>持续集成服务器</li>
<li>频繁集成</li>
</ul>
<p>像 Git 这样的版本控制系统允许多人同时处理同一段代码。根据您的团队结构、经验和其他因素，您可以选择不同的源代码控制分支模型，也称为工作流。一些最受欢迎的包括：</p>
<ul>
<li><a href="https://trunkbaseddevelopment.com/">Trunk-Based Development</a></li>
<li><a href="https://docs.github.com/en/get-started/quickstart/github-flow">GitHub Flow</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow">Forking Workflow</a></li>
<li><a href="https://martinfowler.com/articles/branching-patterns.html#release-branch">Release Branching</a></li>
<li><a href="https://nvie.com/posts/a-successful-git-branching-model/">Git Flow</a></li>
</ul>
<p>各有利弊，适用于不同的场景。例如，分叉策略在开源项目中运作良好，因为它允许任何人在没有特别许可的情况下做出贡献。在本教程中，您将使用称为 GitHub Flow 的流行功能分支工作流程。它只有一个长期存在的主线或主干，传统上称为 master 分支，您可以从中分支出几个短期存在的功能分支。</p>
<blockquote>
<p>注意：尽管使用术语 <code>master</code> 来指代主分支的传统由来已久，但 GitHub 最近宣布将其默认分支名称更改为 <code>main</code> 以更好地反映其目的并避免冒犯性语言。</p>
<p>同时，当您初始化一个新的存储库时，Git 会继续使用 <code>master</code> ，这在您尝试同步本地和远程存储库时偶尔会出现问题。因此，您将坚持在本教程中使用 <code>master</code> 来保持简单，但如果您想更改默认分支名称，请随时采取额外的步骤。您可以在 GitHub 存储库设置中调整默认分支名称。</p>
</blockquote>
<p>虽然您会发现几种不同的方法来实现与 GitHub Flow 的持续集成，但这些是您将针对 Docker 应用程序遵循的步骤：</p>
<ul>
<li>将最新版本的主线获取到您的计算机。</li>
<li>从主线创建一个功能分支。</li>
<li>打开拉取请求以从其他人那里获得早期反馈。</li>
<li>继续在你的功能分支上工作。</li>
<li>经常获取主线，将其合并到您的功能分支并在本地解决任何潜在的冲突。</li>
<li>在本地分支上构建、lint 和测试代码。</li>
<li>只要本地构建和测试成功，就推送您的更改。</li>
<li>每次推送时，检查针对您的功能分支在 CI 服务器上运行的自动化测试。</li>
<li>在再次推送代码之前，在本地重现并修复任何已识别的问题。</li>
<li>完成并通过所有测试后，请求一名或多名同事审查您的更改。</li>
<li>应用他们的反馈，直到审阅者批准您的更新并且所有测试在推送您的最新更改后通过 CI 服务器。</li>
<li>通过将功能分支合并到主线来关闭拉取请求。</li>
<li>对照主线检查 CI 服务器上运行的自动化测试，并集成功能分支的更改。</li>
<li>调查并修复可能发现的任何问题，例如，由于在您上次推送和合并之间其他人向主线引入了新更新。</li>
</ul>
<p>此列表非常全面，但没有适合所有人的单一持续集成流程。您甚至可以比这更彻底，例如，使用 Terraform 或 GitHub Codespaces 提供专用的暂存环境，并将您的功能分支部署到云中，以便在关闭拉取请求之前进行额外的手动测试。但是，为每个拉取请求启动一个新环境可能不符合成本效益。</p>
<blockquote>
<p>注意：软件工程团队通常将持续集成与持续交付结合起来，形成一个称为 CI/CD 的流程。持续交付是持续集成的扩展，它增加了额外的步骤来将经过验证和集成的构建部署到生产环境。</p>
<p>虽然持续交付提供了将构建自动部署到生产环境的技术手段，但它仍然需要业务决策和手动触发。</p>
<p>不要混淆持续交付和持续部署，后者是一个完全自动化的过程，无需人工干预即可将应用程序部署到生产环境。在持续部署中，一旦你推送代码，它就会被测试并集成到主线中，然后最终进入生产环境。</p>
<p>但是，要成功做到这一点，您需要广泛的测试范围和对自动化过程的信任。</p>
</blockquote>
<p>值得强调的重要一点是涉及的测试量。您应该在本地和持续集成服务器上测试您的功能分支，然后针对集成主线再次运行测试。</p>
<p>这是为了确保您的功能正常工作并且不会破坏主线。</p>
<p>您有许多选项可以为您的 Docker 应用程序设置持续集成服务器，包括在线和自托管。流行的选择包括 CircleCI、Jenkins 和 Travis。在本教程中，您将使用 GitHub Actions，这是 GitHub 提供的免费 CI 解决方案。</p>
<h3 id="将代码推送到-github-存储库">将代码推送到 GitHub 存储库</h3>
<p>要利用 GitHub Actions，您必须首先在 GitHub 上创建一个存储库。如果您还没有帐户，请注册，然后登录并创建一个名为 <code>page-tracker</code> 的新存储库。</p>
<p>公共存储库可以无限制地使用 GitHub Actions，而私有存储库每月可在免费层获得 2000 分钟和 500 兆字节的存储空间。</p>
<p>但是，在 Windows 上运行的作业将消耗比在 Linux 上多一倍的分钟数，而在 macOS 上运行的作业将消耗十倍的分钟数！您可以在官方文档中找到有关 GitHub Actions 计费的更多详细信息。</p>
<p>稍后，您将启用分支保护规则，该规则目前仅适用于免费层的公共存储库，因此最好现在就创建一个公共存储库。</p>
<p>保留建议的默认值而不使用 GitHub 的占位符文件初始化新存储库，因为您将推送现有项目。接下来，转到终端并将工作目录更改为您的 <code>page-tracker</code> 项目所在的位置。它应该已经初始化了一个本地 Git 存储库，稍后您将连接到 GitHub。但首先，将所有未决更改提交到本地存储库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">Changes not staged <span class="k">for</span> commit:
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span class="o">)</span>
</span></span><span class="line"><span class="cl">        modified:   docker-compose.yml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">no changes added to commit <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> and/or <span class="s2">&#34;git commit -a&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git commit -am <span class="s2">&#34;Add a test-service to Docker Compose&#34;</span>
</span></span></code></pre></div><p>在提交任何更改之前检查存储库的状态始终是个好主意。您现在可以使用以下两个命令将本地存储库连接到 GitHub：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git remote add origin git@github.com:realpython/page-tracker.git
</span></span><span class="line"><span class="cl">$ git push -u origin master
</span></span></code></pre></div><p>确保将 <code>realpython</code> 替换为您的 GitHub 用户名。第一个命令会将您刚刚创建的 GitHub 上的远程存储库添加到您在 <code>origin</code> 别名下的本地副本。第二个命令会将本地存储库的内容推送到 GitHub。</p>
<p>之后您可以使用您的 GitHub 存储库刷新网页以确认您的文件已成功发送。当您这样做时，您将准备好使用 GitHub Actions 为您的 Docker 应用程序构建持续集成工作流程！</p>
<h3 id="学习-github-actions">学习 GitHub Actions</h3>
<p>首先，熟悉一些新术语会有所帮助。 GitHub Actions 允许您指定一个或多个由特定事件触发的工作流程，例如将代码推送到分支或打开新的拉取请求。每个工作流都可以定义许多由步骤组成的作业，这些作业将在运行器上执行。有两种类型的跑步者：</p>
<ul>
<li>GitHub 托管的运行器：Ubuntu Linux、Windows、macOS</li>
<li>自托管运行器：您拥有和维护的本地服务器</li>
</ul>
<p>在本教程中，您将只使用 GitHub 提供的最新 Ubuntu Linux 运行器。请注意，可以在多个运行器上执行相同的作业，例如检查跨平台兼容性。</p>
<p>除非您另有说明，否则一个工作流程中的作业将在不同的运行器上并行运行，这对于加快构建速度很有用。同时，您可以使一项工作依赖于其他工作。</p>
<p>使用 GitHub Actions 减少构建时间的另一种方法是启用工作流依赖缓存。</p>
<p>作业的每个步骤都由一个动作实现，该动作可以是：</p>
<ul>
<li>自定义 shell 命令或脚本</li>
<li>在另一个 GitHub 存储库中定义的 GitHub 操作</li>
</ul>
<p>有许多预定义的 GitHub 操作，您可以在 GitHub Marketplace 上浏览和查找。社区提供并维护它们。例如，有一个用于在 GitHub 上构建和推送 Docker 组织拥有的 Docker 镜像。由于有许多相互竞争的插件，有时有不止一种方法可以使用 GitHub Actions 达到预期的结果。</p>
<p>与如今与 DevOps 相关的许多工具一样，GitHub 使用 YAML 格式来配置工作流。它会在您的存储库的根文件夹中寻找一个特殊的 <code>.github/workflows/</code> 文件夹，您可以在其中放置多个 YAML 文件，每个文件对应一个不同的工作流程。此外，您可以在其中包含其他文件，例如要在运行器上执行的配置文件或自定义脚本。</p>
<p>您只会为持续集成定义一个工作流程，因此请继续创建必要的文件夹结构，其中包含一个名为 <code>ci.yml</code> 的文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">page-tracker/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── web/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .git/
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .github/
</span></span><span class="line"><span class="cl">│   └── workflows/
</span></span><span class="line"><span class="cl">│       └── ci.yml
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── .gitignore
</span></span><span class="line"><span class="cl">└── docker-compose.yml
</span></span></code></pre></div><p>尽管您可以使用任何您喜欢的代码编辑器为 GitHub Actions 编写工作流文件，但在这种情况下请考虑使用 GitHub 的基于 Web 的编辑器。它不仅提供通用的 YAML 语法突出显示，还提供架构验证和对可用 GitHub Actions 属性的智能建议。因此，您可以先将代码推送到 GitHub，然后使用内置编辑器直接在那里编辑您的 <code>ci.yml</code> 文件。</p>
<p>要打开 GitHub 内置的编辑器，请将 Web 浏览器导航到 <code>ci.yml</code> 文件，然后按 E 或单击铅笔图标。您现在可以开始编写 GitHub Actions 工作流文件。</p>
<h3 id="使用-github-actions-创建工作流">使用 GitHub Actions 创建工作流</h3>
<p>在编辑 <code>ci.yml</code> 文件时，为新工作流指定一个描述性名称并定义应触发它的事件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># .github/workflows/ci.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Continuous Integration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span></code></pre></div><p>将触发此工作流的两个事件是：</p>
<ol>
<li>打开或更改针对 <code>master</code> 分支的拉取请求</li>
<li>推送代码或将分支合并到 <code>master</code> 分支</li>
</ol>
<p>除了分支名称之外，您还可以为每个事件添加更多属性以缩小触发条件。例如，您可以提供充当正过滤器的文件路径模式，该模式仅在某些文件发生更改时才运行工作流。</p>
<p>毕竟，您可能不想在编辑 README 文件或更新文档后运行整个持续集成工作流程。不管怎样，你现在会让事情保持简单。</p>
<p>您的持续集成工作流程的工作是构建 Docker 镜像，使用 Docker Compose 运行端到端测试，如果一切顺利，将构建的镜像推送到 Docker Hub。</p>
<p>感谢您全面的 Dockerfile，将单元测试、各种静态代码分析工具和安全扫描集成到一个命令中。因此，您无需为 CI 工作流程编写大量 YAML。</p>
<p>GitHub Action 工作流中的几乎每项工作都是从从 GitHub 存储库中检出代码开始的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># .github/workflows/ci.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Continuous Integration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">build</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build Docker image and run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Checkout code from GitHub</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v3</span><span class="w">
</span></span></span></code></pre></div><p>您指定一个标识为 <code>build</code> 的作业，它将在 GitHub 提供的最新 Ubuntu 运行器上运行。它的第一步是使用 <code>actions/checkout</code> GitHub 操作检查触发工作流的单个提交。因为 GitHub Actions 实际上是伪装的 GitHub 存储库，所以您可以在 at 符号 ( <code>@</code> ) 后提供 Git 标记或提交哈希以选择特定版本的操作。</p>
<p>作为持续集成管道的下一步，您希望在通过 Docker Compose 执行端到端测试之前为您的 Web 和测试服务构建 Docker 镜像。这次您将在运行器上运行一个 shell 命令，而不是使用现有的操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># .github/workflows/ci.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Continuous Integration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">build</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build Docker image and run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Checkout code from GitHub</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="p">&gt;</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">          docker compose --profile testing up
</span></span></span><span class="line"><span class="cl"><span class="sd">          --build
</span></span></span><span class="line"><span class="cl"><span class="sd">          --exit-code-from test-service</span><span class="w">          
</span></span></span></code></pre></div><p>这两个步骤将始终运行以响应文件顶部列出的事件，即打开拉取请求或将功能分支合并到主线中。</p>
<p>此外，在成功将分支合并到主线后，当所有测试都通过时，您需要将新的 Docker 镜像推送到 Docker Hub。因此，只有当 <code>push</code> 事件触发您的工作流程时，您才会有条件地运行后续步骤。</p>
<p>但是，如何使用 GitHub Actions 安全访问 Docker Hub 而不会泄露您的秘密？你现在就会知道了。</p>
<h3 id="通过-github-actions-secrets-访问-docker-hub">通过 GitHub Actions Secrets 访问 Docker Hub</h3>
<p>早些时候，当您将其中一个 Docker 镜像从终端推送到 Docker Registry 时，您必须通过调用 <code>docker login</code> 并提供您的用户名和密码来登录 Docker Hub。此外，如果启用双因素身份验证，则必须生成具有足够权限的个人访问令牌并提供它而不是密码。</p>
<p>从自动化工作流程推送镜像的步骤相似，因此您必须先进行身份验证。您可以使用 shell 命令或预定义的 GitHub 操作来执行此操作，例如 <code>docker/login-action</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># .github/workflows/ci.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Continuous Integration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">build</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build Docker image and run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Checkout code from GitHub</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Run end-to-end tests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="p">&gt;</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">          docker compose --profile testing up
</span></span></span><span class="line"><span class="cl"><span class="sd">          --build
</span></span></span><span class="line"><span class="cl"><span class="sd">          --exit-code-from test-service</span><span class="w">          
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Login to Docker Hub</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">docker/login-action@v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">if</span><span class="p">:</span><span class="w"> </span><span class="l">${{ github.event_name == &#39;push&#39; }}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">username</span><span class="p">:</span><span class="w"> </span><span class="l">${{ secrets.DOCKERHUB_USERNAME }}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">password</span><span class="p">:</span><span class="w"> </span><span class="l">${{ secrets.DOCKERHUB_TOKEN }}</span><span class="w">
</span></span></span></code></pre></div><p>您有条件地运行此步骤，方法是使用包含在美元符号和双大括号中的 JavaScript 表达式从 <code>github</code> 上下文获取事件类型。然后，您通过另一个预定义的 <code>secrets</code> 上下文和您现在将要定义的两个自定义常量提供您的秘密 Docker Hub 凭据。</p>
<p>通过单击顶部工具栏中带有齿轮图标的选项卡打开 GitHub 存储库的设置，找到并展开安全部分下的秘密和变量，然后单击操作。这将带您进入一个面板，您可以在该面板中为 GitHub Actions 运行器定义环境变量和加密机密。现在，指定您的 <code>DOCKERHUB_USERNAME</code> 和 <code>DOCKERHUB_TOKEN</code> 机密：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/secrets.b7e62f0e5830.png" alt="GitHub Actions Repository Secrets"  />
</p>
<p>请注意，这些秘密是加密的，GitHub 不会再次向您显示它们，因此请确保将它们保存在安全的地方。但是，如果您足够努力，那么您将能够恢复它们——例如，通过您工作流程中的 shell 命令。</p>
<p>当您将功能分支合并到主线时，此操作也会有条件地运行。在 <code>with</code> 部分，您指定 Dockerfile 的路径，请求推送镜像的操作，并列出镜像的标签。请注意，您再次使用 <code>github</code> 上下文来获取当前提交的哈希值，尽管是长格式。</p>
<blockquote>
<p>注意：GitHub Packages 是集成到 GitHub 中的另一项服务。它可以作为 Docker Hub 的替代品。它支持各种包类型，包括 Docker 镜像，让您可以将源代码和二进制包存储在一个地方。 <code>docker/build-push-action</code> 可以利用您的 GitHub 令牌推送到 GitHub Packages。</p>
</blockquote>
<p>此时，您的持续集成工作流已配置完毕并准备就绪。如果您还没有使用 GitHub 内置的代码编辑器，那么请记住提交并推送您的本地存储库以使更改生效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">Untracked files:
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git add &lt;file&gt;...&#34;</span> to include in what will be committed<span class="o">)</span>
</span></span><span class="line"><span class="cl">        .github/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">nothing added to commit but untracked files present <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> to track<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git add .github/
</span></span><span class="line"><span class="cl">$ git commit -m <span class="s2">&#34;Add a continuous integration workflow&#34;</span>
</span></span><span class="line"><span class="cl">$ git push
</span></span></code></pre></div><p>在下一节中，您将启用一些分支保护规则以防止任何人将他们的代码直接推送到 <code>master</code> 分支。因此，工作流中的 <code>push</code> 事件将仅适用于通过拉取请求将功能分支合并到主线中。</p>
<h3 id="启用分支保护规则">启用分支保护规则</h3>
<p>再次转到存储库的设置，单击代码和自动化部分下的分支，然后单击标记为添加分支保护规则的按钮。然后，在 Branch name pattern 字段中输入您的主线名称。如果您遵循本教程中使用的命名约定，则应在输入字段中键入 <code>master</code> ：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/rule_master.8167b2b061aa.png" alt="GitHub Repository&amp;rsquo;s Protected Branch"  />
</p>
<p>接下来，启用其正下方的一个选项，该选项显示 Require a pull request before merging。这将自动需要至少一位审阅者的批准。如果您在 GitHub 上没有其他帐户，您可以暂时取消选中此选项。否则，如果没有其他人批准，您将无法合并您的拉取请求：<img loading="lazy" src="https://files.realpython.com/media/rule_approvals.4cc8505f0715.png" alt="Require a Pull Request Before Merging"  />
</p>
<p>向下滚动一点后，您会看到一个选项，上面写着 Require status checks to pass before merging。选择它以显示更多选项。当你这样做时，检查另一个选项 Require branches to be update before merging，这将防止在你的 <code>master</code> 分支有新提交时关闭拉取请求。最后，在下面的搜索框中输入您的工作名称 <code>build</code> ：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/rule_status_check.6e4a5e464e77.png" alt="Require Status Checks to Pass Before Merging"  />
</p>
<p>现在，每个拉取请求都需要在允许合并之前通过端到端测试。</p>
<p>要在不允许管理员和其他具有提升权限的用户绕过这些规则的情况下强制执行这些规则，您可以在底部选择一个标记为不允许绕过上述设置的选项：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/rule_dont_allow.3a38d146c315.png" alt="Don&amp;rsquo;t Allow Bypassing the Above Settings"  />
</p>
<p>好的。一切就绪！如何使用您的 Docker 应用程序来测试您的持续集成工作流程？</p>
<h3 id="集成来自功能分支的更改">集成来自功能分支的更改</h3>
<p>遵循本教程前面概述的基于 Docker 的持续集成管道。首先创建一个单独的功能分支，以破坏测试的方式修改代码，提交更改并将它们推送到 GitHub：</p>
<p>Windows：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">PS&gt; git checkout -b feature/replace-emoji-face
</span></span><span class="line"><span class="cl">Switched to a new branch <span class="s1">&#39;feature/replace-emoji-face&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PS&gt; <span class="nb">cd</span> web<span class="se">\s</span>rc<span class="se">\p</span>age_tracker
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PS&gt; <span class="o">(</span>Get-Content app.py<span class="o">)</span>.replace<span class="o">(</span><span class="s1">&#39;pensive&#39;</span>, <span class="s1">&#39;thinking&#39;</span><span class="o">)</span> <span class="p">|</span> Set-Content app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PS&gt; git commit -am <span class="s2">&#34;Replace the emoji in an error message&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>feature/replace-emoji-face 9225d18<span class="o">]</span> Replace the emoji in an error message
</span></span><span class="line"><span class="cl"> <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>, <span class="m">1</span> deletion<span class="o">(</span>-<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PS&gt; git push --set-upstream origin feature/replace-emoji-face
</span></span><span class="line"><span class="cl">⋮
</span></span><span class="line"><span class="cl">remote: Create a pull request <span class="k">for</span> <span class="s1">&#39;feature/replace-emoji-face&#39;</span> on GitHub...
</span></span><span class="line"><span class="cl">remote:      https://github.com/realpython/page-tracker/pull/new/feature...
</span></span></code></pre></div><p>Linx + MacOS：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git checkout -b feature/replace-emoji-face
</span></span><span class="line"><span class="cl">Switched to a new branch <span class="s1">&#39;feature/replace-emoji-face&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ sed -i <span class="s1">&#39;s/pensive/thinking/g&#39;</span> web/src/page_tracker/app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git commit -am <span class="s2">&#34;Replace the emoji in an error message&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>feature/replace-emoji-face 9225d18<span class="o">]</span> Replace the emoji in an error message
</span></span><span class="line"><span class="cl"> <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>, <span class="m">1</span> deletion<span class="o">(</span>-<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ git push --set-upstream origin feature/replace-emoji-face
</span></span><span class="line"><span class="cl">⋮
</span></span><span class="line"><span class="cl">remote: Create a pull request <span class="k">for</span> <span class="s1">&#39;feature/replace-emoji-face&#39;</span> on GitHub...
</span></span><span class="line"><span class="cl">remote:      https://github.com/realpython/page-tracker/pull/new/feature...
</span></span><span class="line"><span class="cl">⋮
</span></span></code></pre></div><p>您创建并切换到一个名为 <code>feature/replace-emoji-face</code> 的新本地分支，然后将错误消息中的表情符号从沉思脸更改为思考脸，而不更新相应的单元测试。将分支提交并推送到 GitHub 后，您可以通过突出显示行中的链接从您的功能分支打开一个新的拉取请求到 <code>master</code> 。只要您这样做，您的持续集成工作流程就会启动。</p>
<p>当 GitHub Actions 运行器完成其工作时，由于检查失败，您将无法合并您的分支：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/failed_pr2.e4e611e3f3cf.png" alt="GitHub Status Check Failed With a Conflict"  />
</p>
<p>在这种情况下，您只有一个检查对应于工作流中的 <code>build</code> 作业，您在上一节中将其配置为分支保护规则之一。您可以单击右侧的 Details 链接来调查失败检查的日志，并且您可以选择以调试模式重新运行相应的作业以收集更多数据。</p>
<p>此外，上面的屏幕截图描述了您的功能分支和目标主线之间的假设冲突。这表明其他人修改了与您相同的文件，并且他们在您修改表情符号时成功地将他们的更改与 <code>master</code> 分支集成。</p>
<p>没有自动解决此类冲突的方法，因为它涉及理解代码的逻辑并做出关于保留哪些更改以及丢弃哪些更改的主观决定。</p>
<p>解决此冲突的唯一方法是将更新后的主线合并到您本地的功能分支中，并手动整合冲突的更改。</p>
<p>即使没有任何冲突，如果主线在您的功能分支之前有几个提交，那么无论测试结果如何，您仍然必须将 <code>master</code> 中的最新更改合并到您的分支中。这是因为您之前制定的另一个分支保护规则：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/pr_update2.f48575db3caa.png" alt="GitHub Status Check Passed With an Outdated Branch"  />
</p>
<p>合并拉取请求按钮将保持灰色和禁用状态，直到您采取措施解决所有这些问题。</p>
<p>在现实生活中，您现在应该获取最新的 <code>master</code> 并将其合并到您的功能分支，必要时解决任何冲突。然后，您将更新代码以使所有测试再次通过。返回代码编辑器并使用预期的表情符号修复失败的单元测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"> # web/test/unit/test_app.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> @unittest.mock.patch(&#34;page_tracker.app.redis&#34;)
</span></span><span class="line"><span class="cl"> def test_should_handle_redis_connection_error(mock_redis, http_client):
</span></span><span class="line"><span class="cl">     # Given
</span></span><span class="line"><span class="cl">     mock_redis.return_value.incr.side_effect = ConnectionError
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     # When
</span></span><span class="line"><span class="cl">     response = http_client.get(&#34;/&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     # Then
</span></span><span class="line"><span class="cl">     assert response.status_code == 500
</span></span><span class="line"><span class="cl"><span class="gd">-    assert response.text == &#34;Sorry, something went wrong \N{pensive face}&#34;
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+    assert response.text == &#34;Sorry, something went wrong \N{thinking face}&#34;
</span></span></span></code></pre></div><p>在本地运行测试并对代码的正确性获得信心后，在同一分支上再次提交并将其推送到 GitHub。在这样做之前，值得仔细检查当前分支：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git branch
</span></span><span class="line"><span class="cl">* feature/replace-emoji-face
</span></span><span class="line"><span class="cl">  master
</span></span><span class="line"><span class="cl">$ git add web/test/unit/test_app.py
</span></span><span class="line"><span class="cl">$ git commit -m <span class="s2">&#34;Fix the failing unit test&#34;</span>
</span></span><span class="line"><span class="cl">$ git push
</span></span></code></pre></div><p>拉取请求应该接受您的更改并开始另一个 CI 构建。一旦满足所有保护规则，您最终可以通过单击绿色按钮将您的功能分支合并到受保护的主线中：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/pr_success.0d326c26e9ad.png" alt="GitHub Status Checks Passed"  />
</p>
<p>请注意，合并将触发针对 <code>master</code> 分支的另一个 CI 构建，以测试您的更改是否与代码库的其余部分很好地集成。事情总是有可能出错。另一方面，如果 CI 构建成功，则工作流将标记并将镜像推送到您的 Docker Hub 存储库：</p>
<p><img loading="lazy" src="https://files.realpython.com/media/docker_hub_push.93959f48b437.png" alt="Docker Image Tagged and Pushed By a GitHub Action"  />
</p>
<p>每次 CI 工作流成功时，推送的 Docker 镜像都会被标记为当前 Git 提交哈希和标签 <code>latest</code> 。</p>
<p>恭喜！关于使用 Docker 和朋友构建持续集成管道的整个教程到此结束。给自己当之无愧的表扬，因为这绝非易事！</p>
<h2 id="后续步骤">后续步骤</h2>
<p>您总是可以做很多事情来改进和微调现有的持续集成流程。尽管这是关于构建强大的 CI 管道的详尽且实用的教程，但您只是触及了皮毛！</p>
<p>以下是一些供您考虑的想法：</p>
<ul>
<li>
<p>自动部署到云以实现持续交付。</p>
</li>
<li>
<p>通过全流程自动化转向持续部署。</p>
</li>
<li>
<p>引入负载均衡器和服务副本以获得更好的可扩展性。</p>
</li>
<li>
<p>使用身份验证令牌保护敏感数据存储。</p>
</li>
<li>
<p>配置服务的持久日志记录和监控。</p>
</li>
<li>
<p>实施蓝绿部署以实现零停机。</p>
</li>
<li>
<p>添加功能切换以试验金丝雀发布和 A/B 测试。</p>
</li>
</ul>
<p>通过本教程，您已经为入门打下了良好的基础。您当然可以从这里开始构建一个充分自动化和生产就绪的持续集成系统，利用 Docker 和朋友的力量。</p>
<h2 id="总结">总结</h2>
<p>您现在对如何在容器化环境中构建、部署和管理多容器 Web 应用程序有了深入的了解。您介绍了挂接到 Redis 服务器的 Flask Web 应用程序的开发、测试、保护、码头化和编排。</p>
<p>您还了解了如何使用 Docker、GitHub Actions 和各种其他工具定义持续集成管道。</p>
<p><strong>在本教程中，您已经：</strong></p>
<ul>
<li>在 Docker 容器中本地运行 Redis 服务器</li>
<li>Docker编排 一个用 Flask 编写的 Python Web 应用程序</li>
<li>构建 Docker 镜像并将它们推送到 Docker Hub 注册表</li>
<li>使用 Docker Compose 编排多容器应用程序</li>
<li>在任何地方复制类似生产的基础设施</li>
<li>使用 GitHub Actions 定义持续集成工作流程</li>
</ul>
<p>您准备好构建自己的持续集成管道了吗？在评论中让大家知道！</p>
<blockquote>
<p>免费下载：单击<a href="https://realpython.com/bonus/docker-continuous-integration-code/">此处</a>下载您的 Flask 应用程序和相关资源，以便您可以使用 Docker 定义持续集成管道。</p>
</blockquote>
<p>原文链接：<a href="https://realpython.com/docker-continuous-integration/">Build Robust Continuous Integration With Docker and Friends </a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-19｜武功山看日出、Python初学建议</title>
      <link>https://blog.chensoul.com/posts/2023/05/18/weekly_review_19/</link>
      <pubDate>Thu, 18 May 2023 18:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/18/weekly_review_19/</guid>
      <description>前言 本篇是对 2023-05-08 到 2023-05-14 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 本周继续学习 python，发现一个质量非常高的 python</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-19-00.png" alt="weekly-review-19-00"  />
</p>
<p>本篇是对 <code>2023-05-08</code> 到 <code>2023-05-14</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>本周继续学习 python，发现一个质量非常高的 python 学习网站 <a href="https://realpython.com/">Real Python</a>，该网站有学习 python 的一些教程，是收费的，部分章节是可以免费观看的。</p>
<p>另外，周五晚上老婆临时起意想去武功山看日出，于是立即规划行程并购买火车票。因为一年半之前，我去过一次，所以规划起来还是很轻松的。上一次去是国庆节碰到下雨，没有看到日出。幸运的是，这次是晴天，不仅看到了日落还看到了日出。这一次没有选择住帐篷，而是住在了云中雾客栈，没想到这个客栈离金顶需要40分钟左右的路程，而且有段路程是坑坑洼洼。</p>
<p>去武功山之前，先去了长沙，再次游了橘子洲头，并第一次在长沙跑步打卡。本想在萍乡也跑步打卡，奈何没有得逞。</p>
<p>这次去了长沙和武功山，下次基本上是再也不会去爬武功山了。长沙还会去，因为从武功山回来路上，就和老婆规划着什么时候去张家界。</p>
<h2 id="武功山看日出">武功山看日出</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-19-01.png" alt="weekly-review-19-01"  />
</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-19-02.png" alt="weekly-review-19-02"  />
</p>
<h2 id="理财">理财</h2>
<p>这周总计支出 1784 元，明细如下：</p>
<ul>
<li>5月8日：12元</li>
<li>5月9日：18元</li>
<li>5月10日：200元</li>
<li>5月11日：12元</li>
<li>5月12日：445元</li>
<li>5月13日：662元</li>
<li>5月14日：435元</li>
</ul>
<p>因为周末出去旅游，所以本周支出有所增多。</p>
<h2 id="健身">健身</h2>
<p>本周跑步 56 公里，最长跑步距离为 13 公里。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-19-05.png" alt="weekly-review-19-05"  />
</p>
<p>明细数据如下：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-19-04.png" alt="weekly-review-19-04"  />
</p>
<p>周末出去旅游，路过长沙，在长沙跑了两天，累计跑了6公里。这样，我的<a href="https://run.chensoul.com/">跑步数据</a> 从 <code>2 年里我跑过 1 个省份 1 个城市</code> 变成了<code> 2 年里我跑过 2 个省份 2 个城市</code>。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-19-03.png" alt="."  />
</p>
<h2 id="工作">工作</h2>
<h3 id="java">Java</h3>
<h4 id="博客">博客</h4>
<p>本周完成两篇博客</p>
<ul>
<li><a href="/posts/2023/05/17/obey-the-general-contract-when-overriding-equals/">《Effective Java 3》笔记10：覆盖equals方法时应遵守的约定</a></li>
<li><a href="/posts/2023/05/18/jsr-166/">JSR 166规范</a></li>
</ul>
<h3 id="python">Python</h3>
<h4 id="python初学建议">Python初学建议</h4>
<p><strong>1、新手如何学习 python？</strong></p>
<p>推荐几篇文章：</p>
<ul>
<li>
<p><a href="http://cpython.org/">cPython - 给大学生的入门教程</a></p>
</li>
<li>
<p><a href="https://www.kawabangga.com/how-to-learn-python">如何学Python？</a></p>
</li>
</ul>
<p><strong>2、学习 python 编程的11个建议</strong></p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-19-06.webp" alt="weekly-review-19-06"  />
</p>
<p>原文：<a href="https://realpython.com/python-beginner-tips/">11 Beginner Tips for Learning Python Programming</a>，总结出以下11条新手编程建议：</p>
<ul>
<li>提示 #1：每天编写代码</li>
<li>提示#2：写出来</li>
<li>提示#3：互动</li>
<li>提示#4：休息</li>
<li>提示#5：成为漏洞赏金猎人</li>
<li>提示#6：与正在学习的其他人在一起</li>
<li>技巧#7：教导</li>
<li>技巧#8：结对编程</li>
<li>提示#9：提出“好的”问题</li>
<li>技巧#10：构建一些东西</li>
<li>技巧#11：为开源做贡献</li>
</ul>
<p><strong>3、Pyhton播客：</strong> <a href="https://pythonhunter.org/episodes/1">Ep 01. 新人到底需要什么</a></p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-19-07.png" alt="weekly-review-19-07"  />
</p>
<p>播客中提到的内容：</p>
<ul>
<li><a href="https://www.youtube.com/channel/UC4xKdmAXFh4ACyhpiQ_3qBw">Tech lead</a></li>
<li><a href="https://github.com/encode/starlette">starlette</a></li>
<li><a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">Python’s super() considered super!</a></li>
<li><a href="https://github.com/coleifer/huey">huey</a></li>
<li><a href="https://github.com/agronholm/apscheduler">apscheduler</a></li>
<li><a href="https://www.youtube.com/watch?v=Aj3KMefwOqI">Python 3: ten years later - PyCon 2018</a></li>
<li><a href="https://www.youtube.com/watch?v=MCs5OvhV9S4">David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015</a></li>
<li><a href="https://github.com/uber/pyflame">pyflame</a></li>
<li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a></li>
<li><a href="http://xyproblem.info/">XY问题</a></li>
<li><a href="https://docs.python.org/3/library/logging.html">Python Logger</a></li>
<li><a href="https://docs.python.org/3/library/pdb.html">pdb</a></li>
<li><a href="https://www.jetbrains.com/pycharm/">PyCharm</a></li>
<li><a href="https://jupyter.org/">Jupyter notebook</a></li>
<li><a href="http://www.letmegooglethat.com/">Let me google that</a>, <a href="https://lmgtfy.com/">let me google that for you</a></li>
<li><a href="https://www.zhihu.com/question/27871198">学习操作系统的知识，看哪本书好？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27288770">PHP黑系列之二：PHP 为什么函数命名是如此不一致？</a></li>
<li><a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a></li>
<li><a href="https://7chan.org/pr/src/The_Little_Schemer_4th_2.pdf">The Little Schemer</a></li>
<li><a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">SICP</a></li>
<li><a href="https://cs61a.org/">CS 61A: Structure and Interpretation of Computer Programs</a></li>
</ul>
<h4 id="python--tips">Python  Tips</h4>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-19-08.png" alt="weekly-review-19-08"  />
</p>
<p>本周订阅了 <a href="https://realpython.com/"><strong>Real Python</strong></a> 的 Python Tricks，收到两封邮件，分享如下：</p>
<p><strong>1、如何一行代码合并两个字典</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># How to merge two dictionaries</span>
</span></span><span class="line"><span class="cl"><span class="c1"># in Python 3.5+</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">y</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># In Python 2.x you could</span>
</span></span><span class="line"><span class="cl"><span class="c1"># use this:</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># In these examples, Python merges dictionary keys</span>
</span></span><span class="line"><span class="cl"><span class="c1"># in the order listed in the expression, overwriting </span>
</span></span><span class="line"><span class="cl"><span class="c1"># duplicates from left to right.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># See: https://www.youtube.com/watch?v=Duexw08KaC8</span>
</span></span></code></pre></div><blockquote>
<p><strong>说明：</strong></p>
<p>这段代码用于将两个字典 <code>x</code> 和 <code>y</code> 合并成一个新字典 <code>z</code>，其中 <code>**</code> 是 Python 中的解包运算符，可以将一个字典拆分成多个键值对，然后将这些键值对作为参数传递给一个函数或用于创建一个新的字典。</p>
<p>在这个例子中，<code>{**x, **y}</code> 表示将字典 <code>x</code> 和 <code>y</code> 拆分成多个键值对，然后将这些键值对合并成一个新字典。由于字典 <code>y</code> 中的键 <code>b</code> 与字典 <code>x</code> 中的键 <code>b</code> 相同，因此在合并后的字典中，键 <code>b</code> 对应的值将被更新为字典 <code>y</code> 中的值（即 <code>3</code>）。</p>
</blockquote>
<p>除了上面的方法之外，还可以使用 <code>update()</code> 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">z</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span></code></pre></div><blockquote>
<p>在上面的代码中，首先将字典 <code>x</code> 复制一份到 <code>z</code> 中，然后使用 <code>update()</code> 方法将字典 <code>y</code> 合并到 <code>z</code> 中。如果字典 <code>y</code> 中的键在字典 <code>x</code> 中已经存在，则会使用字典 <code>y</code> 中的值来更新字典 <code>z</code> 中的值。最终得到一个新字典 <code>z</code>，它包含了字典 <code>x</code> 和 <code>y</code> 中的所有键值对。</p>
</blockquote>
<p><strong>2、在 Python 中一次测试多个标志的不同方法</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Different ways to test multiple</span>
</span></span><span class="line"><span class="cl"><span class="c1"># flags at once in Python</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;passed&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;passed&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># These only test for truthiness:</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">x</span> <span class="ow">or</span> <span class="n">y</span> <span class="ow">or</span> <span class="n">z</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;passed&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;passed&#39;</span><span class="p">)</span>
</span></span></code></pre></div><p>除了前面提到的四种方法外，还有其他几种方式来测试多个变量是否至少有一个等于某个值：</p>
<ol>
<li><strong>使用列表解析式</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)]):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;passed&#39;</span><span class="p">)</span>
</span></span></code></pre></div><blockquote>
<p>在上面的代码中，使用列表解析式生成一个新列表，其中包含变量 <code>x</code>、<code>y</code>、<code>z</code> 中每个变量是否等于 1 的布尔值。然后，使用 <code>any()</code> 函数来测试新列表中是否存在至少一个为真的元素，如果存在，则条件为真，执行 <code>print()</code> 语句。</p>
</blockquote>
<ol start="2">
<li><strong>使用 <code>sum()</code> 函数</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">sum</span><span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;passed&#39;</span><span class="p">)</span>
</span></span></code></pre></div><blockquote>
<p>在上面的代码中，使用生成器表达式生成一个新的迭代器对象，其中包含变量 <code>x</code>、<code>y</code>、<code>z</code> 中每个变量是否等于 1 的布尔值。然后，将迭代器对象传递给 <code>sum()</code> 函数，它会将所有为真的元素加起来并返回一个整数。如果返回的整数大于 0，则条件为真，执行 <code>print()</code> 语句。</p>
</blockquote>
<ol start="3">
<li><strong>使用 <code>map()</code> 函数和 <code>any()</code> 函数</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;passed&#39;</span><span class="p">)</span>
</span></span></code></pre></div><blockquote>
<p>在上面的代码中，使用 <code>map()</code> 函数将一个匿名函数 <code>lambda i: i == 1</code> 应用于变量 <code>x</code>、<code>y</code>、<code>z</code> 中的每个元素，它会将每个元素与 1 进行比较并返回一个布尔值。然后，使用 <code>any()</code> 函数来测试返回的布尔值序列中是否存在至少一个为真的元素，如果存在，则条件为真，执行 <code>print()</code> 语句。</p>
</blockquote>
<ol start="4">
<li><strong>使用 <code>reduce()</code> 方法</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="ow">or</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;passed&#39;</span><span class="p">)</span>
</span></span></code></pre></div><blockquote>
<p>在上面的代码中，使用生成器表达式生成一个新的迭代器对象，其中包含变量 <code>x</code>、<code>y</code>、<code>z</code> 中每个变量是否等于 1 的布尔值。然后，使用 <code>reduce()</code> 函数将一个匿名函数 <code>lambda a, b: a or b</code> 应用于迭代器对象中的所有元素，它会将所有元素按照布尔逻辑 <code>or</code> 进行聚合，并返回一个布尔值。如果返回的布尔值为真，则条件为真，执行 <code>print()</code> 语句。</p>
</blockquote>
<h2 id="本周分享">本周分享</h2>
<p>大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道或者我的 <a href="https://memos.chensoul.com/">memos</a> 中。我写了一个 python 脚本从 memos读取最近一周的 memos 记录。</p>
<ul>
<li><strong>2023-05-10</strong> 一些非常有趣的python爬虫例子,对新手比较友好,主要爬取淘宝、天猫、微信、微信读书、豆瓣、QQ等网站。<a href="https://github.com/shengqiangzhang/examples-of-web-crawlers">查看链接</a>  <code>#memos</code> <code>#python</code> <code>#tool</code></li>
<li><strong>2023-05-08</strong> 这个网站整理了开发者的学习成长路线图，有比较详细的技能树，推荐学习内容等等，偏向开发者。 <a href="https://roadmap.sh/python">查看链接</a>  <code>#memos</code> <code>#tool</code></li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-18｜导出豆瓣数据、Effective Java 3第二章总结</title>
      <link>https://blog.chensoul.com/posts/2023/05/10/weekly_review_18/</link>
      <pubDate>Wed, 10 May 2023 10:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/10/weekly_review_18/</guid>
      <description>前言 本篇是对 2023-05-01 到 2023-05-07 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 继上周实现导出苹果接口数据之后，这周又实现了自动</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-05-01</code> 到 <code>2023-05-07</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>继上周实现导出苹果接口数据之后，这周又实现了自动导出豆瓣数据。此外，还萌生了导出每天阅读的数据的想法。奈何现在阅读 app 都需要收费，只能暂且搁置这个想法。</p>
<p>最近在学习 Python，于是将学习中做的笔记发布到了博客，这周发布了两篇文章，希望通过输出来倒逼输入，以此来快速掌握 python 编程并能开发一些项目。另外，计划在学完之后，继续学习 Rust 和 Go，甚至开始学习前端开发。</p>
<p>最近又一次更换了博客主题，主要出发点是想找一个简洁的主题，减少不必要的信息干扰，也不想花时间在修改主题上面。减少了菜单链接，顺手也修改了 <a href="/about/">关于</a> 页面的内容。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-18-01.png" alt="weekly-review-18-01"  />
</p>
<h2 id="导出豆瓣数据">导出豆瓣数据</h2>
<p>最近阅读了一篇文章 <a href="https://conge.livingwithfcs.org/2023/05/05/leaving-douban/">很认真的在考虑不再使用豆瓣这件事</a> ，于是使用<a href="https://github.com/lizheming/doumark-action"> lizheming/doumark-action</a> 导出豆瓣数据。</p>
<p>在我的 github 主页 <a href="https://github.com/chensoul/chensoul">https://github.com/chensoul/chensoul</a> 创建一个 workflow <a href="https://github.com/chensoul/chensoul/blob/main/.github/workflows/douban.yml">douban.yml</a> ，每隔一个小时同步一次豆瓣数据（读书、电影、音乐）到 <a href="https://github.com/chensoul/chensoul/tree/main/data">csv 文件</a>。拿到这些文件之后，就可以通过 html + css 渲染出来，类似这个页面 <a href="https://conge.livingwithfcs.org/books/">书影音</a>。等豆瓣数据增多之后，再考虑实现这个。</p>
<p>除此之外，之前还实现了通过 n8n 实时同步豆瓣数据到 memos 和 telegram：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-18-05.png" alt="weekly-review-18-05"  />
</p>
<p>通过 <a href="https://github.com/chensoul/chensoul/blob/main/build_readme.py">python 脚本 </a>获取最近10条记录，显示到 <a href="https://github.com/chensoul">我的 github 主页</a>。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-18-06.png" alt="weekly-review-18-06"  />
</p>
<h2 id="理财">理财</h2>
<p>这周总计支出 816 元，明细如下：</p>
<ul>
<li>5月1日：55元</li>
<li>5月2日：79元</li>
<li>5月3日：370元，其中270元加油</li>
<li>5月4日：136元，其中捐款50元</li>
<li>5月5日：12元</li>
<li>5月6日：100元，手机话费充值</li>
<li>5月7日：64元</li>
</ul>
<p>最近一直想统计一下工作和生活中的固定支出费用，于是今天花了点时间做了统计。没想到每年工作和生活中固定支出费用竟然达到了1529+6180=7709元。其中大块头是手机话费和停车位费用，手机话费是因为办理一个电信套餐送宽带和一部手机；停车位费用是因为今年买了车。</p>
<p>年费，总计：1529元</p>
<ul>
<li>Typora：89元</li>
<li>百度硬盘：178元，2024-01-28到期</li>
<li>快连VPN：374元，2024-01-16到期</li>
<li>搬瓦工VPS：640元，2024-01-14到期</li>
<li>1Password：248元，2023-08-17到期</li>
</ul>
<p>月费，总计：515*12=6180元</p>
<ul>
<li>
<p>手机话费：189元</p>
</li>
<li>
<p>停车位：320元</p>
</li>
<li>
<p>iCloud：6元</p>
</li>
</ul>
<h2 id="健身">健身</h2>
<p>本周 <a href="https://run.chensoul.com/">跑步</a> 记录如下，总计跑步34.37公里，其中周六第一次跑了12公里，比之前有所进步。遗憾的是，有两天没有跑步，导致连续跑步天数有中断。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-18-04.png" alt="weekly-review-18-04"  />
</p>
<p>从3月份开始跑步到5月，目前总共跑步距离达到了230公里。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-18-03.png" alt="weekly-review-18-03" style="width:50%;" />
<h2 id="工作">工作</h2>
<h3 id="effective-java-3-笔记">Effective Java 3 笔记</h3>
<p>本周写了两篇《Effective Java 3》的学习笔记，分别是：</p>
<ul>
<li><a href="/posts/2023/05/08/avoid-finalizers-and-cleaners/">《Effective Java 3》笔记8：避免使用终结器和清除器</a></li>
<li><a href="/posts/2023/05/08/prefer-try-with-resources-to-try-finally/">《Effective Java 3》笔记9：使用 try-with-resources 优于 try-finally</a></li>
</ul>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-18-02.png" alt="weekly-review-18-02"  />
</p>
<p>至此，《Effective Java 3》第二章学习完了，现在总结如下：</p>
<p>1、静态工厂方法代替构造函数</p>
<p>静态工厂方法是一种创建对象的方式，它们与构造器不同，具有明确的名称，并且可以返回任意类型的对象。静态工厂方法的优点包括：</p>
<ul>
<li>
<p>名称可以描述对象的含义，使得代码更加清晰易读；</p>
</li>
<li>
<p>静态工厂方法可以控制创建对象的方式，提高灵活性；</p>
</li>
<li>
<p>静态工厂方法可以缓存已创建的对象，避免创建重复对象，提高性能；</p>
</li>
<li>
<p>静态工厂方法可以返回任意类型的对象，而不仅仅是该类或者其子类的实例。</p>
</li>
</ul>
<p>2、使用构造器代替构造方法</p>
<p>当一个类需要多个参数时，可以使用构建器，将参数逐个设置，最后调用build方法构建对象。构建器的优点包括：</p>
<ul>
<li>
<p>可以避免长参数列表，使得代码更加清晰易读；</p>
</li>
<li>
<p>构建器可以强制要求必需的参数，提高代码的安全性；</p>
</li>
<li>
<p>构建器可以返回不可变对象，提高代码的线程安全性。</p>
</li>
</ul>
<p>3、使用私有构造函数或枚举类型创建单例</p>
<p>通过私有构造器或者枚举类型来实现Singleton，它们的优点包括：</p>
<ul>
<li>
<p>可以确保只有一个实例存在，提高代码的安全性；</p>
</li>
<li>
<p>可以缩小类的可访问性，提高代码的封装性；</p>
</li>
<li>
<p>可以让代码更加自然，避免使用静态方法和静态变量的限制。</p>
</li>
</ul>
<p>4、用私有构造函数使类不可实例化</p>
<p>使用私有构造函数强制实现不可实例化的主要原因是防止类被意外地实例化，以使代码更加健壮和可靠。在某些情况下，我们只需要使用类中的静态方法和静态字段，而不需要创建该类的实例。</p>
<p>5、依赖注入优于硬编码资源</p>
<p>使用依赖注入比硬编码资源的优点：</p>
<ol>
<li>可测试性：使用依赖注入，很容易创建和注入模拟对象进行测试。这样，我们可以将正在测试的组件隔离开来，并专注于测试其行为，而不必担心其依赖项的行为。</li>
<li>灵活性：使用依赖注入，我们可以轻松地用不同实现替换依赖项。这在需要更改组件的行为而不更改其代码时非常有用。</li>
<li>解耦：依赖注入有助于将组件与其依赖项解耦，使代码更加模块化并易于维护。</li>
<li>关注点分离：依赖注入将依赖项的创建和管理与组件本身分离，允许更清晰地分离关注点。</li>
</ol>
<p>6、避免创建不必要的对象</p>
<p>7、排除过时的对象引用</p>
<p>在代码中及时清理不再使用的对象引用，以避免内存泄漏和性能问题。当一个对象不再需要时，应该尽快将其引用设置为null，这样JVM可以及时回收它所占用的内存。</p>
<p>8、避免使用终结器和清除器</p>
<p>终结方法和清除方法是一种释放资源的方式，但是它们并不可靠，不应该依赖于它们来释放资源。应该使用try-with-resources结构或者显式的调用close方法来释放资源。</p>
<p>9、使用 try-with-resources 优于 try-finally</p>
<p><code>try-with-resources</code> 语句是 Java 7 中引入的一种新语法，主要目的是为了简化资源管理的代码，并确保资源被正确地关闭，避免了资源泄漏和异常处理的问题。</p>
<h3 id="python">Python</h3>
<ul>
<li><a href="/posts/2023/05/09/python-install-build-publish-run/">Python安装、构建、发布、下载和运行</a></li>
<li><a href="/posts/2023/05/09/python-package-and-env-management/">Python包和环境管理</a></li>
</ul>
<h2 id="本周分享">本周分享</h2>
<p>大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道或者我的 <a href="https://memos.chensoul.com/">memos</a> 中。我写了一个 python 脚本从 memos读取最近一周的 memos 记录。</p>
<ul>
<li><strong>2023-05-06</strong> git flow 模型的提出：<a href="https://nvie.com/posts/a-successful-git-branching-model/">查看链接</a>  gitflow-avh 是一个增强工具：<a href="https://github.com/petervanderdoes/gitflow-avh">查看链接</a>  <code>#git</code> <code>#tool</code> <code>#memos</code></li>
<li><strong>2023-05-06</strong> 又有哪家阅读管理网站可取代豆瓣读书 <a href="https://glennwoo.com/2022/07/29/about-reading-tracker-websites/">查看链接</a>  <code>#douban</code> <code>#memos</code></li>
<li><strong>2023-05-05</strong> 分享一些阅人经验：  1. 嘴巴太快的人，往往没什么城府。嘴巴太甜的人，不可以深交。 2. 话少的人往往是两个极端，要么真的简单，要么深不可测。 3. 性格写在脸上的人，人品不会太差。能够控制情绪的人，往往不是一般人。 4. 开口就说“我有一个朋友怎样怎样”的人，往往单纯没啥真本事。 5. 不喜欢麻烦别人的人，通常也不喜欢被别人麻烦。一个不懂拒绝的人，也是一个不懂应酬的人。 6. 如果一个人可以做到潇洒而不合群，这人多半是个老江湖。如果一个人因不合群特别不自在，这人多半是社会小白。 7. 看地位高的大佬推荐什么人、用什么人，那这个大佬就是什么样的人。 8. 越是做事小心翼翼的人，越容易得罪人。反而霸气点的人，往往都会有三分薄面。 9. 善于巴结讨好别人的人，最好不要与之深交，否则必受其累。 10. 看起来一本正经、不苟言笑、斯斯文文的人，往往都比较闷骚。 11. 能在一定位置上的人，无论你多么讨厌他，一定有他某些过人之处。 12. 能够在一段感情失败后，很快走出来的人，要么没有真心付出，要么理性得可怕。 13. 想知道一个人品行如何，可以观察一下他培养出来的孩子。 14. 高度自律的人，往往对别人的要求也很高。 15. 年少得志，太容易获得成功的人，往往容易栽跟头。如果能扛过去并吸取教训，将来的成就会更大，否则容易掉入深渊。 16. 面对恭维或羞辱都不动声色的人，肯定是城府极深的狠角色。这种人千万别乱得罪，否则受到的反击会很突然很猛烈，下场会很惨。 <code>#摘录</code> <code>#memos</code></li>
<li><strong>2023-05-05</strong>  WoodpeckerCI 是一个由社区维护的 DroneCI 分支，使用 Apache License 2.0 许可证发布。社区版进一步扩展了 pipeline 的功能特性、支持对文件路径设置 pipeline 执行条件，并且可以与 Gitea 实现紧密集成。不同的是，DroneCI 的配置文件是 .drone.yml，WoodpeckerCI 重命名为了 .woodpecker.yml。好在 WoodpeckerCI 也兼容 DroneCI 的配置文件，迁移起来并不会太麻烦。   <a href="https://github.com/woodpecker-ci/woodpecker">查看链接</a>  <code>#memos</code> <code>#tool</code></li>
<li><strong>2023-05-04</strong> git-flow[实战系列]  <a href="https://blog.p2hp.com/archives/10929">查看链接</a>  <code>#memos</code> <code>#git</code> <code>#tool</code></li>
<li><strong>2023-05-04</strong> 在 Node.js 生态系统中查找积极维护和流行的库 <a href="https://nodejstoolbox.com/">查看链接</a>  <code>#web</code> <code>#nodejs</code> <code>#memos</code></li>
<li><strong>2023-05-04</strong> 可以用来取代UUID, 效率更高, 支持自定义字符集 <a href="https://github.com/ai/nanoid">查看链接</a>  <code>#memos</code> <code>#tool</code></li>
<li><strong>2023-05-04</strong> unDraw: 一个可以免费使用的插图库, 优势: 可免费商用/支持直接改色 <a href="https://undraw.co/illustrations">查看链接</a>  <code>#memos</code> <code>#tool</code></li>
<li><strong>2023-05-04</strong> 临时文件上传服务  文件传输工具，上传的文件只保留48小时，过期自动删除 <a href="https://sendfiles.online/">查看链接</a>  Pixeldrain 免费文件分享，免费每个文件最大20 GB per file，无广告。 <a href="https://pixeldrain.com/">查看链接</a>  TEMPORARY FILE HOSTING All uploaded files are automatically deleted after 60 minutes. <a href="https://tmpfiles.org/">查看链接</a>  Super simple file sharing! Upload as many files as you like up to 2 GB and get a link to share.（一次下载后，链接即过期） <a href="https://www.file.io/">查看链接</a>  Upload And Share (MP4, WEBM) Temporary Videos <a href="https://tempclip.com/">查看链接</a>  <code>#memos</code> <code>#tool</code></li>
<li><strong>2023-05-04</strong> 适合编程时听的音乐  <a href="https://coderadio.freecodecamp.org/">查看链接</a>  <a href="https://www.programmersmusic.com/">查看链接</a>  <code>#memos</code> <code>#music</code></li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Python包和环境管理</title>
      <link>https://blog.chensoul.com/posts/2023/05/09/python-package-and-env-management/</link>
      <pubDate>Tue, 09 May 2023 10:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/09/python-package-and-env-management/</guid>
      <description>发展历史 Python 包管理工具是 Python 生态系统中的一个重要组成部分，它们为 Python 开发者提供了方便、快捷的包管理方式。以下是 Python 包管理工具的发展历史概述： 1991 年：P</description>
      <content:encoded><![CDATA[<h2 id="发展历史">发展历史</h2>
<p>Python 包管理工具是 Python 生态系统中的一个重要组成部分，它们为 Python 开发者提供了方便、快捷的包管理方式。以下是 Python 包管理工具的发展历史概述：</p>
<ul>
<li>1991 年：Python 语言首次发布，Python 包管理工具还未出现。</li>
<li>1998 年：Python Distutils 工具发布，它是 Python 的第一个包管理工具，可以用于打包、安装和分发 Python 包。</li>
<li>2004 年：easy_install 工具发布，它是一种用于安装、升级和卸载 Python 包的工具，可以自动解析依赖关系并安装所需的其他包。</li>
<li>2007 年：pip 工具发布，它是 easy_install 的一个替代品，提供了更好的依赖项解析、升级和卸载功能，以及更好的用户体验。</li>
<li>2012 年：Python 软件基金会宣布，pip 将成为 Python 包管理生态系统中的标准工具，取代 easy_install。</li>
<li>2013 年：Wheel 格式发布，它是一种用于打包和分发 Python 包的格式，可以包含 C 扩展模块，并且支持多平台安装。</li>
<li>2018 年：PEP 517 和 518 发布，它们提供了一种新的 Python 包构建和分发标准，可以使包构建和分发变得更加简单和可靠。</li>
<li>2018 年：flit 工具发布，它是一种简单的 Python 包构建和分发工具，可以通过 pyproject.toml 文件来配置包的元数据和依赖项。</li>
<li>2019 年：poetry 工具发布，它是一种专注于依赖管理和项目构建的 Python 包管理工具，可以自动解析依赖关系、构建项目、生成 lock 文件等。</li>
<li>2020 年：PEP 621 发布，它是一种新的 Python 包元数据标准，可以用于定义 Python 包的元数据信息，如名称、版本、作者、许可证等。</li>
<li>2020 年：PEP 636 发布，它是一种新的 CPython 扩展模块元数据标准，可以用于定义 CPython 扩展模块的元数据信息，如名称、版本、作者、许可证等。</li>
<li>2021 年：flit 3 发布，它增加了对 PEP 621 和 PEP 636 的支持，可以使用 pyproject.toml 文件来定义 Python 包和 CPython 扩展模块的元数据信息。</li>
</ul>
<p>PyPA 是 Python Packaging Authority 的缩写，即 Python 包管理权威组织。PyPA 的目标是为 Python 社区提供一个标准的、易于使用的包管理工具和相关工具的生态系统，并提供相关的文档和规范。</p>
<p>PyPA 组织成立于 2013 年，由一些 Python 包管理工具的核心开发者组成。目前，PyPA 组织维护了一些 Python 包管理工具和相关工具的项目，包括：</p>
<ul>
<li><code>pip</code>: Python 包管理工具，用于安装和管理 Python 包。</li>
<li><code>setuptools</code>: Python 包构建和分发工具，用于打包和分发 Python 包。</li>
<li><code>wheel</code>: Python 包二进制分发格式，用于加快 Python 包的安装速度。</li>
<li><code>twine</code>: Python 包上传工具，用于将 Python 包上传到 PyPI 或其他包仓库。</li>
<li><code>virtualenv</code>: Python 虚拟环境工具，用于创建和管理 Python 虚拟环境。</li>
</ul>
<p>此外，PyPA 还制定了一些包管理的标准和规范，如：</p>
<ul>
<li><code>PEP 517</code> 和 <code>PEP 518</code>: 定义了 Python 包的构建规范和构建工具的接口规范。</li>
<li><code>PEP 440</code>: 定义了 Python 包版本号的语义化规范。</li>
<li><code>PEP 503</code>: 定义了 Python 包仓库的 URL 命名规范。</li>
<li><code>PEP 621</code>: 定义了 Python 包元数据的标准格式。</li>
</ul>
<p>PyPA 的工作对 Python 社区的包管理生态系统产生了重要的影响，使得 Python 包的构建、分发、安装和管理更加统一和规范。在使用 Python 包时，可以参考 PyPA 的相关工具和规范，以便更好地管理和使用 Python 包。</p>
<h3 id="distutils-发展历史">Distutils 发展历史</h3>
<p>Distutils 是 Python 生态系统中的第一个包管理工具，它为 Python 开发者提供了一种方便、快捷的包管理方式。以下是 Distutils 的发展历史概述：</p>
<ul>
<li>1998 年：Python 1.5.2 版本发布，它成为第一个具备模块打包功能的 Python 版本，但打包功能还比较简单。</li>
<li>1999 年：Distutils 工具发布，它是 Python 1.6 版本中的一个标准库，可以用于打包、安装和分发 Python 包。</li>
<li>2000 年：Distutils 0.9.1 版本发布，它增加了对 Windows 平台的支持，以及对 Python 2.0 版本的支持。</li>
<li>2002 年：Distutils 1.0 版本发布，它增加了对 Python 2.2 版本的支持，以及一些新特性和改进，如支持 C 扩展模块、支持自定义命令、支持打包多个模块等。</li>
<li>2007 年：setuptools 工具发布，它是 Distutils 的一个扩展，提供了更好的依赖项解析、升级和卸载功能，以及更好的插件机制和扩展性。</li>
<li>2013 年：Distutils 项目停止维护，它的代码被合并到 Python 标准库中，成为 Python 打包和分发的标准工具。</li>
</ul>
<p>总的来说，Distutils 是 Python 生态系统中第一个包管理工具，它为 Python 包的构建、打包、安装和分发提供了很多方便和支持。在其发展历史中，Distutils 不断更新迭代，增加了许多新特性和功能，以适应 Python 生态系统的变化和需求。尽管现在 Distutils 不再主动维护，但它的代码被集成到 Python 标准库中，仍然为 Python 包管理提供基础支持。</p>
<h3 id="easy_install-发展历史">easy_install 发展历史</h3>
<p>easy_install 是 Python 包管理工具之一，它的发展历史可以追溯到 2004 年，以下是 easy_install 的发展历史概述：</p>
<ul>
<li>2004 年：easy_install 首次发布，它是一种用于安装、升级和卸载 Python 包的工具，可以自动解析依赖关系并安装所需的其他包。</li>
<li>2005 年：easy_install 被纳入到 setuptools 中，成为 setuptools 的一部分。此时，easy_install 已经成为 Python 包管理生态系统中的一个核心工具。</li>
<li>2007 年：easy_install 0.6b1 发布，它引入了一些新的功能和改进，如对源码分发的支持、对 egg 格式的支持等。</li>
<li>2008 年：pip 工具发布，它是 easy_install 的一个替代品，提供了更好的依赖项解析、升级和卸载功能，以及更好的用户体验。</li>
<li>2012 年：Python 软件基金会宣布，pip 将成为 Python 包管理生态系统中的标准工具，取代 easy_install。</li>
</ul>
<p>总的来说，easy_install 是 Python 包管理生态系统中的一个重要工具，它为 Python 开发者提供了一种简单、方便的包管理方式。尽管 easy_install 的功能和性能在某些方面已经被 pip 和其他工具取代，但它仍然是 Python 包管理历史上的一个重要里程碑，对 Python 包管理工具的发展产生了积极的影响。</p>
<h3 id="setuptools-发展历史">Setuptools 发展历史</h3>
<p>setuptools 是由 Phillip J. Eby 开发的，它是 Python 的一个包管理工具，用于构建、分发和安装 Python 包。</p>
<p>Phillip J. Eby 是一位知名的 Python 社区成员和开源软件贡献者，他也是 Python Packaging Authority 的成员之一。在 2004 年，他开始开发 setuptools，这个项目的目标是为 Python 开发者提供一个更好、更方便的包管理工具，以替代原有的 distutils 工具。</p>
<p>setuptools 和 distutils 的主要区别在于 setuptools 提供了一些额外的功能，如自动发现依赖关系、支持命令扩展、支持 egg 包等。这些功能使得 Python 包的构建、分发和安装变得更加灵活和高效。</p>
<p>setuptools 从一开始就受到了 Python 社区的欢迎和支持，它的代码托管在 GitHub 上，并逐渐发展成为 Python 生态系统中使用最广泛的包管理工具之一。setuptools 也是许多其他 Python 工具和框架的基础，如 Flask、Django、numpy 等。</p>
<p>以下是 Setuptools 的发展历史概述：</p>
<ul>
<li>1994年：Python 1.0版本中没有 <code>setup.py</code>，安装 Python 包需要手动复制文件。随着 Python 的发展，用户需要更方便的方法来安装和管理包，因此开始出现了一些简单的自动化安装工具。</li>
<li>2000年：Distutils 是 Python1.6 官方的包管理工具，它提供了一组用于打包、构建和分发 Python 包的工具和命令。其中，<code>setup.py</code> 是 Distutils 的核心组件，用于定义和配置包的元数据、依赖项和入口点等信息。</li>
<li>2004 年：Setuptools 首次发布，它是 Distutils 的一个扩展，提供了一些额外的功能和扩展，如对 egg 格式的支持、对依赖项的管理、对命令扩展的支持等。</li>
<li>2008 年：Setuptools 0.6 发布，它引入了一些新的功能和改进，如对 Python 2.6 和 3.0 的支持、对 namespace packages 的支持等。</li>
<li>2010 年：Distribute 发布，它是 Setuptools 的一个分支，旨在提供更好的兼容性和易用性。Distribute 移除了一些过时的功能和选项，并添加了一些新的功能和扩展。</li>
<li>2013 年：Setuptools 0.7 发布，它借鉴了 Distribute 的一些设计和功能，并移除了一些过时的功能和选项。Setuptools 0.7 的语法与 Distribute 的语法相同。</li>
<li>2018 年：Setuptools 40.0 发布，它引入了一些新的功能和改进，并移除了一些过时的功能和选项。Setuptools 40.0 的语法与 Setuptools 0.7 相同。</li>
<li>2020 年：Setuptools 49.0 发布，它增加了对 Python 3.9 的支持，并引入了一些新的功能和改进，如对 GitLab 的支持、对环境变量的支持等。</li>
</ul>
<h3 id="setupcfg-发展历史">setup.cfg 发展历史</h3>
<p><code>setup.cfg</code> 文件是 Python 项目的元数据和构建选项的配置文件，它可以替代 <code>setup.py</code> 脚本来定义 Python 项目的元数据和构建选项。以下是 <code>setup.cfg</code> 的主要发展历史：</p>
<ul>
<li>Python 2.5：<code>setuptools</code> 扩展模块发布，引入了 <code>setup.cfg</code> 文件来定义项目的元数据和构建选项。</li>
<li>Python 3.1：<code>distutils2</code> 项目发布，旨在改进 <code>distutils</code> 模块的设计和实现，引入了 <code>setup.cfg</code> 文件作为定义项目元数据和构建选项的首选方式。</li>
<li>Python 3.4：<code>setuptools</code> 扩展模块被添加到 Python 标准库中，成为 <code>distutils</code> 的一部分，<code>setup.cfg</code> 文件成为标准的配置文件格式。</li>
</ul>
<p>随着 Python 的发展，<code>setup.cfg</code> 文件逐渐成为 Python 项目的标准配置文件格式。它提供了比 <code>setup.py</code> 脚本更简洁、更易于阅读和维护的配置方式，同时也更容易与其他工具集成。需要注意的是，<code>setup.cfg</code> 文件并不是必需的，如果没有指定该文件，则 <code>setuptools</code> 将默认使用 <code>setup.py</code> 脚本来定义项目的元数据和构建选项</p>
<h3 id="pyprojecttoml-发展历史">pyproject.toml 发展历史</h3>
<p><code>pyproject.toml</code> 是一个 TOML 格式的文件，用于定义 Python 项目的元数据和构建选项。它是 Python 中的一个新的标准文件，用于替代 <code>setup.py</code> 脚本和 <code>setup.cfg</code> 文件来定义和构建 Python 项目。以下是 <code>pyproject.toml</code> 的主要发展历史：</p>
<ul>
<li>PEP 517：该 PEP 提出了一个新的构建系统接口，用于替代 <code>setup.py</code> 和 <code>setup.cfg</code>，并引入了 <code>pyproject.toml</code> 文件作为定义 Python 项目的元数据和构建选项的标准文件格式。</li>
<li>PEP 518：该 PEP 提出了一种新的方式来定义项目的依赖关系，并引入了 <code>pyproject.toml</code> 文件作为标准的项目元数据文件格式。</li>
</ul>
<p>随着 PEP 517 和 PEP 518 的发布，<code>pyproject.toml</code> 文件逐渐成为 Python 项目的标准元数据文件格式。它提供了比 <code>setup.py</code> 脚本和 <code>setup.cfg</code> 文件更灵活、更易于配置和扩展的方式，同时也更容易与构建工具和依赖管理器集成。需要注意的是，<code>pyproject.toml</code> 文件只在使用 PEP 517 和 PEP 518 规范的构建工具中才会被识别和使用。</p>
<p>总之，<code>pyproject.toml</code> 文件是 Python 项目的标准元数据和构建选项的配置文件，它提供了比 <code>setup.py</code> 脚本和 <code>setup.cfg</code> 文件更灵活、更易于配置和扩展的方式，成为了 Python 项目的标准元数据文件格式。</p>
<h3 id="pip-发展历史">Pip 发展历史</h3>
<p>在 Python 中，pip 和 setuptools 是两个常用的包管理工具，它们在安装和管理 Python 包方面发挥着重要作用。</p>
<p>pip 是由 Ian Bicking 和其他 Python 社区成员开发的，它是 Python 的包管理器之一，用于在 Python 程序中安装和管理软件包。</p>
<p>Ian Bicking 是一位 Python 程序员和开源软件贡献者，他还是 Pylons 和 Paste 等框架的创始人之一。在 2008 年，他开始开发 pip，这个项目的目标是为 Python 社区提供一个更好、更易用的包管理器，以替代原有的 easy_install 工具。</p>
<p>pip 从一开始就受到了 Python 社区的欢迎和支持，它的代码托管在 GitHub 上，并逐渐发展成为 Python 生态系统中使用最广泛的包管理器之一。pip 支持从 PyPI（Python Package Index）等源中下载和安装 Python 包，并自动处理包之间的依赖关系，使得 Python 包的管理变得更加简单和高效。</p>
<p>目前，pip 已经成为了 Python 官方推荐的包管理器，并且已经集成到 Python 2.7.9 和 Python 3.4 以及更高版本中，可以直接使用，无需额外安装。</p>
<p>pip 与 setuptools 有密切的关系，因为它使用 setuptools 来构建和安装 Python 包。</p>
<p>setuptools 是一个 Python 包的构建和分发工具，它提供了一组 API 来定义、构建和打包 Python 包。setuptools 可以自动生成 setup.py 文件，这个文件描述了 Python 包的元数据和依赖关系，以便 pip 和其他工具可以使用它来安装和管理包。</p>
<p>在安装和管理 Python 包时，pip 会使用 setuptools 来解决依赖关系、构建和安装包。pip 会在下载包之前检查包的依赖关系，并使用 setuptools 来安装这些依赖项。如果包需要进行构建，pip 也会使用 setuptools 来构建它们</p>
<p>以下是 pip 的发展历史概述：</p>
<ul>
<li>2008 年：pip 首次发布，它是 easy_install 的一个替代品，提供了更好的依赖项解析、升级和卸载功能，以及更好的用户体验。</li>
<li>2011 年：pip 正式成为 Python 包管理的标准工具之一，并被纳入到 Python 2.7 和 Python 3.2 中。</li>
<li>2013 年：pip 1.4 发布，它引入了一些新的功能和改进，如对 wheel 格式的支持、对安装源的优化等。</li>
<li>2016 年：pip 8.0 发布，它引入了一些新的功能和改进，如对 hash 校验的支持、对源索引的优化等。</li>
<li>2018 年：pip 18.0 发布，它引入了一些新的功能和改进，如对 Python 3.7 的支持、对源索引的改进等。</li>
<li>2020 年：pip 20.0 发布，它引入了一些新的功能和改进，如对 Python 3.8 的支持、对源索引的优化等。</li>
</ul>
<h3 id="wheel-发展历史">Wheel 发展历史</h3>
<p>Wheel 是 Python 包分发的一种格式，它的发展历史可以追溯到 2012 年，以下是 Wheel 的发展历史概述：</p>
<ul>
<li>
<p>2012 年：Wheel 首次提出，它的目标是提供一种更快、更可靠、更简单的 Python 包分发格式，以取代旧的 egg 格式。</p>
</li>
<li>
<p>2013 年：Wheel 1.0 发布，它引入了一些新的功能和改进，如对 namespace packages 的支持、对多平台支持的改进等。</p>
</li>
<li>
<p>2014 年：Wheel 0.24 发布，它引入了一些新的功能和改进，如对 Python 3.4 的支持、对源码分发的改进等。</p>
</li>
<li>
<p>2016 年：Wheel 0.29 发布，它引入了一些新的功能和改进，如对 Python 3.6 的支持、对源码分发的改进等。</p>
</li>
<li>
<p>2018 年：Wheel 0.31 发布，它引入了一些新的功能和改进，如对 Python 3.7 的支持、对源码分发的改进等。</p>
</li>
<li>
<p>2020 年：Wheel 0.35 发布，它引入了一些新的功能和改进，如对 Python 3.9 的支持、对源码分发的改进等。</p>
</li>
</ul>
<p>Egg 是 Python 包分发格式之一，它的全称是 Easy Install Package，是由 setuptools 提供的一种打包和安装 Python 包的格式。Egg 格式早期是作为 Python 包管理工具 easy_install 的默认格式而出现的，但现在已逐渐被 Wheel 格式取代。</p>
<p>Egg 格式的文件扩展名为 .egg，它是一个压缩文件，可以包含 Python 模块、资源文件、文档等。与其他 Python 包分发格式相比，Egg 格式具有以下特点：</p>
<ul>
<li>Egg 格式的文件可以被 easy_install 直接安装，无需解包。</li>
<li>Egg 格式支持 Python 2.x 和 Python 3.x 的跨版本安装。</li>
<li>Egg 格式支持多版本安装，可以在同一台机器上同时安装多个版本的同一 Python 包。</li>
</ul>
<p>虽然 Egg 格式曾经是 Python 包分发生态系统中的一个重要组成部分，但是随着 setuptools 的发展和 Wheel 格式的出现，Egg 格式已经逐渐被取代。现在大部分 Python 包都已经使用 Wheel 格式进行分发，因为它比 Egg 格式更快、更可靠、更灵活，并且能够支持更多的 Python 版本和平台。</p>
<p>Wheel 是 Python 包分发格式之一，它的全称是 Python Wheel Package，是由 Python 社区提供的一种打包和安装 Python 包的格式。与其他 Python 包分发格式相比，Wheel 格式具有以下特点：</p>
<ul>
<li>Wheel 格式的文件扩展名为 .whl，它是一个压缩文件，可以包含 Python 模块、资源文件、文档等。</li>
<li>Wheel 格式支持 Python 2.x 和 Python 3.x 的跨版本安装。</li>
<li>Wheel 格式可以包含 C 扩展模块，因此可以在安装时直接编译和安装 C 扩展模块，而不需要使用其他工具。</li>
<li>Wheel 格式支持多平台安装，即可以在 Windows、Linux、macOS 等不同的操作系统上安装同一个 Wheel 包。</li>
<li>Wheel 格式的安装速度比 Egg 格式快，因为它使用了更简单、更快速的算法。</li>
<li>Wheel 格式可以通过 pip 工具直接安装，无需使用其他 Python 包管理工具。</li>
</ul>
<h2 id="twine-发展历史">Twine 发展历史</h2>
<p>Twine 是 Python 生态系统中的一个包管理工具，它主要用于将打包好的 Python 包上传到 PyPI（Python Package Index）等包仓库中。以下是 Twine 的发展历史概述：</p>
<ul>
<li>2015 年：Twine 工具发布，它是一个用于上传 Python 包到 PyPI 的命令行工具，支持 GPG 签名和 HTTPS 传输。</li>
<li>2016 年：Twine 1.4 版本发布，它增加了对 Wheel 包格式的支持，以及一些新特性和改进，如支持多个 PyPI 仓库、支持检查包重复上传等。</li>
<li>2017 年：Twine 1.8 版本发布，它增加了对 PEP 517 和 PEP 518 的支持，以及一些新特性和改进，如支持源码安装、支持上传多个包文件等。</li>
<li>2018 年：Twine 1.12 版本发布，它增加了对 Python 3.7 和 PyPI 的新特性的支持，以及一些新特性和改进，如支持使用环境变量配置 PyPI 仓库、支持使用 .pypirc 文件配置认证信息等。</li>
<li>2020 年：Twine 3.2 版本发布，它移除了 Python 2 的支持，增加了对 Python 3.9 的支持，以及一些新特性和改进，如支持使用 twine check 命令检查包是否符合 PyPI 标准、支持使用 twine register 命令在 PyPI 中注册项目等。</li>
</ul>
<h2 id="virtualenv-发展历史">virtualenv 发展历史</h2>
<p>Virtualenv 是 Python 生态系统中的一个重要工具，它提供了一种在单个系统中运行多个独立 Python 环境的方式。</p>
<p>Virtualenv 是由 Ian Bicking 开发的，它是一个 Python 虚拟环境管理工具。Ian Bicking 是一位 Python 程序员和开源软件贡献者，他还是 Pylons 和 Paste 等框架的创始人之一。</p>
<p>Virtualenv 的第一个版本于 2007 年发布，它的主要目的是为了解决 Python 包依赖性的问题。在 Python 中，不同的项目可能需要不同的 Python 版本和依赖包，而这些依赖包可能会相互冲突。Virtualenv 可以创建一个隔离的 Python 环境，使得每个项目都可以独立地安装和使用其所需的 Python 版本和依赖包，从而避免了冲突问题。</p>
<p>在 Virtualenv 发布之后，它很快成为了 Python 开发社区中的一个重要工具，受到了广泛的关注和使用。Virtualenv 后来也被集成到了 Python 官方的文档中，并且有许多其他的虚拟环境管理工具，如 Pyenv 和 Conda，也是基于 Virtualenv 的思想和实现方式开发的。</p>
<p>以下是 Virtualenv 的发展历史概述：</p>
<ul>
<li>2007 年：Virtualenv 工具发布，它是一个用于创建独立 Python 环境的工具，可以避免不同项目之间的依赖冲突。</li>
<li>2009 年：Virtualenvwrapper 工具发布，它是 Virtualenv 的一个扩展，提供了更好的虚拟环境管理方式，如创建、切换、删除虚拟环境等。</li>
<li>2010 年：Virtualenv 1.5 版本发布，它增加了对 Python 3 的支持，以及一些新特性和改进，如支持使用 requirements.txt 文件安装依赖、支持使用 pip 安装包等。</li>
<li>2011 年：Virtualenv 1.6 版本发布，它增加了对 Python 3.2 的支持，以及一些新特性和改进，如支持使用 -p 选项指定 Python 解释器、支持使用 &ndash;system-site-packages 选项共享系统 Python 包等。</li>
<li>2013 年：Virtualenv 1.10 版本发布，它增加了对 Python 3.3 的支持，以及一些新特性和改进，如支持使用 &ndash;always-copy 选项复制依赖包、支持使用 &ndash;clear 选项清空虚拟环境等。</li>
<li>2017 年：Virtualenv 16.0 版本发布，它增加了对 Python 3.6 和 pip 10 的支持，以及一些新特性和改进，如支持使用 &ndash;upgrade 选项更新包、支持使用 &ndash;prompt 选项设置虚拟环境提示符等。</li>
<li>2018 年：Virtualenv 16.1 版本发布，它增加了对 Python 3.7 的支持，以及一些新特性和改进，如支持使用 &ndash;creator 选项指定创建虚拟环境的方式、支持使用 &ndash;verbose 选项显示详细信息等。</li>
<li>2019 年：Virtualenv 16.7.0 版本发布，它增加了对 Python 3.8 的支持，以及一些新特性和改进，如支持使用 &ndash;system-site-packages 选项共享系统 Python 包、支持使用 &ndash;copies 选项复制依赖包等。</li>
<li>2020 年：Virtualenv 20.0.0 版本发布，它增加了对 Python 3.9 和 pip 20 的支持，以及一些新特性和改进，如支持使用 &ndash;prompt-cmd 选项设置虚拟环境提示符、支持使用 &ndash;no-pip 选项创建不包含 pip 的虚拟环境等。</li>
<li>2021 年：Virtualenv 20.8.1 版本发布，它增加了对 Python 3.10 的支持，以及一些新特性和改进，如支持使用 &ndash;download 选项从指定 URL 下载 Python 解释器、支持使用 &ndash;clear 选项清空虚拟环境等。</li>
</ul>
<p>总的来说，Virtualenv 是 Python 生态系统中一个非常重要的工具，它提供了一种方便、快捷的虚拟环境管理方式，为 Python 开发者提供了很多便利。在其发展历史中，Virtualenv 不断更新迭代，增加了许多新特性和功能，以适应 Python 生态系统的变化和需求。虽然现在 Virtualenv 已经不再主动维护，但它的代码被集成到其他工具中，如 venv 和 pipenv，仍然为 Python 开发者提供基础支持。</p>
<h2 id="venv-发展历史">venv 发展历史</h2>
<p>venv 是由 Python 官方开发团队开发的，它是 Python 3.3 版本引入的标准库模块，用于创建 Python 虚拟环境。</p>
<p>Python 的官方文档中对 venv 的介绍如下：</p>
<p>&ldquo;venv 模块提供了 Python 3 中的虚拟环境支持。虚拟环境是 Python 环境的隔离副本，包括 Python 解释器和一个独立的库副本。虚拟环境通常用于为不同的项目创建独立的环境，以避免项目之间的依赖冲突。&rdquo;</p>
<p>与 Virtualenv 和其他虚拟环境管理工具不同，venv 是 Python 官方提供的标准库模块，因此它的功能和用法都与 Python 解释器密切相关，并且在 Python 安装时已经预装了 venv 模块，因此不需要额外安装。</p>
<p>在使用 venv 创建虚拟环境时，可以选择使用系统中已经安装的 Python 解释器，也可以使用 venv 模块自动安装一个新的 Python 解释器。创建的虚拟环境和它所依赖的 Python 包都是独立的，不会与系统中的 Python 环境和其他虚拟环境产生冲突。</p>
<p>以下是 venv 的发展历史概述：</p>
<ul>
<li>
<p>2012 年：Python 3.3 版本发布，它引入了 venv 标准库，用于创建独立的 Python 环境，取代了 Python 2 中的 virtualenv 工具。</p>
</li>
<li>
<p>2013 年：venv 1.1 版本发布，它增加了对 Python 3.4 的支持，以及一些新特性和改进，如支持使用 &ndash;system-site-packages 选项共享系统 Python 包、支持使用 &ndash;copies 选项复制依赖包等。</p>
</li>
<li>
<p>2014 年：venv 1.2 版本发布，它增加了对 Python 3.5 的支持，以及一些新特性和改进，如支持使用 &ndash;clear 选项清空虚拟环境、支持使用 &ndash;upgrade 选项更新包等。</p>
</li>
<li>
<p>2015 年：venv 1.3 版本发布，它增加了对 Python 3.6 的支持，以及一些新特性和改进，如支持使用 &ndash;prompt 选项设置虚拟环境提示符、支持使用 &ndash;without-pip 选项创建不包含 pip 的虚拟环境等。</p>
</li>
<li>
<p>2017 年：venv 3.6.0 版本发布，它增加了对 Python 3.6 的支持，以及一些新特性和改进，如支持使用 activate.csh 和 activate.fish 脚本、支持使用 bin/python3 命令启动 Python 解释器等。</p>
</li>
<li>
<p>2018 年：venv 3.7.0 版本发布，它增加了对 Python 3.7 的支持，以及一些新特性和改进，如支持使用 venv 模块创建虚拟环境、支持使用 ensurepip 模块安装 pip 等。</p>
</li>
<li>
<p>2019 年：venv 3.8.0 版本发布，它增加了对 Python 3.8 的支持，以及一些新特性和改进，如支持使用 &ndash;symlinks 选项创建符号链接而非复制文件、支持使用 &ndash;upgrade-deps 选项更新依赖包等。</p>
</li>
<li>
<p>2020 年：venv 3.9.0 版本发布，它增加了对 Python 3.9 的支持，以及一些新特性和改进，如支持使用 &ndash;list 选项列出虚拟环境中已安装的包、支持使用 &ndash;upgrade 选项更新 pip 等。</p>
</li>
<li>
<p>2021 年：venv 3.10.0 版本发布，它增加了对 Python 3.10 的支持，以及一些新特性和改进，如支持使用 &ndash;symlink-to 选项指定符号链接目录、支持使用 &ndash;prompt-cmd 选项设置虚拟环境提示符等。</p>
</li>
</ul>
<h2 id="pyenv发展历史">Pyenv发展历史</h2>
<p>Pyenv 是一个 Python 版本管理工具，可以用于在同一系统中管理多个 Python 版本。以下是 Pyenv 的发展历史概述：</p>
<ul>
<li>2011 年：Pyenv 0.1.0 版本发布，最初由 Yasuhiro Matsumoto 开发。这个版本只支持在 Bash shell 中使用。</li>
<li>2012 年：Pyenv 0.2.0 版本发布，支持在其他 shell 中使用，如 Zsh 和 Fish。</li>
<li>2013 年：Pyenv 0.4.0 版本发布，增加了对 Python 3 的支持。</li>
<li>2014 年：Pyenv 0.4.1 版本发布，增加了对 Jython 和 Stackless Python 的支持。</li>
<li>2015 年：Pyenv 1.0.0 版本发布，它增加了对 Python 的解释器和标准库的支持，以及一些新特性和改进，如增加了 pyenv virtualenv 命令来管理虚拟环境、增加了 pyenv whence 命令来查找可执行文件的位置等。</li>
<li>2018 年：Pyenv 1.2.0 版本发布，增加了对 PyPy3 的支持，并修复了一些 bug。</li>
<li>2020 年：Pyenv 1.2.21 版本发布，增加了对 Python 3.9.0 的支持，并修复了一些 bug。</li>
</ul>
<p>Pyenv 的发展历史显示出它的长期稳定性和不断改进的趋势，以适应不断变化的 Python 生态系统和开发者需求。Pyenv 的主要特点是可以在同一系统中管理多个 Python 版本，可以很方便地切换版本，也支持使用虚拟环境来隔离不同项目的依赖。Pyenv 在 Python 开发者社区中广受欢迎，是一个不可或缺的工具之一。</p>
<h2 id="pipenv发展历史">Pipenv发展历史</h2>
<p>Pipenv 是在 2017 年由 Kenneth Reitz 开发的 Python 项目依赖管理工具。以下是 Pipenv 的发展历史概述：</p>
<ul>
<li>2017 年：Pipenv 1.0.0 版本发布，它是第一个稳定版本。Pipenv 结合了 pip 和 virtualenv 的功能，提供了一个更简单的方式来管理 Python 项目依赖。它自动为每个项目创建虚拟环境，并使用 Pipfile 和 Pipfile.lock 文件来管理项目依赖。</li>
<li>2018 年：Pipenv 2018.5.18 版本发布，它增加了许多新特性和改进，如支持使用 &ndash;skip-lock 选项跳过生成 Pipfile.lock 文件、支持使用 &ndash;deploy 选项安装 Pipfile.lock 文件中的依赖、支持使用 &ndash;update 选项更新依赖等。</li>
<li>2019 年：Pipenv 2019.6.3 版本发布，它增加了对 Python 3.8 的支持，以及一些新特性和改进，如支持使用 &ndash;use-feature 选项安装依赖、支持使用 &ndash;outdated 选项显示过期的依赖等。</li>
<li>2020 年：Pipenv 2020.6.2 版本发布，它增加了支持使用 &ndash;python 选项指定 Python 解释器版本、支持使用 &ndash;pre 选项安装预览版依赖、支持使用 &ndash;keep-outdated 选项保留过期的依赖等。</li>
<li>2021 年：Pipenv 2021.5.29 版本发布，它增加了对 Python 3.10 的支持，以及一些新特性和改进，如支持使用 &ndash;platform 选项指定安装依赖的平台、支持使用 &ndash;bundle 选项生成依赖包压缩文件等。</li>
</ul>
<h2 id="poetry-发展历史">Poetry 发展历史</h2>
<p>Poetry 是一个较新的 Python 项目依赖管理工具，在 2018 年由 Sébastien Eustace 开发。以下是 Poetry 的发展历史概述：</p>
<ul>
<li>2018 年：Poetry 0.1.0 版本发布，它是第一个公开发布的版本。Poetry 通过 pyproject.toml 文件来管理项目依赖，并使用虚拟环境来隔离项目依赖。</li>
<li>2019 年：Poetry 0.12.0 版本发布，它增加了对 Python 3.8 的支持，以及一些新特性和改进，如支持使用 &ndash;lock 选项生成锁文件、支持使用 &ndash;develop 选项安装开发依赖等。</li>
<li>2020 年：Poetry 1.0.0 版本发布，它增加了对 Python 3.9 的支持，以及一些新特性和改进，如支持使用 &ndash;experimental 选项启用实验性功能、支持使用 &ndash;remove-untracked 选项删除未跟踪的依赖等。</li>
<li>2021 年：Poetry 1.2.0 版本发布，它增加了对 Python 3.10 的支持，以及一些新特性和改进，如支持使用 &ndash;workspace 选项管理多个相关项目、支持使用 &ndash;source 选项指定依赖源等。</li>
</ul>
<p>Poetry 的发展历史显示出它的快速发展和不断改进的趋势，以适应不断变化的 Python 生态系统和开发者需求。Poetry 相较于 pipenv 和 virtualenv 等工具，它有着更加简洁的配置文件和更加易于使用的命令行接口，因此在 Python 开发者中越来越受欢迎。</p>
<h2 id="pdm发展历史">Pdm发展历史</h2>
<p>PDM 是一个比较新的 Python 项目依赖管理工具，由李辉开发，它于 2020 年首次发布。以下是 PDM 的发展历史概述：</p>
<ul>
<li>2020 年：PDM 0.1.0 版本发布，它是第一个公开发布的版本。PDM 使用 pyproject.toml 文件来管理项目依赖，并使用虚拟环境来隔离项目依赖。与其他依赖管理工具不同，PDM 可以使用多个依赖源，以便从不同的源安装依赖。</li>
<li>2021 年：PDM 1.0.0 版本发布，它增加了对 Python 3.10 的支持，以及一些新特性和改进，如支持使用 &ndash;edit 选项编辑依赖文件、支持使用 &ndash;update-prereleases 选项更新预览版依赖等。</li>
<li>2022 年：PDM 2.0.0 版本发布，它增加了对 Python 3.11 的支持，以及一些新特性和改进，如支持使用 &ndash;lockfile 选项指定锁定文件、支持使用 &ndash;find-links 选项指定依赖的本地路径或 URL 等。</li>
</ul>
<p>PDM 的发展历史显示出它的快速发展和不断改进的趋势，以适应不断变化的 Python 生态系统和开发者需求。PDM 具有类似 Poetry 的简洁配置文件和易于使用的命令行接口，但 PDM 的多源支持和依赖快照功能则是它的独特特点，这些功能使得 PDM 在一些特定场景下更加适用。</p>
<h2 id="pyflow-发展历史">Pyflow 发展历史</h2>
<p>Pyflow 是另一个 Python 项目依赖管理工具，于 2016 年首次发布。以下是 Pyflow 的发展历史概述：</p>
<ul>
<li>2016 年：Pyflow 0.1.0 版本发布，它是第一个公开发布的版本。Pyflow 使用 requirements.txt 文件来管理项目依赖，并使用虚拟环境来隔离项目依赖。与其他依赖管理工具不同，Pyflow 支持自动化的依赖解决方案，以便更轻松地安装和更新依赖。</li>
<li>2017 年：Pyflow 0.3.0 版本发布，它增加了许多新特性和改进，如支持使用 &ndash;editable 选项安装可编辑依赖、支持使用 &ndash;pre 选项安装预览版依赖等。</li>
<li>2018 年：Pyflow 2.0.0 版本发布，它增加了对 Python 3 的支持，以及一些新特性和改进，如支持使用 Pipfile.lock 文件管理依赖、支持在 Pipfile 中使用多个依赖源等。</li>
</ul>
<p>尽管 Pyflow 的开发已经停止，但是它的一些思想和特性被其他依赖管理工具所采纳，例如 Pipenv 和 Poetry。Pyflow 在其时代内曾经是一个有影响力的依赖管理工具，它的自动化依赖解决方案、虚拟环境功能和多个依赖源等特性为后来的依赖管理工具提供了启示。</p>
<h2 id="conda-发展历史">Conda 发展历史</h2>
<p>Conda 是一个开源的包管理系统和环境管理系统，用于管理 Python 包和其他科学计算相关的软件包。以下是 Conda 的发展历史：</p>
<ol>
<li>
<p>2012 年，Continuum Analytics 公司发布了第一个版本的 Conda，用于管理 Python 环境和软件包。</p>
</li>
<li>
<p>2015 年，Conda 发布了 4.0 版本，引入了虚拟环境和交叉平台支持，支持 Python、R 和其他语言的包管理。</p>
</li>
<li>
<p>2016 年，Conda 发布了 4.2 版本，引入了 Conda Forge，一个社区驱动的软件包仓库，提供了更丰富的软件包和更快的更新周期。</p>
</li>
<li>
<p>2018 年，Conda 发布了 4.5 版本，引入了命令行界面的改进和新功能，如环境快速复制和包依赖关系的可视化。</p>
</li>
<li>
<p>2019 年，Conda 发布了 4.6 版本，引入了环境锁定和自动环境激活功能，提高了环境管理的效率和可靠性。</p>
</li>
<li>
<p>2020 年，Anaconda Inc. 收购了 Quansight 公司，并将其旗下的 Mamba 包管理器与 Conda 进行整合，提高了包管理的速度和稳定性。</p>
</li>
<li>
<p>2021 年，Conda 发布了 4.10 版本，引入了 Conda 市场，一个用户界面友好的软件包搜索和安装工具，提供了更好的用户体验和社区支持。</p>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>项目依赖管理工具（虚拟环境）：</p>
<ul>
<li>官方的：
<ul>
<li>venv</li>
</ul>
</li>
<li>三方的：
<ul>
<li>virtualenv</li>
<li>pyenv</li>
<li>pipenv</li>
<li>pyflow</li>
<li>poetry</li>
<li>pdm</li>
<li>Conda</li>
</ul>
</li>
</ul>
<p>包管理工具：</p>
<ul>
<li>setuptools：包构建</li>
<li>twine：包上传和发布</li>
<li>pip：包安装工具</li>
<li>pypa/build：包构建，用于替代 setuptools</li>
</ul>
<p>下面是 pdm、poetry、pipenv、venv、virtualenv、conda 的简要对比：</p>
<p>1、pdm：</p>
<p>优点：</p>
<ul>
<li>支持 Pipfile.lock 管理依赖项，可以保证依赖项的版本和环境的一致性。</li>
<li>自动创建和管理虚拟环境，可以避免环境冲突和版本问题。</li>
<li>自动安装缺失的系统依赖项，可以避免出现缺少系统库导致的问题。</li>
<li>自动审查安全漏洞，可以避免使用有安全漏洞的依赖项。</li>
</ul>
<p>缺点：</p>
<ul>
<li>还比较新，生态不够完善。</li>
<li>没有像 poetry 和 pipenv 那样支持发布包到 PyPI。</li>
</ul>
<p>2、poetry：</p>
<p>优点：</p>
<ul>
<li>支持 pyproject.toml 管理依赖项，可以保证依赖项的版本和环境的一致性。</li>
<li>自动创建和管理虚拟环境，可以避免环境冲突和版本问题。</li>
<li>自动安装缺失的系统依赖项，可以避免出现缺少系统库导致的问题。</li>
<li>自动审查安全漏洞，可以避免使用有安全漏洞的依赖项。</li>
<li>支持发布包到 PyPI。</li>
</ul>
<p>缺点：</p>
<ul>
<li>有些人觉得配置比较复杂，学习曲线比较陡峭。</li>
</ul>
<p>3、pipenv：</p>
<p>优点：</p>
<ul>
<li>支持 Pipfile 和 Pipfile.lock 管理依赖项，可以保证依赖项的版本和环境的一致性。</li>
<li>自动创建和管理虚拟环境，可以避免环境冲突和版本问题。</li>
<li>自动安装缺失的系统依赖项，可以避免出现缺少系统库导致的问题。</li>
<li>自动审查安全漏洞，可以避免使用有安全漏洞的依赖项。</li>
<li>支持发布包到 PyPI。</li>
</ul>
<p>缺点：</p>
<ul>
<li>有些人觉得速度比较慢。</li>
<li>有些人觉得配置比较复杂，学习曲线比较陡峭。</li>
</ul>
<p>4、venv：</p>
<p>优点：</p>
<ul>
<li>自带 Python，无需安装额外的依赖。</li>
<li>简单易用，命令行操作方便。</li>
<li>Python 3.3+ 后自带，不需要安装额外的库。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只支持 Python 3.3+。</li>
<li>需要手动安装依赖项。</li>
</ul>
<p>5、virtualenv：</p>
<p>优点：</p>
<ul>
<li>支持 Python 2 和 Python 3。</li>
<li>可以在同一台机器上创建多个虚拟环境，可以避免环境冲突和版本问题。</li>
<li>可以在不同的 Python 版本之间切换。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要手动安装依赖项。</li>
</ul>
<p>6、conda：</p>
<p>优点：</p>
<ul>
<li>支持多个操作系统和多个 Python 版本。</li>
<li>可以管理 Python 环境和非 Python 环境。</li>
<li>可以管理依赖项和安装包。</li>
<li>可以创建和管理虚拟环境。</li>
<li>支持发布包到 Anaconda Cloud。</li>
</ul>
<p>缺点：</p>
<ul>
<li>安装包可能比较大。</li>
<li>有些人觉得配置比较复杂，学习曲线比较陡峭。</li>
</ul>
<p>总的来说，这些工具都有各自的优缺点，可以根据自己的需求和使用习惯选择最适合自己的工具。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Python安装、构建、发布、下载和运行</title>
      <link>https://blog.chensoul.com/posts/2023/05/09/python-install-build-publish-run/</link>
      <pubDate>Tue, 09 May 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/05/09/python-install-build-publish-run/</guid>
      <description>最近开始学习 python，这篇文章记录如何安装 python、搭建 python 开发环境，以及如何构建、发布 python 包。我使用的是 macos 系统，所以本篇文章中的一些命</description>
      <content:encoded><![CDATA[<p>最近开始学习 python，这篇文章记录如何安装 python、搭建 python 开发环境，以及如何构建、发布 python 包。我使用的是 macos 系统，所以本篇文章中的一些命令是基于 macos ，特此说明。</p>
<h2 id="1安装">1、安装</h2>
<p>MacOS 上通过 brew 安装 Python3：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">brew install python3
</span></span></code></pre></div><p>查看 python3 安装路径：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ which python3
</span></span><span class="line"><span class="cl">/opt/homebrew/bin/python3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ <span class="nb">type</span> python3
</span></span><span class="line"><span class="cl">python3 is /opt/homebrew/bin/python3
</span></span></code></pre></div><p>查看版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">python --version
</span></span></code></pre></div><p>设置环境变量，我使用的是 zsh，所以需要修改 ~/.zshrc，添加下面代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PYTHON_HOME</span><span class="o">=</span>/opt/homebrew/opt/python@3.11
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PYTHON_HOME</span>/bin:<span class="nv">$PATH</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">python</span><span class="o">=</span>python3
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">pip</span><span class="o">=</span>pip3
</span></span></code></pre></div><p>使配置生效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">source</span> ~/.zshrc
</span></span></code></pre></div><h2 id="2创建项目">2、创建项目</h2>
<p>创建一个目录 chensoul_hello：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkdir chensoul_hello
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> chensoul_hello
</span></span></code></pre></div><p>创建一个 main.py ，打印 helloworld：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hello world&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>试试运行 main.py：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">python main.py
</span></span></code></pre></div><h2 id="3创建虚拟环境">3、创建虚拟环境</h2>
<p>使用 python venv 模块创建虚拟环境 .venv：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">python -m venv .venv
</span></span></code></pre></div><p>使用 . 开头的目录或者文件为隐藏文件。<code>如果使用 git 管理项目，则需要将 .venv 添加到 .gitignore</code>。</p>
<p>激活虚拟环境：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">source</span> .venv/bin/activate
</span></span></code></pre></div><h2 id="4使用-setuptools-管理项目">4、使用 setuptools 管理项目</h2>
<p>setuptools 是 Python 的一个包管理工具，它可以帮助开发人员更方便地打包和发布 Python 代码。setuptools 提供了一些命令行工具，例如 easy_install 和 setup.py。</p>
<p><code>setup.py</code> 文件是 setuptools 用于构建、打包和发布 Python 包的核心文件之一。通过 <code>setup.py</code> 文件，开发人员可以指定包的元数据、依赖关系、安装脚本等信息，从而实现包的安装、升级和卸载等操作。</p>
<p>具体来说，<code>setup.py</code> 文件通常包含以下内容：</p>
<ul>
<li>包的元数据，例如包的名称、版本号、作者、许可证等信息。</li>
<li>包的依赖关系，例如需要依赖哪些其他 Python 包。</li>
<li>包的安装脚本，例如需要安装哪些文件、脚本等。</li>
<li>其他自定义的构建和发布选项，例如文档生成、命令行工具的生成等。</li>
</ul>
<p>通过运行 <code>python setup.py</code> 命令，可以执行一系列操作，例如将包构建为源代码或二进制分发包、将其上传到 PyPI 或其他包仓库、安装包到本地系统等。同时，setuptools 还提供了一些功能，例如自动化依赖关系管理、版本控制、命令行工具的生成和文档的生成等，可以帮助开发人员更加高效地进行 Python 开发。</p>
<p>1、安装 setuptools</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip install setuptools
</span></span></code></pre></div><p>2、创建 setup.py 文件</p>
<p>在使用 setuptools 时，通常需要创建一个 setup.py 文件，用来描述包的信息、依赖关系和安装方式等。setup.py 文件通常包含一个 setup() 函数，用来定义包的元数据和依赖关系等信息。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">find_packages</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">setup</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;chensoul_hello&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">version</span><span class="o">=</span><span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">author</span><span class="o">=</span><span class="s1">&#39;chensoul&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">author_email</span><span class="o">=</span><span class="s1">&#39;chensoul@chensoul.com&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;A simple Python package&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">packages</span><span class="o">=</span><span class="n">find_packages</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;numpy&gt;=1.16.0&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;pandas&gt;=0.23.4&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="n">entry_points</span><span class="o">=</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;console_scripts&#39;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;hello_command=chensoul_hello.cli:main&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>这个 <code>setup.py</code> 文件定义了一个名为 <code>chensoul_hello</code> 的 Python 包，指定了包的元数据、依赖关系等信息。</p>
<ul>
<li><code>name</code>：包的名称。</li>
<li><code>version</code>：包的版本号。</li>
<li><code>author</code>：包的作者。</li>
<li><code>author_email</code>：作者的电子邮件地址。</li>
<li><code>description</code>：包的简要描述。</li>
<li><code>packages</code>：包含需要打包的 Python 包的列表，使用 <code>find_packages()</code> 函数可以自动查找所有包。</li>
<li><code>install_requires</code>：包依赖的其他 Python 包。</li>
<li><code>console_scripts</code>： 是一个可选参数，用于定义包中的命令行工具。它是一个字典，键是命令的名称，值是命令对应的入口点（entry point）。入口点是一个字符串，通常是模块名和函数名的组合，例如 &ldquo;chensoul_hello.cli:main&rdquo;，表示调用 chensoul_hello 包中的 cli 模块的 main 函数。当使用 setuptools 安装包时，console_scripts 会自动创建一个可执行文件，并将入口点指向该文件。这个文件通常被放在 Python 的 bin 目录下，例如 /usr/local/bin。</li>
</ul>
<p>对于上面的例子，如果想要在命令行中使用 hello_command 命令，需要创建名为 &ldquo;chensoul_hello&rdquo; 的 Python 包：</p>
<ul>
<li>
<p>创建一个名为 &ldquo;chensoul_hello&rdquo; 的文件夹，并进入该文件夹。</p>
</li>
<li>
<p>在 &ldquo;chensoul_hello&rdquo; 文件夹中创建一个名为 <code>__init__.py</code> 的空文件。这个文件用于指示 Python 解释器该文件夹是一个 Python 包。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkdir chensoul_hello
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> chensoul_hello
</span></span><span class="line"><span class="cl">touch __init__.py
</span></span></code></pre></div></li>
<li>
<p>在 &ldquo;chensoul_hello&rdquo; 文件夹中创建一个名为 <code>cli.py</code> 的文件。这个文件用于定义命令行脚本的入口函数。在 <code>cli.py</code> 文件中添加以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Hello, world!&#34;</span><span class="p">)</span>
</span></span></code></pre></div></li>
</ul>
<h2 id="5使用-setuptools-构建包">5、使用 setuptools 构建包</h2>
<p>在项目的根目录，使用以下命令来构建源码分发包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">python setup.py sdist
</span></span></code></pre></div><p>或者使用以下命令来构建二进制 wheel 包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">python setup.py bdist_wheel
</span></span></code></pre></div><p>在执行上面两个命令之前，需要确保已经安装了 setuptools 和 wheel。如果没有安装，可以使用以下命令安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip install setuptools wheel
</span></span></code></pre></div><p>也可以一起执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">python setup.py sdist bdist_wheel
</span></span></code></pre></div><p>执行完成后，会在当前目录下生成 dist 目录，并在其中生成两个包文件：一个源代码包和一个二进制包。这两个包文件可以通过 pip 安装，也可以直接将它们拷贝到其他机器上使用。</p>
<h2 id="6使用-twine-发布包">6、使用 twine 发布包</h2>
<p>twine 是一个 Python 包，用于将 Python 包上传到 PyPI 或其他类似的包仓库。它可以帮助你将打包好的 Python 包上传到 PyPI 服务器或其他类似的服务器。</p>
<ol>
<li>安装 twine</li>
</ol>
<p>在终端或命令行中运行以下命令安装 twine：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip install twine
</span></span></code></pre></div><ol start="2">
<li>打包 Python 包</li>
</ol>
<p>如果你已经使用 setuptools 构建了源码分发包或二进制 wheel 包，可以使用 <code>wheel</code> 工具来将其转换为 wheel 包或上传到 PyPI 或其他支持的包仓库。例如，使用以下命令将源码分发包转换为 wheel 包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip wheel dist/chensoul_hello-1.0.0.tar.gz
</span></span></code></pre></div><ol start="3">
<li>注册账号</li>
</ol>
<p>在上传包之前，你需要注册一个 PyPI 账号。如果你还没有注册，请访问 PyPI 网站（https://pypi.org/account/register/）进行注册。</p>
<p>在使用 <code>twine</code> 工具上传包时，需要先在 PyPI 网站上注册账号并获取上传凭证（例如 API 密钥或用户名密码），然后将凭证保存在本地的 <code>$HOME/.pypirc</code> 文件中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">pypi</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nx">username</span> <span class="p">=</span> <span class="nx">__token__</span>
</span></span><span class="line"><span class="cl">  <span class="nx">password</span> <span class="p">=</span> <span class="nx">pypi-XXXXXX</span>
</span></span></code></pre></div><ol start="4">
<li>上传 Python 包</li>
</ol>
<p><code>twine</code> 工具支持上传到以下包仓库：</p>
<ul>
<li>
<p>PyPI（Python Package Index）：PyPI 是 Python 社区的官方包仓库，提供了大量的 Python 包供用户下载和使用。PyPI 使用 <a href="https://pypi.org/">https://pypi.org/</a> 作为官方网站，可以使用 <code>twine</code> 工具将包上传到 PyPI。</p>
</li>
<li>
<p>Test PyPI：Test PyPI 是 PyPI 的一个测试环境，用于测试和验证包的上传和分发过程。Test PyPI 使用 <a href="https://test.pypi.org/">https://test.pypi.org/</a> 作为官方网站，可以使用 <code>twine</code> 工具将包上传到 Test PyPI。</p>
</li>
<li>
<p>任何支持 twine 格式的包仓库：<code>twine</code> 工具支持将包上传到任何支持 twine 格式的包仓库，只需要指定包仓库的 URL 和凭证即可。例如，可以使用 <code>twine</code> 工具将包上传到自己的私有包仓库或第三方包仓库。</p>
</li>
</ul>
<p>例如，使用以下命令将一个 wheel 包上传到 PyPI：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ twine upload dist/chensoul_hello-1.0.0-py3-none-any.whl
</span></span><span class="line"><span class="cl">Enter your username: __token__
</span></span><span class="line"><span class="cl">Enter your password:
</span></span></code></pre></div><p>或者使用以下命令将一个源码分发包上传到 PyPI：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">twine upload dist/chensoul_hello-1.0.0.tar.gz
</span></span></code></pre></div><p>同时上传wheel 包和源码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">twine upload dist/*
</span></span></code></pre></div><p>这个命令将会上传 <code>dist</code> 目录下的所有包到 Test PyPI。需要注意的是，上传到不同的包仓库可能需要不同的命令和参数，具体可以参考包仓库的文档或帮助信息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">twine upload --repository-url https://test.pypi.org/legacy/ dist/*
</span></span></code></pre></div><p>如果上传时提示错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Uploading distributions to https://upload.pypi.org/legacy/
</span></span><span class="line"><span class="cl">Uploading chensoul_hello-1.0.0-py3-none-any.whl
</span></span><span class="line"><span class="cl">100% ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 4.5/4.5 kB • 00:00 • ?
</span></span><span class="line"><span class="cl">WARNING  Error during upload. Retry with the --verbose option <span class="k">for</span> more details.
</span></span><span class="line"><span class="cl">ERROR    HTTPError: <span class="m">403</span> Forbidden from https://upload.pypi.org/legacy/
</span></span><span class="line"><span class="cl">        The user <span class="s1">&#39;chensoul&#39;</span> isn<span class="s1">&#39;t allowed to upload to project &#39;</span>my-package<span class="err">&#39;</span>. See https://pypi.org/help/#project-name <span class="k">for</span> more information.
</span></span></code></pre></div><p>原因是项目名称 my-package 不合法或者已存在，需要修改包名称。</p>
<p>如果项目已经存在，则可以添加参数覆盖已经存在的项目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">twine upload dist/* --skip-existing
</span></span></code></pre></div><h2 id="7使用-pip-安装包">7、使用 pip 安装包</h2>
<p>如果你想安装、升级或删除 Python 包，可以使用 <code>pip</code> 工具来进行操作。</p>
<p>使用以下命令来安装本地的包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip install dist/chensoul_hello-1.0.0.tar.gz
</span></span></code></pre></div><p>或者安装本地的 wheel 包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip install dist/chensoul_hello-1.0.0-py3-none-any.whl
</span></span></code></pre></div><p>也可以使用以下命令来从仓库中安装一个包及其依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pip install chensoul_hello
</span></span></code></pre></div><p>查看本地下载的安装包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ pip list<span class="p">|</span>grep chensoul-hello
</span></span><span class="line"><span class="cl">chensoul-hello     1.0.0
</span></span></code></pre></div><blockquote>
<p>在使用 setuptools 构建 Python 包时，包名应该符合 Python 包命名规范。具体来说，包名应该只包含小写字母、数字和短横线 <code>-</code>，不能包含其他字符，包名应该以字母开头，并且不能超过 32 个字符。</p>
<p>另外，如果你在包名中使用了短横线 <code>-</code>，在引用包时需要将其替换成下划线 <code>_</code>。例如，如果你的包名为 <code>chensoul-hello</code>，在引用包时应该使用 <code>import chensoul_hello</code>。</p>
<p>总之，在使用 setuptools 构建 Python 包时，包名应该符合 Python 包命名规范，并且如果包名中包含短横线 <code>-</code>，在引用包时应该使用下划线 <code>_</code>。</p>
</blockquote>
<p>可以使用以下命令导出当前环境中的所有依赖项列表到 requirements.txt 文件中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip freeze &gt; requirements.txt
</span></span></code></pre></div><p>可以使用以下命令根据 requirements.txt 文件中的依赖项列表安装包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip install -r requirements.txt
</span></span></code></pre></div><h2 id="8运行命令">8、运行命令</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ hello_command
</span></span><span class="line"><span class="cl">Hello, world!
</span></span></code></pre></div><h2 id="9使用-pypabuild-构建包">9、使用 pypa/build 构建包</h2>
<p>执行下面命令时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">python setup.py bdist_wheel
</span></span></code></pre></div><p>出现一个警告：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">        ********************************************************************************
</span></span><span class="line"><span class="cl">        Please avoid running <span class="sb">``</span>setup.py<span class="sb">``</span> directly.
</span></span><span class="line"><span class="cl">        Instead, use pypa/build, pypa/installer, pypa/build or
</span></span><span class="line"><span class="cl">        other standards-based tools.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        See https://blog.ganssle.io/articles/2021/10/setup-py-deprecated.html <span class="k">for</span> details.
</span></span><span class="line"><span class="cl">        ********************************************************************************
</span></span></code></pre></div><p>pypa/build 和 pypa/installer 是 Python Packaging Authority（PyPA）维护的两个工具，分别用于构建和安装 Python 包。pypa/build 就是 build 模块，而 pypa/installer 就是pip。</p>
<p>下面是它们的使用方法：</p>
<ol>
<li>
<p>安装 pypa/build 工具：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip install build
</span></span></code></pre></div></li>
<li>
<p>运行以下命令构建包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">python -m build
</span></span></code></pre></div><p><code>python -m build</code> 是一个用于构建 Python 包的命令行工具，它是 Python 3.10 中新增的标准库模块 <code>build</code> 的入口点。使用 <code>python -m build</code> 可以方便地构建源代码发行包和二进制发行包，支持多种格式，包括 <code>sdist</code>、<code>wheel</code>、<code>zip</code>、<code>tar</code> 等。</p>
<p>在使用 <code>python -m build</code> 构建 Python 包之前，需要确保你的项目符合 Python 包的标准。具体来说，你需要在项目根目录下创建一个 <code>setup.cfg</code> 文件和一个 <code>setup.py</code> 文件，其中 <code>setup.cfg</code> 文件包含项目元数据和构建选项，<code>setup.py</code> 文件包含构建和打包的具体实现。</p>
</li>
<li>
<p>如果需要发布包到 PyPI 或其他包仓库，可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">twine upload dist/*
</span></span></code></pre></div></li>
</ol>
<h2 id="10附录">10、附录</h2>
<h3 id="pypabuild-和-setuptools-对比">pypa/build 和 setuptools 对比</h3>
<p><code>python -m build</code> 和 <code>python setup.py sdist bdist_wheel</code> 都是用于构建 Python 包的命令行工具，但它们有一些区别。</p>
<ul>
<li><code>python -m build</code> 是 Python 3.10 中新增的标准库模块 <code>build</code> 的入口点，支持多种构建格式，包括 <code>sdist</code>、<code>wheel</code>、<code>zip</code>、<code>tar</code> 等。它可以自动构建源代码发行包和二进制发行包，并支持多种平台和 Python 版本。<code>python -m build</code> 的使用方式比较简单，需要在项目根目录下创建一个 <code>setup.py</code> 文件或者 <code>pyproject.toml</code> 文件，然后在项目根目录下执行 <code>python -m build</code> 命令即可。</li>
<li><code>python setup.py sdist bdist_wheel</code> 是传统的 Python 包构建方式，需要在项目根目录下创建一个 <code>setup.py</code> 文件，其中包含构建和打包的具体实现。它支持的构建格式比较有限，只包括 <code>sdist</code> 和 <code>bdist_wheel</code> 两种格式。<code>python setup.py sdist bdist_wheel</code> 的使用方式相对较为繁琐，需要执行多个命令，并指定相应的参数和选项。</li>
</ul>
<p>总之，<code>python -m build</code> 是 Python 3.10 中新增的标准库模块 <code>build</code> 的入口点，支持多种构建格式，使用起来比较简单。而 <code>python setup.py sdist bdist_wheel</code> 是传统的 Python 包构建方式，使用起来相对较为繁琐，但仍然是一种常见的构建方式。需要根据自己的实际情况选择适合的构建工具。</p>
<p>相对于使用 <code>python setup.py sdist bdist_wheel</code> 命令，使用 <code>python -m build</code> 命令有以下几个优点：</p>
<ol>
<li>更简单的命令：<code>python -m build</code> 命令比 <code>python setup.py sdist bdist_wheel</code> 命令更加简单易用，因为它不需要你编写 <code>setup.py</code> 文件。你可以使用 <code>pyproject.toml</code> 文件来代替，这样会更简单和现代化。</li>
<li>更好的配置：<code>build</code> 模块使用 <code>pyproject.toml</code> 文件来配置包的构建，这是一种更现代和标准化的配置方式。该文件可以指定构建依赖项、包含在软件包中的其他文件以及其他元数据。</li>
<li>更多的输出格式：<code>python -m build</code> 支持比 <code>python setup.py sdist bdist_wheel</code> 更多的输出格式，包括 <code>wheel</code>、<code>sdist</code>、<code>zip</code>、<code>tar</code> 等等。</li>
<li>更好的性能：相对于 <code>python setup.py sdist bdist_wheel</code> 命令，<code>python -m build</code> 命令通常更快，特别是对于具有许多依赖项的大型项目而言。这是因为 <code>build</code> 可以并行处理某些任务，例如构建二进制软件包。</li>
<li>更好的兼容性：<code>python -m build</code> 设计为与多个 Python 版本和平台兼容，而 <code>python setup.py sdist bdist_wheel</code> 命令通常特定于特定版本或平台。</li>
</ol>
<p>综上所述，相对于 <code>python setup.py sdist bdist_wheel</code> 命令，<code>python -m build</code> 提供了一种更简单、更现代、更灵活的构建 Python 包的方式，具有更好的性能和兼容性。不过，<code>python setup.py sdist bdist_wheel</code> 命令仍然是构建软件包的常用和得到广泛支持的方法，特别是对于较老的项目或具有更复杂要求的项目而言。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-15｜Umami升级到2.0、汉街蜡像馆、使用Strava跑步</title>
      <link>https://blog.chensoul.com/posts/2023/04/18/weekly_review_15/</link>
      <pubDate>Tue, 18 Apr 2023 17:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/18/weekly_review_15/</guid>
      <description>前言 ​ 题图：楚河汉街蜡像馆 本篇是对 2023-04-10 到 2023-04-16 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这周的工作不算忙碌，继续学</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-01.png" alt="weekly-review-15-01"  />
</p>
<p>​														<em>题图：楚河汉街蜡像馆</em></p>
<p>本篇是对 <code>2023-04-10</code> 到 <code>2023-04-16</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这周的工作不算忙碌，继续学习《Effective Java 3》这本书，并花了一些时间学习 Rust、Python 的基础语法。</p>
<p>这个月已经过了一半，减肥也进行了两周，体重从72公斤减到了现在的68.4公斤。在之前每天走路1万步的基础上，打算开始每天跑步，比记录跑步数据。</p>
<p>这周总计支出916元，明细如下：</p>
<ul>
<li>4月12日：329元，开通ETC预存300元</li>
<li>4月15日：116元，周末买菜做饭</li>
<li>4月16日：471元，老婆过生，吃饭和看电影</li>
</ul>
<p>四月累计支出共 2025 元，其中餐饮和购物占了一半。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-05.jpeg" alt="weekly-review-15-05" style="width:50%;" />
<h2 id="健身">健身</h2>
<p>这周每天走路步数如下，其中有一天因为加班而没有完成一万步的目标。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-06.png" alt="weekly-review-15-06" style="width:50%;" />
<p>受 <a href="https://conge.livingwithfcs.org/">@Conge</a> 博客影响，开始记录每天的跑步数据。首先是注册了 strava 账号，然后参考 <a href="https://github.com/yihong0618/running_page">running_page</a> 部署了一个我的跑步主页 <a href="https://run.chensoul.com/">run.chensoul.com</a>。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-02.png" alt="weekly-review-15-02"  />
</p>
<p>因为我之前是使用悦跑圈 APP 记录跑步，所以又参考<a href="https://github.com/yihong0618/running_page/blob/master/README-CN.md#joyrun%E6%82%A6%E8%B7%91%E5%9C%88">这篇文章</a>导出 gpx 数据，然后<a href="https://github.com/yihong0618/running_page/blob/master/README-CN.md#gpx_to_strava">同步</a>到 Strava。最后，可以把悦跑圈 APP 卸载了。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-03.png" alt="weekly-review-15-03"  />
</p>
<p>上周跑步数据如下，总计28.64公里，比上周的19.05公里多了9.6公里。</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-04.png" alt="weekly-review-15-04"  />
</p>
<p>上面搞定了之后，就可以使用 Strava 来跑步了。为了增加社交乐趣性，我在 n8n 里面创建了一个 workflow，将 Strava 活动发送到我的『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，效果如下。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-07.png" alt="weekly-review-15-07" style="width:50%;" />
<h2 id="umami升级到20">Umami升级到2.0</h2>
<p>1、首先备份数据库</p>
<p>2、升级数据库</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone https://github.com/umami-software/migrate-v1-v2.git
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> migrate-v1-v2
</span></span><span class="line"><span class="cl">yarn install
</span></span><span class="line"><span class="cl">yarn build
</span></span></code></pre></div><p>创建 .env 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-properties" data-lang="properties"><span class="line"><span class="cl"><span class="c1">#修改为你的数据库地址</span>
</span></span><span class="line"><span class="cl"><span class="na">DATABASE_URL</span><span class="o">=</span><span class="s">postgresql://umami:xxxxx@postgres.chensoul.com:5432/umami</span>
</span></span></code></pre></div><p>运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">yarn start
</span></span></code></pre></div><p>3、重新部署静态页面</p>
<p>日志提示报错：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-16.png" alt="weekly-review-15-16"  />
</p>
<p>解决办法是修改 scripts/check-db.js：</p>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-17.png" alt="weekly-review-15-17"  />
</p>
<p>4、修改跟踪脚本，把站点中所有追踪脚本名字<code>umami.js</code>改为<code>script.js</code>。</p>
<p>5、最后查看实时仪表盘。我的 umami 实时 <a href="https://umami.chensoul.com/realtime/f110cfa0-b737-4690-a032-2b9073a57fc3">访问地址</a></p>
<h2 id="工作">工作</h2>
<h3 id="effective-java-3-笔记">Effective Java 3 笔记</h3>
<p>请参考《<a href="/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources">Effective Java 3 笔记：依赖注入优于硬编码资源</a>》。</p>
<h2 id="汉街蜡像馆">汉街蜡像馆</h2>
<p>周末趁武汉旅游大年卡还没过期，跑到楚河汉街蜡像馆去溜达了一圈。因为有年卡，省去了150元的门票。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-08.png" alt="weekly-review-15-08" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-09.png" alt="weekly-review-15-09" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-10.png" alt="weekly-review-15-10" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-11.png" alt="weekly-review-15-11" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-12.png" alt="weekly-review-15-12" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-13.png" alt="weekly-review-15-13" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-14.png" alt="weekly-review-15-14" style="width:67%;" />
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekly-review-15-15.png" alt="weekly-review-15-15" style="width:67%;" />
<h2 id="好物分享">好物分享</h2>
<p>虽然大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。</p>
<h3 id="一些文章">一些文章</h3>
<p>1、<a href="https://www3.ntu.edu.sg/home/ehchua/programming/index.html">Java 编程教程</a></p>
<p><img loading="lazy" src="https://cdn.beekka.com/blogimg/asset/202301/bg2023011504.webp" alt="img"  />
</p>
<p>这个网站是新加坡南洋理工大学的一位老师的教案（英文），主要内容为新生的 Java 编程</p>
<p>2、<a href="https://offsec.tools/">offsec.tools</a></p>
<p><img loading="lazy" src="https://cdn.beekka.com/blogimg/asset/202301/bg2023012101.webp" alt="img"  />
</p>
<p>这个网站收集各种安全相关的软件工具，目前共有600多个。</p>
<p>3、<a href="https://juemuren4449.com/archives/habit-formation-plan">我的习惯养成计划：五分钟规则+打卡</a></p>
<p>4、<a href="https://www.jitao.tech/posts/my-guiding-principles-after-20-years-of-programming/">我编程 20 年的指导原则</a></p>
<p>5、<a href="https://lenciel.com/2022/10/renaming-with-zmv/">用 zmv 批量重命名文件</a></p>
<h3 id="一些工具">一些工具</h3>
<ul>
<li><a href="https://webperformancereport.com/">WebPerformance Report</a> 这个网站可以用邮箱订阅你的网站性能的个性化报告。它会监控指定网站的性能，每周会发送一封报告邮件给你。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-14｜如何学习一门编程语言</title>
      <link>https://blog.chensoul.com/posts/2023/04/13/weekly_review_14/</link>
      <pubDate>Thu, 13 Apr 2023 09:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/04/13/weekly_review_14/</guid>
      <description>前言 本篇是对 2023-04-03 到 2023-04-09 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这周还是和以前一样每天运动，并开始施行断食。因为</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p><img loading="lazy" src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekl-review-14-01.jpg" alt="weekl-review-14-01"  />
</p>
<p>本篇是对 <code>2023-04-03</code> 到 <code>2023-04-09</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这周还是和以前一样每天运动，并开始施行断食。因为是刚开始断食，有时候忍不住饥饿感而吃了一些东西。</p>
<p>本周工作主要是发布了一个版本，其余时间用来学习 Rust 和 Python，初学这两种语言，他们语法上有很多相似之处。如何学习一门编程语言？整理了一些步骤。尝试了一下用多种语言编写猜数游戏，这些语言包括 Rust、Ptyhon、Go、NodeJs、JavaScript、Kotlin、Bash，除了 Java。这是一个很有意思的事情，如果能够把这些语言都熟练掌握，那就更好了。</p>
<h2 id="关于健身">关于健身</h2>
<p>完成了每天一万步的计划，并且共跑步 5 次，一共 18.6 公里，平均配速 7 分钟4 9 秒，每天跳绳 500+。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekl-review-14-03.jpg" alt="weekl-review-14-03" style="width:67%;" />
<h2 id="关于记账">关于记账</h2>
<p>本周继续使用微信记账本记录每天支出。累计消费835元，明细如下：</p>
<ul>
<li>
<p>4月3日，周一：支出 59 元，餐饮</p>
</li>
<li>
<p>4月4日，周二：支出 0 元，</p>
</li>
<li>
<p>4月5日，周三：支出 228 元，超市购物</p>
</li>
<li>
<p>4月6日，周四：支出 15 元，停车费</p>
</li>
<li>
<p>4月7日，周五：支出 12 元</p>
</li>
<li>
<p>4月8日，周六：支出 415 元，加油+餐饮</p>
</li>
<li>
<p>4月8日，周日：支出 106 元，餐饮</p>
</li>
</ul>
<h2 id="如何学习一门编程语言">如何学习一门编程语言</h2>
<p>学习一门编程语言的基础语法对于初学者来说非常重要，以下是一些详细的步骤：</p>
<ol>
<li>了解编程语言的基础概念：在学习编程语言之前，了解编程的基础概念是非常重要的。例如，变量、数据类型、条件语句、循环、函数等等。</li>
<li>寻找学习资源：学习编程语言的基础语法可以通过各种学习资源来实现，如书籍、教程、在线视频和交互式学习平台等。选择适合自己的学习资源是非常重要的。</li>
<li>学习变量和数据类型：在学习编程语言之前，学习变量和数据类型是必须的。了解如何定义变量、赋值和使用不同的数据类型，例如字符串、整数、浮点数、布尔值等等。</li>
<li>学习条件语句：条件语句是编程语言中的重要概念之一。例如，学习如何使用if语句和else语句，使程序在特定条件下执行不同的代码块。</li>
<li>学习循环：循环是编程语言中的另一个重要概念。例如，学习如何使用while循环和for循环，使程序在特定条件下重复执行代码块。</li>
<li>学习函数：函数是编程语言中的重要概念之一。学习如何定义和使用函数，以将代码结构化并重用。</li>
<li>练习编写代码：练习编写代码是学习编程语言基础语法的重要方式。编写小程序或项目，例如打印&quot;Hello World&quot;、计算器或猜数字游戏等。</li>
<li>学习调试和错误处理：学习如何调试代码和处理常见错误，例如语法错误、逻辑错误和运行时错误等。</li>
</ol>
<p>总结一下，学习一门编程语言的步骤：</p>
<ul>
<li>
<p>安装</p>
</li>
<li>
<p>Hello World</p>
<ul>
<li>注释</li>
<li>格式化输出</li>
</ul>
</li>
<li>
<p>变量和常量</p>
</li>
<li>
<p>数据类型</p>
<ul>
<li>基本类型
<ul>
<li>运算</li>
<li>类型转换</li>
</ul>
</li>
<li>复杂类型</li>
</ul>
</li>
<li>
<p>表达式和语句</p>
<ul>
<li>条件</li>
<li>循环</li>
<li>断言</li>
</ul>
</li>
<li>
<p>函数</p>
</li>
<li>
<p>类和对象</p>
</li>
<li>
<p>包和模块</p>
</li>
<li>
<p>异常处理</p>
</li>
<li>
<p>标准库</p>
<ul>
<li>IO</li>
<li>网络</li>
<li>多线程</li>
</ul>
</li>
<li>
<p>单元测试</p>
</li>
</ul>
<p>接下来，打算按照上面的步骤来学习 Rust、Python、Go，也许还会有 NodeJs 和 Kotlin，并整理相关笔记。</p>
<h2 id="工作">工作</h2>
<h3 id="effective-java-3-笔记">Effective Java 3 笔记</h3>
<p>请参考 <a href="/posts/2023/04/11/enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/">《Effective Java 3》笔记：使用私有构造函数或枚举类型创建单例</a></p>
<h3 id="rust">Rust</h3>
<p>因为对 <a href="https://tauri.app/">Tauri</a> 这个 GUI 框架挺感兴趣，所以我开始学习 Rust 了，目前在参考 <a href="https://rustwiki.org/">https://rustwiki.org/</a> 上的 <a href="https://rustwiki.org/zh-CN/rust-by-example/">通过例子学 Rust</a> 和 《Rust权威指南》 学习 Rust。</p>
<img src="https://chensoul.oss-cn-hangzhou.aliyuncs.com/images/weekl-review-14-02.jpg" alt="weekl-review-14-02" style="width:50%;" />
<h2 id="好物分享">好物分享</h2>
<p>虽然大部分有意思的内容会分享在 『<a href="https://t.me/chensoul_share">ChenSoul Share</a>』Telegram 频道，不过还是挑选一部分在这里列举一下，感觉更像一个 newsletter 了。</p>
<h3 id="一些文章">一些文章</h3>
<ul>
<li><a href="http://ebookconverter.blogspot.com/2013/11/where-to-find-epub-file-in-ibooks-for.html">Where to find the EPUB file in iBooks for Mac under OS X 10.9 Mavericks</a></li>
<li><a href="https://roy.wang/umami-js-quicken/">使用 CDN 加速 Umami 静态资源</a></li>
<li><a href="https://blog.alswl.com/2023/04/web-api-guidelines/">实用 Web API 规范</a></li>
<li><a href="https://utgd.net/article/9367">一次本地免费过滤 RSS 的尝试：NetNewsWire</a></li>
<li><a href="https://catcoding.me/p/redis-antriez/">不想当作家的程序员写不出 Redis</a></li>
<li><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2023/03/30/kotlin-syntax.html">Kotlin 语法一站式手册</a></li>
</ul>
<h3 id="一些工具">一些工具</h3>
<ul>
<li><a href="https://listmonk.app/">Listmonk</a> 一款自主托管的电子邮件列表管理工具。它允许您将邮件列表导入到自己的服务器中，并使用它来管理您的邮件列表和发送电子邮件。Listmonk具有良好的可扩展性和自定义性，可通过REST API进行操作，并支持高级功能，例如自定义字段、模板和自动化工作流程，从而使其成为一个非常有用和灵活的电子邮件列表管理工具。与其他在线邮件列表服务相比，Listmonk的优势之一是您完全掌控自己的数据和服务器，因此您不必担心第三方公司的数据隐私问题。</li>
<li><a href="https://ricks-apps.com/osx/sitesucker/index.html">SiteSucker</a> SiteSucker是一款MacOS平台上的免费工具，它可以帮助用户将整个网站下载到本地电脑中。使用SiteSucker，用户只需要输入目标网站的URL，它就会自动下载该网站的所有页面、图像、视频和其他资源，并将它们保存在本地硬盘上，以便用户离线浏览或备份。SiteSucker支持多线程下载和断点续传，可以在不中断下载的情况下暂停和恢复下载任务。此外，它还可以过滤URL，以便用户只下载特定类型的文件，例如HTML、图像或视频文件。总之，SiteSucker是一款非常实用的工具，适用于需要离线浏览网站、备份网站或进行网站抓取的用户。</li>
<li><a href="https://montaigne.io/">Montaigne</a> 用苹果笔记来创建网站、博客或作品集</li>
<li><a href="https://github.com/BlueMatthew/WechatExporter">WechatExporter</a> 聊天记录导出</li>
<li><a href="https://paw.cloud/">RapidAPI</a> 一款MacOS平台上的API开发工具，它旨在帮助开发人员更轻松地设计、测试和调试API。Paw提供了一个直观的用户界面，可以让用户轻松地构建和调试API请求，并查看服务器响应。Paw支持多种API协议和格式，例如REST、SOAP、GraphQL、JSON和XML等，可以与多种服务器端点和身份验证方式进行集成。此外，Paw还具有强大的自动化和脚本化功能，允许用户使用JavaScript或Python编写自定义脚本，以自动化API测试和集成工作流程。</li>
<li><a href="https://gist.github.com/VincentSit/a682f4162b998c7f24d08ab34bf233da">卸载MacOS微信键盘</a></li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>周报-6｜买车和选号、粉色理论</title>
      <link>https://blog.chensoul.com/posts/2023/02/13/weekly_review_6/</link>
      <pubDate>Mon, 13 Feb 2023 00:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/02/13/weekly_review_6/</guid>
      <description>前言 本篇是对 2023-02-06 到 2023-02-12 这周生活的记录与思考。首发在我的个人 博客，你可以移步了解更多或者给我留言。 这篇周报又是在坐地铁的时候完成编写的，一边坐地铁</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>本篇是对 <code>2023-02-06</code> 到 <code>2023-02-12</code> 这周生活的记录与思考。首发在我的个人 <a href="https://blog.chensoul.com/">博客</a>，你可以移步了解更多或者给我留言。</p>
<p>这篇周报又是在坐地铁的时候完成编写的，一边坐地铁，一边回顾上一周发生的事情，一边复盘和总结。坐地铁大概有一个半小时，从家到公司的一段通勤路程。现在还没有买车，所以都是坐地铁上下班。</p>
<p>说到车，周六去二手市场买了一辆 17 年出产的上汽宝来，今天周一去过了户并且选了一个幸运的车牌号，尾号是 8688，寓意着要发发发！</p>
<p>上个月报名的内观训练营，这周也结业了，训练营运营人员还给我发了一个结业证书。</p>
<p>这是写周报的第六周，观察了一下博客访问量，从开始统计起到这周不到一个月的时间，访问量突破了 1000。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/blog-pv-1000.png" alt="blog-pv-1000"  />
</p>
<h2 id="工作">工作</h2>
<p>这周的工作主要内容是在项目里实现用户可以切换租户和租户数据拆分。</p>
<p>第一个功能的需求是一个账号（有姓名、手机号、密码等属性）可以访问多个租户，在每个租户里有自己的数据权限和角色。第二个功能，主要是使用 SQL 进行数据加工。</p>
<p>总体上来说，这周工作处于充实忙碌的情况。而且，上下班的通勤时间，也在 B 站上看视频。这周主要看的是小马哥的 Java 训练营的公开视频。小马哥的 B 站视频，是我最近刷的比较多的一个视频，另外一个是 coder1v5 的视频，他们分享的视频都是关于 Java 的，里面有非常多的干货，而且还提供了源代码。如果你也是一名 Java 开发工程师，推荐你也关注他们。</p>
<h2 id="生活">生活</h2>
<h3 id="买车和选号">买车和选号</h3>
<p>去年 11 月 16 日，拿到了驾照，直到现在才买了一辆车。过年前，因为疫情加上工作忙，一直没有抽出时间去了解车子行情。可能是对于车子的需求感没有那么强的原因，才导致考驾照、买车不积极。结婚之前，住在公司旁边，走路五分钟上下班，根本就用不上车。结婚之后，从光谷搬到汉口，每天上下班在路上通勤时间都有三个小时了。每天早上七点就要起来做饭（带饭到公司，中午微波炉热着吃，每天可以省下一餐伙食费），然后去赶地铁。疫情放开之前，地铁上人不多，每次都有位置坐。疫情放开之后，地铁里都是人，不是每次都有位置坐，经常要站着。站着的时候，有时候就内观冥想，想想最近有没有做得不对的地方，想想工作下一步该怎么计划；有时候就看 B 站关于 Java 的视频。也算是充分利用了这段通勤时间。</p>
<p>为了上下班通勤更方便，才计划买车的，也不知道开车能够缩短多少通勤时间，也希望这节约下来的时间，可以用在读书和健身上。另外一方面，买车了之后，回家看望父母会更方便。这就是买车的原因。</p>
<img src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/my-first-car.jpeg" style="width:60%"/>
<p>考虑到刚拿驾照、以后还要买房，这次就只买了一个二手车。原计划只买个三万左右的车，最后还是超出了预算。</p>
<p>去二手市场买车的时候，是在周六，周末过不了户，所以这周一又过来办理过户和选车牌号。过户的过程还是很快的，全部交给二手市场的人代办。至于，选车牌号，之前了解了一下，车牌号尽量选尾号都是数字的，这样好记；不要带数字 4，不吉利；选号有时间限制，超过了时间未选，会默认选第一个。点击 “选号开始” 按钮之前，心里还有点紧张。当看到第一屏的号码时候，很快地扫描了一遍，发现了一个尾号为 8688 的号码。于是，就跟一同过来买车的姐夫说，这个号码怎么样。姐夫激动地说这个号码好，就选这个。真的没有想到今天运气这么好，选到了这么好的一个号码。激动得想跟朋友圈里的好友分享。之前买车的时候，付完预付款，就有分享买车的喜悦的冲动。这时候，老婆在旁边跟我说，要低调，不要和身边的亲戚说。所以，就一直没有告诉亲人和身边的朋友。没想到，这次选了一个幸运的车牌号，还是没忍住发了一个部分好友不可见的朋友圈。</p>
<p>这说明自己定力还是不够，分享欲太强，不够谦虚和低调。满招损，谦受益。只是买了一个车和选到一个幸运的车牌号而已，不能高兴太早，后面还要花时间练车上路、开车还要慢和稳，不能出交通事故，铭记 “新手上路，多多指教”。</p>
<p>学英语，最重要的是练习。开车，最重要的是慢。</p>
<h2 id="学习">学习</h2>
<h3 id="内观冥想">内观冥想</h3>
<p>一月份报名内观冥想训练营的初衷是想学习内观冥想的方法，后来因为每天早上要赶地铁以及觉得课程内容和自己期望的有些差距，就没有坚持听课和打卡。</p>
<p>虽然，没有听完所有课程，但是从开始几节课程，初步体会和感受了一下什么是内观冥想，也认识了一些内观冥想的朋友。也没有想到，最后还收到了一个结业证书。</p>
<img src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/vipassana-study-certificate.jpeg" style="width:60%"/>
<h3 id="python">Python</h3>
<p>最近有个机器学习的项目，用到了 Python，所以需要学习 Python 并掌握相关的业务知识。这一个机会，同时也是一个挑战。</p>
<h2 id="娱乐">娱乐</h2>
<p>-《粉色理论》。这部泰国双女主的同性电视剧，豆瓣上评分 9.2，在这周完结了。</p>
<p><img loading="lazy" src="http://chensoul.oss-cn-hangzhou.aliyuncs.com/images/fenhonglilun.jpeg" alt="fenhonglilun"  />
</p>
<h2 id="分享">分享</h2>
<ul>
<li>
<p><a href="https://pdai.tech/md/spring/springboot/springboot-x-task-hashwheeltimer-timer.html">HashedWheelTimer</a>：是来自于 Netty 的工具类，在 netty-common 包中。它用于实现延时任务。</p>
</li>
<li>
<p><a href="https://github.com/killbill/killbill-commons">Killbill common queue</a>：一个基于DB实现的分布式的队列，它上层还包装了EventBus事件总线机制。</p>
</li>
</ul>
<p>以上。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
