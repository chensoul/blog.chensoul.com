<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>security on ChenSoul</title>
    <link>https://blog.chensoul.com/tags/security/</link>
    <description>Recent content in security on ChenSoul</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 25 Aug 2023 08:00:00 +0800</lastBuildDate><atom:link href="https://blog.chensoul.com/tags/security/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[译]使用@Async进行Spring Security上下文传播</title>
      <link>https://blog.chensoul.com/posts/2023/08/25/spring-security-async-principal-propagation/</link>
      <pubDate>Fri, 25 Aug 2023 08:00:00 +0800</pubDate>
      
      <guid>https://blog.chensoul.com/posts/2023/08/25/spring-security-async-principal-propagation/</guid>
      <description>1. 简介 在本教程中，我们将重点关注使用 @Async 传播 Spring Security 主体 默认情况下，Spring Security 身份验证绑定到 ThreadLocal - 因此，当执行流在带有 @Async 的新线程中运行时，它不会</description>
      <content:encoded><![CDATA[<h2 id="1-简介">1. 简介</h2>
<p>在本教程中，我们将重点关注使用 <code>@Async</code> 传播 Spring Security 主体
默认情况下，Spring Security 身份验证绑定到 <code>ThreadLocal</code> - 因此，当执行流在带有 <code>@Async</code> 的新线程中运行时，它不会是经过身份验证的上下文。</p>
<p>这并不理想——让我们解决它。</p>
<h2 id="2maven依赖">2.Maven依赖</h2>
<p>为了在 Spring Security 中使用异步集成，我们需要在 pom.xml 的依赖项中包含以下部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.security<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-security-config<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>5.7.3<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>可以在<a href="https://search.maven.org/classic/#search%7Cga%7C1%7Cg%3A%22org.springframework.security%22">此处</a>找到最新版本的 Spring Security 依赖项。</p>
<h2 id="3使用async进行spring-security传播">3.使用@Async进行Spring Security传播</h2>
<p>我们先写一个简单的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s">&#34;/async&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ResponseBody</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">Object</span> <span class="nf">standardProcessing</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;Outside the @Async logic - before the async call: &#34;</span>
</span></span><span class="line"><span class="cl">      <span class="o">+</span> <span class="n">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getAuthentication</span><span class="o">().</span><span class="na">getPrincipal</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">asyncService</span><span class="o">.</span><span class="na">asyncCall</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;Inside the @Async logic - after the async call: &#34;</span>
</span></span><span class="line"><span class="cl">      <span class="o">+</span> <span class="n">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getAuthentication</span><span class="o">().</span><span class="na">getPrincipal</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getAuthentication</span><span class="o">().</span><span class="na">getPrincipal</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>我们想要检查 Spring <code>SecurityContext</code> 是否传播到新线程。首先，我们在异步调用之前记录上下文，接下来我们运行异步方法，最后再次记录上下文。<code> asyncCall()</code> 方法具有以下实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Async</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Override</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">asyncCall</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;Inside the @Async logic: &#34;</span>
</span></span><span class="line"><span class="cl">      <span class="o">+</span> <span class="n">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getAuthentication</span><span class="o">().</span><span class="na">getPrincipal</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>正如我们所看到的，只有一行代码将输出异步方法的新线程内的上下文。</p>
<h2 id="4-默认配置">4. 默认配置</h2>
<p>默认情况下，<code>@Async</code> 方法内的安全上下文将具有空值。</p>
<p>特别是，如果我们运行异步逻辑，我们将能够在主程序中记录 <code>Authentication</code> 对象，但是当我们将其记录在 <code>@Async</code> 中时，它将为 null。这是日志输出的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">web - 2016-12-30 22:41:58,916 [http-nio-8081-exec-3] INFO
</span></span><span class="line"><span class="cl">  o.baeldung.web.service.AsyncService -
</span></span><span class="line"><span class="cl">  Outside the @Async logic - before the async call:
</span></span><span class="line"><span class="cl">  org.springframework.security.core.userdetails.User@76507e51:
</span></span><span class="line"><span class="cl">  Username: temporary; ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">web - 2016-12-30 22:41:58,921 [http-nio-8081-exec-3] INFO
</span></span><span class="line"><span class="cl">  o.baeldung.web.service.AsyncService -
</span></span><span class="line"><span class="cl">  Inside the @Async logic - after the async call:
</span></span><span class="line"><span class="cl">  org.springframework.security.core.userdetails.User@76507e51:
</span></span><span class="line"><span class="cl">  Username: temporary; ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  web - 2016-12-30 22:41:58,926 [SimpleAsyncTaskExecutor-1] ERROR
</span></span><span class="line"><span class="cl">  o.s.a.i.SimpleAsyncUncaughtExceptionHandler -
</span></span><span class="line"><span class="cl">  Unexpected error occurred invoking async method
</span></span><span class="line"><span class="cl">  &#39;public void com.baeldung.web.service.AsyncServiceImpl.asyncCall()&#39;.
</span></span><span class="line"><span class="cl">  java.lang.NullPointerException: null
</span></span></code></pre></div><p>因此，正如您所看到的，在执行程序线程内，我们的调用失败并出现 NPE，正如预期的那样——因为主体在那里不可用。</p>
<h2 id="5-异步安全上下文配置">5. 异步安全上下文配置</h2>
<p>如果我们想要访问异步线程内部的主体，就像我们可以在外部访问它一样，我们需要创建 <code>DelegatingSecurityContextAsyncTaskExecutor</code> bean：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span> 
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">DelegatingSecurityContextAsyncTaskExecutor</span> <span class="nf">taskExecutor</span><span class="o">(</span><span class="n">ThreadPoolTaskExecutor</span> <span class="n">delegate</span><span class="o">)</span> <span class="o">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">DelegatingSecurityContextAsyncTaskExecutor</span><span class="o">(</span><span class="n">delegate</span><span class="o">);</span> 
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>通过这样做，Spring 将在每个 <code>@Async</code> 调用中使用当前的 <code>SecurityContext</code>。</p>
<p>现在，让我们再次运行该应用程序并查看日志信息以确保情况确实如此：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">web - 2016-12-30 22:45:18,013 [http-nio-8081-exec-3] INFO
</span></span><span class="line"><span class="cl">  o.baeldung.web.service.AsyncService -
</span></span><span class="line"><span class="cl">  Outside the @Async logic - before the async call:
</span></span><span class="line"><span class="cl">  org.springframework.security.core.userdetails.User@76507e51:
</span></span><span class="line"><span class="cl">  Username: temporary; ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">web - 2016-12-30 22:45:18,018 [http-nio-8081-exec-3] INFO
</span></span><span class="line"><span class="cl">  o.baeldung.web.service.AsyncService -
</span></span><span class="line"><span class="cl">  Inside the @Async logic - after the async call:
</span></span><span class="line"><span class="cl">  org.springframework.security.core.userdetails.User@76507e51:
</span></span><span class="line"><span class="cl">  Username: temporary; ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">web - 2016-12-30 22:45:18,019 [SimpleAsyncTaskExecutor-1] INFO
</span></span><span class="line"><span class="cl">  o.baeldung.web.service.AsyncService -
</span></span><span class="line"><span class="cl">  Inside the @Async logic:
</span></span><span class="line"><span class="cl">  org.springframework.security.core.userdetails.User@76507e51:
</span></span><span class="line"><span class="cl">  Username: temporary; ...
</span></span></code></pre></div><p>正如我们所期望的，我们在异步执行器线程中看到了相同的原理。</p>
<h2 id="6-使用案例">6. 使用案例</h2>
<p>有一些有趣的用例，我们可能希望确保 <code>SecurityContext</code> 像这样传播：</p>
<ul>
<li>我们想要发出多个可以并行运行并且可能需要大量时间来执行的外部请求</li>
<li>我们需要在本地进行一些重要的处理，并且我们的外部请求可以与该处理并行执行</li>
<li>其他代表即发即忘场景，例如发送电子邮件</li>
</ul>
<h2 id="7结论">7.结论</h2>
<p>在本快速教程中，我们介绍了 Spring 对使用传播的 <code>SecurityContext</code> 发送异步请求的支持。从编程模型的角度来看，新功能看似简单。</p>
<p>请注意，如果先前以同步方式将多个方法调用链接在一起，则转换为异步方法可能需要同步结果。</p>
<p>此 <a href="https://github.com/eugenp/tutorials/tree/master/spring-security-modules/spring-security-web-rest">示例</a> 也可作为 Github 上的 Maven 项目提供。</p>
<p>原文链接：<a href="https://www.baeldung.com/spring-security-async-principal-propagation">https://www.baeldung.com/spring-security-async-principal-propagation</a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
