<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring-Boot | ChenSoul</title>
<meta name=keywords content><meta name=description content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta name=author content="chensoul"><link rel=canonical href=https://blog.chensoul.cc/tags/spring-boot/><meta name=google-site-verification content="nBXwg45SBRjTX78SA-mH0asrAbsdu9c1nk0ObSry7aQ"><link crossorigin=anonymous href=/assets/css/stylesheet.48da2331f774073f2b09ec285a9c0e15fd969021a9d2d0fb60b7cbb73cef5ecc.css integrity="sha256-SNojMfd0Bz8rCewoWpwOFf2WkCGp0tD7YLfLtzzvXsw=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chensoul.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chensoul.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chensoul.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chensoul.cc/apple-touch-icon.png><link rel=mask-icon href=https://blog.chensoul.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.chensoul.cc/tags/spring-boot/index.xml><link rel=alternate hreflang=en href=https://blog.chensoul.cc/tags/spring-boot/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-FYpQY8JdLU"><meta property="og:title" content="Spring-Boot"><meta property="og:description" content="健康，爱情和使命，按照这个顺序，其它的都不重要"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.chensoul.cc/tags/spring-boot/"><meta property="og:site_name" content="ChenSoul"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spring-Boot"><meta name=twitter:description content="健康，爱情和使命，按照这个顺序，其它的都不重要"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chensoul.cc/ accesskey=h title="ChenSoul (Alt + H)">ChenSoul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chensoul.cc/categories title=分类><span>分类</span></a></li><li><a href=https://blog.chensoul.cc/tags title=标签><span>标签</span></a></li><li><a href=https://blog.chensoul.cc/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.chensoul.cc/index.xml title=订阅><span>订阅</span></a></li><li><a href=https://github.com/chensoul title=关于><span>关于</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><h1>Spring-Boot
<a href=/tags/spring-boot/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring Boot集成SpringDoc生成Api文档</h2></header><div class=entry-content><p>以下以 Maven 为例介绍 Spring Boot集成SpringDoc生成Api文档。
添加依赖 &lt;dependency> &lt;groupId>org.springdoc&lt;/groupId> &lt;artifactId>springdoc-openapi-starter-webmvc-ui&lt;/artifactId> &lt;/dependency> 配置 annotationProcessor，实现通过 javadoc 生成文档。 每个 maven 模块都需要配置：
&lt;properties> &lt;therapi-runtime-javadoc.version>0.15.0&lt;/therapi-runtime-javadoc.version> &lt;maven-compiler-plugin.version>3.13.0&lt;/maven-compiler-plugin.version> &lt;/properties> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>${maven-compiler-plugin.version}&lt;/version> &lt;configuration> &lt;annotationProcessorPaths> &lt;!-- https://springdoc.org/#javadoc-support --> &lt;path> &lt;groupId>com.github.therapi&lt;/groupId> &lt;artifactId>therapi-runtime-javadoc-scribe&lt;/artifactId> &lt;version>${therapi-runtime-javadoc.version}&lt;/version> &lt;/path> &lt;/annotationProcessorPaths> &lt;/configuration> &lt;/plugin> 配置 spring boot 插件，生成 build.properties &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;executions> &lt;execution> &lt;goals> &lt;goal>repackage&lt;/goal> &lt;goal>build-info&lt;/goal> &lt;/goals> &lt;/execution> &lt;/executions> &lt;/plugin> 自动装配 @Configuration(proxyBeanMethods = false) @ConditionalOnProperty(name = SPRINGDOC_ENABLED, matchIfMissing = true) @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) public class SpringdocConfig { @Value("${server.port}") private String port; @Value("${openapi.prod-url:https://localhost}") private String prodUrl; @Bean public OpenAPI openAPI() { Server devServer = new Server(); devServer.setUrl("http://localhost:" + port); devServer.setDescription("Server URL in Development environment"); Server prodServer = new Server(); prodServer....</p></div><footer class=entry-footer><span title='2024-07-10 00:00:00 +0000 UTC'>2024-07-10</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;149 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Spring Boot集成SpringDoc生成Api文档" href=https://blog.chensoul.cc/posts/2024/07/10/springdoc-with-spring-boot/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>使用 Docker 容器化并运行 Spring Boot 应用程序</h2></header><div class=entry-content><p>本文翻译自 Docker 官方网站的《Java language-specific guide》文章，并做了一些改动。
Java 入门指南教您如何使用 Docker 创建容器化的 Spring Boot 应用程序。在本模块中，您将学习如何：
使用 Maven 容器化并运行 Spring Boot 应用程序 设置本地开发环境以将数据库连接到容器，配置调试器，并使用 Compose Watch 进行实时重新加载 在容器内运行单元测试 使用 GitHub Actions 为应用程序配置 CI/CD 管道 将容器化应用程序本地部署到 Kubernetes 以测试和调试您的部署 完成 Java 入门模块后，您应该能够根据本指南中提供的示例和说明来容器化您自己的 Java 应用程序。
容器化你的应用 先决条件 您已安装最新版本的 Docker Desktop，Docker 会定期添加新功能，本指南的某些部分可能仅适用于最新版本的 Docker Desktop。
您有一个 Git 客户端。本节中的示例使用基于命令行的 Git 客户端，但您可以使用任何客户端。
获取示例应用程序 将要使用的示例应用程序克隆到本地开发机器。在终端中运行以下命令来克隆存储库。
$ git clone https://github.com/spring-projects/spring-petclinic.git $ cd spring-petclinic 初始化 Docker 资产 现在您有了一个应用程序，您可以使用它docker init来创建必要的 Docker 资产来容器化您的应用程序。在 spring-petclinic 中已包含 Docker 资产。系统将提示您覆盖现有 Docker 资产。要继续本指南，请选择y覆盖它们。
$ docker init Welcome to the Docker Init CLI! This utility will walk you through creating the following files with sensible defaults for your project: - .dockerignore - Dockerfile - compose....</p></div><footer class=entry-footer><span title='2024-07-09 00:00:00 +0000 UTC'>2024-07-09</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1453 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 使用 Docker 容器化并运行 Spring Boot 应用程序" href=https://blog.chensoul.cc/posts/2024/07/09/docker-for-spring-boot/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring Boot项目创建Docker镜像并运行应用</h2></header><div class=entry-content><p>手动创建 Dockerfile 添加 Dockerfile
在您的 Spring Boot 项目根目录下创建一个名为 Dockerfile 的文件，并添加以下内容:
# 使用 OpenJDK 21 作为基础镜像 FROM openjdk:21 # 设置工作目录 WORKDIR /app # 将 JAR 文件复制到容器中 COPY target/*.jar app.jar # 暴露 8080 端口 EXPOSE 8080 # 设置容器启动时执行的命令 ENTRYPOINT ["java", "-jar", "app.jar"] 这个 Dockerfile 将使用 OpenJDK 21 作为基础镜像，将编译后的 JAR 文件复制到容器中，并在容器启动时执行 java -jar app.jar 命令。
使用 Google Distroless 基础镜像:
Distroless 基础镜像是一种精简的 Linux 发行版,只包含应用程序运行所需的最小依赖项。 在 Dockerfile 中使用 gcr.io/distroless/java:11 作为基础镜像可以大幅减小最终镜像的体积。 如果 target 目录下存在多个 jar 文件，则可以在 dockerfile 同级添加一个 .dockerignore 文件忽略掉 *-sources.jar ：
# Include any files or directories that you don't want to be copied to your # container here (e.g., local build artifacts, temporary files, etc....</p></div><footer class=entry-footer><span title='2024-06-06 00:00:00 +0000 UTC'>2024-06-06</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1737 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to Spring Boot项目创建Docker镜像并运行应用" href=https://blog.chensoul.cc/posts/2024/06/06/spring-boot-docker-image/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]使用 Spring Boot 构建 RESTful API：集成 DDD 和六边形架构</h2></header><div class=entry-content><p>原文链接：Building a RESTful API with Spring Boot: Integrating DDD and Hexagonal Architecture
介绍 在快节奏的软件开发世界中，API 扮演着至关重要的角色，可以有效地促进不同系统之间的交互和数据交换。API 创建最突出的技术之一是 Spring Boot，它是一种强大的工具，可以简化 Java 应用程序的开发，使开发人员可以专注于业务逻辑而不是环境设置。
在本文中，我们将探讨如何使用 Spring Boot 设计和构建 RESTful API，但我们将超越单纯的开发。我们将集成领域驱动设计 (DDD) 和六边形架构等高级概念，这些概念对于创建强大、可扩展且易于维护的应用程序至关重要。这些方法不仅可以改善代码结构和关注点分离，还可以促进技术团队和利益相关者之间的协作，使软件设计与业务需求保持一致。
在本文中，我们将把这些复杂的概念分解为简单的解释和实际示例，确保即使是初学者也可以遵循这些高级实践并将其应用到自己的项目中。无论您是希望增强应用程序架构的经验丰富的开发人员，还是 Spring Boot 世界的新手，您都可以在本文中找到适合您的开发需求的宝贵经验和技巧。
让我们深入了解构建 API 的迷人过程，该 API 不仅运行良好，而且从概念到实现都设计精良。
第 0 节：什么是 REST API？ 什么是 API？ API（应用程序编程接口）是一组规则和规范，允许不同的应用程序或软件组件相互交互。它充当中介，使开发人员能够访问软件服务中的特定功能或数据，而无需了解该软件的内部细节。
REST API 的起源 REST（表述性状态转移）架构由 Roy Fielding 于 2000 年在其博士论文中定义。REST 是一套原则，概述了应如何设计客户端和服务器之间的交互。它的创建是出于对标准的需求，该标准可以提高互联网通信的可扩展性，从而提供比当时可用的接口（例如被认为过于复杂和僵化的 SOAP）更简单、更高效的接口。
REST 旨在解决什么问题？ REST 的出现是为了应对现有架构的复杂性，这些复杂性使 Web 应用程序的开发和可扩展性变得复杂。通过采用无状态模型并使用标准 HTTP 方法（GET、POST、PUT、DELETE），REST 简化了客户端与服务器交互的实现。这种简单性使开发人员能够创建更高效、更易于维护的 Web 和移动应用程序。
REST基于六个基本原则：
**统一接口：**确保客户端和服务器之间的接口一致、标准化。 **无状态：**每个客户端对服务器的请求都必须包含理解和完成请求所需的所有信息。 **可缓存：**响应必须隐式或显式地定义它们是否可缓存。 **分层系统：**客户端不需要知道它是直接与终端服务器通信还是与中介通信。 **客户端-服务器：**用户界面（客户端）和数据存储（服务器）之间的职责分离，通过简化服务器组件增强了用户界面跨多个平台的可移植性和可扩展性。 **按需代码（可选）：**服务器可以通过发送可执行代码来扩展或定制客户端的功能。 结合这些原则不仅解决了可扩展性和维护问题，而且还促进了更为健壮、交互和高效的 Web 应用程序的创建。
现在，如果你已经读到这里，你可能会想，“HTTP 到底是什么？”好吧，让我们开始吧。
HTTP 简介 HTTP（超文本传输协议）是互联网工程任务组（IETF）定义的网络交互中使用的底层协议。它是浏览器（客户端）和网络服务器之间传输数据的手段。该协议基于请求-响应模型，对于 RESTful 通信至关重要，因为它的方法促进了 REST API 中基本的 CRUD（创建、读取、更新、删除）操作。
HTTP 方法及其使用时机 HTTP 方法定义您想要对已识别的资源执行的操作。以下是 REST API 中最常用的方法：
**GET：**用于从服务器检索信息。它不应修改资源的状态，因此非常适合无副作用的读取操作。示例：获取用户列表或特定用户的详细信息。 **POST：**用于创建新资源。当请求结果导致服务器状态改变或产生副作用时，此方法非常有用。例如：添加新用户。 **PUT：**用于更新/替换现有资源。在请求中发送完整实体很重要。示例：更新现有用户的姓名和年龄。 **DELETE：**用于删除资源。例如：删除用户。 **PATCH：**与 PUT 不同，PATCH 用于对资源进行部分更新。例如：仅更新用户的名称而不触及其他字段。 HTTP 方法的最佳实践 在设计 RESTful API 时，遵循一些最佳实践以确保 API 易于理解和使用至关重要：...</p></div><footer class=entry-footer><span title='2024-05-30 00:00:00 +0000 UTC'>2024-05-30</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1225 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]使用 Spring Boot 构建 RESTful API：集成 DDD 和六边形架构" href=https://blog.chensoul.cc/posts/2024/05/30/building-a-restful-api-with-spring-boot-integrating-ddd-and-hexagonal-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2024-01-17｜MySQL 主从复制、ShardingJDBC实现读写分离、集成Springdoc+Javadoc</h2></header><div class=entry-content><p>今天做了什么：
观看《2022年黑马程序员新版java课程》中 MySQL 主从复制和读写分离相关视频，使用 Docker 搭建 MySQL 主从复制环境。 foodie-cloud 项目实现读写分离并集成 Springdoc Docker 搭建 MySQL 主从复制环境 参考文章 ：基于 Docker 的 MySQL 主从复制搭建及原理（真正弄懂）
先创建两个容器：
version: '3.8' services: mysql-master: image: mysql:8 restart: always env_file: - .env ports: - "3307:3306" environment: - TZ=Asia/Shanghai - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} - MYSQL_DATABASE=${MYSQL_DATABASE} - MYSQL_USER=${MYSQL_USER} - MYSQL_PASSWORD=${MYSQL_PASSWORD} command: --default-authentication-plugin=mysql_native_password --explicit_defaults_for_timestamp=true --lower_case_table_names=1 --tls-version='' --log-bin=mysql-bin --server-id=1 healthcheck: test: "/usr/bin/mysql --user=${MYSQL_USER} --password=${MYSQL_PASSWORD} -e 'SHOW DATABASES;'" interval: 5s timeout: 2s retries: 10 mysql-slave: image: mysql:8 restart: always env_file: - .env ports: - "3308:3306" environment: - TZ=Asia/Shanghai - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} - MYSQL_DATABASE=${MYSQL_DATABASE} - MYSQL_USER=${MYSQL_USER} - MYSQL_PASSWORD=${MYSQL_PASSWORD} command: --default-authentication-plugin=mysql_native_password --explicit_defaults_for_timestamp=true --lower_case_table_names=1 --tls-version='' --log-bin=mysql-bin --server-id=2 healthcheck: test: "/usr/bin/mysql --user=${MYSQL_USER} --password=${MYSQL_PASSWORD} -e 'SHOW DATABASES;'" interval: 5s timeout: 2s retries: 10 ....</p></div><footer class=entry-footer><span title='2024-01-17 00:00:00 +0000 UTC'>2024-01-17</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;392 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to 2024-01-17｜MySQL 主从复制、ShardingJDBC实现读写分离、集成Springdoc+Javadoc" href=https://blog.chensoul.cc/posts/2024/01/17/til/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Boot3和Spring6中的新特性</h2></header><div class=entry-content><p>Spring Boot 3.0 于 2022 年 11 月正式发布，包含一些新功能和改进。这是继大约 4.5 年前发布 Spring Boot 2.0 后 Spring Boot 的第一个主要版本。它也是第一个支持 Spring Framework 6.0 的 Spring Boot GA 版本。作为开发人员，我们需要了解这些更新，才能顺利使用 Spring Boot。毫无疑问，新版本中最大的转变之一是放弃了对旧版本 Java 的支持。
在本文中，我们将讨论“Spring Boot 3 和 Spring 6 中的新功能”。
Spring 3.0 版本有哪些主要亮点？ Spring 3.0 版本的亮点包括：
Java 17 基线 支持 Jakarta EE 10 和 EE 9 基线 支持使用 GraalVM 生成本机映像，取代实验性 Spring Native 项目 通过测微计和测微计追踪提高了可观测性 谁可以真正使用 Spring Boot 3？ 如前所述，Spring Boot 3.0 最大的转变是忽略了对旧版本 Java 的支持。是的，我们至少需要 Java 17 才能使用 Spring Boot 3.0。因此，在使用 Spring Boot 3.0 之前必须具备 JDK 17 环境。
Spring Boot 3 和 Spring 6 有哪些新功能？ 这里需要注意的重要一点是 Spring Boot 3.0 构建于 Spring Framework 6 之上并需要 Spring Framework 6。因此，如果您的 pom....</p></div><footer class=entry-footer><span title='2023-10-13 00:00:00 +0000 UTC'>2023-10-13</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;703 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Boot3和Spring6中的新特性" href=https://blog.chensoul.cc/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]SPRING BOOT JWT - 如何使用 SPRING SECURITY 和 JSON WEB 令牌保护您的 REST API</h2></header><div class=entry-content><p>如果您快速搜索如何使用 JSON Web Tokens 在 Spring Boot 中保护 REST API，您会发现很多相同的结果。这些结果包含一种方法，该方法涉及编写自定义过滤器链并引入第三方库来编码和解码 JWT。
在看完这些令人费解且令人困惑的教程后，我说必须有一种更简单的方法来做到这一点。我做了任何直接接触 Spring Security 团队的人都会做的事情，我向他们寻求帮助。他们告诉我，Spring Security 确实使用 oAuth2 资源服务器内置了对 JWT 的支持。
在本教程中，您将学习如何使用 JSON Web Tokens (JWT) 和 Spring Security 来保护您的 API。我并不是说这种方法无论如何都很容易，但对我来说，它比其他选择更有意义。
Github 存储库
应用架构 在我们开始编写一些代码之前，我想确保我们对于我们正在构建的内容都达成共识。在下面的示例中，您有一个客户端应用程序，它可以是一个简单的命令行应用程序、一个用 Angular 或 Vue 等编写的完整前端应用程序，或者系统中的其他一些服务。
该客户端应用程序将调用使用 Spring Boot 编写的服务器应用程序，该应用程序通过 REST API 公开数据。在下面的示例中，它是一个整体，但如果您有分布式架构，则同样适用。当前有 3 个 REST 控制器公开资源产品、订单和客户。
您要做的是保护所有资源，以便当客户端调用 REST API 时，客户端将收到 401（未经授权），这意味着客户端请求尚未完成，因为它缺少所请求资源的有效身份验证凭据。
JSON 网络令牌 (JWT) JSON Web 令牌是一种开放方法，用于在两方之间安全地表示声明。 JWT 是一组声明（JSON 属性-值对），它们共同构成一个 JSON 对象。它由三部分组成：
Header: 由两个属性组成：{ “alg”: “HS256”, “typ”: “JWT” }。 alg 是用于加密 JWT 的算法。 Payload: 这是存储要发送的数据的地方；该数据存储为 JSON 属性-值对。 Signature: 这是通过加密创建的，使用标头中指定的算法：（i）base64Url 编码的标头，（ii）base64Url 编码的有效负载，以及（iii）秘密（或私钥）： HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret|privateKey) 最终的 JWT 由三部分组成。每个都是 base64Url 编码的，并且与下一个之间用点分隔。有关更多详细信息，请参阅 openid.net 和 jwt.io 网站。...</p></div><footer class=entry-footer><span title='2023-09-19 00:00:00 +0000 UTC'>2023-09-19</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;907 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]SPRING BOOT JWT - 如何使用 SPRING SECURITY 和 JSON WEB 令牌保护您的 REST API" href=https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Security 与 JWT for REST API</h2></header><div class=entry-content><p>免责声明：Spring Security 5+ 已发布 OAuth JWT 支持。建议使用最新版本的 OAuth 来支持 JWT，而不是使用自定义安全性或过滤器。
Spring 被认为是 Java 生态系统中值得信赖的框架，并且被广泛使用。将 Spring 称为框架不再有效，因为它更多的是涵盖各种框架的总括术语。其中一个框架是 Spring Security，它是一个功能强大且可定制的身份验证和授权框架。它被认为是保护基于 Spring 的应用程序的事实标准，因此，如果您希望实现 Spring JWT 令牌解决方案，那么将其基于 Spring Security 是有意义的。
尽管它很受欢迎，但我必须承认，当涉及到单页应用程序时，Spring 的配置并不简单和直接。我怀疑原因是它更多地是作为一个面向应用程序的 MVC 框架开始的，其中网页渲染发生在服务器端，并且通信是基于会话的。
如果后端基于 Java 和 Spring，那么使用 Spring Security 和 JWT 进行身份验证/授权并将其配置为无状态通信是有意义的。虽然有很多文章解释了这是如何完成的，但对我来说，第一次设置它仍然令人沮丧，我必须阅读并总结来自多个来源的信息。这就是我决定编写这个 Spring Security 教程的原因，我将在其中尝试总结并涵盖您在配置过程中可能遇到的所有必需的微妙细节和缺陷。
术语定义 在深入探讨技术细节之前，我想明确定义 Spring Security 上下文中使用的术语，以确保我们都使用相同的语言。 这些是我们需要解决的术语：
Authentication 验证是指根据提供的凭据验证用户身份的过程。一个常见的示例是在登录网站时输入用户名和密码。您可以将其视为对“您是谁？”这个问题的答案。 Authorization 授权是指假设用户已成功通过身份验证，则确定用户是否具有执行特定操作或读取特定数据的适当权限的过程。您可以将其视为“用户可以执行/阅读此操作吗？”问题的答案。 Principle 原则是指当前经过身份验证的用户。 Granted authority 授予权限是指经过认证的用户的权限。 Role 角色是指经过身份验证的用户的一组权限。 创建基本的 Spring 应用程序 在开始配置 Spring Security 框架之前，让我们创建一个基本的 Spring Web 应用程序。为此，我们可以使用 Spring Initializr 并生成一个模板项目。对于一个简单的 Web 应用程序，只需要 Spring Web 框架依赖就足够了：
&lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;/dependencies> 创建项目后，我们可以向其中添加一个简单的 REST 控制器，如下所示：
@RestController @RequestMapping("hello") public class HelloRestController { @GetMapping("user") public String helloUser() { return "Hello User"; } @GetMapping("admin") public String helloAdmin() { return "Hello Admin"; } } 之后，如果我们构建并运行该项目，我们可以在 Web 浏览器中访问以下 URL：...</p></div><footer class=entry-footer><span title='2023-09-19 00:00:00 +0000 UTC'>2023-09-19</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1507 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Security 与 JWT for REST API" href=https://blog.chensoul.cc/posts/2023/09/19/spring-security-tutorial/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Boot项目如何实现JWT认证？</h2></header><div class=entry-content><p>没有人可以否认这样一个事实：安全性是生产就绪应用程序的一项重要功能。尽管我们可以使用内存身份验证、JDBC 身份验证或通过 UserDetailsS​​ervice 来保护一个 Web 应用程序的安全。但是，当一个应用程序在内部使用其他应用程序的服务时，使用 Web 服务概念实现安全性就变得很重要。在这种情况下，我们使用具有特定有效期的令牌来保护我们的应用程序。此外，我们将学习“如何在 Spring Boot 项目中实现 JWT 身份验证？”以整体了解 JWT（JSON Web Token）身份验证背后的概念。
由于 JWT 代表“JSON Web Token”，很明显，该令牌仅以 JSON 形式保存数据。
此外，与上述身份验证技术不同，JWT 属于无状态身份验证。简而言之，它没有数据。通常，这种类型的身份验证用于 Web 服务、服务器的水平扩展，甚至在某种程度上用于 OAuth 技术。为了说明该网络服务，让我们可视化从亚马逊预订订单的过程。在这里，用户与 Amazon 应用程序交互，而 Amazon 应用程序在内部通过 Web 服务调用与支付网关应用程序交互。
现在让我们开始讨论我们的主题“如何在 Spring Boot 项目中实现 JWT 身份验证？”以及相关点。
您对整篇文章有何期望？ 读完本文后，您将能够回答：
什么是安全上下文中的无状态和有状态身份验证？ 无状态认证和有状态认证有什么区别？ 那么什么是 Token，什么是 JWT(JSON Web Token)？
使用 JWT 认证有什么好处？
JWT 内部如何运作？
我们在什么情况下使用 JWT 身份验证？
此外，JWT 身份验证和状态身份验证之间有什么区别？
此外，如何生成 JWT 编码令牌以及如何将其解码回来？
如何在 Spring Boot 项目中逐步实现 JWT 认证？
在 Spring Boot 3.0 中，如何在不使用 WebSecurityConfigurerAdapter 的情况下编写安全配置类？
最后，如何测试启用 JWT 安全的应用程序？
什么是无状态和有状态身份验证？ 通常有两种类型的认证技术。两者都发生在客户端服务器概念中，服务器仅在身份验证后才向客户端提供服务。这里的客户端可以是浏览器，也可以是另一个服务器。
状态认证 在这种类型的身份验证中，客户端和服务器之间涉及会话管理。当客户端向服务器请求服务时，它首先登录到服务器。然后服务器创建一个会话并以键值对的形式存储该信息。这个会话是服务器端的一种内存。我们也称其为 HttpSession，因为 Http 协议管理它。
此外，为了响应客户端请求，服务器以 Cookie 的形式向客户端提供带有响应的会话 id。该 cookie 存储在客户端浏览器中。当同一个客户端第二次发出请求时，请求头中也会带有 cookie。因此，服务器会检查请求标头，如果在 cookie 中发现相同的 SID（会话 ID），则假定该请求来自同一客户端。通过这种方式，会话管理就发生了。
当客户端从服务器注销时，会话会相应地被销毁。结果，服务器相应地从内存中删除会话信息（键值）。同样重要的是，对于每个新客户端，服务器都会创建一个新会话（内存）。
无状态身份验证 当客户端向服务器发送服务请求时，它首先登录到服务器。因此，服务器生成一个令牌（编码格式的数据）并将响应发送到客户端。在发出第二个请求时，客户端将相同的令牌与请求一起发送到服务器。现在，服务器从请求中读取令牌并验证令牌。事实上，从第一个请求开始，服务器就检查客户端的有效登录（凭据）。...</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1974 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Boot项目如何实现JWT认证？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[译]Spring Boot项目如何实现Security？</h2></header><div class=entry-content><p>如今，几乎每个客户都要求在实时应用程序中实现强大的安全功能。安全功能对于保持机密性、完整性和可用性的需求是非常有效的。现实世界中有很多类型的安全性，但我们作为开发人员将重点关注应用程序/软件安全性。
此外，在应用程序安全方面，我们的工作基本上是确保两件事。首先，只有有效的用户才能访问该应用程序。其次，如果用户有效，他/她只能访问该应用程序中允许的数据/信息。我认为，没有什么可以解释它们，因为您必须已经了解这两个术语，即身份验证和授权。
您可能已经猜到我们将在当前主题“如何在 Spring Boot 项目中实现安全性？”中讨论什么内容。
在本文中，我们将从基本原理开始学习。接下来，我们将逐步结束它，直到我们有信心在 Spring Boot 应用程序中实现安全功能。因此，让我们开始逐步讨论“如何在 Spring Boot 项目中实现安全性？”。 Spring Boot 教程页面上有一系列有关 Spring Boot Security 的教程。
我们在本文中介绍了两个版本的“如何在 Spring Boot 项目中实现安全性？”的示例：使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。此外，还涵盖了使用 Spring Boot 3.0 及更高版本的“如何在 Spring Boot 项目中实现安全性？”的示例。
您将从本文中学到什么？ 为什么我们需要在 Spring Boot 应用程序中实现安全性？
Security 在 Spring Boot 应用程序内部如何工作？
javax.servlet.Filter 在 Spring Boot 应用程序中实现安全性方面的作用是什么？
Spring Boot 项目中使用了多少种授权类型？
Spring Boot 项目中有多少种实现安全性的方法？
在 Spring Boot 项目中实现 WebSecurity 的步骤是什么？
另外，如何在 Spring Boot 项目中使用@EnableWebSecurity、@Configuration、@Bean？
如何实现内存中身份验证安全示例
如何实现 JDBC 认证安全示例
如何在 Spring Boot 项目中使用 Thymeleaf ？
如何测试启用安全的功能？
相反，如何禁用应用程序的安全功能？
最后但并非最不重要的一点是，您将学习“如何在 Spring Boot 项目中实现安全性？”使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。
为什么我们需要应用程序中的安全性？ 现在，随着恶意攻击将重点从操作系统和网络转移到应用程序/软件和移动设备/设备，一天的数据面临最大的风险。此外，从业务/客户的角度来看，应用程序安全在维护信任、建立品牌形象和降低风险方面发挥着重要作用。事实上，没有其中任何一项，都无法想象一家成功的企业。
总之，无论您是为了内部使用、销售目的还是购买目的而创建应用程序，安全性都是每个应用程序最重要的功能。
根据最新的 2020 年 Verizon 数据泄露调查报告，所有数据泄露中有 43% 是针对 Web 应用程序的攻击。这一数字比 2019 年增加了一倍。此外，86% 的违规行为都是出于经济动机。...</p></div><footer class=entry-footer><span title='2023-08-18 00:00:00 +0000 UTC'>2023-08-18</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1807 words&nbsp;·&nbsp;chensoul</footer><a class=entry-link aria-label="post link to [译]Spring Boot项目如何实现Security？" href=https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://blog.chensoul.cc/tags/spring-boot/page/2/>Next&nbsp;2/3&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://blog.chensoul.cc/>ChenSoul</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=https://umami.chensoul.cc/random-string.js data-website-id=821c25f8-a31a-4607-92d7-91ee76843d00></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>