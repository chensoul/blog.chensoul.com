<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Spring-Security on ChenSoul</title>
    <link>https://blog.chensoul.cc/tags/spring-security/</link>
    <description>Recent content in Spring-Security on ChenSoul</description>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 24 Jan 2024 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://blog.chensoul.cc/tags/spring-security/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2024-01-24｜今天做了什么</title>
      <link>https://blog.chensoul.cc/posts/2024/01/24/til/</link>
      <pubDate>Wed, 24 Jan 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/01/24/til/</guid>
      <description>今天做了什么：
观看 B 站视频《鸟宝的春天11_security编码实现》
参考视频中示例使用 SecurityFilterChain DSL 语法实现用户名密码登录功能。
扩展 WebAuthenticationDetails ，修改客户端 IP 获取方式，并记录服务端 IP。
public class CustomWebAuthenticationDetails extends WebAuthenticationDetails { private static final long serialVersionUID = 4441359628463408329L; @Getter private final String serverAddress; public CustomWebAuthenticationDetails(final HttpServletRequest request, final String serverAddress) { super(HttpRequestUtils.getClientIp(request), extractSessionId(request)); this.serverAddress = serverAddress; } protected static String extractSessionId(final HttpServletRequest request) { final HttpSession session = request.getSession(false); return (session != null) ? session.getId() : null; } } 获取客户端 IP 使用了 HttpRequestUtils 类，实际上就是从 Request 的 header 中获取 IP。
private static final List&amp;lt;String&amp;gt; CLIENT_IP_HEADER_NAMES = Arrays.asList(&amp;#34;X-Forwarded-For&amp;#34;, &amp;#34;X-Real-IP&amp;#34;, &amp;#34;Proxy-Client-IP&amp;#34;, &amp;#34;WL-Proxy-Client-IP&amp;#34;, &amp;#34;HTTP_CLIENT_IP&amp;#34;, &amp;#34;HTTP_X_FORWARDED_FOR&amp;#34;); public static String getClientIp(HttpServletRequest request, String... otherHeaderNames) { if (request == null) { return null; } if (ArrayUtils.</description>
    </item>
    <item>
      <title>2024-01-23｜今天做了什么</title>
      <link>https://blog.chensoul.cc/posts/2024/01/23/til/</link>
      <pubDate>Tue, 23 Jan 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/01/23/til/</guid>
      <description>今天做了什么：
重构 foodie-cloud 项目，修改模块名称、表名及字段名。
修改 spring-security-oauth2-legacy-examples ，测试资源服务器通过 jwt、jwk、远程三种方式获取用户信息；测试 sso 单点登录（进行中）。</description>
    </item>
    <item>
      <title>2024-01-10｜ Java审计框架inspektr</title>
      <link>https://blog.chensoul.cc/posts/2024/01/10/til/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/01/10/til/</guid>
      <description>今天做了什么：
1、Java Lambda 增强 https://github.com/jOOQ/jOOL 和 https://github.com/vavr-io/vavr ，jOOL 在 jdk8 下存在编译错误，计划，整合这两个项目，创建一个新的项目，只引入自己需要的一些类。
2、https://www.pac4j.org/ 一个安全框架
3、https://github.com/apereo/inspektr 一个轻量级的 Java 审计框架。这个是在看 CAS 源码的过程中，发现的。
在 CAS 的源码中，有一些比较不错的代码，引入到自己的项目中，另外，打算仿照这个 inspektr 框架，重写公司微服务项目中的日志记录模块。
4、分享一个安全相关的 wiki 网站：https://wukong-doc.redhtc.com/security
总结：
待办事项：
重写微服务日志记录模块 写一个 Lambda 类库 重构公司微服务框架 继续重构 foodie-cloud 支持单点登录 支持全文检索 集成 Spring Security OAuth2 </description>
    </item>
    <item>
      <title>2024-01-09｜单点登录</title>
      <link>https://blog.chensoul.cc/posts/2024/01/09/til/</link>
      <pubDate>Tue, 09 Jan 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/01/09/til/</guid>
      <description>今天做了什么：
使用 renovate 监控第三方依赖更新 ，renovate 貌似需要付费，放弃。 spring-security-oauth2-samples 示例工程重命名模块和包名，代码见 spring-security-oauth2-boot 实现单点登录并测试 实现单点登录并测试 实现单点登录（Single Sign-On，SSO）可以采用多种思路和技术。下面是几种常见的实现思路：
基于令牌（Token）的SSO：用户在登录时，认证服务器颁发一个令牌给用户，该令牌包含用户的身份信息。用户在访问其他应用时，将令牌发送给应用服务器进行验证，从而实现单点登录。 基于会话（Session）的SSO：用户在登录时，认证服务器创建一个会话，并将会话ID发送给用户的浏览器。用户在访问其他应用时，浏览器将会话ID发送给应用服务器进行验证，从而实现单点登录。 基于身份提供者（Identity Provider，IdP）的SSO：使用一个独立的身份提供者（如OpenID Connect、SAML等），用户在登录时将身份验证委托给身份提供者。身份提供者负责验证用户身份，并向应用程序提供令牌或身份凭证，实现单点登录。 基于代理（Proxy）的SSO：通过在前端部署反向代理服务器或负载均衡器，将用户的登录状态存储在代理服务器中。用户访问其他应用时，代理服务器将用户的身份信息传递给应用服务器，从而实现单点登录。 基于统一认证系统（CAS）的SSO：使用CAS作为中央认证服务器，用户在登录时通过CAS进行认证，并获取一个票据（ticket）。用户访问其他应用时，应用服务器将票据发送给CAS进行验证，从而实现单点登录。 这些思路和技术并非互斥，可以根据具体需求和系统架构的复杂性选择适合的实现方式。此外，还可以使用现有的SSO解决方案和身份管理平台，如Auth0、Okta、Keycloak等，简化SSO的实现过程。
基于 OAuth2 单点登录 在 spring-security-oauth2-legacy-examples 添加单点登录 github 示例。参考了 oauth2-sample-java-webapp
CAS 实现单点登录 CAS（Central Authentication Service）是一套完整的统一身份认证解决方案，完整资料可查阅其 官方网站。CAS包括对应的协议(CAS Protocol)、协议的实现(CAS Server)和与CAS服务交互的软件包(CAS Client)。
CAS Client接入示例：https://github.com/apereo?q=client
CAS 交互时序图：https://apereo.github.io/cas/7.0.x/images/cas_flow_diagram.png
参考 SpringBoot+CAS整合服务端和客户端实现SSO单点登录与登出快速入门上手 这篇文章，代码在 这里。</description>
    </item>
    <item>
      <title>2023-12-28｜今天做了什么</title>
      <link>https://blog.chensoul.cc/posts/2023/12/28/til/</link>
      <pubDate>Thu, 28 Dec 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/12/28/til/</guid>
      <description>今天做了什么：
重构微服务项目中使用 spring-security-oauth2 搭建 OAuth2 认证服务和资源服务的代码，减少其他模块对此的耦合度。计划将 spring-security-oauth2 迁移到 spring-security-oauth2-authorization-server 上，即使用 OAuth2.1 授权和认证。Spring Authorization Server 相关文档，可以参考 https://blog.51cto.com/u_15268610/category2。
看 xuxiaowei-cloud master 分支源代码，整理 /login 登陆逻辑，参数：username、password、tenantId、clientId
登陆成功
记录登陆日志 转向 /login/success 获取客户端信息，将授权地址、校验 token 地址返回给前端 前端重定向到授权页面 授权同意，则重定向到客户端表中配置的重定向地址 /oauth2/code/{id}，并通过 code 去获取 token，最后再重定向到用户指定的回调地址 重新梳理用户中心领域模型。
领域模型：
客户端，对应 OAuth 中的客户端的概念。
应用
租户
用户
角色
资源
区域
门店
领域模型之间的关系说明：
客户端和应用多对的的关系，应用和租户是多对多的关系，租户和资源是多对多的关系，应用和资源一对多的关系。为了简化操作，可以创建一个中间表保存客户端、应用、租户、资源之间的关系。 资源、用户、角色是 RBAC 模型。角色和应用是多对一的关系，租户和角色是一对多的关系，即角色是隶属于应用和租户。不太应用的不同租户下的角色不一样。 租户和区域是一对多的关系，区域和门店是一对多的关系，门店和应用是多对多的关系。 用户和租户是多对多的关系。 流程：
登陆：使用用户名、密码、客户端 ID、租户 ID（首次登陆时为空，取用户有权限的租户中的第一个） 登陆。通过 客户端 ID、租户 ID 、用户名查询该用户的权限。 登陆之后，再选择租户进入首页。 创建客户端之后，可以绑定应用。 创建租户时，可以通过资源树（客户端+应用+资源）开通资源，可以给租户开通的应用开通门店。 </description>
    </item>
    <item>
      <title>2023-12-27｜今天做了什么</title>
      <link>https://blog.chensoul.cc/posts/2023/12/27/til/</link>
      <pubDate>Wed, 27 Dec 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/12/27/til/</guid>
      <description>今天做了什么：
微服务项目中认证服务器配置授权码模式，并测试通过
扩展 RedisAuthorizationCodeServices ，支持设置过期时间。
注意：OAuth2Authentication 无法从 json 反序列化，故无法使用 JSON 反序列化类，只能使用 JDK 反序列化类。 扩展 BearerTokenExtractor，支持从 request 请求的 header 中读取 access_token
配置 JWK token 使用时
扩展 JwtAccessTokenConverter ，用于解析 jwks 接口返回的 json，相关说明参考 creating-the-jwk-set-endpoint JwkDefinitionSource 类中获取 jwkSetUrls 时，不支持 url 中配置服务名称，即不支持负载均衡。故，重写该类以支持通过 RestTemplate （可以注入一个支持负载均衡的 RestTemplate） 解析 jwkSetUrls 返回的 json 类型的字符串；创建了一个支持负载均衡的 TokenStore。 运行 xuxiaowei-cloud 项目时
提示 Rollup failed to resolve import &amp;quot;@vue/shared&amp;quot;，原因：这个错误是由于无法解析到 @vue/shared 这个包导致的。@vue/shared 是 Vue 内部使用的一个共享工具库。解决方案：将 @vue/shared 添加到项目的依赖中。
npm install --save @vue/shared Controller 的方法上添加注解判断是否有权限，例子：@PreAuthorize(&amp;quot;hasAuthority(&#39;manage_user_authority&#39;) or #oauth2.hasScope(&#39;manage_user_authority&#39;)&amp;quot;)
Principal 中的用户对象，即 UserDetails 对象不添加额外字段，只有 username，如果想获取用户信息，需要通过用户服务去查询。
关于 OAuth2 的参考资料：
Oauth2.0搭建问题记录
OAuth 2.0 实战
关于 Spring Cloud 集成 OAuth2 的参考仓库：
https://gitee.com/youlaitech/youlai-mall
https://gitee.com/dromara/RuoYi-Cloud-Plus
https://gitee.com/dromara/open-capacity-platform/</description>
    </item>
    <item>
      <title>2023-12-22｜今天做了什么</title>
      <link>https://blog.chensoul.cc/posts/2023/12/22/til/</link>
      <pubDate>Fri, 22 Dec 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/12/22/til/</guid>
      <description>今天做了什么：
我使用的 Idea 插件。
springdoc-openapi v1.7.0 示例
Spring Security OAuth Boot 2 Autoconfig 转换成 maven 项目，并添加示例
Idea 1、插件
GenerateSerialVersionUID：自动生成 serialVersionUID
MicroProfile Starter：创建 MicroProfile 微服务应用
Easy Javadoc：快速生成 Javadoc
快捷键 作用域 说明 ctrl \ 类、方法、属性（光标放上面就行，不要双击选中！） 生成当前文档注释 ctrl \ 选中的中文 生成选中的中文的英文命名 ctrl \ 选中的非中文 弹框展示翻译结果 ctrl shift \ 类 生成全部文档注释 .ignore
Maven Helper
MetricsReloaded
MybatisX
PlantUML Diagram Generator
Save Actions Tool
SequenceDiagram
StringManipulation
Translation
WakaTime
2、快捷键
多个窗口之前切换，MacOS 快捷键：Command + ~ springdoc-openapi v1.7.0 将项目中使用的 swagger doc 迁移到 springdoc-openapi v1.7.0，关于 springdoc 的使用，在 github 上创建了一个示例仓库： springdoc-examples
Spring Security OAuth Boot 2 Autoconfig 将 Spring Security OAuth Boot 2 Autoconfig 修改成 maven 项目，并添加 samples 示例。修改后的项目地址：https://github.com/chensoul/spring-security-oauth2-boot</description>
    </item>
    <item>
      <title>2023-12-21｜Spring Security对OAuth2的支持及实现方式</title>
      <link>https://blog.chensoul.cc/posts/2023/12/21/til/</link>
      <pubDate>Thu, 21 Dec 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/12/21/til/</guid>
      <description>Today I Learned. 今天分享内容：Spring Security 对 OAuth2 的支持
Spring Security 提供了对 OAuth 的支持，并且有几个相关的项目可以用于实现 OAuth 功能。以下是一些常见的 Spring Security OAuth 项目及其相关信息：
Spring Security OAuth（https://github.com/spring-attic/spring-security-oauth）：官方提供的 Spring Security OAuth 项目，为 Spring 应用程序提供了 OAuth 1.0 和 OAuth 2.0 的支持。该项目在 Spring Security 5.x 版本后已不再维护，建议使用后续提到的 Spring Authorization Server。 Spring Security 5（https://github.com/spring-attic/spring-security）：Spring Security 5.x 版本开始将 OAuth 2.0 客户端支持集成到核心库中，使得在 Spring Security 中实现 OAuth 2.0 认证变得更加简单。你可以使用 Spring Security 5.x 以及后续版本来实现 OAuth 2.0 客户端功能。 Spring Security OAuth2 Boot（https://github.com/spring-attic/spring-security-oauth2-boot），该项目是 spring-attic 组织维护的，提供了 Spring Boot 2 和旧版 Spring Security OAuth 的自动配置。该项目已经停止了活跃的开发和更新，最新的提交日期是 2022 年 5 月 20 日。 Spring Authorization Server（https://github.com/spring-projects/spring-authorization-server）：官方提供的用于构建 OAuth 2.0 授权服务器的实验性项目。它是 Spring Security 5.3 之后推出的替代方案，旨在提供更简化和灵活的 OAuth 2.0 授权服务器功能。 Authorization Server
目前，Spring Security 不支持实现 OAuth 2.</description>
    </item>
    <item>
      <title>2023-12-19｜Spring Security OAuth2配置JWT、Github Actions配置代码扫描</title>
      <link>https://blog.chensoul.cc/posts/2023/12/19/til/</link>
      <pubDate>Tue, 19 Dec 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/12/19/til/</guid>
      <description>Today I Learned. 今天分享内容：Spring Security OAuth2 配置JWT、Github Actions配置代码扫描，另外，修改了 spring-security-oauth2-legacy 仓库，支持授权认证中心的多种配置方式（jdbc、内存、redis、jwt）、资源中心的多种配置方式（jwt、jdbc、redis、remote、jwk-set-uri）。
Spring Security OAuth2 配置JWT 使用 Spring Security 实现OAuth2 配置 JWT 非对称加密时， JwtAccessTokenConverter 设置生成私钥签名和公钥验证器（可省略）。
@Bean public JwtAccessTokenConverter jwtAccessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); // 设置私钥签名 converter.setSigner(new RsaSigner((RSAPrivateKey) new RSA(&amp;#34;privateKey&amp;#34;, null).getPrivateKey())); // 设置公钥验证器，可省略 converter.setVerifier(new RsaVerifier((RSAPublicKey) new RSA(null, &amp;#34;publicKey&amp;#34;).getPublicKey())); return jwtAccessTokenConverter; } 注意：这里使用了 Hutool 的 RSA 从字符串生成 PrivateKey 和 PublicKey
去掉对 Hutool 的依赖，则可以使用自己实现的 RSAUtil 类：
public class RSAUtil { public static final String ALGORITHM_KEY = &amp;#34;RSA&amp;#34;; @SneakyThrows public static PrivateKey getPrivateKeyFromString(String privateKeyStr) { byte[] privateKeyBytes = Base64.getDecoder().decode(privateKeyStr.replaceAll(&amp;#34;\n&amp;#34;, &amp;#34;&amp;#34;)); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes); KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_KEY); return keyFactory.generatePrivate(keySpec); } @SneakyThrows public static PublicKey getPublicKeyFromString(String publicKeyStr) { byte[] publicKeyBytes = Base64.</description>
    </item>
    <item>
      <title>2023-12-18｜使用Spring Security实现OAuth2授权和认证</title>
      <link>https://blog.chensoul.cc/posts/2023/12/18/til/</link>
      <pubDate>Mon, 18 Dec 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/12/18/til/</guid>
      <description>Today I Learned. 今天分享内容：使用Spring Security实现OAuth2授权和认证。
最近在开发 Spring Cloud 微服务时，需要对 OAuth2 的异常处理进行定制，从网上搜到一个 github 仓库：oauth2。这篇仓库的代码实现了 OAuth2 的四种授权模式、I18N 国际化、异常处理、JWT Token，我 fork 了一份代码，做了一些改动，去掉了 webflux、eureka 相关代码。
代码仓库地址：https://github.com/chensoul/spring-security-oauth2-legacy，相关依赖的版本：
spring-boot: 2.7.18 org.springframework.security.oauth:spring-security-oauth2-autoconfigure: 2.6.8 org.springframework.security.oauth:spring-security-oauth2: 2.5.2.RELEASE org.springframework.security:spring-security-jwt 1.1.1.RELEASE 特性 统一异常处理 参考spring security的 ExceptionTranslationFilter 类
异常处理类 AccessDeniedHandler AuthenticationEntryPoint jwt key生成 生成 JKS 文件 keytool -genkeypair -alias myalias -storetype PKCS12 -keyalg RSA -keypass mypass -keystore mykeystore.jks -storepass mypass -validity 3650 导出公钥 # 保存为 public.cer 文件： keytool -exportcert -alias myalias -storepass mypass -keystore mykeystore.jks -file public.cer # 保存为 public.key 文件 keytool -list -rfc --keystore mykeystore.jks -storepass mypass | openssl x509 -inform pem -pubkey &amp;gt; public.key 导出私钥，将其保存为 private.key 文件： keytool -importkeystore -srckeystore mykeystore.</description>
    </item>
    <item>
      <title>[译]Spring Security 面试问题</title>
      <link>https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/</link>
      <pubDate>Thu, 12 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/12/spring-security-interview-questions/</guid>
      <description>本面试准备指南将讨论一些常见的 Spring Security 面试问题。无论您是准备面试还是只是想增强对 Spring Security 的了解，这些问题都将帮助您理解关键概念并指导您设计常见安全问题的解决方案。
1. Spring Security 的核心特性是什么？ Spring Security 提供的两个最突出的功能是身份验证和授权。这些功能在确保应用程序的安全性方面发挥着至关重要的作用。然而，Spring Security 超越了身份验证和授权，还提供了额外的功能来防止漏洞利用并与其他框架集成。
1.1.验证 身份验证是验证尝试访问应用程序的用户身份的过程。 Spring Security 提供多种身份验证方法（基于表单的身份验证、HTTP 基本身份验证、OAuth2、Siteminder、OpenID Connect、LDAP、JDBC 等），允许应用程序使用各种方法对用户进行身份验证。
它还支持自定义，当默认选项不满足要求时，可以实现自定义的身份验证机制。
1.2.授权 授权是向经过身份验证的用户或实体授予许可或权利的过程。用户或实体成功通过身份验证后，授权将决定他们可以在应用程序中访问哪些操作或资源。 Spring Security 为开发人员提供了多种方法来实现授权并控制用户对应用程序不同部分的访问。以下是一些常见的方法：
基于 Web URL 的授权：可以根据特定的 URL 或 URL 模式实施访问控制，规范哪些用户可以访问某些资源。 方法级授权：如果需要，甚至可以对 Java Bean 中的方法进行访问控制，从而在方法级提供细粒度的授权。 域实例级授权：Spring Security 提供了控制对特定域实例的访问的能力，允许基于某些实体的所有权或关联进行授权。 1.3.防止漏洞利用 Spring Security 提供了多种功能来防范常见的 Web 应用程序安全漏洞。一些显着的功能包括：
跨站请求伪造 (CSRF) 保护：Spring Security 会自动将 CSRF 令牌添加到表单和 AJAX 请求中，从而防止 CSRF 攻击。 跨站脚本 (XSS) 保护：Spring Security 支持输出编码，并提供实用程序通过清理用户输入来防止 XSS 攻击。 点击劫持保护：Spring Security 包括 X-Frame-Options 支持，以防止点击劫持攻击。 1.4.集成 Spring Security 与其他框架和库无缝集成，以增强应用程序的安全性。一些关键的集成是：
Spring MVC：Spring Security 与 Spring MVC 集成，为 Web 应用程序提供无缝的安全功能。它可以安全地处理请求、身份验证、授权并防止常见的 Web 漏洞。 Spring Data：Spring Security 与 Spring Data 集成，以便在查询中引用当前用户。这种集成确保可以根据身份验证和授权规则轻松访问和过滤用户特定的数据。 Jackson：Jackson 的支持可以实现 Spring Security 相关类的高效序列化和反序列化，特别是在使用分布式会话或 Spring Session 等框架时，从而提高效率和可扩展性。 密码学：Spring Security 与各种密码库和算法集成，以提供敏感信息的安全存储和传输。这种集成包括密码散列、加密和安全通信协议等功能，以保护数据的机密性和完整性。 有关 Spring Security 功能的更详细信息，请参阅官方文档。</description>
    </item>
    <item>
      <title>[译]SPRING BOOT JWT - 如何使用 SPRING SECURITY 和 JSON WEB 令牌保护您的 REST API</title>
      <link>https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/</guid>
      <description>如果您快速搜索如何使用 JSON Web Tokens 在 Spring Boot 中保护 REST API，您会发现很多相同的结果。这些结果包含一种方法，该方法涉及编写自定义过滤器链并引入第三方库来编码和解码 JWT。
在看完这些令人费解且令人困惑的教程后，我说必须有一种更简单的方法来做到这一点。我做了任何直接接触 Spring Security 团队的人都会做的事情，我向他们寻求帮助。他们告诉我，Spring Security 确实使用 oAuth2 资源服务器内置了对 JWT 的支持。
在本教程中，您将学习如何使用 JSON Web Tokens (JWT) 和 Spring Security 来保护您的 API。我并不是说这种方法无论如何都很容易，但对我来说，它比其他选择更有意义。
Github 存储库
应用架构 在我们开始编写一些代码之前，我想确保我们对于我们正在构建的内容都达成共识。在下面的示例中，您有一个客户端应用程序，它可以是一个简单的命令行应用程序、一个用 Angular 或 Vue 等编写的完整前端应用程序，或者系统中的其他一些服务。
该客户端应用程序将调用使用 Spring Boot 编写的服务器应用程序，该应用程序通过 REST API 公开数据。在下面的示例中，它是一个整体，但如果您有分布式架构，则同样适用。当前有 3 个 REST 控制器公开资源产品、订单和客户。
您要做的是保护所有资源，以便当客户端调用 REST API 时，客户端将收到 401（未经授权），这意味着客户端请求尚未完成，因为它缺少所请求资源的有效身份验证凭据。
JSON 网络令牌 (JWT) JSON Web 令牌是一种开放方法，用于在两方之间安全地表示声明。 JWT 是一组声明（JSON 属性-值对），它们共同构成一个 JSON 对象。它由三部分组成：
Header: 由两个属性组成：{ &amp;ldquo;alg&amp;rdquo;: &amp;ldquo;HS256&amp;rdquo;, &amp;ldquo;typ&amp;rdquo;: &amp;ldquo;JWT&amp;rdquo; }。 alg 是用于加密 JWT 的算法。 Payload: 这是存储要发送的数据的地方；该数据存储为 JSON 属性-值对。 Signature: 这是通过加密创建的，使用标头中指定的算法：（i）base64Url 编码的标头，（ii）base64Url 编码的有效负载，以及（iii）秘密（或私钥）： HMACSHA256(base64UrlEncode(header) + &amp;#34;.&amp;#34; + base64UrlEncode(payload), secret|privateKey) 最终的 JWT 由三部分组成。每个都是 base64Url 编码的，并且与下一个之间用点分隔。有关更多详细信息，请参阅 openid.net 和 jwt.io 网站。</description>
    </item>
    <item>
      <title>[译]Spring Security 与 JWT for REST API</title>
      <link>https://blog.chensoul.cc/posts/2023/09/19/spring-security-tutorial/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/19/spring-security-tutorial/</guid>
      <description>免责声明：Spring Security 5+ 已发布 OAuth JWT 支持。建议使用最新版本的 OAuth 来支持 JWT，而不是使用自定义安全性或过滤器。
Spring 被认为是 Java 生态系统中值得信赖的框架，并且被广泛使用。将 Spring 称为框架不再有效，因为它更多的是涵盖各种框架的总括术语。其中一个框架是 Spring Security，它是一个功能强大且可定制的身份验证和授权框架。它被认为是保护基于 Spring 的应用程序的事实标准，因此，如果您希望实现 Spring JWT 令牌解决方案，那么将其基于 Spring Security 是有意义的。
尽管它很受欢迎，但我必须承认，当涉及到单页应用程序时，Spring 的配置并不简单和直接。我怀疑原因是它更多地是作为一个面向应用程序的 MVC 框架开始的，其中网页渲染发生在服务器端，并且通信是基于会话的。
如果后端基于 Java 和 Spring，那么使用 Spring Security 和 JWT 进行身份验证/授权并将其配置为无状态通信是有意义的。虽然有很多文章解释了这是如何完成的，但对我来说，第一次设置它仍然令人沮丧，我必须阅读并总结来自多个来源的信息。这就是我决定编写这个 Spring Security 教程的原因，我将在其中尝试总结并涵盖您在配置过程中可能遇到的所有必需的微妙细节和缺陷。
术语定义 在深入探讨技术细节之前，我想明确定义 Spring Security 上下文中使用的术语，以确保我们都使用相同的语言。 这些是我们需要解决的术语：
Authentication 验证是指根据提供的凭据验证用户身份的过程。一个常见的示例是在登录网站时输入用户名和密码。您可以将其视为对“您是谁？”这个问题的答案。 Authorization 授权是指假设用户已成功通过身份验证，则确定用户是否具有执行特定操作或读取特定数据的适当权限的过程。您可以将其视为“用户可以执行/阅读此操作吗？”问题的答案。 Principle 原则是指当前经过身份验证的用户。 Granted authority 授予权限是指经过认证的用户的权限。 Role 角色是指经过身份验证的用户的一组权限。 创建基本的 Spring 应用程序 在开始配置 Spring Security 框架之前，让我们创建一个基本的 Spring Web 应用程序。为此，我们可以使用 Spring Initializr 并生成一个模板项目。对于一个简单的 Web 应用程序，只需要 Spring Web 框架依赖就足够了：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 创建项目后，我们可以向其中添加一个简单的 REST 控制器，如下所示：
@RestController @RequestMapping(&amp;#34;hello&amp;#34;) public class HelloRestController { @GetMapping(&amp;#34;user&amp;#34;) public String helloUser() { return &amp;#34;Hello User&amp;#34;; } @GetMapping(&amp;#34;admin&amp;#34;) public String helloAdmin() { return &amp;#34;Hello Admin&amp;#34;; } } 之后，如果我们构建并运行该项目，我们可以在 Web 浏览器中访问以下 URL：</description>
    </item>
    <item>
      <title>[译]Spring Boot项目如何实现JWT认证？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/</guid>
      <description>没有人可以否认这样一个事实：安全性是生产就绪应用程序的一项重要功能。尽管我们可以使用内存身份验证、JDBC 身份验证或通过 UserDetailsS​​ervice 来保护一个 Web 应用程序的安全。但是，当一个应用程序在内部使用其他应用程序的服务时，使用 Web 服务概念实现安全性就变得很重要。在这种情况下，我们使用具有特定有效期的令牌来保护我们的应用程序。此外，我们将学习“如何在 Spring Boot 项目中实现 JWT 身份验证？”以整体了解 JWT（JSON Web Token）身份验证背后的概念。
由于 JWT 代表“JSON Web Token”，很明显，该令牌仅以 JSON 形式保存数据。
此外，与上述身份验证技术不同，JWT 属于无状态身份验证。简而言之，它没有数据。通常，这种类型的身份验证用于 Web 服务、服务器的水平扩展，甚至在某种程度上用于 OAuth 技术。为了说明该网络服务，让我们可视化从亚马逊预订订单的过程。在这里，用户与 Amazon 应用程序交互，而 Amazon 应用程序在内部通过 Web 服务调用与支付网关应用程序交互。
现在让我们开始讨论我们的主题“如何在 Spring Boot 项目中实现 JWT 身份验证？”以及相关点。
您对整篇文章有何期望？ 读完本文后，您将能够回答：
什么是安全上下文中的无状态和有状态身份验证？ 无状态认证和有状态认证有什么区别？ 那么什么是 Token，什么是 JWT(JSON Web Token)？
使用 JWT 认证有什么好处？
JWT 内部如何运作？
我们在什么情况下使用 JWT 身份验证？
此外，JWT 身份验证和状态身份验证之间有什么区别？
此外，如何生成 JWT 编码令牌以及如何将其解码回来？
如何在 Spring Boot 项目中逐步实现 JWT 认证？
在 Spring Boot 3.0 中，如何在不使用 WebSecurityConfigurerAdapter 的情况下编写安全配置类？
最后，如何测试启用 JWT 安全的应用程序？
什么是无状态和有状态身份验证？ 通常有两种类型的认证技术。两者都发生在客户端服务器概念中，服务器仅在身份验证后才向客户端提供服务。这里的客户端可以是浏览器，也可以是另一个服务器。
状态认证 在这种类型的身份验证中，客户端和服务器之间涉及会话管理。当客户端向服务器请求服务时，它首先登录到服务器。然后服务器创建一个会话并以键值对的形式存储该信息。这个会话是服务器端的一种内存。我们也称其为 HttpSession，因为 Http 协议管理它。
此外，为了响应客户端请求，服务器以 Cookie 的形式向客户端提供带有响应的会话 id。该 cookie 存储在客户端浏览器中。当同一个客户端第二次发出请求时，请求头中也会带有 cookie。因此，服务器会检查请求标头，如果在 cookie 中发现相同的 SID（会话 ID），则假定该请求来自同一客户端。通过这种方式，会话管理就发生了。
当客户端从服务器注销时，会话会相应地被销毁。结果，服务器相应地从内存中删除会话信息（键值）。同样重要的是，对于每个新客户端，服务器都会创建一个新会话（内存）。
无状态身份验证 当客户端向服务器发送服务请求时，它首先登录到服务器。因此，服务器生成一个令牌（编码格式的数据）并将响应发送到客户端。在发出第二个请求时，客户端将相同的令牌与请求一起发送到服务器。现在，服务器从请求中读取令牌并验证令牌。事实上，从第一个请求开始，服务器就检查客户端的有效登录（凭据）。</description>
    </item>
    <item>
      <title>[译]Spring Boot项目如何实现Security？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/</guid>
      <description>如今，几乎每个客户都要求在实时应用程序中实现强大的安全功能。安全功能对于保持机密性、完整性和可用性的需求是非常有效的。现实世界中有很多类型的安全性，但我们作为开发人员将重点关注应用程序/软件安全性。
此外，在应用程序安全方面，我们的工作基本上是确保两件事。首先，只有有效的用户才能访问该应用程序。其次，如果用户有效，他/她只能访问该应用程序中允许的数据/信息。我认为，没有什么可以解释它们，因为您必须已经了解这两个术语，即身份验证和授权。
您可能已经猜到我们将在当前主题“如何在 Spring Boot 项目中实现安全性？”中讨论什么内容。
在本文中，我们将从基本原理开始学习。接下来，我们将逐步结束它，直到我们有信心在 Spring Boot 应用程序中实现安全功能。因此，让我们开始逐步讨论“如何在 Spring Boot 项目中实现安全性？”。 Spring Boot 教程页面上有一系列有关 Spring Boot Security 的教程。
我们在本文中介绍了两个版本的“如何在 Spring Boot 项目中实现安全性？”的示例：使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。此外，还涵盖了使用 Spring Boot 3.0 及更高版本的“如何在 Spring Boot 项目中实现安全性？”的示例。
您将从本文中学到什么？ 为什么我们需要在 Spring Boot 应用程序中实现安全性？
Security 在 Spring Boot 应用程序内部如何工作？
javax.servlet.Filter 在 Spring Boot 应用程序中实现安全性方面的作用是什么？
Spring Boot 项目中使用了多少种授权类型？
Spring Boot 项目中有多少种实现安全性的方法？
在 Spring Boot 项目中实现 WebSecurity 的步骤是什么？
另外，如何在 Spring Boot 项目中使用@EnableWebSecurity、@Configuration、@Bean？
如何实现内存中身份验证安全示例
如何实现 JDBC 认证安全示例
如何在 Spring Boot 项目中使用 Thymeleaf ？
如何测试启用安全的功能？
相反，如何禁用应用程序的安全功能？
最后但并非最不重要的一点是，您将学习“如何在 Spring Boot 项目中实现安全性？”使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。
为什么我们需要应用程序中的安全性？ 现在，随着恶意攻击将重点从操作系统和网络转移到应用程序/软件和移动设备/设备，一天的数据面临最大的风险。此外，从业务/客户的角度来看，应用程序安全在维护信任、建立品牌形象和降低风险方面发挥着重要作用。事实上，没有其中任何一项，都无法想象一家成功的企业。
总之，无论您是为了内部使用、销售目的还是购买目的而创建应用程序，安全性都是每个应用程序最重要的功能。
根据最新的 2020 年 Verizon 数据泄露调查报告，所有数据泄露中有 43% 是针对 Web 应用程序的攻击。这一数字比 2019 年增加了一倍。此外，86% 的违规行为都是出于经济动机。</description>
    </item>
    <item>
      <title>[译]如何在Spring Boot2中使用UserDetailsService实现安全性？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot2-using-userdetailsservice/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot2-using-userdetailsservice/</guid>
      <description>继续上一篇关于实现 Spring Security 的两种不同方法的文章，在本文中，我们将学习第三种方法“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现 Security？”。经过上一篇文章后，我希望我们都非常熟悉安全性的基础知识，甚至是 Spring Boot 应用程序中的安全性基础知识。这次我们将创建一个用户注册表并将用户及其角色保存到数据库中。
然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
如果您正在寻找“如何在 Spring Boot 3 及以上版本中使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”，请访问有关使用 Spring Boot 3 的 Spring Security UserDetailsS​​ervice 的单独文章。
为了说明这一点，我们将把一些角色发挥作用，并在整个过程中围绕它们进行发挥，以使其变得清晰。此外，我们将有一些页面并限制它们仅可由某些特定角色访问。同样重要的是，我们必须创建一个小型 MVC Web 应用程序，以使注册过程向用户开放。用户在注册时将输入自己的角色。然后我们可以在其之上实现安全功能。
让我们开始相应的主题“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”。
总体而言，您对这篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 在 Spring Security 应用程序中如何内部工作并带有流程图？
另外，如何使用注解：@EnableWebSecurity、@Configuration、@Bean、@GetMapping、@Autowired、@Data、@Entity、@Table、@Id、@GenerateValue、@Column、@ElementCollection、@CollectionTable、@JoinColumn ， @服务
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 是做什么的？使用它有什么好处？ UserDetailsS​​ervice 是 Spring 中 org.springframework.security.core.userdetails 包下的预定义接口。我们的实现类实现了这个接口并重写了它的 loadUserByUsername(String username) 方法。此方法返回 UserDetails，它又是一个接口。预定义的 User 类（org.springframework.security.core.userdetails.User）是 UserDetails 接口的实现。总之，在 loadUserByUsername(String username) 方法中，我们传递用户名，它返回我们预定义的 User 对象（org.</description>
    </item>
    <item>
      <title>[译]如何在Spring Boot3中使用UserDetailsService实现安全性？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot3-using-userdetailsservice/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot3-using-userdetailsservice/</guid>
      <description>作为有关 Spring Security 的系列文章的继续，在本文中我们将学习“如何在 Spring Boot 3 中使用 UserDetailsService 实现 Spring Boot 中的安全性？”。经过前面的文章，我希望我们都非常熟悉安全性的基础知识，甚至 Spring Boot 应用程序中的安全性基础知识。 Spring Boot 3 发布后，我们将在这里实现“使用 Spring Boot 3 的 Spring Security UserDetailsService”。
在本文中，我们将创建一个用户注册表单并将用户及其角色保存在数据库中。然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
您对整篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 Spring Boot 3 实现 Spring Security UserDetailsService？
如何在基于 Spring 的应用程序中实现基于角色的安全性？
此外，如何以及在哪里使用注释：@EnableWebSecurity，@Configuration，@Bean，@GetMapping，@Autowired，@Data，@Entity，@Table，@Id，@GenerateValue，@Column，@ElementCollection，@CollectionTable， @JoinColumn，@Service
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
示例中使用的软件/技术 有时某些版本与其他版本冲突。因此，列出经过测试可以相互协作的组合。下面是经过测试的软件组合，用于使用 Spring Boot 3 开发 Spring Security UserDetailsS​​ervice。它也使实现完美无缺。
Spring Boot 3.0.0
JDK 17 or later
Maven 3.8.1 3）Maven 3.8.1
IDE – STS 4.7.1. RELEASE
IDE – STS 4.7.1。发布
Jars Used 下面是这些示例中 maven 使用 pom.</description>
    </item>
    <item>
      <title>[译]没有WebSecurityConfigurerAdapter的Spring Security.md</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/</guid>
      <description>在 Spring Security 模块的上下文中，WebSecurityConfigurerAdapter 是一个抽象类，根据 Spring 官方网站 2022 年 2 月 21 日发布的公告，该类已从 Spring Security 5.7.0-M2 中弃用。它通常用于扩展 configure() 方法由自定义配置子类实现。因此，它鼓励用户转向基于组件的安全配置。为了支持对这种新配置设计的更改，我们将讨论常见用例列表和未来建议的替代方案。因此，我们将讨论没有 WebSecurityConfigurerAdapter 的 Spring Security 用例的实现。
了解这一变化很重要，因为迟早我们将使用最新版本的 Spring Security 来开发安全功能。让我们讨论“没有 WebSecurityConfigurerAdapter 的 Spring Security”主题及其相关概念。
什么是 WebSecurityConfigurerAdapter？ WebSecurityConfigurerAdapter 是 Spring Security 模块提供的一个抽象类。一般来说，我们使用它来重写它的 configure()方法来定义我们的安全配置类。通常，我们在应用程序中实现 Spring Security 时使用两个具有不同参数的 configure() 方法。一种用于声明与身份验证相关的配置，另一种用于声明与授权相关的配置。该代码类似于下面的代码片段。
@Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // configure Authentication ...... } @Override protected void configure(HttpSecurity http) throws Exception { // configure Authorization ...... } } 为什么我们需要学习这个改变？ 如果您使用 Spring Boot 2.7.0 和 maven，它将自动下载 Spring Security 5.7.0 或更高版本。在这种情况下，您会发现 WebSecurityConfigurerAdapter 已被弃用。如果您仍然想使用此类而不弃用，您可以在 pom.xml 中将 Spring Boot 版本更改为较低版本（例如 2.6.6 ），如下所示。它将自动下载低于 5.</description>
    </item>
    <item>
      <title>[译]Spring Security - JWT</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-jwt/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-jwt/</guid>
      <description>简介和概述 JSON Web Token 或 JWT（更常见的名称）是一种开放的互联网标准 (RFC 7519)，用于以紧凑的方式在各方之间安全地传输可信信息。令牌包含编码为 JSON 对象的声明，并使用私有密钥或公钥/私钥对进行数字签名。它们是独立且可验证的，因为它们经过数字签名。 JWT 可以进行签名和/或加密。
签名的令牌验证令牌中包含的声明的完整性，而加密的令牌则向其他方隐藏声明。
JWT 也可用于信息交换，尽管它们更常用于授权，因为它们比使用内存中随机令牌的会话管理具有很多优势。其中最重要的是允许将身份验证逻辑委托给第三方服务器，例如 AuthO 等。
JWT 令牌分为 3 部分，即标头、有效负载和签名，格式为
[Header].[Payload].[Signature] Header − JWT 令牌的标头包含应用于 JWT 的加密操作列表。这可以是签名技术、有关内容类型的元数据信息等。标头以 JSON 对象的形式呈现，该对象被编码为 base64URL。有效 JWT 标头的示例是 { &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 这里，“alg”为我们提供了有关所用算法类型的信息，“typ”为我们提供了信息的类型。
Payload − JWT 的有效负载部分包含使用令牌传输的实际数据。这部分也称为 JWT 令牌的“声明”部分。索赔可以分为三种类型：注册索赔、公开索赔和私人索赔。 注册的声明是推荐的但不是强制的声明，例如 iss(发行者)、sub(主题)、aud(受众) 等。 公共声明是那些使用 JWT 的人定义的声明。 私人声明或自定义声明是为了在相关方之间共享信息而创建的用户定义的声明。 有效负载对象的示例可以是。
{ &amp;#34;sub&amp;#34;: &amp;#34;12345&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Johnny Hill&amp;#34;, &amp;#34;admin&amp;#34;: false } 有效负载对象与标头对象一样，也采用 base64Url 编码，并且该字符串构成 JWT 的第二部分。
Signature− JWT 的签名部分用于验证消息在此过程中没有更改。如果令牌是用私钥签名的，它还会验证发送者的身份。它是使用编码的标头、编码的有效负载、秘密和标头中指定的算法创建的。签名的一个例子是。 HMACSHA256(base64UrlEncode(header) + &amp;#34;.&amp;#34; + base64UrlEncode(payload), secret); 如果我们输入标头、有效负载和签名，我们会得到一个令牌，如下所示。
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6I kpvaG4gRG9lIiwiYWRtaW4iOmZhbHNlfQ.gWDlJdpCTIHVYKkJSfAVNUn0ZkAjMxskDDm-5Fhe WJ7xXgW8k5CllcGk4C9qPrfa1GdqfBrbX_1x1E39JY8BYLobAfAg1fs_Ky8Z7U1oCl6HL63yJq_ wVNBHp49hWzg3-ERxkqiuTv0tIuDOasIdZ5FtBdtIP5LM9Oc1tsuMXQXCGR8GqGf1Hl2qv8MCyn NZJuVdJKO_L3WGBJouaTpK1u2SEleVFGI2HFvrX_jS2ySzDxoO9KjbydK0LNv_zOI7kWv-gAmA j-v0mHdJrLbxD7LcZJEGRScCSyITzo6Z59_jG_97oNLFgBKJbh12nvvPibHpUYWmZuHkoGvuy5RLUA 现在，可以使用承载模式在授权标头中使用此令牌。
Authorization − Bearer 授权 - 持有者
使用 JWT 令牌进行授权是其最常见的应用。令牌通常在服务器中生成并发送到客户端，并存储在会话存储或本地存储中。要访问受保护的资源，客户端将在标头中发送 JWT，如上所述。我们将在下面的部分中看到 Spring Security 中的 JWT 实现。</description>
    </item>
    <item>
      <title>[译]Spring Security - OAuth2</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-oauth2/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-oauth2/</guid>
      <description>OAuth 2.0 基础知识 OAuth 2.0 由 IETF OAuth 工作组开发并于 2012 年 10 月发布。它作为一种开放授权协议，使第三方应用程序能够代表资源所有者对 HTTP 服务进行有限访问。它可以在不泄露用户身份或长期凭证的情况下做到这一点。第三方应用程序本身也可以代表其使用它。
OAuth 的工作原理包括将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问用户的帐户。
让我们考虑一个例子。假设我们要登录网站“clientsite.com”。我们可以通过 Facebook、Github、Google 或 Microsoft 登录。我们选择上面给出的选项中的任何选项，然后我们将被重定向到相应的网站进行登录。如果登录成功，系统会询问我们是否要授予 clientsite.com 访问其请求的特定数据的权限。
我们选择所需的选项，然后使用授权代码或错误代码重定向到 clientsite.com，登录是否成功取决于我们在第三方资源中的操作。这就是 OAuth 2 的基本工作原理。
OAuth 系统涉及五个关键角色。让我们把它们列出来 -
User / Resource Owner − 用户/资源所有者- 最终用户，负责身份验证并同意与客户端共享资源。 User-Agent − 用户代理- 用户使用的浏览器。 Client − 客户端 - 请求访问令牌的应用程序。 Authorization Server − 授权服务器- 用于验证用户/客户端的服务器。它颁发访问令牌并在其整个生命周期内对其进行跟踪。 Resource Server − 资源服务器- 提供对所请求资源的访问的 API。它验证访问令牌并提供授权。 入门 我们将使用 Spring Security 和 OAuth 2.0 开发一个 Spring Boot 应用程序来说明上述内容。我们现在将开发一个带有内存数据库的基本应用程序来存储用户凭据。该应用程序将使我们轻松了解 OAuth 2.0 与 Spring Security 的工作原理。
让我们使用 Spring 初始化程序在 Java 8 中创建一个 Maven 项目。让我们从 start.spring.io 开始。我们生成一个具有以下依赖项的应用程序 -
Spring Web Spring Security Cloud OAuth2 Spring Boot Devtools 通过上面的配置，我们点击 Generate 按钮生成一个项目。该项目将以 zip 文件形式下载。我们将 zip 解压到一个文件夹中。然后我们可以在我们选择的 IDE 中打开该项目。我在这里使用 Spring Tools Suite，因为它针对 Spring 应用程序进行了优化。我们也可以根据需要使用 Eclipse 或 IntelliJ Idea。</description>
    </item>
    <item>
      <title>[译]Spring Security - 使用数据库表单登录</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-with-database/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-with-database/</guid>
      <description>内容 简介和概述 Spring Security 的基本组件 AuthenticationFilter 认证过滤器 AuthenticationManager 认证管理器 AuthenticationProvider 认证提供者 UserDetailsService 用户详情服务 PasswordEncoder 密码编码器 Spring 安全上下文 表单登录 使用数据库登录 登录尝试限制 入门（实用指南） 简介和概述 除了提供各种内置的身份验证和授权选项之外，Spring Security 还允许我们根据需要自定义身份验证过程。从自定义登录页面到我们自己的自定义身份验证提供程序和身份验证过滤器，我们几乎可以自定义身份验证过程的各个方面。
我们可以定义自己的身份验证过程，范围可以从使用用户名和密码的基本身份验证到复杂的身份验证，例如使用令牌和 OTP 的双因素身份验证。此外，我们可以使用各种数据库 - 关系数据库和非关系数据库，使用各种密码编码器，将恶意用户锁定在其帐户之外，等等。
今天，我们将讨论三种此类自定义，即自定义表单登录、数据库提供的身份验证以及限制登录尝试。尽管这些都是非常基本的用例，但它们仍然可以让我们更仔细地了解 Spring Security 的身份验证和授权过程。我们还将建立一个注册页面，用户可以通过该页面在我们的应用程序中进行注册。
首先我们看一下 Spring Security 的架构。它从 servlet 过滤器开始。这些过滤器拦截请求，对其执行操作，然后将请求传递到过滤器链中的下一个过滤器或请求处理程序，或者在不满足某些条件时阻止它们。正是在这个过程中，Spring Security 可以对请求进行身份验证并对请求执行各种身份验证检查。
它还可以通过不允许未经身份验证或恶意请求访问我们受保护的资源来阻止它们通过。因此我们的应用程序和资源受到保护。
Spring Security 架构的组件 正如我们在上图中看到的那样，Spring Security 的基本组件如下所示。我们将在讨论过程中简要讨论它们。我们还将讨论它们在身份验证和授权过程中的角色。
AuthenticationFilter 认证过滤器 这是拦截请求并尝试对其进行身份验证的过滤器。在 Spring Security 中，它将请求转换为身份验证对象并将身份验证委托给 AuthenticationManager。
AuthenticationManager 认证管理器 它是身份验证的主要策略接口。它使用单独的方法 authenticate()来验证请求。 authenticate() 方法执行身份验证，并在身份验证成功时返回 Authentication 对象，或者在身份验证失败时抛出 AuthenticationException。如果该方法无法决定，它将返回 null。这个过程中的认证过程委托给了我们接下来要讨论的 AuthenticationProvider。
AuthenticationProvider 认证提供者 AuthenticationManager 由 ProviderManager 实现，后者将流程委托给一个或多个 AuthenticationProvider 实例。任何实现 AuthenticationProvider 接口的类都必须实现两个方法——authenticate() 和 supports()。首先，我们来谈谈 supports()方法。它用于检查我们的 AuthenticationProvider 实现类是否支持特定的身份验证类型。如果支持则返回 true，否则返回 false。
接下来是 authenticate() 方法。这是身份验证发生的地方。如果支持该认证类型，则启动认证过程。这里这个类可以使用 UserDetailsS​​ervice 实现的 loadUserByUsername() 方法。如果未找到用户，则会抛出 UsernameNotFoundException。
另一方面，如果找到用户，则使用该用户的身份验证详细信息来验证该用户。例如，在基本认证场景中，可以将用户提供的密码与数据库中的密码进行核对。如果发现它们彼此匹配，则说明成功。然后我们可以从此方法返回一个 Authentication 对象，该对象将存储在安全上下文中，我们将在稍后讨论。
UserDetailsService 用户详情服务 它是 Spring Security 的核心接口之一。任何请求的身份验证主要取决于 UserDetailsS​​ervice 接口的实现。它最常用于数据库支持的身份验证中以检索用户数据。通过单独的 loadUserByUsername() 方法的实现来检索数据，我们可以在其中提供逻辑来获取用户的用户详细信息。如果未找到用户，该方法将抛出 UsernameNotFoundException。</description>
    </item>
    <item>
      <title>[译]Spring Security - 表单登录、记住我和注销</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-remember-me-and-logout/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-remember-me-and-logout/</guid>
      <description>内容 简介和概述 入门（实用指南） 简介和概述 Spring Security 附带了大量内置功能和工具，为我们提供方便。在这个例子中，我们将讨论其中三个有趣且有用的功能 -
表单登录 记住账号 登出 表单登录 基于表单的登录是 Spring Security 提供支持的一种用户名/密码身份验证形式。这是通过 Html 表单提供的。
每当用户请求受保护的资源时，Spring Security 都会检查请求的身份验证。如果请求未经过身份验证/授权，用户将被重定向到登录页面。登录页面必须由应用程序以某种方式呈现。 Spring Security 默认提供该登录表单。
此外，如果需要，任何其他配置都必须明确提供，如下所示 -
protected void configure(HttpSecurity http) throws Exception { http // ... .formLogin( form -&amp;gt; form.loginPage(&amp;#34;/login&amp;#34;) .permitAll() ); } 此代码要求模板文件夹中存在一个 login.html 文件，该文件将在点击 /login 时返回。该 HTML 文件应包含一个登录表单。此外，该请求应该是对 /login 的 post 请求。参数名称应分别为用户名和密码的“username”和“password”。除此之外，表单中还需要包含 CSRF 令牌。
一旦我们完成了代码练习，上面的代码片段就会更加清晰。
记住账号 这种类型的身份验证需要将记住我的 cookie 发送到浏览器。该 cookie 存储用户信息/身份验证主体，并存储在浏览器中。因此，网站可以在下次会话启动时记住用户的身份。 Spring Security 已为此操作准备了必要的实现。
一种使用散列来保护基于 cookie 的令牌的安全性，而另一种使用数据库或其他持久存储机制来存储生成的令牌。
登出 默认 URL /logout 通过以下方式注销用户：
使 HTTP 会话失效 清除配置的所有 RememberMe 身份验证 清除 SecurityContextHolder 重定向到/login?logout WebSecurityConfigurerAdapter 自动将注销功能应用于 Spring Boot 应用程序。
Getting Started (Practical Guide) 像往常一样，我们首先访问 start.spring.io。这里我们选择一个 maven 项目。我们将项目命名为“formlogin”并选择所需的 Java 版本。我在此示例中选择 Java 8。我们还继续添加以下依赖项 -</description>
    </item>
    <item>
      <title>[译]Spring Security 和 Spring Boot 入门</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security/</guid>
      <description>Spring Security 是一个有助于保护企业应用程序安全的框架。通过与 Spring MVC、Spring Webflux 或 Spring Boot 集成，我们可以创建一个强大且高度可定制的身份验证和访问控制框架。在本文中，我们将解释核心概念并仔细研究 Spring Security 提供的默认配置及其工作原理。我们将进一步尝试自定义它们并分析它们对示例 Spring Boot 应用程序的影响。
示例代码 本文附有 GitHub 上的工作代码示例。
创建示例应用程序 让我们从头开始构建一个 Spring Boot 应用程序，看看 spring 如何配置和提供安全性。让我们从 spring starter 创建一个应用程序并添加所需的最少依赖项。
生成项目后，我们将其导入到 IDE 中并将其配置为在端口 8083 上运行。
mvnw clean verify spring-boot:run (for Windows) ./mvnw clean verify spring-boot:run (for Linux) 在应用程序启动时，我们应该看到一个登录页面。
控制台日志打印作为默认安全配置的一部分随机生成的默认密码：
使用默认用户名 user 和默认密码（来自日志），我们应该能够登录该应用程序。我们可以在 application.yml 中覆盖这些默认值：
spring: security: user: name: admin password: passw@rd 现在，我们应该能够使用用户 admin 和密码 passw@rd 登录。
依赖版本 在这里，我们使用了 Spring Boot 2.7.5 版本。基于此版本，Spring Boot 内部将 Spring Security 版本解析为 5.7.4。但是，如果需要，我们可以在 pom.xml 中覆盖这些版本，如下所示：
&amp;lt;properties&amp;gt; &amp;lt;spring-security.version&amp;gt;5.2.5.RELEASE&amp;lt;/spring-security.version&amp;gt; &amp;lt;/properties&amp;gt; 了解安全组件 要了解默认配置的工作原理，我们首先需要了解以下内容：
Servlet Filters 过滤器 Authentication 认证 Authorization 授权 Servlet Filters 让我们仔细看看应用程序启动时的控制台日志。我们看到 DefaultSecurityFilterChain 在请求到达 DispatcherServlet 之前触发一系列过滤器。 DispatcherServlet 是 Web 框架中的关键组件，用于处理传入的 Web 请求并将它们分派到适当的处理程序进行处理。</description>
    </item>
    <item>
      <title>[译]Spring Security：深入了解身份验证和授权</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-authentication-and-authorization/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-authentication-and-authorization/</guid>
      <description>您可以使用本指南来了解 Spring Security 是什么以及其核心功能（如身份验证、授权或常见漏洞保护）如何工作。此外，还有全面的常见问题解答。
（编者注：大约 6500 字，您可能不想尝试在移动设备上阅读本文。将其添加为书签，稍后再回来。）
介绍 迟早每个人都需要为其项目添加安全性，在 Spring 生态系统中，您可以借助 Spring Security 库来实现这一点。
因此，您继续将 Spring Security 添加到您的 Spring Boot（或普通 Spring）项目中，然后突然……​
&amp;hellip;您有自动生成的登录页面。 &amp;hellip;您无法再执行 POST 请求。 &amp;hellip;​ 您的整个应用程序处于锁定状态，并提示您输入用户名和密码。 在经历了随后的精神崩溃之后，您可能会对这一切是如何运作的感兴趣。
什么是 Spring Security 以及它是如何工作的？ 简短的回答： 从本质上讲，Spring Security 实际上只是一堆 servlet 过滤器，可帮助您向 Web 应用程序添加身份验证和授权。 它还与 Spring Web MVC（或 Spring Boot）等框架以及 OAuth2 或 SAML 等标准很好地集成。它会自动生成登录/注销页面并防止 CSRF 等常见漏洞。 现在，这并没有什么帮助，不是吗？ 幸运的是，还有一个很长的答案：本文的其余部分。
网络应用程序安全：101 在成为 Spring Security 大师之前，您需要了解三个重要概念：
Authentication 验证 Authorization 授权 Servlet Filters 过滤器 建议：不要跳过本节，因为它是 Spring Security 所做的一切的基础。另外，我会让它尽可能有趣。
1. 认证 首先，如果您正在运行典型的（Web）应用程序，您需要用户进行身份验证。这意味着您的应用程序需要验证用户是否是他所声称的人，通常通过用户名和密码检查来完成。
用户：“我是美国总统。我的 *username* 是：potus！” 您的网络应用程序：“当然可以，那么您的 *password* 是什么，总统先生？” 用户：“我的密码是：th3don4ld”。 您的网络应用程序：“正确。欢迎，先生！”
2、授权 在更简单的应用程序中，身份验证可能就足够了：用户经过身份验证后，她就可以访问应用程序的每个部分。
但大多数应用程序都有权限（或角色）的概念。想象一下：可以访问您的网上商店面向公众的前端的客户，以及可以访问单独管理区域的管理员。
两种类型的用户都需要登录，但身份验证这一事实并不能说明他们可以在系统中执行哪些操作。因此，您还需要检查经过身份验证的用户的权限，即您需要授权该用户。
用户：“让我玩那个核足球&amp;hellip;&amp;hellip;”。 您的网络应用程序：“等一下，我需要先检查您的 *permissions* ……是的，总统先生，您拥有正确的许可级别。尽情享受吧。” 用户：“那个红色按钮又是什么……​？”
3.Servlet 过滤器 最后但并非最不重要的一点是，让我们看一下 Servlet 过滤器。它们与身份验证和授权有什么关系？ （如果您对 Java Servlet 或 Filter 完全陌生，我建议您阅读旧的但仍然非常有效的 Head First Servlets 书。）</description>
    </item>
    <item>
      <title>Spring Security和OAuth2发展过程</title>
      <link>https://blog.chensoul.cc/posts/2023/08/15/spring-security-oauth2-history/</link>
      <pubDate>Tue, 15 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/15/spring-security-oauth2-history/</guid>
      <description>Spring Security 的发展过程 Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分，于 2004 年发布，现在已经成为 Spring 生态系统的核心组件。 Spring Security 的发展过程可以分为三个阶段：
第一阶段：Spring Security 起源于一个名为 Acegi Security 的开源项目，初期重点实现了 Spring 应用的身份认证和授权服务功能。2003 年，Acegi Security 作为一个孵化项目被捐献给 Spring 社区。2004 年，正式作为 Spring 框架的核心组件之一 Absorbed 进 Spring。并更名为 Spring Security。Spring Security 1.0 版本 Spring Security 1.0 版本发布于 2004 年。它提供了最基本的安全功能，包括身份验证和授权。身份验证是验证用户是否是他们所声称的人的过程。授权是确定用户是否有权访问特定资源的过程。 Spring Security 1.0 版本使用了以下技术来实现身份验证和授权：
表单身份验证：表单身份验证是通过用户提交表单来验证用户身份的过程。 基于角色的访问控制 (RBAC)：RBAC 是一种授权模型，它将用户分配到角色，然后这些角色被授予对特定资源的访问权限。 第二阶段：Spring Security 2.0 版本 Spring Security 2.0 版本发布于 2006 年。它提供了更多的安全功能，包括加密和会话管理。加密是将数据转换成无法被他人理解的形式的过程。会话管理是跟踪用户会话的状态的过程。 Spring Security 2.0 版本使用了以下技术来实现加密和会话管理：
安全套接字层 (SSL)：SSL 是一种加密协议，它可以保护数据在传输过程中不被窃听。 会话管理：Spring Security 提供了自己的会话管理实现，它可以跟踪用户会话的状态。 第三阶段：Spring Security 3.0 版本 Spring Security 3.0 版本发布于 2008 年。它是一个重大的版本更新，它提供了许多新的安全功能，包括 OAuth、SAML 和 OpenID。 OAuth 是一种授权框架，它允许第三方应用程序访问用户的资源。SAML 是一种单点登录 (SSO) 协议，它允许用户在一个地方登录，然后访问多个网站。OpenID 是一种开放的身份验证协议，它允许用户使用他们选择的身份提供商来验证他们的身份。 Spring Security 3.0 版本使用了以下技术来实现 OAuth、SAML 和 OpenID：</description>
    </item>
    <item>
      <title>[译]Spring Boot授权服务器 - 使用 Java 的资源服务器和客户端凭证示例</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-authorization-server/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-authorization-server/</guid>
      <description>概述 在本文中，我们将创建一个授权服务器，为任何客户端生成 access_token。这称为 OAuth2 的 client_credentials 流程。它主要用于服务间通信。
我们将使用 spring boot oauth2 授权服务器依赖项来创建身份验证服务器。我们还将创建一个资源服务器和客户端来对其进行端到端测试。
Spring 授权服务器 我们首先创建授权服务器。
依赖项： 让我们将以下依赖项添加到我们的项目中。
implementation &amp;#39;org.springframework.security:spring-security-oauth2-authorization-server:1.0.0&amp;#39; implementation &amp;#39;org.springframework.boot:spring-boot-starter-security&amp;#39; implementation &amp;#39;org.springframework.boot:spring-boot-starter-web&amp;#39; testImplementation &amp;#39;org.springframework.boot:spring-boot-starter-test&amp;#39; testImplementation &amp;#39;org.springframework.security:spring-security-test&amp;#39; 我们正在使用 spring oauth2 依赖项的最新（当时）稳定版本。
Java 实现： 让我们创建一个名为 AuthorizationServerConfig 的配置类，并向该类添加 @Configuration 注解。现在让我们创建以下 bean 来完成配置：
SecurityFilterChain @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SecurityFilterChain authServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); return http.build(); } 我们将把 bean 的顺序设置为最高，因为我们想首先执行它。
RegisteredClientRepository @Bean public RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(&amp;#34;oauth-client&amp;#34;) .clientSecret(&amp;#34;{noop}oauth-secret&amp;#34;) .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .scope(OidcScopes.OPENID) .scope(&amp;#34;articles.read&amp;#34;) .build(); return new InMemoryRegisteredClientRepository(registeredClient); } 现在让我们使用内存存储库对内容进行硬编码。我们可以根据我们的需要更新这些。
JwtDecoder @Bean public JwtDecoder jwtDecoder(JWKSource&amp;lt;SecurityContext&amp;gt; jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } 我们将使用它来解码令牌以进行验证。
JWKSource @Bean public JWKSource&amp;lt;SecurityContext&amp;gt; jwkSource() throws NoSuchAlgorithmException { RSAKey rsaKey = generateRsa(); JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -&amp;gt; jwkSelector.</description>
    </item>
    <item>
      <title>[译]使用 Spring Boot 和 Spring Security 配置 CORS</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-cors/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-cors/</guid>
      <description>跨源资源共享 (CORS) 是一种基于 HTTP 标头的机制，允许服务器显式将某些源列入白名单，并帮助绕过同源策略。
这是必需的，因为浏览器默认应用同源策略以确保安全。通过在 Web 应用程序中实施 CORS，网页可以请求额外的资源并从其他域加载到浏览器中。
本文将重点介绍在基于 Spring 的应用程序中实现 CORS 的各种方式。要详细了解 CORS 的工作原理，请参阅这篇优秀的介绍性文章。
示例代码 本文附有 GitHub 上的工作代码示例。
CORS 特定 HTTP 响应标头概述 CORS 规范定义了服务器返回的一组响应标头，这将是后续部分的重点。
响应头 描述 Access-Control-Allow-Origin 以逗号分隔的白名单来源列表或“*”。 Access-Control-Allow-Methods Web 服务器允许跨源请求的 HTTP 方法的逗号分隔列表。 Access-Control-Allow-Headers Web 服务器允许跨源请求的 HTTP 标头的逗号分隔列表。 Access-Control-Expose-Headers 客户端脚本认为可以安全显示的以逗号分隔的 HTTP 标头列表。 Access-Control-Allow-Credentials 如果浏览器通过传递凭据（以 cookie 或授权标头的形式）向服务器发出请求，则其值设置为 true 。 Access-Control-Max-Age 指示预检请求的结果可以缓存多长时间。 设置示例客户端应用程序 我们将使用一个简单的角度应用程序来调用 REST 端点，我们可以使用浏览器开发人员工具检查这些端点。您可以在 GitHub 上查看源代码。
ng serve --open 我们应该能够成功启动客户端应用程序。
设置示例服务器应用程序 我们将使用一个基于 Spring 的示例应用程序，其中包含客户端应用程序可以调用的 GET 和 POST 请求。请注意，您会发现两个独立的应用程序：一个使用 Spring MVC (REST)，另一个使用 Spring Reactive 堆栈。
为简单起见，两个应用程序之间的 CORS 配置相同，并且定义了相同的端点。两台服务器都从不同的端口 8091 和 8092 启动。
与应用程序捆绑在一起的 Maven Wrapper 将用于启动服务。您可以查看 Spring REST 源代码和 Spring Reactive 源代码。
mvnw clean verify spring-boot:run (for Windows) ./mvnw clean verify spring-boot:run (for Linux) 一旦 Spring 应用程序成功启动，客户端应用程序应该能够成功从服务器加载数据。</description>
    </item>
    <item>
      <title>[译]在 Spring 中实现 OAuth2：使用范围（第 2 部分）</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring-scopes/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring-scopes/</guid>
      <description>我们在上一篇文章中了解了基本的 OAuth2 概念以及如何在 Spring 中实现和执行不同的授权。在这篇文章中，我们将介绍 OAuth2 的另一个重要概念：范围。
OAuth 范围 保护对应用程序的访问通常分两个步骤进行：身份验证和授权。要理解这两个概念，假设您在绝密政府大楼工作。在开始之前，你会得到一张卡片，可以让你进入建筑物。 OAuth 令牌可以看作是允许您访问的卡片。
一旦你进去，你决定去三楼见你的一位同事，在尝试使用你的卡打开三楼的门后，你听到一声嘟嘟声，告诉你你没有被授权。在 OAuth 中，范围是一种定义令牌可以访问哪些资源以及不能访问哪些资源的方法。范围允许访问控制，并且可以被视为相当于传统身份验证中的用户角色。
实现 为了演示范围，我们将使用第 1 部分中的示例。
在资源服务器的控制器中，我们有以下端点：
@RestController(&amp;#34;/&amp;#34;) public class ResourceController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(){ return &amp;#34;hello&amp;#34;; } @GetMapping(&amp;#34;/foo&amp;#34;) public String foo(){ return &amp;#34;foo&amp;#34;; } @PostMapping(&amp;#34;/bar&amp;#34;) public String bar(){ return &amp;#34;bar&amp;#34;; } @DeleteMapping(&amp;#34;/test&amp;#34;) public String test(){ return &amp;#34;test&amp;#34;; } } 第一步是使用所需的范围配置授权服务器：
clients.inMemory().withClient(&amp;#34;my-trusted-client&amp;#34;) .authorizedGrantTypes(&amp;#34;password&amp;#34;, &amp;#34;refresh_token&amp;#34;, &amp;#34;implicit&amp;#34;, &amp;#34;client_credentials&amp;#34;, &amp;#34;authorization_code&amp;#34;) .authorities(&amp;#34;CLIENT&amp;#34;) .scopes(&amp;#34;read&amp;#34;, &amp;#34;write&amp;#34;, &amp;#34;trust&amp;#34;) .accessTokenValiditySeconds(60) .redirectUris(&amp;#34;http://localhost:8081/test.html&amp;#34;) .resourceIds(&amp;#34;resource&amp;#34;) .secret(&amp;#34;mysecret&amp;#34;); 要在资源服务器中启用范围检查，我们有两个选项：使用安全配置或使用方法安全性。
使用安全配置： @Override public void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(HttpMethod.GET,&amp;#34;/hello&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) .antMatchers(HttpMethod.GET,&amp;#34;/foo&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) .antMatchers(HttpMethod.POST,&amp;#34;/bar&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;write&amp;#39;)&amp;#34;) .antMatchers(HttpMethod.DELETE,&amp;#34;/test&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;trust&amp;#39;)&amp;#34;) .anyRequest().authenticated(). and().csrf().disable(); } 使用方法安全性： @PreAuthorize(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(){ return &amp;#34;hello&amp;#34;; } @PreAuthorize(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) @GetMapping(&amp;#34;/foo&amp;#34;) public String foo(){ return &amp;#34;foo&amp;#34;; } @PreAuthorize(&amp;#34;#oauth2.</description>
    </item>
    <item>
      <title>[译]在 Spring 中实现 OAuth2：第 1 部分</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring/</guid>
      <description>OAuth2 是一组规范，主要提供对 Rest API 的安全访问的方法。 OAuth 的主要目的是允许通过使用令牌来执行身份验证和授权，而不必为每个操作提供凭据。由于本文的重点是实现，并且为了不重新发明轮子，可以查看 OAuth RFC 或维基百科以获取更多理论背景。在这篇文章中，我们将深入探讨 Spring 中的 OAuth2 实现以及如何使用不同的授权类型，但在此之前值得提供一些重要概念的简要定义。
访问令牌和刷新令牌 身份验证成功后将提供访问令牌以及刷新令牌。访问令牌有一个有限的有效期（标准为 1 小时），之后需要刷新令牌才能获取新的访问令牌和新的刷新令牌。 Referesh 令牌通常会在使用后过期。
资源服务器和授权服务器 OAuth 引入了授权服务器的概念，授权服务器是发出访问和刷新令牌的实体，并在每个操作中进行咨询以查看令牌是否有效。资源服务器只是由不同客户端应用程序（前端应用程序、移动设备、其他后端服务&amp;hellip;&amp;hellip;）访问的实际 Rest API。资源服务器和授权服务器可以是不同的实体，也可以是同一实体。
授权类型 OAuth 中最常用的授权有：客户端凭据、密码、授权码和隐式授权。每项资助都有特定的流程和用例，但由于本文的重点不是理论，因此我们将重点关注其实施。有关授权及其用途的更多详细信息，请参阅 OAuth RFC。
实现 在实现方面，我们将使用 Spring Boot 来利用其自动配置和引导功能，并更多地关注我们的核心主题。
资源服务器： 我们有一个资源服务器，其中包含我们希望保护的以下端点：
@RestController(&amp;#34;/&amp;#34;) public class ResourceController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(){ return &amp;#34;hello&amp;#34;; } @GetMapping(&amp;#34;/foo&amp;#34;) public String foo(){ return &amp;#34;foo&amp;#34;; } @GetMapping(&amp;#34;/bar&amp;#34;) public String bar(){ return &amp;#34;bar&amp;#34;; } @GetMapping(&amp;#34;/test&amp;#34;) public String test(){ return &amp;#34;test&amp;#34;; } } 为此，我们需要配置一个用 @EnableResourceServer 注释的 ResourceServerConfigurerAdapter bean：
@Configuration @EnableResourceServer public class ResourceSecurityConfiguration extends ResourceServerConfigurerAdapter { @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(&amp;#34;resource&amp;#34;); } @Override public void configure(HttpSecurity http) throws Exception { http .</description>
    </item>
    <item>
      <title>[译]使用Spring Boot2和Spring Security 5以及JDBC令牌存储进行Oauth2集中授权</title>
      <link>https://blog.chensoul.cc/posts/2023/07/14/oauth-2-centralized-authorization-with-spring-boot-2-and-spring-security-5-and-jdbc-token-store/</link>
      <pubDate>Fri, 14 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/14/oauth-2-centralized-authorization-with-spring-boot-2-and-spring-security-5-and-jdbc-token-store/</guid>
      <description>在这篇文章中，我们将了解如何使用 Spring Boot 2 和 Spring Security 5 OAuth2 来实现集中授权的授权服务器以及如何通过 GUI 对其进行管理，还将提供资源服务器演示以及 github 下的整个项目。
很多示例涵盖了基于早期版本的 Spring boot 2 和 Spring Security 5 使用内存令牌实现 Oauth2，因此想法是使用 MySql 数据库作为令牌存储。
为了深入探讨这个主题，我们必须：
配置 Spring 安全。 配置数据库。 创建授权服务器。 创建资源服务器。 使用 curl 客户端使用访问令牌获取安全资源。 什么是 Oauth 2？ OAuth 2.0 是行业标准授权协议。 OAuth 2.0 取代了 2006 年创建的原始 OAuth 协议上所做的工作。OAuth 2.0 注重客户端开发人员的简单性，同时为 Web 应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。
该规范及其扩展正在 IETF OAuth 工作组内开发。
Oauth 2 角色 OAuth2 定义了 4 个角色：
资源所有者：通常是您自己。
资源服务器：托管受保护数据的服务器（例如 Google 托管您的个人资料和个人信息）。
客户端：请求访问资源服务器的应用程序（网站、Javascript 应用程序或移动应用程序&amp;hellip;&amp;hellip;）。
授权服务器：向客户端颁发访问令牌的服务器。该令牌将用于客户端请求资源服务器。该服务器可以与资源服务器相同（相同的物理服务器和相同的应用程序），而且经常是这种情况。
下图说明了角色流程：
授权类型 OAuth 2 为不同的用例提供了多种“授权类型”。定义的授权类型型有：
授权码：授权码授予是使用您的 Facebook 或 Google 帐户登录应用程序的功能。 密码：旨在用于基于用户代理的客户端。其次，授权服务器不会像授权代码授予那样返回授权代码来交换访问令牌，而是返回访问令牌。 客户端凭据：客户端可以仅使用其客户端凭据（或其他支持的身份验证方式）请求访问令牌，当客户端请求访问其下的受保护资源控制权，或先前已被其他资源所有者控制的与授权服务器安排。 隐式授权：隐式授权是一种简化的授权代码流，针对使用 JavaScript 等脚本语言在浏览器中实现的客户端进行了优化。在隐式流程中，而不是向客户端发出授权代码，直接向客户端颁发访问令牌。 示范 让我们动手吧
业务层 为简单起见，我们的主要业务应用程序将是使用一个实体的产品 API，我们的访问规则将是：
PRODUCT_CREATE PRODUCT_UPDATE PRODUCT_DISPLAY PRODUCT_ADMIN OAuth2 客户端设置 要设置 Oauth 2 客户端，我们需要创建下表 [有关更多详细信息，请参阅链接]</description>
    </item>
  </channel>
</rss>
