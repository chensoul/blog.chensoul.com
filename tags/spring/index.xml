<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Spring on ChenSoul</title>
    <link>https://blog.chensoul.cc/tags/spring/</link>
    <description>Recent content in Spring on ChenSoul</description>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 09 May 2024 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://blog.chensoul.cc/tags/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>All things about Spring Modulith</title>
      <link>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</link>
      <pubDate>Thu, 09 May 2024 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</guid>
      <description>VMware 推出了一个实验性的项目Spring Modulith，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。
2022 年 11 月推出的Spring Boot 3会是 Spring Modulith 的基础。所以它的基线是 Spring Framework 6、Java 17 和 Jakarta EE 9。Spring Modulith 是Moduliths（其名字有个“s”后缀）项目的继承者。该项目使用 Spring Boot 2.7，目前已经退役，只接收缺陷修正，直至 2023 年 11 月份。
https://spring.io/blog/2022/10/21/introducing-spring-modulith
https://www.baeldung.com/spring-modulith
https://www.baeldung.com/spring-modulith-event-externalization
https://piotrminkowski.com/2023/10/13/guide-to-modulith-with-spring-boot/
https://springdoc.cn/guide-to-modulith-with-spring-boot/
https://medium.com/andamp/event-sourcing-with-spring-modulith-2b35b0569dbb
https://www.geeksforgeeks.org/what-is-spring-modulith/
https://github.com/xsreality/spring-modulith-with-ddd
https://riteshshergill.medium.com/the-spring-modulith-monolithic-but-manageable-ca1532a1e585
https://www.infoq.com/news/2022/11/spring-modulith-launch/
https://dzone.com/articles/architecture-style-modulith-vs-microservices
https://speakerdeck.com/olivergierke/spring-modulith-a-deep-dive
https://www.jappware.com/proffesional-activity/make-monolithic-apps-great-again-with-spring-modulith-coffeejug/
https://blog.worldline.tech/2024/01/23/modulith.html
https://springdoc.cn/spring-modulith-intro/
https://dimitri.codes/checking-out-spring-modulith/
https://www.lefer.cn/posts/29752/
https://www.jdon.com/63003.html
https://blog.csdn.net/cfy_banq/article/details/132185951
https://www.zhihu.com/question/567053421</description>
    </item>
    <item>
      <title>[译]Spring Boot3和Spring6中的新特性</title>
      <link>https://blog.chensoul.cc/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/</link>
      <pubDate>Fri, 13 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/</guid>
      <description>Spring Boot 3.0 于 2022 年 11 月正式发布，包含一些新功能和改进。这是继大约 4.5 年前发布 Spring Boot 2.0 后 Spring Boot 的第一个主要版本。它也是第一个支持 Spring Framework 6.0 的 Spring Boot GA 版本。作为开发人员，我们需要了解这些更新，才能顺利使用 Spring Boot。毫无疑问，新版本中最大的转变之一是放弃了对旧版本 Java 的支持。
在本文中，我们将讨论“Spring Boot 3 和 Spring 6 中的新功能”。
Spring 3.0 版本有哪些主要亮点？ Spring 3.0 版本的亮点包括：
Java 17 基线 支持 Jakarta EE 10 和 EE 9 基线 支持使用 GraalVM 生成本机映像，取代实验性 Spring Native 项目 通过测微计和测微计追踪提高了可观测性 谁可以真正使用 Spring Boot 3？ 如前所述，Spring Boot 3.0 最大的转变是忽略了对旧版本 Java 的支持。是的，我们至少需要 Java 17 才能使用 Spring Boot 3.0。因此，在使用 Spring Boot 3.0 之前必须具备 JDK 17 环境。
Spring Boot 3 和 Spring 6 有哪些新功能？ 这里需要注意的重要一点是 Spring Boot 3.0 构建于 Spring Framework 6 之上并需要 Spring Framework 6。因此，如果您的 pom.</description>
    </item>
    <item>
      <title>[译]SPRING BOOT JWT - 如何使用 SPRING SECURITY 和 JSON WEB 令牌保护您的 REST API</title>
      <link>https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/</guid>
      <description>如果您快速搜索如何使用 JSON Web Tokens 在 Spring Boot 中保护 REST API，您会发现很多相同的结果。这些结果包含一种方法，该方法涉及编写自定义过滤器链并引入第三方库来编码和解码 JWT。
在看完这些令人费解且令人困惑的教程后，我说必须有一种更简单的方法来做到这一点。我做了任何直接接触 Spring Security 团队的人都会做的事情，我向他们寻求帮助。他们告诉我，Spring Security 确实使用 oAuth2 资源服务器内置了对 JWT 的支持。
在本教程中，您将学习如何使用 JSON Web Tokens (JWT) 和 Spring Security 来保护您的 API。我并不是说这种方法无论如何都很容易，但对我来说，它比其他选择更有意义。
Github 存储库
应用架构 在我们开始编写一些代码之前，我想确保我们对于我们正在构建的内容都达成共识。在下面的示例中，您有一个客户端应用程序，它可以是一个简单的命令行应用程序、一个用 Angular 或 Vue 等编写的完整前端应用程序，或者系统中的其他一些服务。
该客户端应用程序将调用使用 Spring Boot 编写的服务器应用程序，该应用程序通过 REST API 公开数据。在下面的示例中，它是一个整体，但如果您有分布式架构，则同样适用。当前有 3 个 REST 控制器公开资源产品、订单和客户。
您要做的是保护所有资源，以便当客户端调用 REST API 时，客户端将收到 401（未经授权），这意味着客户端请求尚未完成，因为它缺少所请求资源的有效身份验证凭据。
JSON 网络令牌 (JWT) JSON Web 令牌是一种开放方法，用于在两方之间安全地表示声明。 JWT 是一组声明（JSON 属性-值对），它们共同构成一个 JSON 对象。它由三部分组成：
Header: 由两个属性组成：{ &amp;ldquo;alg&amp;rdquo;: &amp;ldquo;HS256&amp;rdquo;, &amp;ldquo;typ&amp;rdquo;: &amp;ldquo;JWT&amp;rdquo; }。 alg 是用于加密 JWT 的算法。 Payload: 这是存储要发送的数据的地方；该数据存储为 JSON 属性-值对。 Signature: 这是通过加密创建的，使用标头中指定的算法：（i）base64Url 编码的标头，（ii）base64Url 编码的有效负载，以及（iii）秘密（或私钥）： HMACSHA256(base64UrlEncode(header) + &amp;#34;.&amp;#34; + base64UrlEncode(payload), secret|privateKey) 最终的 JWT 由三部分组成。每个都是 base64Url 编码的，并且与下一个之间用点分隔。有关更多详细信息，请参阅 openid.net 和 jwt.io 网站。</description>
    </item>
    <item>
      <title>[译]Spring Security 与 JWT for REST API</title>
      <link>https://blog.chensoul.cc/posts/2023/09/19/spring-security-tutorial/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/09/19/spring-security-tutorial/</guid>
      <description>免责声明：Spring Security 5+ 已发布 OAuth JWT 支持。建议使用最新版本的 OAuth 来支持 JWT，而不是使用自定义安全性或过滤器。
Spring 被认为是 Java 生态系统中值得信赖的框架，并且被广泛使用。将 Spring 称为框架不再有效，因为它更多的是涵盖各种框架的总括术语。其中一个框架是 Spring Security，它是一个功能强大且可定制的身份验证和授权框架。它被认为是保护基于 Spring 的应用程序的事实标准，因此，如果您希望实现 Spring JWT 令牌解决方案，那么将其基于 Spring Security 是有意义的。
尽管它很受欢迎，但我必须承认，当涉及到单页应用程序时，Spring 的配置并不简单和直接。我怀疑原因是它更多地是作为一个面向应用程序的 MVC 框架开始的，其中网页渲染发生在服务器端，并且通信是基于会话的。
如果后端基于 Java 和 Spring，那么使用 Spring Security 和 JWT 进行身份验证/授权并将其配置为无状态通信是有意义的。虽然有很多文章解释了这是如何完成的，但对我来说，第一次设置它仍然令人沮丧，我必须阅读并总结来自多个来源的信息。这就是我决定编写这个 Spring Security 教程的原因，我将在其中尝试总结并涵盖您在配置过程中可能遇到的所有必需的微妙细节和缺陷。
术语定义 在深入探讨技术细节之前，我想明确定义 Spring Security 上下文中使用的术语，以确保我们都使用相同的语言。 这些是我们需要解决的术语：
Authentication 验证是指根据提供的凭据验证用户身份的过程。一个常见的示例是在登录网站时输入用户名和密码。您可以将其视为对“您是谁？”这个问题的答案。 Authorization 授权是指假设用户已成功通过身份验证，则确定用户是否具有执行特定操作或读取特定数据的适当权限的过程。您可以将其视为“用户可以执行/阅读此操作吗？”问题的答案。 Principle 原则是指当前经过身份验证的用户。 Granted authority 授予权限是指经过认证的用户的权限。 Role 角色是指经过身份验证的用户的一组权限。 创建基本的 Spring 应用程序 在开始配置 Spring Security 框架之前，让我们创建一个基本的 Spring Web 应用程序。为此，我们可以使用 Spring Initializr 并生成一个模板项目。对于一个简单的 Web 应用程序，只需要 Spring Web 框架依赖就足够了：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 创建项目后，我们可以向其中添加一个简单的 REST 控制器，如下所示：
@RestController @RequestMapping(&amp;#34;hello&amp;#34;) public class HelloRestController { @GetMapping(&amp;#34;user&amp;#34;) public String helloUser() { return &amp;#34;Hello User&amp;#34;; } @GetMapping(&amp;#34;admin&amp;#34;) public String helloAdmin() { return &amp;#34;Hello Admin&amp;#34;; } } 之后，如果我们构建并运行该项目，我们可以在 Web 浏览器中访问以下 URL：</description>
    </item>
    <item>
      <title>[译]REST API 的自定义错误消息处理</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/global-error-handler-in-a-spring-rest-api/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/global-error-handler-in-a-spring-rest-api/</guid>
      <description>1. 概述 在本教程中，我们将讨论如何为 Spring REST API 实现全局错误处理程序。
我们将使用每个异常的语义为客户端构建有意义的错误消息，其明确的目标是为客户端提供所有信息以轻松诊断问题。
2. 自定义错误消息 让我们首先实现一个用于通过线路发送错误的简单结构 — ApiError：
public class ApiError { private HttpStatus status; private String message; private List&amp;lt;String&amp;gt; errors; public ApiError(HttpStatus status, String message, List&amp;lt;String&amp;gt; errors) { super(); this.status = status; this.message = message; this.errors = errors; } public ApiError(HttpStatus status, String message, String error) { super(); this.status = status; this.message = message; errors = Arrays.asList(error); } } 这里的信息应该很简单：
status – HTTP 状态代码 message – 与异常相关的错误消息 error – 构建的错误消息列表 当然，对于 Spring 中的实际异常处理逻辑，我们将使用 @ControllerAdvice 注解：
@ControllerAdvice public class CustomRestExceptionHandler extends ResponseEntityExceptionHandler { ... } 3. 处理错误请求异常 3.1.处理异常 现在让我们看看如何处理最常见的客户端错误 - 基本上是客户端向 API 发送无效请求的情况：
BindException – 发生致命绑定错误时抛出此异常。 MethodArgumentNotValidException – 当使用 @Valid 注解的参数验证失败时抛出此异常： @Override protected ResponseEntity&amp;lt;Object&amp;gt; handleMethodArgumentNotValid( MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { List&amp;lt;String&amp;gt; errors = new ArrayList&amp;lt;String&amp;gt;(); for (FieldError error : ex.</description>
    </item>
    <item>
      <title>[译]Spring Events</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/spring-events/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/spring-events/</guid>
      <description>1. 概述 在本教程中，我们将讨论如何在 Spring 中使用事件。
事件是框架中最容易被忽视的功能之一，但也是最有用的功能之一。与 Spring 中的许多其他功能一样，事件发布是 ApplicationContext 提供的功能之一。
有一些简单的准则需要遵循：
如果我们使用 Spring Framework 4.2 之前的版本，事件类应该扩展 ApplicationEvent。从 4.2 版本开始，事件类不再需要扩展 ApplicationEvent 类。 发布者应该注入一个 ApplicationEventPublisher 对象。 监听器应该实现 ApplicationListener 接口。 2. 自定义事件 Spring 允许我们创建和发布默认情况下同步的自定义事件。这有一些优点，例如侦听器能够参与发布者的事务上下文。
2.1.一个简单的应用程序事件 让我们创建一个简单的事件类——只是一个存储事件数据的占位符。
在本例中，事件类保存一条字符串消息：
public class CustomSpringEvent extends ApplicationEvent { private String message; public CustomSpringEvent(Object source, String message) { super(source); this.message = message; } public String getMessage() { return message; } } 2.2.发布者 现在让我们创建该事件的发布者。发布者构造事件对象并将其发布给正在侦听的任何人。
要发布事件，发布者只需注入 ApplicationEventPublisher 并使用 publishEvent() API：
@Component public class CustomSpringEventPublisher { @Autowired private ApplicationEventPublisher applicationEventPublisher; public void publishCustomEvent(final String message) { System.out.println(&amp;#34;Publishing custom event. &amp;#34;); CustomSpringEvent customSpringEvent = new CustomSpringEvent(this, message); applicationEventPublisher.publishEvent(customSpringEvent); } } 或者，发布者类可以实现 ApplicationEventPublisherAware 接口，这也将在应用程序启动时注入事件发布者。通常，使用 @Autowire 注入发布者会更简单。</description>
    </item>
    <item>
      <title>[译]使用@Async进行Spring Security上下文传播</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/spring-security-async-principal-propagation/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/spring-security-async-principal-propagation/</guid>
      <description>1. 简介 在本教程中，我们将重点关注使用 @Async 传播 Spring Security 主体 默认情况下，Spring Security 身份验证绑定到 ThreadLocal - 因此，当执行流在带有 @Async 的新线程中运行时，它不会是经过身份验证的上下文。
这并不理想——让我们解决它。
2.Maven 依赖 为了在 Spring Security 中使用异步集成，我们需要在 pom.xml 的依赖项中包含以下部分：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-config&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.7.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 可以在此处找到最新版本的 Spring Security 依赖项。
3.使用@Async 进行 Spring Security 传播 我们先写一个简单的例子：
@RequestMapping(method = RequestMethod.GET, value = &amp;#34;/async&amp;#34;) @ResponseBody public Object standardProcessing() throws Exception { log.info(&amp;#34;Outside the @Async logic - before the async call: &amp;#34; + SecurityContextHolder.getContext().getAuthentication().getPrincipal()); asyncService.asyncCall(); log.info(&amp;#34;Inside the @Async logic - after the async call: &amp;#34; + SecurityContextHolder.getContext().getAuthentication().getPrincipal()); return SecurityContextHolder.getContext().getAuthentication().getPrincipal(); } 我们想要检查 Spring SecurityContext 是否传播到新线程。首先，我们在异步调用之前记录上下文，接下来我们运行异步方法，最后再次记录上下文。 asyncCall() 方法具有以下实现：
@Async @Override public void asyncCall() { log.info(&amp;#34;Inside the @Async logic: &amp;#34; + SecurityContextHolder.getContext().getAuthentication().getPrincipal()); } 正如我们所看到的，只有一行代码将输出异步方法的新线程内的上下文。</description>
    </item>
    <item>
      <title>[译]使用Spring进行REST的错误处理</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/exception-handling-for-rest-with-spring/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/exception-handling-for-rest-with-spring/</guid>
      <description>1. 概述 本教程将说明如何使用 Spring 为 REST API 实现异常处理。我们还将获得一些历史概述，并了解不同版本引入了哪些新选项。
在 Spring 3.2 之前，Spring MVC 应用程序中处理异常的两种主要方法是 HandlerExceptionResolver 或 @ExceptionHandler 注解。两者都有一些明显的缺点。
从 3.2 开始，我们使用了 @ControllerAdvice 注释来解决前两个解决方案的局限性，并促进整个应用程序的统一异常处理。
现在 Spring 5 引入了 ResponseStatusException 类，一种在 REST API 中进行基本错误处理的快速方法。
所有这些都有一个共同点：它们很好地处理了关注点分离。应用程序可以正常抛出异常来指示某种失败，然后将单独处理。
最后，我们将了解 Spring Boot 带来的功能以及如何配置它以满足我们的需求。
2.方案一：控制器级@ExceptionHandler 第一个解决方案在 @Controller 级别工作。我们将定义一个处理异常的方法并使用@ExceptionHandler 进行注释：
public class FooController{ //... @ExceptionHandler({ CustomException1.class, CustomException2.class }) public void handleException() { // } } 这种方法有一个主要缺点：· 注解的方法仅对特定的控制器有效，而不是对整个应用程序全局有效。当然，将其添加到每个控制器使其不太适合通用异常处理机制。
我们可以通过让所有控制器扩展基本控制器类来解决此限制。
然而，对于无论出于何种原因这是不可能的应用程序来说，此解决方案可能是一个问题。例如，控制器可能已经从另一个基类扩展，该基类可能位于另一个 jar 中或不可直接修改，或者本身可能不可直接修改。
接下来，我们将研究另一种解决异常处理问题的方法 - 一种全局的方法，不包括对现有工件（例如控制器）的任何更改。
3.解决方案 2：HandlerExceptionResolver 第二种解决方案是定义一个 HandlerExceptionResolver。这将解决应用程序抛出的任何异常。它还允许我们在 REST API 中实现统一的异常处理机制。
在选择自定义解析器之前，让我们先回顾一下现有的实现。
3.1.异常处理器异常解析器 该解析器是在 Spring 3.1 中引入的，并且在 DispatcherServlet 中默认启用。这实际上是前面介绍的 @ExceptionHandler 机制如何工作的核心组件。
3.2.默认处理程序异常解析器 这个解析器是在 Spring 3.0 中引入的，并且在 DispatcherServlet 中默认启用。
它用于将标准 Spring 异常解析为其相应的 HTTP 状态代码，即客户端错误 4xx 和服务器错误 5xx 状态代码。以下是它处理的 Spring 异常的完整列表以及它们如何映射到状态代码。</description>
    </item>
    <item>
      <title>[译]如何在Spring中执行@Async</title>
      <link>https://blog.chensoul.cc/posts/2023/08/25/spring-async/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/25/spring-async/</guid>
      <description>1. 概述 在本教程中，我们将探讨 Spring 中的异步执行支持和 @Async 注解。
简单地说，用 @Async 注解 bean 的方法将使其在单独的线程中执行。换句话说，调用者不会等待被调用方法的完成。
Spring 的一个有趣的方面是，框架中的事件支持还 支持异步处理（如果需要）。
2.启用异步支持 让我们首先通过 Java 注解启用异步处理。
我们将通过将 @EnableAsync 添加到配置类来完成此操作：
@Configuration @EnableAsync public class SpringAsyncConfig { ... } 启用注解就足够了。但也有一些简单的配置选项：
annotation 默认情况下，@EnableAsync 检测 Spring 的 @Async 注解和 EJB 3.1 javax.ejb.Asynchronous。我们也可以使用此选项来检测其他用户定义的注解类型。 mode 指示应使用的建议类型 - 基于 JDK 代理或 AspectJ 编织。 proxyTargetClass 指示应使用的代理类型 — CGLIB 或 JDK。仅当模式设置为 AdviceMode.PROXY 时，此属性才有效。 order 设置应用 AsyncAnnotationBeanPostProcessor 的顺序。默认情况下，它最后运行，以便它可以考虑所有现有代理。 我们还可以使用任务命名空间通过 XML 配置启用异步处理：
&amp;lt;task:executor id=&amp;#34;myexecutor&amp;#34; pool-size=&amp;#34;5&amp;#34; /&amp;gt; &amp;lt;task:annotation-driven executor=&amp;#34;myexecutor&amp;#34;/&amp;gt; 3.@Async 注解 首先，让我们回顾一下规则。 @Async 有两个限制：
它必须仅应用于公共方法。 自调用（从同一个类中调用异步方法）将不起作用。 原因很简单：该方法需要公开，以便可以被代理。并且自调用不起作用，因为它绕过代理并直接调用底层方法。
3.1.返回类型为 void 的方法 这是配置具有 void 返回类型的方法以异步运行的简单方法：
@Async public void asyncMethodWithVoidReturnType() { System.out.println(&amp;#34;Execute method asynchronously. &amp;#34; + Thread.currentThread().getName()); } 3.2.具有返回类型的方法 我们还可以通过将实际返回包装在 Future 中来将 @Async 应用于具有返回类型的方法：</description>
    </item>
    <item>
      <title>[译]Spring Boot项目如何实现JWT认证？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/</guid>
      <description>没有人可以否认这样一个事实：安全性是生产就绪应用程序的一项重要功能。尽管我们可以使用内存身份验证、JDBC 身份验证或通过 UserDetailsS​​ervice 来保护一个 Web 应用程序的安全。但是，当一个应用程序在内部使用其他应用程序的服务时，使用 Web 服务概念实现安全性就变得很重要。在这种情况下，我们使用具有特定有效期的令牌来保护我们的应用程序。此外，我们将学习“如何在 Spring Boot 项目中实现 JWT 身份验证？”以整体了解 JWT（JSON Web Token）身份验证背后的概念。
由于 JWT 代表“JSON Web Token”，很明显，该令牌仅以 JSON 形式保存数据。
此外，与上述身份验证技术不同，JWT 属于无状态身份验证。简而言之，它没有数据。通常，这种类型的身份验证用于 Web 服务、服务器的水平扩展，甚至在某种程度上用于 OAuth 技术。为了说明该网络服务，让我们可视化从亚马逊预订订单的过程。在这里，用户与 Amazon 应用程序交互，而 Amazon 应用程序在内部通过 Web 服务调用与支付网关应用程序交互。
现在让我们开始讨论我们的主题“如何在 Spring Boot 项目中实现 JWT 身份验证？”以及相关点。
您对整篇文章有何期望？ 读完本文后，您将能够回答：
什么是安全上下文中的无状态和有状态身份验证？ 无状态认证和有状态认证有什么区别？ 那么什么是 Token，什么是 JWT(JSON Web Token)？
使用 JWT 认证有什么好处？
JWT 内部如何运作？
我们在什么情况下使用 JWT 身份验证？
此外，JWT 身份验证和状态身份验证之间有什么区别？
此外，如何生成 JWT 编码令牌以及如何将其解码回来？
如何在 Spring Boot 项目中逐步实现 JWT 认证？
在 Spring Boot 3.0 中，如何在不使用 WebSecurityConfigurerAdapter 的情况下编写安全配置类？
最后，如何测试启用 JWT 安全的应用程序？
什么是无状态和有状态身份验证？ 通常有两种类型的认证技术。两者都发生在客户端服务器概念中，服务器仅在身份验证后才向客户端提供服务。这里的客户端可以是浏览器，也可以是另一个服务器。
状态认证 在这种类型的身份验证中，客户端和服务器之间涉及会话管理。当客户端向服务器请求服务时，它首先登录到服务器。然后服务器创建一个会话并以键值对的形式存储该信息。这个会话是服务器端的一种内存。我们也称其为 HttpSession，因为 Http 协议管理它。
此外，为了响应客户端请求，服务器以 Cookie 的形式向客户端提供带有响应的会话 id。该 cookie 存储在客户端浏览器中。当同一个客户端第二次发出请求时，请求头中也会带有 cookie。因此，服务器会检查请求标头，如果在 cookie 中发现相同的 SID（会话 ID），则假定该请求来自同一客户端。通过这种方式，会话管理就发生了。
当客户端从服务器注销时，会话会相应地被销毁。结果，服务器相应地从内存中删除会话信息（键值）。同样重要的是，对于每个新客户端，服务器都会创建一个新会话（内存）。
无状态身份验证 当客户端向服务器发送服务请求时，它首先登录到服务器。因此，服务器生成一个令牌（编码格式的数据）并将响应发送到客户端。在发出第二个请求时，客户端将相同的令牌与请求一起发送到服务器。现在，服务器从请求中读取令牌并验证令牌。事实上，从第一个请求开始，服务器就检查客户端的有效登录（凭据）。</description>
    </item>
    <item>
      <title>[译]Spring Boot项目如何实现Security？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/</guid>
      <description>如今，几乎每个客户都要求在实时应用程序中实现强大的安全功能。安全功能对于保持机密性、完整性和可用性的需求是非常有效的。现实世界中有很多类型的安全性，但我们作为开发人员将重点关注应用程序/软件安全性。
此外，在应用程序安全方面，我们的工作基本上是确保两件事。首先，只有有效的用户才能访问该应用程序。其次，如果用户有效，他/她只能访问该应用程序中允许的数据/信息。我认为，没有什么可以解释它们，因为您必须已经了解这两个术语，即身份验证和授权。
您可能已经猜到我们将在当前主题“如何在 Spring Boot 项目中实现安全性？”中讨论什么内容。
在本文中，我们将从基本原理开始学习。接下来，我们将逐步结束它，直到我们有信心在 Spring Boot 应用程序中实现安全功能。因此，让我们开始逐步讨论“如何在 Spring Boot 项目中实现安全性？”。 Spring Boot 教程页面上有一系列有关 Spring Boot Security 的教程。
我们在本文中介绍了两个版本的“如何在 Spring Boot 项目中实现安全性？”的示例：使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。此外，还涵盖了使用 Spring Boot 3.0 及更高版本的“如何在 Spring Boot 项目中实现安全性？”的示例。
您将从本文中学到什么？ 为什么我们需要在 Spring Boot 应用程序中实现安全性？
Security 在 Spring Boot 应用程序内部如何工作？
javax.servlet.Filter 在 Spring Boot 应用程序中实现安全性方面的作用是什么？
Spring Boot 项目中使用了多少种授权类型？
Spring Boot 项目中有多少种实现安全性的方法？
在 Spring Boot 项目中实现 WebSecurity 的步骤是什么？
另外，如何在 Spring Boot 项目中使用@EnableWebSecurity、@Configuration、@Bean？
如何实现内存中身份验证安全示例
如何实现 JDBC 认证安全示例
如何在 Spring Boot 项目中使用 Thymeleaf ？
如何测试启用安全的功能？
相反，如何禁用应用程序的安全功能？
最后但并非最不重要的一点是，您将学习“如何在 Spring Boot 项目中实现安全性？”使用 WebSecurityConfigurerAdapter 和不使用 WebSecurityConfigurerAdapter。
为什么我们需要应用程序中的安全性？ 现在，随着恶意攻击将重点从操作系统和网络转移到应用程序/软件和移动设备/设备，一天的数据面临最大的风险。此外，从业务/客户的角度来看，应用程序安全在维护信任、建立品牌形象和降低风险方面发挥着重要作用。事实上，没有其中任何一项，都无法想象一家成功的企业。
总之，无论您是为了内部使用、销售目的还是购买目的而创建应用程序，安全性都是每个应用程序最重要的功能。
根据最新的 2020 年 Verizon 数据泄露调查报告，所有数据泄露中有 43% 是针对 Web 应用程序的攻击。这一数字比 2019 年增加了一倍。此外，86% 的违规行为都是出于经济动机。</description>
    </item>
    <item>
      <title>[译]如何在Spring Boot2中使用UserDetailsService实现安全性？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot2-using-userdetailsservice/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot2-using-userdetailsservice/</guid>
      <description>继续上一篇关于实现 Spring Security 的两种不同方法的文章，在本文中，我们将学习第三种方法“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现 Security？”。经过上一篇文章后，我希望我们都非常熟悉安全性的基础知识，甚至是 Spring Boot 应用程序中的安全性基础知识。这次我们将创建一个用户注册表并将用户及其角色保存到数据库中。
然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
如果您正在寻找“如何在 Spring Boot 3 及以上版本中使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”，请访问有关使用 Spring Boot 3 的 Spring Security UserDetailsS​​ervice 的单独文章。
为了说明这一点，我们将把一些角色发挥作用，并在整个过程中围绕它们进行发挥，以使其变得清晰。此外，我们将有一些页面并限制它们仅可由某些特定角色访问。同样重要的是，我们必须创建一个小型 MVC Web 应用程序，以使注册过程向用户开放。用户在注册时将输入自己的角色。然后我们可以在其之上实现安全功能。
让我们开始相应的主题“如何使用 UserDetailsS​​ervice 在 Spring Boot 中实现安全性？”。
总体而言，您对这篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 在 Spring Security 应用程序中如何内部工作并带有流程图？
另外，如何使用注解：@EnableWebSecurity、@Configuration、@Bean、@GetMapping、@Autowired、@Data、@Entity、@Table、@Id、@GenerateValue、@Column、@ElementCollection、@CollectionTable、@JoinColumn ， @服务
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
UserDetailsService 是做什么的？使用它有什么好处？ UserDetailsS​​ervice 是 Spring 中 org.springframework.security.core.userdetails 包下的预定义接口。我们的实现类实现了这个接口并重写了它的 loadUserByUsername(String username) 方法。此方法返回 UserDetails，它又是一个接口。预定义的 User 类（org.springframework.security.core.userdetails.User）是 UserDetails 接口的实现。总之，在 loadUserByUsername(String username) 方法中，我们传递用户名，它返回我们预定义的 User 对象（org.</description>
    </item>
    <item>
      <title>[译]如何在Spring Boot3中使用UserDetailsService实现安全性？</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot3-using-userdetailsservice/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/how-to-implement-security-in-spring-boot3-using-userdetailsservice/</guid>
      <description>作为有关 Spring Security 的系列文章的继续，在本文中我们将学习“如何在 Spring Boot 3 中使用 UserDetailsService 实现 Spring Boot 中的安全性？”。经过前面的文章，我希望我们都非常熟悉安全性的基础知识，甚至 Spring Boot 应用程序中的安全性基础知识。 Spring Boot 3 发布后，我们将在这里实现“使用 Spring Boot 3 的 Spring Security UserDetailsService”。
在本文中，我们将创建一个用户注册表单并将用户及其角色保存在数据库中。然后，根据用户角色，我们将借助预定义的 UserDetailsS​​ervice 检查身份验证和授权功能。
您对整篇文章有何期望？ Spring Security 上下文中的 UserDetailsS​​ervice 概念是什么？
实施 UserDetailsService 有什么好处？
如何使用 Spring Boot 3 实现 Spring Security UserDetailsService？
如何在基于 Spring 的应用程序中实现基于角色的安全性？
此外，如何以及在哪里使用注释：@EnableWebSecurity，@Configuration，@Bean，@GetMapping，@Autowired，@Data，@Entity，@Table，@Id，@GenerateValue，@Column，@ElementCollection，@CollectionTable， @JoinColumn，@Service
如何使用 Spring MVC 和 Thymeleaf 开发用户注册应用程序？
如何测试启用安全的应用程序？
如何在没有 WebSecurityConfigurerAdapter 的情况下使用 UserDetailsService 在 Spring Boot 中实现安全性？
示例中使用的软件/技术 有时某些版本与其他版本冲突。因此，列出经过测试可以相互协作的组合。下面是经过测试的软件组合，用于使用 Spring Boot 3 开发 Spring Security UserDetailsS​​ervice。它也使实现完美无缺。
Spring Boot 3.0.0
JDK 17 or later
Maven 3.8.1 3）Maven 3.8.1
IDE – STS 4.7.1. RELEASE
IDE – STS 4.7.1。发布
Jars Used 下面是这些示例中 maven 使用 pom.</description>
    </item>
    <item>
      <title>[译]没有WebSecurityConfigurerAdapter的Spring Security.md</title>
      <link>https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/</link>
      <pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/18/spring-security-without-websecurityconfigureradapter/</guid>
      <description>在 Spring Security 模块的上下文中，WebSecurityConfigurerAdapter 是一个抽象类，根据 Spring 官方网站 2022 年 2 月 21 日发布的公告，该类已从 Spring Security 5.7.0-M2 中弃用。它通常用于扩展 configure() 方法由自定义配置子类实现。因此，它鼓励用户转向基于组件的安全配置。为了支持对这种新配置设计的更改，我们将讨论常见用例列表和未来建议的替代方案。因此，我们将讨论没有 WebSecurityConfigurerAdapter 的 Spring Security 用例的实现。
了解这一变化很重要，因为迟早我们将使用最新版本的 Spring Security 来开发安全功能。让我们讨论“没有 WebSecurityConfigurerAdapter 的 Spring Security”主题及其相关概念。
什么是 WebSecurityConfigurerAdapter？ WebSecurityConfigurerAdapter 是 Spring Security 模块提供的一个抽象类。一般来说，我们使用它来重写它的 configure()方法来定义我们的安全配置类。通常，我们在应用程序中实现 Spring Security 时使用两个具有不同参数的 configure() 方法。一种用于声明与身份验证相关的配置，另一种用于声明与授权相关的配置。该代码类似于下面的代码片段。
@Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // configure Authentication ...... } @Override protected void configure(HttpSecurity http) throws Exception { // configure Authorization ...... } } 为什么我们需要学习这个改变？ 如果您使用 Spring Boot 2.7.0 和 maven，它将自动下载 Spring Security 5.7.0 或更高版本。在这种情况下，您会发现 WebSecurityConfigurerAdapter 已被弃用。如果您仍然想使用此类而不弃用，您可以在 pom.xml 中将 Spring Boot 版本更改为较低版本（例如 2.6.6 ），如下所示。它将自动下载低于 5.</description>
    </item>
    <item>
      <title>[译]Spring Security - JWT</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-jwt/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-jwt/</guid>
      <description>简介和概述 JSON Web Token 或 JWT（更常见的名称）是一种开放的互联网标准 (RFC 7519)，用于以紧凑的方式在各方之间安全地传输可信信息。令牌包含编码为 JSON 对象的声明，并使用私有密钥或公钥/私钥对进行数字签名。它们是独立且可验证的，因为它们经过数字签名。 JWT 可以进行签名和/或加密。
签名的令牌验证令牌中包含的声明的完整性，而加密的令牌则向其他方隐藏声明。
JWT 也可用于信息交换，尽管它们更常用于授权，因为它们比使用内存中随机令牌的会话管理具有很多优势。其中最重要的是允许将身份验证逻辑委托给第三方服务器，例如 AuthO 等。
JWT 令牌分为 3 部分，即标头、有效负载和签名，格式为
[Header].[Payload].[Signature] Header − JWT 令牌的标头包含应用于 JWT 的加密操作列表。这可以是签名技术、有关内容类型的元数据信息等。标头以 JSON 对象的形式呈现，该对象被编码为 base64URL。有效 JWT 标头的示例是 { &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 这里，“alg”为我们提供了有关所用算法类型的信息，“typ”为我们提供了信息的类型。
Payload − JWT 的有效负载部分包含使用令牌传输的实际数据。这部分也称为 JWT 令牌的“声明”部分。索赔可以分为三种类型：注册索赔、公开索赔和私人索赔。 注册的声明是推荐的但不是强制的声明，例如 iss(发行者)、sub(主题)、aud(受众) 等。 公共声明是那些使用 JWT 的人定义的声明。 私人声明或自定义声明是为了在相关方之间共享信息而创建的用户定义的声明。 有效负载对象的示例可以是。
{ &amp;#34;sub&amp;#34;: &amp;#34;12345&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Johnny Hill&amp;#34;, &amp;#34;admin&amp;#34;: false } 有效负载对象与标头对象一样，也采用 base64Url 编码，并且该字符串构成 JWT 的第二部分。
Signature− JWT 的签名部分用于验证消息在此过程中没有更改。如果令牌是用私钥签名的，它还会验证发送者的身份。它是使用编码的标头、编码的有效负载、秘密和标头中指定的算法创建的。签名的一个例子是。 HMACSHA256(base64UrlEncode(header) + &amp;#34;.&amp;#34; + base64UrlEncode(payload), secret); 如果我们输入标头、有效负载和签名，我们会得到一个令牌，如下所示。
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6I kpvaG4gRG9lIiwiYWRtaW4iOmZhbHNlfQ.gWDlJdpCTIHVYKkJSfAVNUn0ZkAjMxskDDm-5Fhe WJ7xXgW8k5CllcGk4C9qPrfa1GdqfBrbX_1x1E39JY8BYLobAfAg1fs_Ky8Z7U1oCl6HL63yJq_ wVNBHp49hWzg3-ERxkqiuTv0tIuDOasIdZ5FtBdtIP5LM9Oc1tsuMXQXCGR8GqGf1Hl2qv8MCyn NZJuVdJKO_L3WGBJouaTpK1u2SEleVFGI2HFvrX_jS2ySzDxoO9KjbydK0LNv_zOI7kWv-gAmA j-v0mHdJrLbxD7LcZJEGRScCSyITzo6Z59_jG_97oNLFgBKJbh12nvvPibHpUYWmZuHkoGvuy5RLUA 现在，可以使用承载模式在授权标头中使用此令牌。
Authorization − Bearer 授权 - 持有者
使用 JWT 令牌进行授权是其最常见的应用。令牌通常在服务器中生成并发送到客户端，并存储在会话存储或本地存储中。要访问受保护的资源，客户端将在标头中发送 JWT，如上所述。我们将在下面的部分中看到 Spring Security 中的 JWT 实现。</description>
    </item>
    <item>
      <title>[译]Spring Security - OAuth2</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-oauth2/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-with-oauth2/</guid>
      <description>OAuth 2.0 基础知识 OAuth 2.0 由 IETF OAuth 工作组开发并于 2012 年 10 月发布。它作为一种开放授权协议，使第三方应用程序能够代表资源所有者对 HTTP 服务进行有限访问。它可以在不泄露用户身份或长期凭证的情况下做到这一点。第三方应用程序本身也可以代表其使用它。
OAuth 的工作原理包括将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问用户的帐户。
让我们考虑一个例子。假设我们要登录网站“clientsite.com”。我们可以通过 Facebook、Github、Google 或 Microsoft 登录。我们选择上面给出的选项中的任何选项，然后我们将被重定向到相应的网站进行登录。如果登录成功，系统会询问我们是否要授予 clientsite.com 访问其请求的特定数据的权限。
我们选择所需的选项，然后使用授权代码或错误代码重定向到 clientsite.com，登录是否成功取决于我们在第三方资源中的操作。这就是 OAuth 2 的基本工作原理。
OAuth 系统涉及五个关键角色。让我们把它们列出来 -
User / Resource Owner − 用户/资源所有者- 最终用户，负责身份验证并同意与客户端共享资源。 User-Agent − 用户代理- 用户使用的浏览器。 Client − 客户端 - 请求访问令牌的应用程序。 Authorization Server − 授权服务器- 用于验证用户/客户端的服务器。它颁发访问令牌并在其整个生命周期内对其进行跟踪。 Resource Server − 资源服务器- 提供对所请求资源的访问的 API。它验证访问令牌并提供授权。 入门 我们将使用 Spring Security 和 OAuth 2.0 开发一个 Spring Boot 应用程序来说明上述内容。我们现在将开发一个带有内存数据库的基本应用程序来存储用户凭据。该应用程序将使我们轻松了解 OAuth 2.0 与 Spring Security 的工作原理。
让我们使用 Spring 初始化程序在 Java 8 中创建一个 Maven 项目。让我们从 start.spring.io 开始。我们生成一个具有以下依赖项的应用程序 -
Spring Web Spring Security Cloud OAuth2 Spring Boot Devtools 通过上面的配置，我们点击 Generate 按钮生成一个项目。该项目将以 zip 文件形式下载。我们将 zip 解压到一个文件夹中。然后我们可以在我们选择的 IDE 中打开该项目。我在这里使用 Spring Tools Suite，因为它针对 Spring 应用程序进行了优化。我们也可以根据需要使用 Eclipse 或 IntelliJ Idea。</description>
    </item>
    <item>
      <title>[译]Spring Security - 使用数据库表单登录</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-with-database/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-with-database/</guid>
      <description>内容 简介和概述 Spring Security 的基本组件 AuthenticationFilter 认证过滤器 AuthenticationManager 认证管理器 AuthenticationProvider 认证提供者 UserDetailsService 用户详情服务 PasswordEncoder 密码编码器 Spring 安全上下文 表单登录 使用数据库登录 登录尝试限制 入门（实用指南） 简介和概述 除了提供各种内置的身份验证和授权选项之外，Spring Security 还允许我们根据需要自定义身份验证过程。从自定义登录页面到我们自己的自定义身份验证提供程序和身份验证过滤器，我们几乎可以自定义身份验证过程的各个方面。
我们可以定义自己的身份验证过程，范围可以从使用用户名和密码的基本身份验证到复杂的身份验证，例如使用令牌和 OTP 的双因素身份验证。此外，我们可以使用各种数据库 - 关系数据库和非关系数据库，使用各种密码编码器，将恶意用户锁定在其帐户之外，等等。
今天，我们将讨论三种此类自定义，即自定义表单登录、数据库提供的身份验证以及限制登录尝试。尽管这些都是非常基本的用例，但它们仍然可以让我们更仔细地了解 Spring Security 的身份验证和授权过程。我们还将建立一个注册页面，用户可以通过该页面在我们的应用程序中进行注册。
首先我们看一下 Spring Security 的架构。它从 servlet 过滤器开始。这些过滤器拦截请求，对其执行操作，然后将请求传递到过滤器链中的下一个过滤器或请求处理程序，或者在不满足某些条件时阻止它们。正是在这个过程中，Spring Security 可以对请求进行身份验证并对请求执行各种身份验证检查。
它还可以通过不允许未经身份验证或恶意请求访问我们受保护的资源来阻止它们通过。因此我们的应用程序和资源受到保护。
Spring Security 架构的组件 正如我们在上图中看到的那样，Spring Security 的基本组件如下所示。我们将在讨论过程中简要讨论它们。我们还将讨论它们在身份验证和授权过程中的角色。
AuthenticationFilter 认证过滤器 这是拦截请求并尝试对其进行身份验证的过滤器。在 Spring Security 中，它将请求转换为身份验证对象并将身份验证委托给 AuthenticationManager。
AuthenticationManager 认证管理器 它是身份验证的主要策略接口。它使用单独的方法 authenticate()来验证请求。 authenticate() 方法执行身份验证，并在身份验证成功时返回 Authentication 对象，或者在身份验证失败时抛出 AuthenticationException。如果该方法无法决定，它将返回 null。这个过程中的认证过程委托给了我们接下来要讨论的 AuthenticationProvider。
AuthenticationProvider 认证提供者 AuthenticationManager 由 ProviderManager 实现，后者将流程委托给一个或多个 AuthenticationProvider 实例。任何实现 AuthenticationProvider 接口的类都必须实现两个方法——authenticate() 和 supports()。首先，我们来谈谈 supports()方法。它用于检查我们的 AuthenticationProvider 实现类是否支持特定的身份验证类型。如果支持则返回 true，否则返回 false。
接下来是 authenticate() 方法。这是身份验证发生的地方。如果支持该认证类型，则启动认证过程。这里这个类可以使用 UserDetailsS​​ervice 实现的 loadUserByUsername() 方法。如果未找到用户，则会抛出 UsernameNotFoundException。
另一方面，如果找到用户，则使用该用户的身份验证详细信息来验证该用户。例如，在基本认证场景中，可以将用户提供的密码与数据库中的密码进行核对。如果发现它们彼此匹配，则说明成功。然后我们可以从此方法返回一个 Authentication 对象，该对象将存储在安全上下文中，我们将在稍后讨论。
UserDetailsService 用户详情服务 它是 Spring Security 的核心接口之一。任何请求的身份验证主要取决于 UserDetailsS​​ervice 接口的实现。它最常用于数据库支持的身份验证中以检索用户数据。通过单独的 loadUserByUsername() 方法的实现来检索数据，我们可以在其中提供逻辑来获取用户的用户详细信息。如果未找到用户，该方法将抛出 UsernameNotFoundException。</description>
    </item>
    <item>
      <title>[译]Spring Security - 表单登录、记住我和注销</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-remember-me-and-logout/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-form-login-remember-me-and-logout/</guid>
      <description>内容 简介和概述 入门（实用指南） 简介和概述 Spring Security 附带了大量内置功能和工具，为我们提供方便。在这个例子中，我们将讨论其中三个有趣且有用的功能 -
表单登录 记住账号 登出 表单登录 基于表单的登录是 Spring Security 提供支持的一种用户名/密码身份验证形式。这是通过 Html 表单提供的。
每当用户请求受保护的资源时，Spring Security 都会检查请求的身份验证。如果请求未经过身份验证/授权，用户将被重定向到登录页面。登录页面必须由应用程序以某种方式呈现。 Spring Security 默认提供该登录表单。
此外，如果需要，任何其他配置都必须明确提供，如下所示 -
protected void configure(HttpSecurity http) throws Exception { http // ... .formLogin( form -&amp;gt; form.loginPage(&amp;#34;/login&amp;#34;) .permitAll() ); } 此代码要求模板文件夹中存在一个 login.html 文件，该文件将在点击 /login 时返回。该 HTML 文件应包含一个登录表单。此外，该请求应该是对 /login 的 post 请求。参数名称应分别为用户名和密码的“username”和“password”。除此之外，表单中还需要包含 CSRF 令牌。
一旦我们完成了代码练习，上面的代码片段就会更加清晰。
记住账号 这种类型的身份验证需要将记住我的 cookie 发送到浏览器。该 cookie 存储用户信息/身份验证主体，并存储在浏览器中。因此，网站可以在下次会话启动时记住用户的身份。 Spring Security 已为此操作准备了必要的实现。
一种使用散列来保护基于 cookie 的令牌的安全性，而另一种使用数据库或其他持久存储机制来存储生成的令牌。
登出 默认 URL /logout 通过以下方式注销用户：
使 HTTP 会话失效 清除配置的所有 RememberMe 身份验证 清除 SecurityContextHolder 重定向到/login?logout WebSecurityConfigurerAdapter 自动将注销功能应用于 Spring Boot 应用程序。
Getting Started (Practical Guide) 像往常一样，我们首先访问 start.spring.io。这里我们选择一个 maven 项目。我们将项目命名为“formlogin”并选择所需的 Java 版本。我在此示例中选择 Java 8。我们还继续添加以下依赖项 -</description>
    </item>
    <item>
      <title>[译]Spring Security 和 Spring Boot 入门</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security/</guid>
      <description>Spring Security 是一个有助于保护企业应用程序安全的框架。通过与 Spring MVC、Spring Webflux 或 Spring Boot 集成，我们可以创建一个强大且高度可定制的身份验证和访问控制框架。在本文中，我们将解释核心概念并仔细研究 Spring Security 提供的默认配置及其工作原理。我们将进一步尝试自定义它们并分析它们对示例 Spring Boot 应用程序的影响。
示例代码 本文附有 GitHub 上的工作代码示例。
创建示例应用程序 让我们从头开始构建一个 Spring Boot 应用程序，看看 spring 如何配置和提供安全性。让我们从 spring starter 创建一个应用程序并添加所需的最少依赖项。
生成项目后，我们将其导入到 IDE 中并将其配置为在端口 8083 上运行。
mvnw clean verify spring-boot:run (for Windows) ./mvnw clean verify spring-boot:run (for Linux) 在应用程序启动时，我们应该看到一个登录页面。
控制台日志打印作为默认安全配置的一部分随机生成的默认密码：
使用默认用户名 user 和默认密码（来自日志），我们应该能够登录该应用程序。我们可以在 application.yml 中覆盖这些默认值：
spring: security: user: name: admin password: passw@rd 现在，我们应该能够使用用户 admin 和密码 passw@rd 登录。
依赖版本 在这里，我们使用了 Spring Boot 2.7.5 版本。基于此版本，Spring Boot 内部将 Spring Security 版本解析为 5.7.4。但是，如果需要，我们可以在 pom.xml 中覆盖这些版本，如下所示：
&amp;lt;properties&amp;gt; &amp;lt;spring-security.version&amp;gt;5.2.5.RELEASE&amp;lt;/spring-security.version&amp;gt; &amp;lt;/properties&amp;gt; 了解安全组件 要了解默认配置的工作原理，我们首先需要了解以下内容：
Servlet Filters 过滤器 Authentication 认证 Authorization 授权 Servlet Filters 让我们仔细看看应用程序启动时的控制台日志。我们看到 DefaultSecurityFilterChain 在请求到达 DispatcherServlet 之前触发一系列过滤器。 DispatcherServlet 是 Web 框架中的关键组件，用于处理传入的 Web 请求并将它们分派到适当的处理程序进行处理。</description>
    </item>
    <item>
      <title>[译]Spring Security：深入了解身份验证和授权</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-security-authentication-and-authorization/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-security-authentication-and-authorization/</guid>
      <description>您可以使用本指南来了解 Spring Security 是什么以及其核心功能（如身份验证、授权或常见漏洞保护）如何工作。此外，还有全面的常见问题解答。
（编者注：大约 6500 字，您可能不想尝试在移动设备上阅读本文。将其添加为书签，稍后再回来。）
介绍 迟早每个人都需要为其项目添加安全性，在 Spring 生态系统中，您可以借助 Spring Security 库来实现这一点。
因此，您继续将 Spring Security 添加到您的 Spring Boot（或普通 Spring）项目中，然后突然……​
&amp;hellip;您有自动生成的登录页面。 &amp;hellip;您无法再执行 POST 请求。 &amp;hellip;​ 您的整个应用程序处于锁定状态，并提示您输入用户名和密码。 在经历了随后的精神崩溃之后，您可能会对这一切是如何运作的感兴趣。
什么是 Spring Security 以及它是如何工作的？ 简短的回答： 从本质上讲，Spring Security 实际上只是一堆 servlet 过滤器，可帮助您向 Web 应用程序添加身份验证和授权。 它还与 Spring Web MVC（或 Spring Boot）等框架以及 OAuth2 或 SAML 等标准很好地集成。它会自动生成登录/注销页面并防止 CSRF 等常见漏洞。 现在，这并没有什么帮助，不是吗？ 幸运的是，还有一个很长的答案：本文的其余部分。
网络应用程序安全：101 在成为 Spring Security 大师之前，您需要了解三个重要概念：
Authentication 验证 Authorization 授权 Servlet Filters 过滤器 建议：不要跳过本节，因为它是 Spring Security 所做的一切的基础。另外，我会让它尽可能有趣。
1. 认证 首先，如果您正在运行典型的（Web）应用程序，您需要用户进行身份验证。这意味着您的应用程序需要验证用户是否是他所声称的人，通常通过用户名和密码检查来完成。
用户：“我是美国总统。我的 *username* 是：potus！” 您的网络应用程序：“当然可以，那么您的 *password* 是什么，总统先生？” 用户：“我的密码是：th3don4ld”。 您的网络应用程序：“正确。欢迎，先生！”
2、授权 在更简单的应用程序中，身份验证可能就足够了：用户经过身份验证后，她就可以访问应用程序的每个部分。
但大多数应用程序都有权限（或角色）的概念。想象一下：可以访问您的网上商店面向公众的前端的客户，以及可以访问单独管理区域的管理员。
两种类型的用户都需要登录，但身份验证这一事实并不能说明他们可以在系统中执行哪些操作。因此，您还需要检查经过身份验证的用户的权限，即您需要授权该用户。
用户：“让我玩那个核足球&amp;hellip;&amp;hellip;”。 您的网络应用程序：“等一下，我需要先检查您的 *permissions* ……是的，总统先生，您拥有正确的许可级别。尽情享受吧。” 用户：“那个红色按钮又是什么……​？”
3.Servlet 过滤器 最后但并非最不重要的一点是，让我们看一下 Servlet 过滤器。它们与身份验证和授权有什么关系？ （如果您对 Java Servlet 或 Filter 完全陌生，我建议您阅读旧的但仍然非常有效的 Head First Servlets 书。）</description>
    </item>
    <item>
      <title>[译]为 Spring Boot 应用程序创建优化的 Docker 映像</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-boot-docker/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-boot-docker/</guid>
      <description>容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。
本文着眼于容器化 Spring Boot 应用程序的不同方法：
使用 Docker 文件构建 Docker 镜像， 使用 Cloud-Native Buildpack 从源代码构建 OCI 映像， 通过使用分层工具将 JAR 的各个部分拆分为不同的层，在运行时优化映像。 示例代码 本文附有 GitHub 上的工作代码示例。
容器术语 我们将从整篇文章中使用的容器术语开始：
Container image: 具有特定格式的文件。我们通过运行构建工具将应用程序转换为容器映像。 Container: 容器镜像的运行时实例。 Container engine: t 负责运行 Container 的守护进程。 Container host: 容器引擎运行的主机。 Container registry: 用于发布和分发容器映像的共享位置。 OCI Standard: 开放容器倡议 (OCI) 是在 Linux 基金会下形成的一个轻量级、开放的治理结构。 OCI 镜像规范定义了容器镜像格式和运行时的行业标准，以确保所有容器引擎都可以运行任何构建工具生成的容器镜像。 为了容器化应用程序，我们将应用程序封装在容器映像中，并将该映像发布到共享注册表。容器运行时从注册表中提取该映像，解压该映像，然后在其中运行应用程序。
Spring Boot 2.3 版本提供了用于构建 OCI 映像的插件。
Docker 恰好是最常用的容器实现，并且我们在示例中使用 Docker，因此本文中所有后续对容器的引用都将指 Docker。
以传统方式构建容器镜像 通过向 Docker 文件添加一些指令，可以非常轻松地创建 Spring Boot 应用程序的 Docker 镜像。
我们首先构建一个可执行 JAR，并作为 Docker 文件指令的一部分，在应用必要的自定义后将可执行 JAR 复制到基本 JRE 映像上。
让我们从 Spring Initializr 创建带有 web 、 lombok 和 actuator 依赖项的 Spring Boot 应用程序。我们还添加了一个休息控制器来使用 GET 方法公开 API。
创建 Docker 文件 接下来，我们通过添加 Dockerfile 来容器化该应用程序：</description>
    </item>
    <item>
      <title>[译]深入了解Spring事务管理：@Transactional</title>
      <link>https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/</guid>
      <description>您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。
唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。
介绍 在本指南中，您将了解 Spring 核心事务抽象框架的主要支柱（这是一个令人困惑的术语，不是吗？） - 用大量代码示例进行描述：
@Transactional （声明式事务管理）与编程式事务管理。 物理事务与逻辑事务。 Spring @Transactional 与 JPA/Hibernate 集成。 Spring @Transactional 与 Spring Boot 或 Spring MVC 集成。 回滚、代理、常见陷阱等等。 与 Spring 官方文档相反，本指南不会直接深入探讨 Spring-first 主题，从而让您感到困惑。
相反，您将以非常规的方式学习 Spring 事务管理：从头开始，一步一步。这意味着，从普通的老式 JDBC 事务管理开始。
Why? 为什么？
因为 Spring 所做的一切都是基于这些 JDBC 基础知识。如果您掌握了这些基础知识，稍后您将可以使用 Spring 的 @Transactional 注释节省大量时间。
普通 JDBC 事务管理的工作原理 如果您在不完全了解 JDBC 事务的情况下考虑跳过本节：请不要这样做。
如何启动、提交或回滚 JDBC 事务 第一个重要的收获是：无论您使用 Spring 的 @Transactional 注释、普通 Hibernate、jOOQ 还是任何其他数据库库，都没有关系。
最后，它们都执行相同的操作来打开和关闭（我们称之为“管理”）数据库事务。普通的 JDBC 事务管理代码如下所示：
import java.sql.Connection; Connection connection = dataSource.getConnection(); // (1) try (connection) { connection.setAutoCommit(false); // (2) // execute some SQL statements... connection.commit(); // (3) } catch (SQLException e) { connection.</description>
    </item>
    <item>
      <title>Spring Security和OAuth2发展过程</title>
      <link>https://blog.chensoul.cc/posts/2023/08/15/spring-security-oauth2-history/</link>
      <pubDate>Tue, 15 Aug 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/08/15/spring-security-oauth2-history/</guid>
      <description>Spring Security 的发展过程 Spring Security 是一个功能强大且广泛使用的安全框架，为企业级应用程序提供了全面的安全性。Spring Security 最初是 Acegi Security 项目的一部分，于 2004 年发布，现在已经成为 Spring 生态系统的核心组件。 Spring Security 的发展过程可以分为三个阶段：
第一阶段：Spring Security 起源于一个名为 Acegi Security 的开源项目，初期重点实现了 Spring 应用的身份认证和授权服务功能。2003 年，Acegi Security 作为一个孵化项目被捐献给 Spring 社区。2004 年，正式作为 Spring 框架的核心组件之一 Absorbed 进 Spring。并更名为 Spring Security。Spring Security 1.0 版本 Spring Security 1.0 版本发布于 2004 年。它提供了最基本的安全功能，包括身份验证和授权。身份验证是验证用户是否是他们所声称的人的过程。授权是确定用户是否有权访问特定资源的过程。 Spring Security 1.0 版本使用了以下技术来实现身份验证和授权：
表单身份验证：表单身份验证是通过用户提交表单来验证用户身份的过程。 基于角色的访问控制 (RBAC)：RBAC 是一种授权模型，它将用户分配到角色，然后这些角色被授予对特定资源的访问权限。 第二阶段：Spring Security 2.0 版本 Spring Security 2.0 版本发布于 2006 年。它提供了更多的安全功能，包括加密和会话管理。加密是将数据转换成无法被他人理解的形式的过程。会话管理是跟踪用户会话的状态的过程。 Spring Security 2.0 版本使用了以下技术来实现加密和会话管理：
安全套接字层 (SSL)：SSL 是一种加密协议，它可以保护数据在传输过程中不被窃听。 会话管理：Spring Security 提供了自己的会话管理实现，它可以跟踪用户会话的状态。 第三阶段：Spring Security 3.0 版本 Spring Security 3.0 版本发布于 2008 年。它是一个重大的版本更新，它提供了许多新的安全功能，包括 OAuth、SAML 和 OpenID。 OAuth 是一种授权框架，它允许第三方应用程序访问用户的资源。SAML 是一种单点登录 (SSO) 协议，它允许用户在一个地方登录，然后访问多个网站。OpenID 是一种开放的身份验证协议，它允许用户使用他们选择的身份提供商来验证他们的身份。 Spring Security 3.0 版本使用了以下技术来实现 OAuth、SAML 和 OpenID：</description>
    </item>
    <item>
      <title>[译]Spring Boot异常处理完整指南</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-exception-handling/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-exception-handling/</guid>
      <description>处理异常是构建健壮应用程序的重要部分。 Spring Boot 提供了不止一种方法。
本文将探讨这些方法，并提供一些关于何时某种给定方法可能优于另一种方法的指导。
示例代码 本文附有 GitHub 上的工作代码示例。
介绍 Spring Boot 为我们提供了处理异常的工具，而不仅仅是简单的“try-catch”块。为了使用这些工具，我们应用了一些注释，使我们能够将异常处理视为横切关注点：
@ResponseStatus @ExceptionHandler @ControllerAdvice 在深入了解这些注释之前，我们将首先了解 Spring 如何处理 Web 控制器抛出的异常——这是捕获异常的最后一道防线。
我们还将查看 Spring Boot 提供的一些配置来修改默认行为。
我们将确定这样做时面临的挑战，然后我们将尝试使用这些注释来克服这些挑战。
Spring Boot 默认的异常处理机制 假设我们有一个名为 ProductController 的控制器，当未找到具有给定 id 的 Product 时，其 getProduct(...) 方法会抛出 NoSuchElementFoundException 运行时异常：
@RestController @RequestMapping(&amp;#34;/product&amp;#34;) public class ProductController { private final ProductService productService; //constructor omitted for brevity... @GetMapping(&amp;#34;/{id}&amp;#34;) public Response getProduct(@PathVariable String id){ // this method throws a &amp;#34;NoSuchElementFoundException&amp;#34; exception return productService.getProduct(id); } } 如果我们使用无效的 id 调用 /product API，服务将抛出 NoSuchElementFoundException 运行时异常，我们将得到以下响应：
{ &amp;#34;timestamp&amp;#34;: &amp;#34;2020-11-28T13:24:02.239+00:00&amp;#34;, &amp;#34;status&amp;#34;: 500, &amp;#34;error&amp;#34;: &amp;#34;Internal Server Error&amp;#34;, &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;path&amp;#34;: &amp;#34;/product/1&amp;#34; } 我们可以看到，除了格式良好的错误响应之外，有效负载没有为我们提供任何有用的信息。甚至 message 字段也是空的，我们可能希望包含“未找到 id 1 的项目”之类的内容。
让我们从修复错误消息问题开始。
Spring Boot 提供了一些属性，我们可以使用它们添加异常消息、异常类，甚至堆栈跟踪作为响应负载的一部分：</description>
    </item>
    <item>
      <title>[译]Spring Boot授权服务器 - 使用 Java 的资源服务器和客户端凭证示例</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-authorization-server/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-authorization-server/</guid>
      <description>概述 在本文中，我们将创建一个授权服务器，为任何客户端生成 access_token。这称为 OAuth2 的 client_credentials 流程。它主要用于服务间通信。
我们将使用 spring boot oauth2 授权服务器依赖项来创建身份验证服务器。我们还将创建一个资源服务器和客户端来对其进行端到端测试。
Spring 授权服务器 我们首先创建授权服务器。
依赖项： 让我们将以下依赖项添加到我们的项目中。
implementation &amp;#39;org.springframework.security:spring-security-oauth2-authorization-server:1.0.0&amp;#39; implementation &amp;#39;org.springframework.boot:spring-boot-starter-security&amp;#39; implementation &amp;#39;org.springframework.boot:spring-boot-starter-web&amp;#39; testImplementation &amp;#39;org.springframework.boot:spring-boot-starter-test&amp;#39; testImplementation &amp;#39;org.springframework.security:spring-security-test&amp;#39; 我们正在使用 spring oauth2 依赖项的最新（当时）稳定版本。
Java 实现： 让我们创建一个名为 AuthorizationServerConfig 的配置类，并向该类添加 @Configuration 注解。现在让我们创建以下 bean 来完成配置：
SecurityFilterChain @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SecurityFilterChain authServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); return http.build(); } 我们将把 bean 的顺序设置为最高，因为我们想首先执行它。
RegisteredClientRepository @Bean public RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(&amp;#34;oauth-client&amp;#34;) .clientSecret(&amp;#34;{noop}oauth-secret&amp;#34;) .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .scope(OidcScopes.OPENID) .scope(&amp;#34;articles.read&amp;#34;) .build(); return new InMemoryRegisteredClientRepository(registeredClient); } 现在让我们使用内存存储库对内容进行硬编码。我们可以根据我们的需要更新这些。
JwtDecoder @Bean public JwtDecoder jwtDecoder(JWKSource&amp;lt;SecurityContext&amp;gt; jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } 我们将使用它来解码令牌以进行验证。
JWKSource @Bean public JWKSource&amp;lt;SecurityContext&amp;gt; jwkSource() throws NoSuchAlgorithmException { RSAKey rsaKey = generateRsa(); JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -&amp;gt; jwkSelector.</description>
    </item>
    <item>
      <title>[译]使用 Spring Boot 和 Spring Security 配置 CORS</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-cors/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-cors/</guid>
      <description>跨源资源共享 (CORS) 是一种基于 HTTP 标头的机制，允许服务器显式将某些源列入白名单，并帮助绕过同源策略。
这是必需的，因为浏览器默认应用同源策略以确保安全。通过在 Web 应用程序中实施 CORS，网页可以请求额外的资源并从其他域加载到浏览器中。
本文将重点介绍在基于 Spring 的应用程序中实现 CORS 的各种方式。要详细了解 CORS 的工作原理，请参阅这篇优秀的介绍性文章。
示例代码 本文附有 GitHub 上的工作代码示例。
CORS 特定 HTTP 响应标头概述 CORS 规范定义了服务器返回的一组响应标头，这将是后续部分的重点。
响应头 描述 Access-Control-Allow-Origin 以逗号分隔的白名单来源列表或“*”。 Access-Control-Allow-Methods Web 服务器允许跨源请求的 HTTP 方法的逗号分隔列表。 Access-Control-Allow-Headers Web 服务器允许跨源请求的 HTTP 标头的逗号分隔列表。 Access-Control-Expose-Headers 客户端脚本认为可以安全显示的以逗号分隔的 HTTP 标头列表。 Access-Control-Allow-Credentials 如果浏览器通过传递凭据（以 cookie 或授权标头的形式）向服务器发出请求，则其值设置为 true 。 Access-Control-Max-Age 指示预检请求的结果可以缓存多长时间。 设置示例客户端应用程序 我们将使用一个简单的角度应用程序来调用 REST 端点，我们可以使用浏览器开发人员工具检查这些端点。您可以在 GitHub 上查看源代码。
ng serve --open 我们应该能够成功启动客户端应用程序。
设置示例服务器应用程序 我们将使用一个基于 Spring 的示例应用程序，其中包含客户端应用程序可以调用的 GET 和 POST 请求。请注意，您会发现两个独立的应用程序：一个使用 Spring MVC (REST)，另一个使用 Spring Reactive 堆栈。
为简单起见，两个应用程序之间的 CORS 配置相同，并且定义了相同的端点。两台服务器都从不同的端口 8091 和 8092 启动。
与应用程序捆绑在一起的 Maven Wrapper 将用于启动服务。您可以查看 Spring REST 源代码和 Spring Reactive 源代码。
mvnw clean verify spring-boot:run (for Windows) ./mvnw clean verify spring-boot:run (for Linux) 一旦 Spring 应用程序成功启动，客户端应用程序应该能够成功从服务器加载数据。</description>
    </item>
    <item>
      <title>[译]使用 Spring 的 Null-Safety 注解保护您的代码免受 NullPointerExceptions 的影响</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-null-safety-annotations/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-null-safety-annotations/</guid>
      <description>NullPointerExceptions （通常缩写为“NPE”）对于每个 Java 程序员来说都是一场噩梦。
我们可以在互联网上找到大量解释如何编写空安全代码的文章。空安全确保我们在代码中添加了适当的检查，以保证对象引用不能为空，或者毕竟在对象为空时采取可能的安全措施。
由于 NullPointerException 是一个运行时异常，因此在代码编译过程中很难找出这种情况。 Java 的类型系统没有办法快速消除危险的空对象引用。
幸运的是，Spring 框架提供了一些注释来解决这个问题。在本文中，我们将学习如何使用这些注释通过 Spring Boot 编写空安全代码。
示例代码 本文附有 GitHub 上的工作代码示例。
Spring 中的空安全注解 在 Spring 核心包 org.springframework.lang 下，有 4 个这样的注解：
@NonNull, @NonNull ， @NonNullFields, @NonNullFields ， @Nullable, @NonNullApi. Eclipse 和 IntelliJ IDEA 等流行的 IDE 可以理解这些注释。它们可以在编译期间警告开发人员潜在的问题。
我们将在本教程中使用 IntelliJ IDEA。让我们通过一些代码示例来了解更多信息。
要创建基础项目，我们可以使用 Spring Initializr。 Spring Boot 启动器就是我们所需要的，不需要添加任何额外的依赖项。
IDE 配置 请注意，并非所有开发工具都可以显示这些编译警告。如果您没有看到相关警告，请检查 IDE 中的编译器设置。
IntelliJ 对于 IntelliJ，我们可以在“Build, Execution, Deployment -&amp;gt; Compiler”下激活注释检查：
Eclipse 对于 Eclipse，我们可以在“Java -&amp;gt; Compiler -&amp;gt; Errors/Warnings”下找到设置：
示例代码 让我们使用一个简单的 Employee 类来理解注释：
package io.reflectoring.nullsafety; // imports class Employee { String id; String name; LocalDate joiningDate; String pastEmployment; // standard constructor, getters, setters } @NonNull 大多数情况下， id 字段（在 Employee 类中）将是一个不可为 null 的值。因此，为了避免任何潜在的 NullPointerException 我们可以将此字段标记为 @NonNull ：</description>
    </item>
    <item>
      <title>[译]使用Spring Boot Actuator公开有用的信息端点</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-info-endpoint/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/spring-boot-info-endpoint/</guid>
      <description>在分布式、快节奏的环境中，开发团队通常希望了解他们部署应用程序的时间、部署的应用程序版本、部署的 Git 提交等等。
Spring Boot Actuator 帮助我们监控和管理应用程序。它公开了提供应用程序运行状况、指标和其他相关信息的各种端点。
在本文中，我们将了解如何使用 Spring Boot Actuator 和 Maven/Gradle 构建插件将此类信息添加到我们的项目中。
示例代码 本文附有 GitHub 上的工作代码示例。
启用 Spring Boot 执行器 Spring Boot Actuator 是 Spring Boot 的一个子项目。在本节中，我们将快速了解如何引导示例项目并启用 /info 端点。如果您想了解更多有关 Spring Boot Actuator 的信息，已经有一个很棒的教程了。
让我们使用 Spring Initializr 快速创建一个 Spring Boot 项目。我们将需要以下依赖项：
依赖性 目的 Spring Boot Actuator 公开应用程序管理端点，例如 info 。 Spring Web 启用 Web 应用程序行为。 如果有帮助，这里是 Maven 和 Gradle 中预填充项目的链接。
项目构建后，我们将通过 HTTP 公开内置的 /info 端点。默认情况下， /info Web 端点处于禁用状态。我们可以通过在 application.properties 配置中添加 management.endpoints.web.exposure.include 属性来简单地启用它：
management.endpoints.web.exposure.include=health,info 让我们运行 Spring Boot 应用程序并在浏览器中打开 URL http://localhost:8080/actuator/info 。目前还看不到任何有用的东西，因为我们仍然需要进行一些配置更改。在下一节中，我们将了解如何在此响应中添加信息丰富的构建信息。
保护端点 如果您公开公开端点，请确保适当保护它们。我们不应在不知情的情况下泄露任何敏感信息。
Spring Boot 应用程序信息 Spring 从应用程序上下文中定义的各种 InfoContributor bean 收集有用的应用程序信息。下面是默认 InfoContributor beans 的摘要：
ID Bean Name 用法 build BuildInfoContributor 公开构建信息。 env EnvironmentInfoContributor 公开 Environment 中名称以 info.</description>
    </item>
    <item>
      <title>[译]在 Spring 中实现 OAuth2：使用范围（第 2 部分）</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring-scopes/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring-scopes/</guid>
      <description>我们在上一篇文章中了解了基本的 OAuth2 概念以及如何在 Spring 中实现和执行不同的授权。在这篇文章中，我们将介绍 OAuth2 的另一个重要概念：范围。
OAuth 范围 保护对应用程序的访问通常分两个步骤进行：身份验证和授权。要理解这两个概念，假设您在绝密政府大楼工作。在开始之前，你会得到一张卡片，可以让你进入建筑物。 OAuth 令牌可以看作是允许您访问的卡片。
一旦你进去，你决定去三楼见你的一位同事，在尝试使用你的卡打开三楼的门后，你听到一声嘟嘟声，告诉你你没有被授权。在 OAuth 中，范围是一种定义令牌可以访问哪些资源以及不能访问哪些资源的方法。范围允许访问控制，并且可以被视为相当于传统身份验证中的用户角色。
实现 为了演示范围，我们将使用第 1 部分中的示例。
在资源服务器的控制器中，我们有以下端点：
@RestController(&amp;#34;/&amp;#34;) public class ResourceController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(){ return &amp;#34;hello&amp;#34;; } @GetMapping(&amp;#34;/foo&amp;#34;) public String foo(){ return &amp;#34;foo&amp;#34;; } @PostMapping(&amp;#34;/bar&amp;#34;) public String bar(){ return &amp;#34;bar&amp;#34;; } @DeleteMapping(&amp;#34;/test&amp;#34;) public String test(){ return &amp;#34;test&amp;#34;; } } 第一步是使用所需的范围配置授权服务器：
clients.inMemory().withClient(&amp;#34;my-trusted-client&amp;#34;) .authorizedGrantTypes(&amp;#34;password&amp;#34;, &amp;#34;refresh_token&amp;#34;, &amp;#34;implicit&amp;#34;, &amp;#34;client_credentials&amp;#34;, &amp;#34;authorization_code&amp;#34;) .authorities(&amp;#34;CLIENT&amp;#34;) .scopes(&amp;#34;read&amp;#34;, &amp;#34;write&amp;#34;, &amp;#34;trust&amp;#34;) .accessTokenValiditySeconds(60) .redirectUris(&amp;#34;http://localhost:8081/test.html&amp;#34;) .resourceIds(&amp;#34;resource&amp;#34;) .secret(&amp;#34;mysecret&amp;#34;); 要在资源服务器中启用范围检查，我们有两个选项：使用安全配置或使用方法安全性。
使用安全配置： @Override public void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(HttpMethod.GET,&amp;#34;/hello&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) .antMatchers(HttpMethod.GET,&amp;#34;/foo&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) .antMatchers(HttpMethod.POST,&amp;#34;/bar&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;write&amp;#39;)&amp;#34;) .antMatchers(HttpMethod.DELETE,&amp;#34;/test&amp;#34;).access(&amp;#34;#oauth2.hasScope(&amp;#39;trust&amp;#39;)&amp;#34;) .anyRequest().authenticated(). and().csrf().disable(); } 使用方法安全性： @PreAuthorize(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(){ return &amp;#34;hello&amp;#34;; } @PreAuthorize(&amp;#34;#oauth2.hasScope(&amp;#39;read&amp;#39;)&amp;#34;) @GetMapping(&amp;#34;/foo&amp;#34;) public String foo(){ return &amp;#34;foo&amp;#34;; } @PreAuthorize(&amp;#34;#oauth2.</description>
    </item>
    <item>
      <title>[译]在 Spring 中实现 OAuth2：第 1 部分</title>
      <link>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring/</link>
      <pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/26/using-oauth2-in-spring/</guid>
      <description>OAuth2 是一组规范，主要提供对 Rest API 的安全访问的方法。 OAuth 的主要目的是允许通过使用令牌来执行身份验证和授权，而不必为每个操作提供凭据。由于本文的重点是实现，并且为了不重新发明轮子，可以查看 OAuth RFC 或维基百科以获取更多理论背景。在这篇文章中，我们将深入探讨 Spring 中的 OAuth2 实现以及如何使用不同的授权类型，但在此之前值得提供一些重要概念的简要定义。
访问令牌和刷新令牌 身份验证成功后将提供访问令牌以及刷新令牌。访问令牌有一个有限的有效期（标准为 1 小时），之后需要刷新令牌才能获取新的访问令牌和新的刷新令牌。 Referesh 令牌通常会在使用后过期。
资源服务器和授权服务器 OAuth 引入了授权服务器的概念，授权服务器是发出访问和刷新令牌的实体，并在每个操作中进行咨询以查看令牌是否有效。资源服务器只是由不同客户端应用程序（前端应用程序、移动设备、其他后端服务&amp;hellip;&amp;hellip;）访问的实际 Rest API。资源服务器和授权服务器可以是不同的实体，也可以是同一实体。
授权类型 OAuth 中最常用的授权有：客户端凭据、密码、授权码和隐式授权。每项资助都有特定的流程和用例，但由于本文的重点不是理论，因此我们将重点关注其实施。有关授权及其用途的更多详细信息，请参阅 OAuth RFC。
实现 在实现方面，我们将使用 Spring Boot 来利用其自动配置和引导功能，并更多地关注我们的核心主题。
资源服务器： 我们有一个资源服务器，其中包含我们希望保护的以下端点：
@RestController(&amp;#34;/&amp;#34;) public class ResourceController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(){ return &amp;#34;hello&amp;#34;; } @GetMapping(&amp;#34;/foo&amp;#34;) public String foo(){ return &amp;#34;foo&amp;#34;; } @GetMapping(&amp;#34;/bar&amp;#34;) public String bar(){ return &amp;#34;bar&amp;#34;; } @GetMapping(&amp;#34;/test&amp;#34;) public String test(){ return &amp;#34;test&amp;#34;; } } 为此，我们需要配置一个用 @EnableResourceServer 注释的 ResourceServerConfigurerAdapter bean：
@Configuration @EnableResourceServer public class ResourceSecurityConfiguration extends ResourceServerConfigurerAdapter { @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(&amp;#34;resource&amp;#34;); } @Override public void configure(HttpSecurity http) throws Exception { http .</description>
    </item>
    <item>
      <title>[译]使用Spring Boot2和Spring Security 5以及JDBC令牌存储进行Oauth2集中授权</title>
      <link>https://blog.chensoul.cc/posts/2023/07/14/oauth-2-centralized-authorization-with-spring-boot-2-and-spring-security-5-and-jdbc-token-store/</link>
      <pubDate>Fri, 14 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/14/oauth-2-centralized-authorization-with-spring-boot-2-and-spring-security-5-and-jdbc-token-store/</guid>
      <description>在这篇文章中，我们将了解如何使用 Spring Boot 2 和 Spring Security 5 OAuth2 来实现集中授权的授权服务器以及如何通过 GUI 对其进行管理，还将提供资源服务器演示以及 github 下的整个项目。
很多示例涵盖了基于早期版本的 Spring boot 2 和 Spring Security 5 使用内存令牌实现 Oauth2，因此想法是使用 MySql 数据库作为令牌存储。
为了深入探讨这个主题，我们必须：
配置 Spring 安全。 配置数据库。 创建授权服务器。 创建资源服务器。 使用 curl 客户端使用访问令牌获取安全资源。 什么是 Oauth 2？ OAuth 2.0 是行业标准授权协议。 OAuth 2.0 取代了 2006 年创建的原始 OAuth 协议上所做的工作。OAuth 2.0 注重客户端开发人员的简单性，同时为 Web 应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。
该规范及其扩展正在 IETF OAuth 工作组内开发。
Oauth 2 角色 OAuth2 定义了 4 个角色：
资源所有者：通常是您自己。
资源服务器：托管受保护数据的服务器（例如 Google 托管您的个人资料和个人信息）。
客户端：请求访问资源服务器的应用程序（网站、Javascript 应用程序或移动应用程序&amp;hellip;&amp;hellip;）。
授权服务器：向客户端颁发访问令牌的服务器。该令牌将用于客户端请求资源服务器。该服务器可以与资源服务器相同（相同的物理服务器和相同的应用程序），而且经常是这种情况。
下图说明了角色流程：
授权类型 OAuth 2 为不同的用例提供了多种“授权类型”。定义的授权类型型有：
授权码：授权码授予是使用您的 Facebook 或 Google 帐户登录应用程序的功能。 密码：旨在用于基于用户代理的客户端。其次，授权服务器不会像授权代码授予那样返回授权代码来交换访问令牌，而是返回访问令牌。 客户端凭据：客户端可以仅使用其客户端凭据（或其他支持的身份验证方式）请求访问令牌，当客户端请求访问其下的受保护资源控制权，或先前已被其他资源所有者控制的与授权服务器安排。 隐式授权：隐式授权是一种简化的授权代码流，针对使用 JavaScript 等脚本语言在浏览器中实现的客户端进行了优化。在隐式流程中，而不是向客户端发出授权代码，直接向客户端颁发访问令牌。 示范 让我们动手吧
业务层 为简单起见，我们的主要业务应用程序将是使用一个实体的产品 API，我们的访问规则将是：
PRODUCT_CREATE PRODUCT_UPDATE PRODUCT_DISPLAY PRODUCT_ADMIN OAuth2 客户端设置 要设置 Oauth 2 客户端，我们需要创建下表 [有关更多详细信息，请参阅链接]</description>
    </item>
    <item>
      <title>Java设计模式：Ambassador</title>
      <link>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</link>
      <pubDate>Thu, 06 Jul 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/07/06/java-design-patterns-ambassador/</guid>
      <description>本文主要介绍 Ambassador 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 在客户端上提供帮助程序服务实例，并从共享资源上转移常用功能。
Ambassador 设计模式的主要目的是将客户端应用程序与远程服务器之间的通信细节隔离开来，从而使客户端应用程序可以专注于自己的业务逻辑，而不必关注网络通信细节和错误处理。
在传统的客户端应用程序中，通常需要处理大量的网络通信细节和错误处理，这会使代码变得复杂且难以维护。而使用 Ambassador 设计模式可以将这些细节和处理逻辑集中在一个单独的类中，从而使客户端应用程序的代码更加简洁、易于维护和扩展。
此外，使用 Ambassador 设计模式还可以提高客户端应用程序与远程服务器之间的通信安全性和可靠性。例如，Ambassador 类可以负责统一处理所有的网络通信，从而可以更轻松地实现安全性和可靠性控制。
解释 假设有一个旧版的远程服务，该服务提供了许多客户端访问的功能，但由于用户的大量请求，导致连接问题变得普遍。此外，新的请求频率规则需要同时实现延迟检测和客户端日志功能。为了解决这些问题，可以使用 Ambassador 设计模式。
微软文档 做了如下阐述
可以将大使服务视为与客户端位于同一位置的进程外代理。 此模式对于以语言不可知的方式减轻常见的客户端连接任务（例如监视，日志记录，路由，安全性（如 TLS）和弹性模式）的工作很有用。 它通常与旧版应用程序或其他难以修改的应用程序一起使用，以扩展其网络功能。 它还可以使专业团队实现这些功能。
在该模式中，可以创建一个 Ambassador 类来充当客户端应用程序和远程服务之间的代理。Ambassador 类负责处理所有的网络通信细节和错误处理，并实现新的请求频率规则，包括延迟检测和客户端日志功能。
具体来说，Ambassador 类可以实现以下功能：
延迟检测：在请求到达远程服务之前，Ambassador 类可以检测请求的时间戳，并计算出请求的延迟时间。如果请求的延迟时间超过了预设的阈值，Ambassador 类可以将请求拒绝。 客户端日志功能：Ambassador 类可以记录请求的时间戳、请求的内容和响应的内容，并将这些信息保存到客户端的日志文件中。这样可以帮助客户端应用程序进行调试和故障排除。 连接问题处理：Ambassador 类可以监控远程服务的连接状态，并在连接出现问题时进行自动重试。同时，Ambassador 类还可以实现一些优化策略，例如使用连接池等，以提高连接的可靠性和性能。 程序示例
有了上面的介绍我们将在这个例子中模仿功能。我们有一个用远程服务实现的接口，同时也是大使服务。
interface RemoteServiceInterface { long doRemoteFunction(int value) throws Exception; } 表示为单例的远程服务。
public class RemoteService implements RemoteServiceInterface { private static final Logger LOGGER = LoggerFactory.getLogger(RemoteService.class); private static RemoteService service = null; static synchronized RemoteService getRemoteService() { if (service == null) { service = new RemoteService(); } return service; } private RemoteService() {} @Override public long doRemoteFunction(int value) { long waitTime = (long) Math.</description>
    </item>
    <item>
      <title>Java设计模式：Active Object</title>
      <link>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/26/java-design-patterns-active-object/</guid>
      <description>本文主要介绍 Active Object 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 活动对象（Active Object）是一种设计模式，其主要目的是将并发和异步处理的问题从客户端代码中分离出来，从而提高系统的性能、可靠性和可维护性。活动对象模式是一种能够帮助开发人员处理多线程、异步和并发问题的设计模式。
在传统的并发编程模型中，客户端代码需要直接管理线程和锁等细节，这样会导致代码复杂度和维护成本的增加，同时也容易出现各种问题，如死锁、竞态条件等。活动对象模式通过引入活动对象来解决这些问题，活动对象将客户端代码发送的消息添加到内部的消息队列中，并使用单独的线程异步处理这些消息。这种模式可以提高系统的性能和可扩展性，同时使得客户端代码更加简单和易于维护。
活动对象模式的目的包括：
将并发和异步处理的问题从客户端代码中分离出来，从而使得客户端代码更加简单和易于维护。客户端代码只需要发送消息即可，不需要关心异步处理的细节，活动对象将并发和异步处理的问题封装起来，提供简单的接口供客户端使用。 提高系统的性能和可扩展性。活动对象使用单独的线程池异步处理消息，可以更好地利用系统资源，提高系统的性能和可扩展性。 提高系统的可靠性和健壮性。活动对象将消息添加到内部的消息队列中，避免了竞态条件和死锁等问题，从而提高了系统的可靠性和健壮性。 将多线程和异步处理的细节封装起来，使得客户端代码更加抽象和通用。客户端代码可以使用相同的接口来访问不同的服务，从而提高代码的复用性和可维护性。 解释 活动对象模式的核心思想是将并发和异步处理的问题从客户端代码中分离出来。具体来说，活动对象模式包含以下几个关键组件：
活动对象（Active Object）：活动对象是一个封装了某种服务的对象，它将客户端代码发送的消息添加到内部的消息队列中，并使用单独的线程异步处理这些消息。活动对象通常包含一个消息队列和一个线程池，用于异步处理消息。 方法调用请求（Method Invocation Request）：客户端代码向活动对象发送方法调用请求，包括方法名和参数列表等信息。活动对象将方法调用请求封装为一个消息对象，并添加到内部的消息队列中。 消息队列（Message Queue）：消息队列是活动对象内部用于存储方法调用请求的队列。活动对象将客户端代码发送的消息添加到消息队列中，并使用单独的线程异步处理这些消息。 线程池（Thread Pool）：线程池是活动对象用于异步处理消息的线程池。活动对象从消息队列中取出消息，并使用线程池中的线程异步处理这些消息。 程序示例
public abstract class ActiveCreature{ private final Logger logger = LoggerFactory.getLogger(ActiveCreature.class.getName()); private BlockingQueue&amp;lt;Runnable&amp;gt; requests; private String name; private Thread thread; public ActiveCreature(String name) { this.name = name; this.requests = new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(); thread = new Thread(new Runnable() { @Override public void run() { while (true) { try { requests.</description>
    </item>
    <item>
      <title>Java设计模式：Abstract Document</title>
      <link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</link>
      <pubDate>Mon, 22 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-document/</guid>
      <description>本文主要介绍 Abstract Document 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 使用动态属性，并在保持类型安全的同时实现非类型化语言的灵活性。
抽象文档模式中的属性对象可以动态添加和删除属性，并且属性类型是在运行时确定的，这使得抽象文档模式具有一定的灵活性和可扩展性。
在抽象文档模式中，属性对象通常使用 Map 或者 List 等数据结构来实现。动态属性的添加和删除可以通过 Map 的 put 和 remove 方法实现，而属性的类型可以通过泛型来确定。
解释 抽象文档模式使您能够处理其他非静态属性。 此模式使用特征的概念来实现类型安全，并将不同类的属性分离为一组接口。
真实世界例子
考虑由多个部分组成的汽车。 但是，我们不知道特定汽车是否真的拥有所有零件，或者仅仅是零件中的一部分。 我们的汽车是动态而且非常灵活的。
通俗的说
抽象文档模式允许在对象不知道的情况下将属性附加到对象。
维基百科说
面向对象的结构设计模式，用于组织松散类型的键值存储中的对象并使用类型化的视图公开数据。 该模式的目的是在强类型语言中实现组件之间的高度灵活性，在这种语言中，可以在不丢失类型安全支持的情况下，将新属性动态地添加到对象树中。 该模式利用特征将类的不同属性分成不同的接口。
程序示例
让我们首先定义基类Document和AbstractDocument。 它们基本上使对象拥有属性映射和任意数量的子对象。
以下代码在 java 8 中编译正常。
Document 接口：
public interface Document { Void put(String key, Object value); Object get(String key); &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; children(String key, Function&amp;lt;Map&amp;lt;String, Object&amp;gt;, T&amp;gt; constructor); } 以下接口不使用 Java 8 的 Stream API：
public interface Document { Object get(String key); void put(String key, Object value); List&amp;lt;Document&amp;gt; children(String key); } AbstractDocument 抽象类：</description>
    </item>
    <item>
      <title>Java设计模式：Abstract Factory</title>
      <link>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</link>
      <pubDate>Mon, 22 May 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/05/22/java-design-patterns-abstract-factory/</guid>
      <description>本文主要介绍 Abstract Factory 模式，在 Java Design Patterns 网站上有对该模式进行介绍。这里主要是做个笔记，并添加一些扩展，以加深对该设计模式的理解。
Java Design Patterns 提供了各种 Java 设计模式的介绍、示例代码和用例说明。该网站旨在帮助 Java 开发人员了解和应用各种常见的设计模式，以提高代码的可读性、可维护性和可扩展性。
Java Design Patterns 网站提供了多种设计模式分类方式，包括创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），以及其他一些常见的模式。
对于每个设计模式，该网站提供了详细的介绍、示例代码和用例说明，并且提供了一些常见的使用场景和注意事项。开发人员可以根据自己的需求选择适合自己的设计模式，并且可以参考示例代码和用例说明来理解和应用该模式。
此外，Java Design Patterns 网站还提供了一些其他资源，如设计模式的 UML 图、设计模式的优缺点、设计模式的比较等。这些资源可以帮助开发人员更好地理解和应用设计模式。
中文网站：https://java-design-patterns.com/zh/
Github 上源码仓库（非官方）：https://github.com/iluwatar/java-design-patterns
目的 抽象工厂（Abstract Factory）是一种创建型设计模式，它提供了一种方式来创建一系列相关或依赖对象的家族，而无需指定它们具体的类。
抽象工厂模式使用一个抽象工厂接口来定义一组相关的工厂方法，每个工厂方法都能够创建一组相关的产品。具体的工厂实现了这个接口，并能够创建具体的产品。客户端代码只需要使用抽象工厂接口来创建产品，而不需要关心具体的产品实现。
解释 真实世界例子
要创建一个王国，我们需要具有共同主题的对象。精灵王国需要精灵国王、精灵城堡和精灵军队，而兽人王国需要兽人国王、兽人城堡和兽人军队。王国中的对象之间存在依赖关系。
通俗的说
工厂的工厂； 一个将单个但相关/从属的工厂分组在一起而没有指定其具体类别的工厂。
维基百科上说
抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法
程序示例
翻译上面的王国示例。 首先，我们为王国中的对象提供了一些接口和实现。
public interface Castle { String getDescription(); } public interface King { String getDescription(); } public interface Army { String getDescription(); } // Elven implementations -&amp;gt; public class ElfCastle implements Castle { static final String DESCRIPTION = &amp;#34;This is the Elven castle!&amp;#34;; @Override public String getDescription() { return DESCRIPTION; } } public class ElfKing implements King { static final String DESCRIPTION = &amp;#34;This is the Elven king!</description>
    </item>
    <item>
      <title>《Effective Java 3》笔记5：依赖注入优于硬编码资源</title>
      <link>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</link>
      <pubDate>Mon, 17 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://blog.chensoul.cc/posts/2023/04/17/prefer-dependency-injection-to-hardwiring-resources/</guid>
      <description>本文是 《Effective Java 3》第二章的学习笔记，在整理笔记过程中，通过 chatgpt 的帮助做了一些扩展。
介绍 依赖注入是软件工程中使用的一种设计模式，用于将组件和依赖项相互解耦。而不是在组件内部创建和管理依赖项，我们从外部传递它们。这种方法可以帮助创建更模块化和灵活的代码。
相比之下，硬编码资源涉及在组件内部直接创建和管理依赖项。这种方法可能会使代码不太灵活，难以维护。
举例 许多类依赖于一个或多个底层资源。例如，拼写检查程序依赖于字典。常见做法是，将这种类实现为静态实用工具类：
// Inappropriate use of static utility - inflexible &amp;amp; untestable! public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() {} // Noninstantiable public static boolean isValid(String word) { ... } public static List&amp;lt;String&amp;gt; suggestions(String typo) { ... } } 类似地，我们也经常看到它们的单例实现：
// Inappropriate use of singleton - inflexible &amp;amp; untestable! public class SpellChecker { public static INSTANCE = new SpellChecker(...); private final Lexicon dictionary = ...; private SpellChecker(...) {} public boolean isValid(String word) { ... } public List&amp;lt;String&amp;gt; suggestions(String typo) { ... } } 这两种方法都不令人满意，因为它们假设只使用一个字典。在实际应用中，每种语言都有自己的字典，特殊的字典用于特殊的词汇表。另外，最好使用一个特殊的字典进行测试。
你可以尝试让 SpellChecker 支持多个字典：首先取消 dictionary 字段的 final 修饰，并在现有的拼写检查器中添加更改 dictionary 的方法。但是在并发环境中这种做法是笨拙的、容易出错的和不可行的。静态实用工具类和单例不适用于由底层资源参数化的类。</description>
    </item>
  </channel>
</rss>
